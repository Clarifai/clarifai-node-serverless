// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: proto/clarifai/api/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Duration } from "../../../google/protobuf/duration";
import { Value } from "../../../google/protobuf/struct";
import {
  Annotation,
  AnnotationFilter,
  AnnotationSearchMetrics,
  AnnotationTrack,
  App,
  AppDuplication,
  AppQuery,
  AuditLogEntry,
  AuditLogQuery,
  BulkOperation,
  CloudProvider,
  Collaboration,
  Collaborator,
  Collector,
  ComputeCluster,
  ComputePlaneMetrics,
  Concept,
  ConceptCount,
  ConceptLanguage,
  ConceptQuery,
  ConceptRelation,
  Data,
  Dataset,
  DatasetInput,
  DatasetVersion,
  DatasetVersionExport,
  DatasetVersionMetricsGroup,
  DatasetVersionMetricsGroupType,
  datasetVersionMetricsGroupTypeFromJSON,
  datasetVersionMetricsGroupTypeToJSON,
  DatasetVersionRequestOrigin,
  datasetVersionRequestOriginFromJSON,
  datasetVersionRequestOriginToJSON,
  Deployment,
  EndpointDeps,
  EvalInfo,
  EvalMetrics,
  EvaluationType,
  evaluationTypeFromJSON,
  evaluationTypeToJSON,
  FieldsValue,
  Hit,
  HitCount,
  Input,
  InputCount,
  InputIDConflictResolution,
  inputIDConflictResolutionFromJSON,
  inputIDConflictResolutionToJSON,
  InputsAddJob,
  InputsDataSource,
  InputsExtractionJob,
  InputsUpload,
  InstalledModuleVersion,
  InstanceType,
  Key,
  KnowledgeGraph,
  LabelOrder,
  LicenseType,
  licenseTypeFromJSON,
  licenseTypeToJSON,
  LogEntry,
  Model,
  ModelQuery,
  ModelReference,
  ModelType,
  ModelTypeField,
  ModelVersion,
  ModelVersionExport,
  ModelVersionInputExample,
  Module,
  ModuleVersion,
  Nodepool,
  Output,
  OutputConfig,
  Password,
  PasswordViolations,
  PatchAction,
  Pipeline,
  PipelineStep,
  PipelineStepVersion,
  PipelineVersion,
  PipelineVersionRun,
  ProcessingInfo,
  Query,
  Runner,
  RunnerSelector,
  ScopeDeps,
  Search,
  Secret,
  StatValue,
  StatValueAggregateQuery,
  StatValueAggregateResult,
  Task,
  TaskAssignment,
  TaskInputSource_TaskInputSourceType,
  taskInputSource_TaskInputSourceTypeFromJSON,
  taskInputSource_TaskInputSourceTypeToJSON,
  TaskStatusCountPerUser,
  TritonCondaEnvInfo,
  Upload,
  UploadContentPart,
  User,
  UserAppIDSet,
  Visibility,
  Worker,
  Workflow,
  WorkflowResult,
  WorkflowState,
  WorkflowVersion,
  WorkflowVersionEvaluation,
  WorkflowVersionEvaluationData,
  WorkflowVersionEvaluationTemplate,
} from "./resources";
import { BaseResponse, Status } from "./status/status";
import { StatusCode, statusCodeFromJSON, statusCodeToJSON } from "./status/status_code";

export const protobufPackage = "clarifai.api";

export enum OrganizationInvitationStatus {
  NOT_SET = 0,
  PENDING = 1,
  ACCEPTED = 2,
  CANCELLED = 3,
  DECLINED = 4,
  EXPIRED = 5,
  UNRECOGNIZED = -1,
}

export function organizationInvitationStatusFromJSON(object: any): OrganizationInvitationStatus {
  switch (object) {
    case 0:
    case "NOT_SET":
      return OrganizationInvitationStatus.NOT_SET;
    case 1:
    case "PENDING":
      return OrganizationInvitationStatus.PENDING;
    case 2:
    case "ACCEPTED":
      return OrganizationInvitationStatus.ACCEPTED;
    case 3:
    case "CANCELLED":
      return OrganizationInvitationStatus.CANCELLED;
    case 4:
    case "DECLINED":
      return OrganizationInvitationStatus.DECLINED;
    case 5:
    case "EXPIRED":
      return OrganizationInvitationStatus.EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationInvitationStatus.UNRECOGNIZED;
  }
}

export function organizationInvitationStatusToJSON(object: OrganizationInvitationStatus): string {
  switch (object) {
    case OrganizationInvitationStatus.NOT_SET:
      return "NOT_SET";
    case OrganizationInvitationStatus.PENDING:
      return "PENDING";
    case OrganizationInvitationStatus.ACCEPTED:
      return "ACCEPTED";
    case OrganizationInvitationStatus.CANCELLED:
      return "CANCELLED";
    case OrganizationInvitationStatus.DECLINED:
      return "DECLINED";
    case OrganizationInvitationStatus.EXPIRED:
      return "EXPIRED";
    case OrganizationInvitationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PutTaskAssignmentsRequestAction {
  PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET = 0,
  /**
   * LABEL_START - Create a list of task assignments for labeler => 10 inputs are assigned to the labeler.
   * This is a fully sync action.
   * If task assignments already exist, then return existing task assignments.
   */
  LABEL_START = 1,
  /**
   * LABEL_SUBMIT - Submit task assignments => mark task assignment work as completed.
   * This is a partially sync action.
   * Sync: task assignments are updated as follows:
   * * when review_strategy is NONE, then task assignment status is updated to SUCCESS.
   * * when review strategy is CONSENSUS, then task assignment status is updated to AWAITING_CONSENSUS_REVIEW.
   * * when review strategy is MANUAL, then task assignment status is updated to AWAITING_REVIEW.
   * If task assignments are already submitted, then no update is performed on them.
   * Async: annotations added for the same input as the task assignment are updated as follows:
   * * when review_strategy is NONE, then annotation status is updated to SUCCESS.
   * * when review strategy is CONSENSUS, then annotation status is updated to SUCCESS (if it reaches consensus) or AWAITING_REVIEW (if it does not reach consensus).
   * * when review strategy is MANUAL, then annotation status is updated to AWAITING_REVIEW.
   */
  LABEL_SUBMIT = 2,
  /**
   * REVIEW_START - Assign task assignments for reviewer to review => 10 task assignments are assigned to the reviewer.
   * This is a fully sync action.
   * If task assignments are already assigned for review, then return existing task assignments.
   */
  REVIEW_START = 10,
  /**
   * REVIEW_APPROVE - Approve task assignments.
   * There are two types of configurations:
   * * Batch approve: approve a list of task assignment IDs;
   * * Bulk approve: approve all task assignments from a list of workers.
   * This is a partially sync action.
   * Sync: task assignments are updated to SUCCESS
   * Async: annotations added for the same input as the task assignment are updated to SUCCESS
   */
  REVIEW_APPROVE = 11,
  /**
   * REVIEW_REQUEST_CHANGES - Request changes for task assignments.
   * There are two types of configurations:
   * * Batch request changes: request changes for a list of task assignment IDs;
   * * Bulk request changes: request changes for all task assignments from a list of workers.
   * This is a partially sync action.
   * Sync: task assignments are updated to PENDING
   * Async: annotations added for the same input as the task assignment are updated to PENDING
   */
  REVIEW_REQUEST_CHANGES = 12,
  /**
   * REVIEW_REJECT - Reject task assignments.
   * There are two types of configurations:
   * * Batch reject: reject a list of task assignment IDs;
   * * Bulk reject: reject all task assignments from a list of workers.
   * This is a partially sync action.
   * Sync: task assignments are updated to REVIEW_DENIED
   * Async: annotations added for the same input as the task assignment are updated to REVIEW_DENIED
   */
  REVIEW_REJECT = 13,
  UNRECOGNIZED = -1,
}

export function putTaskAssignmentsRequestActionFromJSON(object: any): PutTaskAssignmentsRequestAction {
  switch (object) {
    case 0:
    case "PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET":
      return PutTaskAssignmentsRequestAction.PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET;
    case 1:
    case "LABEL_START":
      return PutTaskAssignmentsRequestAction.LABEL_START;
    case 2:
    case "LABEL_SUBMIT":
      return PutTaskAssignmentsRequestAction.LABEL_SUBMIT;
    case 10:
    case "REVIEW_START":
      return PutTaskAssignmentsRequestAction.REVIEW_START;
    case 11:
    case "REVIEW_APPROVE":
      return PutTaskAssignmentsRequestAction.REVIEW_APPROVE;
    case 12:
    case "REVIEW_REQUEST_CHANGES":
      return PutTaskAssignmentsRequestAction.REVIEW_REQUEST_CHANGES;
    case 13:
    case "REVIEW_REJECT":
      return PutTaskAssignmentsRequestAction.REVIEW_REJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PutTaskAssignmentsRequestAction.UNRECOGNIZED;
  }
}

export function putTaskAssignmentsRequestActionToJSON(object: PutTaskAssignmentsRequestAction): string {
  switch (object) {
    case PutTaskAssignmentsRequestAction.PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET:
      return "PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET";
    case PutTaskAssignmentsRequestAction.LABEL_START:
      return "LABEL_START";
    case PutTaskAssignmentsRequestAction.LABEL_SUBMIT:
      return "LABEL_SUBMIT";
    case PutTaskAssignmentsRequestAction.REVIEW_START:
      return "REVIEW_START";
    case PutTaskAssignmentsRequestAction.REVIEW_APPROVE:
      return "REVIEW_APPROVE";
    case PutTaskAssignmentsRequestAction.REVIEW_REQUEST_CHANGES:
      return "REVIEW_REQUEST_CHANGES";
    case PutTaskAssignmentsRequestAction.REVIEW_REJECT:
      return "REVIEW_REJECT";
    case PutTaskAssignmentsRequestAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Split the results into pages. */
export interface Pagination {
  /** (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1. */
  page: number;
  /** (optional URL parameter) The number of results that will be contained in each page. Defaults to 128. */
  perPage: number;
}

/** GetAnnotationRequest */
export interface GetAnnotationRequest {
  userAppId: UserAppIDSet | undefined;
  annotationId: string;
  inputId: string;
}

/** ListAnnotationsRequest */
export interface ListAnnotationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List annotations for these IDs */
  ids: string[];
  /**
   * List annotations for these Input IDs
   * Note that 'ids' are optional but if the are provided the number and order in
   * 'ids' and 'input_ids' should match
   * If you do not specify 'ids' all the annotations for 'input_ids' are returned
   * If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
   */
  inputIds: string[];
  /**
   * Only return the annotations that has one of these user IDs, effectively operating as an
   * OR among them to filter down the results.
   * If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
   * Setting user_ids does also set list_all_annotations=True.
   */
  userIds: string[];
  /**
   * Only return the annotations that has one of these model version IDs, effectively operating as an
   * OR among them to filter down the results.
   * If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
   * Setting model_version_ids does also set list_all_annotations=True.
   */
  modelVersionIds: string[];
  /**
   * Only return the annotations that has one of these workflow version IDs, effectively operating as an
   * OR among them to filter down the results.
   * If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
   * Setting workflow_version_ids does also set list_all_annotations=True.
   */
  workflowVersionIds: string[];
  /**
   * Set status to filter by a list of statuses
   * If not statuses are provided then annotations with any status will be returned.
   */
  statuses: Status[];
  /**
   * Set this flag to list both trusted and not trusted annotations
   * by default it's listing only trusted annotations
   */
  listAllAnnotations: boolean;
  /** Set this flag to return the model output for model annotations in the response. */
  returnModelOutput: boolean;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Flag to filter annotations by task_id */
  taskId: string;
}

/** PostAnnotationsRequest */
export interface PostAnnotationsRequest {
  userAppId: UserAppIDSet | undefined;
  annotations: Annotation[];
}

/** PatchAnnotationsRequest */
export interface PatchAnnotationsRequest {
  userAppId: UserAppIDSet | undefined;
  annotations: Annotation[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
  /**
   * If the request is a "remove" action and the annotation is left with empty data,
   * then setting delete_if_empty_data to true will delete the annotation,
   * if possible (for example, will not delete an input-level annotation).
   */
  deleteIfEmptyData: boolean;
}

/** PatchAnnotationsStatusRequest */
export interface PatchAnnotationsStatusRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Filter by user IDs */
  userIds: string[];
  /** Filter by task ID */
  taskId: string;
  /** Filter by Status codes */
  statusCodes: StatusCode[];
  /** 'overwrite' is supported */
  action: string;
  /** Update filtered annotations to this status */
  statusCode: StatusCode;
}

/** PatchAnnotationsStatusResponse */
export interface PatchAnnotationsStatusResponse {
  status: Status | undefined;
  userIds: string[];
  updatedCount: number;
}

/** DeleteAnnotationRequest */
export interface DeleteAnnotationRequest {
  userAppId: UserAppIDSet | undefined;
  inputId: string;
  annotationId: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteAnnotationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Delete annotations with IDs */
  ids: string[];
  /**
   * Delete annotations for these Input IDs
   * Note that 'ids' are optional but if the are provided the number and order in
   * 'ids' and 'input_ids' should match
   * If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
   * However you need to specify at least one value for 'input_ids'
   * i.e. this API does not support deleting all annotations
   */
  inputIds: string[];
}

/** ListAnnotationTracksRequest */
export interface ListAnnotationTracksRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
  inputId: string;
  page: number;
  perPage: number;
}

/** PostAnnotationTracksRequest */
export interface PostAnnotationTracksRequest {
  userAppId: UserAppIDSet | undefined;
  annotationTracks: AnnotationTrack[];
  inputId: string;
}

/** PatchAnnotationTracksRequest */
export interface PatchAnnotationTracksRequest {
  userAppId: UserAppIDSet | undefined;
  annotationTracks: AnnotationTrack[];
  inputId: string;
  /** Use always 'overwrite' */
  action: string;
}

/** DeleteAnnotationTracksRequest */
export interface DeleteAnnotationTracksRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
  inputId: string;
}

/** MultiAnnotationTrackResponse */
export interface MultiAnnotationTrackResponse {
  status: Status | undefined;
  annotationTracks: AnnotationTrack[];
}

/** SingleAnnotationResponse */
export interface SingleAnnotationResponse {
  status: Status | undefined;
  annotation: Annotation | undefined;
}

/** MultiAnnotationResponse */
export interface MultiAnnotationResponse {
  status: Status | undefined;
  annotations: Annotation[];
}

/** ListAnnotationWorkersRequest */
export interface ListAnnotationWorkersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * (optional URL parameter) List of additional fields to be included in the response.
   * Currently supported: all, names
   */
  additionalFields: string[];
  /** (optional URL parameter) Only list workers that have created trusted annotations. */
  trustedOnly: boolean;
}

/** MultiWorkerResponse */
export interface MultiWorkerResponse {
  status: Status | undefined;
  workers: Worker[];
}

/** GetAppRequest */
export interface GetAppRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts */
  additionalFields: string[];
}

/** ListAppsRequest */
export interface ListAppsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts */
  additionalFields: string[];
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the name. */
  sortByName?:
    | boolean
    | undefined;
  /**
   * Whether to order by the modified_at time.
   * If none of the sort options is set to true, will sort by modified_at.
   */
  sortByModifiedAt?:
    | boolean
    | undefined;
  /** Whether to order by the created_at time. */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by the number of users stared the app */
  sortByStarCount?:
    | boolean
    | undefined;
  /** Whether to order by the id */
  sortById?:
    | boolean
    | undefined;
  /**
   * Filtering options:
   * If true, we only return apps that are handpicked by clarifai staff
   */
  featuredOnly: boolean;
  /** If true, we only return apps that are starred by the requesting user */
  starredOnly: boolean;
  /** If true, we only return apps that are marked as a template by the app owner. */
  templateOnly: boolean;
  /** Filter by visibility of the app. If set, only return apps with the specified visibility. */
  visibility:
    | Visibility
    | undefined;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the application:
   *   - id
   *   - name
   *   - description
   *   - notes
   *   - user_id (unless user_app_id.user_id is already set)
   *
   * Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
   * and used for partial prefix-matching (so searching for "clari" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
  /**
   * Query various text fields (id, name, description, and notes) that can contain the words in the query string
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  query: string;
  /**
   * Filter by the id, name and notes of the app. This supports wilcard queries like "gen*" to match "general" as an example.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  name: string;
  /**
   * Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  id: string;
}

/** PostAppsRequest */
export interface PostAppsRequest {
  userAppId: UserAppIDSet | undefined;
  apps: App[];
}

/** DeleteAppRequest */
export interface DeleteAppRequest {
  userAppId: UserAppIDSet | undefined;
}

/** PatchAppsRequest */
export interface PatchAppsRequest {
  userAppId: UserAppIDSet | undefined;
  apps: App[];
  /**
   * The action to perform on the patched App objects except App.Metadata
   * Supported values: 'overwrite' and 'remove'.
   *
   * Note that 'remove' can only be used to remove the app image by setting
   * 'image.url' in the request to the current value returned for that app.
   */
  action: string;
  /** The action to perform on the patched App.Metadata */
  metadataAction:
    | PatchAction
    | undefined;
  /** If set, the app will be automatically reindexed upon change of its base workflow. */
  reindex: boolean;
}

export interface PatchAppsDetailsRequest {
  userAppId: UserAppIDSet | undefined;
  apps: App[];
  /**
   * The action to perform on the patched App objects
   * Supported values: 'overwrite' and 'remove'.
   *
   * Note that 'remove' can only be used to remove the app image by setting
   * 'image.url' in the request to the current value returned for that app.
   */
  action: string;
}

/** PatchAppRequest */
export interface PatchAppRequest {
  userAppId: UserAppIDSet | undefined;
  app:
    | App
    | undefined;
  /**
   * The action to perform on the patched App object except App.Metadata
   * Supported values: 'overwrite' and 'remove'.
   *
   * Note that 'remove' can only be used to remove the app image by setting
   * 'image.url' in the request to the current value returned for the app.
   */
  action: string;
  /** The action to perform on the patched App.Metadata */
  metadataAction:
    | PatchAction
    | undefined;
  /** If set, the app will be automatically reindexed upon change of its base workflow. */
  reindex: boolean;
}

/** PatchAppsIdsRequest */
export interface PatchAppsIdsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Array containing 1 entry */
  ids: IdUpdateSource[];
  /**
   * The action to perform on the patched objects
   * Only 'overwrite' is supported
   */
  action: string;
}

/** Search over the available applications. */
export interface PostAppsSearchesRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The body of the request. */
  appQuery:
    | AppQuery
    | undefined;
  /**
   * Pagination parameters here since there are no url args in this
   * POST request.
   */
  pagination: Pagination | undefined;
}

/** SingleAppResponse */
export interface SingleAppResponse {
  status: Status | undefined;
  app: App | undefined;
}

/** MultiAppResponse */
export interface MultiAppResponse {
  status: Status | undefined;
  apps: App[];
}

/** ListCollaboratorsRequest */
export interface ListCollaboratorsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * Set this flag to list both deleted and not deleted collaborators
   * by default it's listing only not deleted collaborators
   */
  listAllCollaborators: boolean;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PostCollaboratorsRequest */
export interface PostCollaboratorsRequest {
  userAppId: UserAppIDSet | undefined;
  collaborators: Collaborator[];
}

/** PatchCollaboratorsRequest */
export interface PatchCollaboratorsRequest {
  userAppId: UserAppIDSet | undefined;
  collaborators: Collaborator[];
  /**
   * The action to perform on the patched objects
   * For now only action 'overwrite' is supported
   */
  action: string;
}

/** DeleteCollaboratorsRequest */
export interface DeleteCollaboratorsRequest {
  userAppId: UserAppIDSet | undefined;
  collaboratorIds: string[];
  userEmails: string[];
}

/** MultiCollaboratorsResponse */
export interface MultiCollaboratorsResponse {
  status: Status | undefined;
  collaborators: Collaborator[];
  /**
   * The owner of the application.
   *
   * When listing users that have access to the application, i.e. collaborators,
   * it is often relevant to also include the application owner, so return
   * their information here for convenience.
   *
   * Note: app_owner is only returned by ListCollaborators and only if the
   * owner is a regular user, not an organization.
   */
  appOwner: User | undefined;
}

/** ListCollaborationsRequest */
export interface ListCollaborationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * Filtering options:
   * If true, we only return collaborations on apps that are marked as a template by the app owner.
   */
  templateOnly: boolean;
}

/** MultiCollaborationsResponse */
export interface MultiCollaborationsResponse {
  status: Status | undefined;
  collaborations: Collaboration[];
}

/** GetStatusCodeRequest */
export interface GetStatusCodeRequest {
  statusCodeId: string;
}

/** ListStatusCodesRequest */
export interface ListStatusCodesRequest {
}

/** SingleStatusCodeResponse */
export interface SingleStatusCodeResponse {
  /** Status of this request. */
  status: Status | undefined;
}

/** MultiStatusCodeResponse */
export interface MultiStatusCodeResponse {
  status: Status | undefined;
  statuses: Status[];
}

/** GetConceptRequest */
export interface GetConceptRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The concept's id. */
  conceptId: string;
}

/** ListConceptsRequest */
export interface ListConceptsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Fuzzy match on concept ID */
  id: string;
}

/** ListModelConceptsRequest */
export interface ListModelConceptsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Model id */
  modelId: string;
  /** Model version Id. Optional, if not provided latest model version is used. */
  versionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the concept:
   *   - id
   *   - name
   *
   * Keywords are used for partial prefix-matching (so searching for "larif" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
}

/** PostConceptsSearchesRequest */
export interface PostConceptsSearchesRequest {
  /** Ids present in the url of the request. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The body of the request. */
  conceptQuery:
    | ConceptQuery
    | undefined;
  /** Request additional info to be retrieved for each concept in the response. */
  extraInfo:
    | ConceptExtraInfoRequest
    | undefined;
  /**
   * Pagination parameters here since there are no url args in this
   * POST request.
   */
  pagination: Pagination | undefined;
}

export interface ConceptExtraInfoRequest {
  /**
   * Determine if the concept is searchable by rank using this model.
   * Currently, only embedder models are supported.
   * ########## Supported fields ##########
   * - app_id
   * - id
   * - model_version.id
   * - user_id
   */
  rankableModel: Model | undefined;
}

/** PostConceptsRequest */
export interface PostConceptsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The concepts to add. */
  concepts: Concept[];
}

/** PatchConceptsRequest */
export interface PatchConceptsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The concepts to patch. */
  concepts: Concept[];
  /**
   * The action to perform on the patched objects
   * For now ony action 'overwrite' is supported
   */
  action: string;
}

/** GetConceptCountsRequest */
export interface GetConceptCountsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** SingleConceptResponse */
export interface SingleConceptResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned concept. */
  concept: Concept | undefined;
}

/** MultiConceptResponse */
export interface MultiConceptResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned concepts. */
  concepts: Concept[];
}

/** MultiConceptCountResponse */
export interface MultiConceptCountResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned concept counts. */
  conceptCounts: ConceptCount[];
}

/** GET all relations such that the concept_id refers to the subject of the relation */
export interface ListConceptRelationsRequest {
  /** The user_id and app_id information. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * The subject concept id in your app to get all the relationships for.
   * Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
   *
   * When listing all the relations it will only return one direction of the relationship
   * with the predicate acting on the subject and not the inverse like is done when providing a
   * concept_id so that we can return a reliable page size always.
   *
   * When providing a concept_id, if a hyponym is present in the DB such as:
   * 'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
   * then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
   * object.
   * But you can also list the concept relations for 'food' and it will return the same hyponym
   * relationship with 'honey' as object and 'hypernym' as predicate.
   * Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
   * when listing the relations.
   */
  conceptId: string;
  /**
   * If predicate is provided then only list relations with that predicate.
   *
   * Note that if no subject is set in concept_id and predicate is set to
   * 'hypernym', then it will return any stored hyponyms as hypernyms with
   * just the subject and object swapped since they are reversed relations.
   *
   * Valid predicates are:
   * - 'hypernym'
   * - 'hyponym'
   * - 'synonym'
   */
  predicate: string;
  /**
   * If knowledge_graph_id is provided then just list relations from that knowledge graph.
   * If not provided then list relations from all knowledge graphs including the global one for this
   * app one (ie. knowledge_graph "") and any specific ones in the app.
   */
  knowledgeGraphId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** POST new concept relations */
export interface PostConceptRelationsRequest {
  /** The user_id and app_id information. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The subject concept id you're going to add relations for. */
  conceptId: string;
  /** The relationships you're going to add. */
  conceptRelations: ConceptRelation[];
}

/** DELETE concept relations */
export interface DeleteConceptRelationsRequest {
  /** The user_id and app_id information. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The concept to delete relationship for. */
  conceptId: string;
  /** The concept relationship ids to delete. */
  ids: string[];
}

/** GET all knowledge graphs */
export interface ListKnowledgeGraphsRequest {
  /** The user_id and app_id information. */
  userAppId: UserAppIDSet | undefined;
}

/** POST new knowledge graphs */
export interface PostKnowledgeGraphsRequest {
  /** The user_id and app_id information. */
  userAppId: UserAppIDSet | undefined;
  knowledgeGraphs: KnowledgeGraph[];
}

/** MultiConceptRelationResponse */
export interface MultiConceptRelationResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned concept relations. */
  conceptRelations: ConceptRelation[];
}

/** MultiKnowledgeGraphResponse */
export interface MultiKnowledgeGraphResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned knowledge graphs. */
  knowledgeGraphs: KnowledgeGraph[];
}

/** GET single concept language for the given concept. */
export interface GetConceptLanguageRequest {
  userAppId: UserAppIDSet | undefined;
  conceptId: string;
  /** This is the language identifier. */
  language: string;
}

/** List multiple concept languages for the given concept. */
export interface ListConceptLanguagesRequest {
  userAppId: UserAppIDSet | undefined;
  conceptId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PATCH multiple concept languages for the given concept. */
export interface PatchConceptLanguagesRequest {
  userAppId: UserAppIDSet | undefined;
  conceptId: string;
  conceptLanguages: ConceptLanguage[];
  /** The action to perform with the objects in the PATCH. */
  action: string;
}

/** POST multiple concept languages for the given concept. */
export interface PostConceptLanguagesRequest {
  userAppId: UserAppIDSet | undefined;
  conceptId: string;
  conceptLanguages: ConceptLanguage[];
}

/** SingleConceptLanguageResponse */
export interface SingleConceptLanguageResponse {
  status: Status | undefined;
  conceptLanguage: ConceptLanguage | undefined;
}

/** MultiConceptLanguageResponse */
export interface MultiConceptLanguageResponse {
  status: Status | undefined;
  conceptLanguages: ConceptLanguage[];
}

/** GetInputRequest */
export interface GetInputRequest {
  userAppId: UserAppIDSet | undefined;
  inputId: string;
}

export interface GetVideoManifestRequest {
  userAppId: UserAppIDSet | undefined;
  inputId: string;
}

/** GetInputSamplesRequest */
export interface GetInputSamplesRequest {
  userAppId: UserAppIDSet | undefined;
  taskId: string;
  /** URL param. If zero ids provided, returns for all task labelers */
  userIds: string[];
}

/** ListInputsRequest */
export interface ListInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Set status to filter by status */
  status: Status | undefined;
  ids: string[];
}

/** StreamInputsRequest */
export interface StreamInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 20.
   */
  perPage: number;
  lastId: string;
  /**
   * By default, the endpoint return inputs by the time when it is added.
   * If this is set to true, we will return inputs by id.
   */
  orderById: boolean;
  descending: boolean;
}

/** PostInputsRequest */
export interface PostInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * List of inputs to post.
   * For each input, the following fields are used:
   * * id
   * * data
   * * dataset_ids
   */
  inputs: Input[];
  /**
   * Collect statistics about created inputs in job with given ID.
   * * If job ID is empty, then job is not created.
   * * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
   * * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
   */
  inputsAddJobId: string;
  /** How to handle input ID conflicts. */
  inputIdConflictResolution: InputIDConflictResolution;
}

/** PatchInputsRequest */
export interface PatchInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * List of inputs to patch.
   * Inputs are identified by id field.
   * For each input, the following fields are patchable:
   * * data
   */
  inputs: Input[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

/** DeleteInputRequest */
export interface DeleteInputRequest {
  userAppId: UserAppIDSet | undefined;
  inputId: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteInputsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

/** SingleInputResponse */
export interface SingleInputResponse {
  status: Status | undefined;
  input: Input | undefined;
}

export interface GetVideoManifestResponse {
  status:
    | Status
    | undefined;
  /**
   * MPEG-dash manifest as data-URI, base64-encoded
   * Can be empty if status is FAILED
   * Can be fallback manifest if status is MIXED_STATUS
   */
  manifestUrl: string;
}

/** MultiInputResponse */
export interface MultiInputResponse {
  status: Status | undefined;
  inputs: Input[];
  inputsAddJob: InputsAddJob | undefined;
}

/** MultiInputAnnotationResponse */
export interface MultiInputAnnotationResponse {
  status: Status | undefined;
  hits: Hit[];
}

/** SingleInputCountResponse */
export interface SingleInputCountResponse {
  status: Status | undefined;
  counts: InputCount | undefined;
}

/** GetInputCountRequest */
export interface GetInputCountRequest {
  userAppId: UserAppIDSet | undefined;
}

/** ListDatasetsRequest */
export interface ListDatasetsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  additionalFields: string[];
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the created_at time. */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by the number of users stared the app */
  sortByStarCount?:
    | boolean
    | undefined;
  /** If neither sort option is set to true, will sort by modified_at. */
  sortByModifiedAt?:
    | boolean
    | undefined;
  /** Whether to order by the external id */
  sortById?:
    | boolean
    | undefined;
  /** Filtering options: */
  starredOnly: boolean;
  /** Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only. */
  bookmark: boolean;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the dataset:
   *   - id
   *   - description
   *   - notes
   *   - user_id (unless user_app_id.user_id is already set)
   *
   * Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
   * and used for partial prefix-matching (so searching for "clari" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
  /**
   * Fuzzy filter on dataset ID
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  id: string;
}

/** GetDatasetRequest */
export interface GetDatasetRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  additionalFields: string[];
}

/** Request to add one or more datasets. */
export interface PostDatasetsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of datasets that are requested to be added. */
  datasets: Dataset[];
}

/** Request to patch several datasets. */
export interface PatchDatasetsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of datasets that are requested to be updated. */
  datasets: Dataset[];
  /**
   * The action to perform on the patched objects
   * Supported values: 'overwrite', 'merge', and 'remove'.
   *
   * Note that 'remove' can only be used to remove the dataset image by setting
   * 'image.url' in the request to the current value returned for that dataset.
   */
  action: string;
}

/** Request to delete several datasets by list of ids. */
export interface DeleteDatasetsRequest {
  userAppId: UserAppIDSet | undefined;
  datasetIds: string[];
}

/** MultiDatasetResponse */
export interface MultiDatasetResponse {
  status: Status | undefined;
  datasets: Dataset[];
}

/** SingleDatasetResponse */
export interface SingleDatasetResponse {
  status: Status | undefined;
  dataset: Dataset | undefined;
}

/** ListDatasetInputsRequest */
export interface ListDatasetInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** GetDatasetInputRequest */
export interface GetDatasetInputRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** Identify dataset input by id. */
  inputId: string;
}

/** Request to add one or more datasets. */
export interface PostDatasetInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /**
   * List of inputs that are requested to be added to this dataset.
   * Identify each input by id field. All other inputs fields are ignored.
   */
  datasetInputs: DatasetInput[];
  /** Query to search inputs to be added to this dataset. */
  search: Search | undefined;
}

/** Request to delete several dataset inputs by list of ids. */
export interface DeleteDatasetInputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** Specify which inputs to delete from dataset. */
  inputIds: string[];
}

/** MultiDatasetInputResponse */
export interface MultiDatasetInputResponse {
  status: Status | undefined;
  datasetInputs: DatasetInput[];
  bulkOperation: BulkOperation | undefined;
}

/** SingleDatasetInputResponse */
export interface SingleDatasetInputResponse {
  status: Status | undefined;
  datasetInput: DatasetInput | undefined;
}

/** ListDatasetVersionsRequest */
export interface ListDatasetVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** (optional URL parameter) Filter by origin of dataset version */
  requestOrigins: DatasetVersionRequestOrigin[];
}

/** GetDatasetVersionRequest */
export interface GetDatasetVersionRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** Identify dataset version by id. */
  datasetVersionId: string;
}

/** ListDatasetVersionMetricsGroupsRequest */
export interface ListDatasetVersionMetricsGroupsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** Identify dataset version by id. */
  datasetVersionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter. */
  parentPaths: string[];
  /** Filter by parent type. Multiple types are OR-ed. Empty list results in no filter. */
  types: DatasetVersionMetricsGroupType[];
  /** Filter by value. Multiple values are OR-ed. Empty list results in no filter. */
  values: any[];
}

/** Request to add one or more dataset versions. */
export interface PostDatasetVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** List of dataset versions that are requested to be added. */
  datasetVersions: DatasetVersion[];
}

/** Request to patch several dataset versions. */
export interface PatchDatasetVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** List of dataset versions that are requested to be updated. */
  datasetVersions: DatasetVersion[];
  /**
   * The action to perform on the patched objects
   * For now, only 'overwrite' action is supported
   */
  action: string;
}

/** Request to delete several dataset versions by list of ids. */
export interface DeleteDatasetVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  datasetVersionIds: string[];
}

/** Request to create exports of a dataset version. */
export interface PutDatasetVersionExportsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify dataset by id. */
  datasetId: string;
  /** Identify dataset version by id. */
  datasetVersionId: string;
  /**
   * exports is the list of requested dataset version exports.
   * Only setting the 'format' field of the export is supported.
   */
  exports: DatasetVersionExport[];
}

export interface MultiDatasetVersionResponse {
  status: Status | undefined;
  datasetVersions: DatasetVersion[];
}

export interface MultiDatasetVersionExportResponse {
  status: Status | undefined;
  exports: DatasetVersionExport[];
}

export interface MultiDatasetVersionMetricsGroupResponse {
  status: Status | undefined;
  datasetVersionMetricsGroups: DatasetVersionMetricsGroup[];
}

export interface SingleDatasetVersionResponse {
  status: Status | undefined;
  datasetVersion: DatasetVersion | undefined;
}

/**
 * //////////////////////////////////////////////////
 * Model prediction related stuff needs inputs and produces outputs.
 * //////////////////////////////////////////////////
 * Model prediction.
 */
export interface PostModelOutputsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
  inputs: Input[];
  /**
   * This allows you to specify config options for the model such as
   * the language which appear's in the model's output_info.
   */
  model:
    | Model
    | undefined;
  /** Allow filtering of prediction requests down to specific Nodepools, Deployments or Runners */
  runnerSelector:
    | RunnerSelector
    | undefined;
  /** Configure the prediction cache to avoid expensive compute for predict requests */
  usePredictCache: boolean;
  /** Configuration to provide logs summarization when request errors out */
  enableLogSummaryOnError: boolean;
}

/** Listing the inputs that went into training this model. */
export interface ListModelInputsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostComputePlaneMetricsRequest {
  /** List of ComputePlaneMetrics. */
  computePlaneMetrics: ComputePlaneMetrics[];
}

export interface PostLogEntriesRequest {
  /** List of log entries to be stored. */
  logEntries: LogEntry[];
}

export interface ListLogEntriesRequest {
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to last page.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 32.
   */
  perPage: number;
  /** The type of log entry. Examples: model, agent, build, training. */
  logType: string;
  /**
   * Who the logs are for.
   * The user app id, if a user produced the logs.
   */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The Model ID, if a model produced the logs. */
  modelId: string;
  /** The Version ID, if a model version produced the logs. */
  modelVersionId: string;
  /** Workflow Id, if a workflow produced the logs. */
  workflowId: string;
  /** Where the logs came from. */
  computeClusterUserId: string;
  computeClusterId: string;
  nodepoolId: string;
  runnerId: string;
  /**
   * Pipelines that produced the logs for a given pipeline run with log_type: pipeline.version.run
   * Must include user_app_id with user_id and app_id as well.
   */
  pipelineId: string;
  pipelineVersionId: string;
  pipelineVersionRunId: string;
  /** During pipeline step build provide these IDs. */
  pipelineStepId: string;
  pipelineStepVersionId: string;
}

export interface StreamLogEntriesRequest {
  /** The type of log entry. Examples: model, agent, build, training. */
  logType: string;
  /**
   * Who the logs are for.
   * The user app id, if a user produced the logs.
   */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * For models if you set log_type to "builder" then you get the model build logs.
   * The Model ID, if a model produced the logs.
   */
  modelId: string;
  /** The Version ID, if a model version produced the logs. */
  modelVersionId: string;
  /** Workflow Id, if a workflow produced the logs. */
  workflowId: string;
  /** Where the logs came from. */
  computeClusterUserId: string;
  computeClusterId: string;
  nodepoolId: string;
  runnerId: string;
  /**
   * Pipelines that produced the logs with log_type: pipeline.version.run
   * Must include user_app_id with user_id and app_id as well.
   */
  pipelineId: string;
  pipelineVersionId: string;
  pipelineVersionRunId: string;
  /**
   * During pipeline step build provide these IDs with log_type: builder
   * Must include user_app_id with user_id and app_id as well.
   */
  pipelineStepId: string;
  pipelineStepVersionId: string;
}

/** GetKeyRequest */
export interface GetKeyRequest {
  userAppId: UserAppIDSet | undefined;
  keyId: string;
}

/** ListKeysRequest */
export interface ListKeysRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * Filtering options:
   * If true, only return keys that have not expired.
   */
  notExpired: boolean;
  /** Only return keys that have the listed scopes. */
  scopes: string[];
  /** Only return keys that have the listed endpoints. */
  endpoints: string[];
  /** Only return keys with the listed type. */
  type: string;
}

/** ListAppKeysRequest */
export interface ListAppKeysRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PostKeysRequest */
export interface PostKeysRequest {
  userAppId: UserAppIDSet | undefined;
  keys: Key[];
}

/** DeleteKeyRequest */
export interface DeleteKeyRequest {
  userAppId: UserAppIDSet | undefined;
  keyId: string;
}

/** PatchKeysRequest */
export interface PatchKeysRequest {
  userAppId: UserAppIDSet | undefined;
  keys: Key[];
  /**
   * The action to perform on the patched objects
   * For now only action 'overwrite' is supported
   */
  action: string;
}

/** SingleKeyResponse */
export interface SingleKeyResponse {
  status: Status | undefined;
  key: Key | undefined;
}

/** MultiKeyResponse */
export interface MultiKeyResponse {
  status: Status | undefined;
  keys: Key[];
}

/** GetModelRequest */
export interface GetModelRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  /**
   * This is included so that we can re-use this request for multiple
   * rpcs with and without the version_id.
   */
  versionId: string;
  language: string;
  trainedBefore: boolean;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets */
  additionalFields: string[];
}

/** ListModelsRequest */
export interface ListModelsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets, counts */
  additionalFields: string[];
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the name */
  sortByName?:
    | boolean
    | undefined;
  /** Whether to order by the number of training inputs */
  sortByNumInputs?:
    | boolean
    | undefined;
  /**
   * Whether to order by the modified_at time of the latest model version.
   * If none of the sort options is set to true, will sort by modified_at.
   */
  sortByModifiedAt?:
    | boolean
    | undefined;
  /** Whether to order by the created_at */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by count of stars */
  sortByStarCount?:
    | boolean
    | undefined;
  /**
   * Filtering options:
   * Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
   * supported.
   */
  modelTypeId: string;
  /** If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types. */
  trainedOnly: boolean;
  /**
   * The list of input fields to the model.
   * For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
   */
  inputFields: string[];
  /**
   * The list of output fields to the model.
   * For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
   */
  outputFields: string[];
  /** Filter by the license of the model version */
  license: string;
  /** If true, we only return models that are handpicked by clarifai staff */
  featuredOnly: boolean;
  /** If true, we only return models that are starred by the requesting user */
  starredOnly: boolean;
  /** List of toolkit tags to filter by */
  toolkits: string[];
  /** List of use_case tags to filter by */
  useCases: string[];
  /** List of language tags to filter by */
  languages: string[];
  /**
   * Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
   * away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
   *
   * @deprecated
   */
  dontFetchFromMain: boolean;
  /**
   * Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
   * Note: you can not filter `trained_only` and bookmark at the same time.
   * When filter by bookmark, we will return trained and untrained models.
   */
  bookmark: boolean;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the model:
   *   - id
   *   - name
   *   - description
   *   - notes
   *   - user_id (unless user_app_id.user_id is already set)
   *
   * Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
   * and used for partial prefix-matching (so searching for "clari" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
  /**
   * Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  query: string;
  /**
   * Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  name: string;
  /**
   * Extends the name filter to include the user_id of the application owner that the model belongs to.
   * Deprecated: use search instead of name.
   *
   * @deprecated
   */
  filterByUserId: boolean;
  /** Filter by the model version ids. If set, only return the model of these versions. */
  modelVersionIds: string[];
  /** Filter by LicenseType */
  licenseType: LicenseType;
  /** Filter by Source */
  source: number;
  /** Filter by Creator */
  creator: string;
  /** Filter by model versions runners with replicas >= min_replicas. */
  minReplicas: number;
  /** If true, show replica counts for models. */
  showReplicas: boolean;
  /** Filter by visibility of the model. If set, only return models with the specified visibility. */
  visibility: Visibility | undefined;
}

/** ResourceCountRequest */
export interface GetResourceCountsRequest {
  userAppId: UserAppIDSet | undefined;
}

/** ResourceCountResponse */
export interface GetResourceCountsResponse {
  status: Status | undefined;
  datasets: number;
  models: number;
  workflows: number;
  modules: number;
  inputs: number;
}

export interface PatchModelToolkitsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  toolkits: string[];
  /** overwrite supported */
  action: string;
}

/** PatchModelCheckConsentsRequest */
export interface PatchModelCheckConsentsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** the model id */
  modelId: string;
  /** the consents */
  checkConsents: string[];
  /** overwrite supported */
  action: string;
}

export interface PatchModelUseCasesRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  usecases: string[];
  /** overwrite supported */
  action: string;
}

export interface PatchModelLanguagesRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  languages: string[];
  /** Only overwrite supported */
  action: string;
}

export interface MultiModelToolkitResponse {
  status: Status | undefined;
  toolkits: string[];
}

export interface MultiModelCheckConsentResponse {
  status: Status | undefined;
  checkConsents: string[];
}

export interface MultiModelUseCaseResponse {
  status: Status | undefined;
  usecases: string[];
}

export interface MultiModelLanguageResponse {
  status: Status | undefined;
  languages: string[];
}

/** PostModelsRequest */
export interface PostModelsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * NOTE: inconsistent since "model" is not plural, please use "models" below.
   * Previously you could only create one model at a time.
   * We still support this but you should pass it as models=[model] so
   * that this endpoint is consistent with the rest of our API.
   *
   * @deprecated
   */
  model:
    | Model
    | undefined;
  /** This allows you to create one or more model by posting it to the API. */
  models: Model[];
}

/** PatchModelsRequest */
export interface PatchModelsRequest {
  userAppId: UserAppIDSet | undefined;
  models: Model[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   *
   * Note that 'remove' can be used to remove the model image by setting
   * 'image.url' in the request to the current value returned for that model.
   * This cannot be used in a request that is patching other fields as well.
   */
  action: string;
}

export interface IdUpdateSource {
  /** old id */
  id: string;
  /** new id */
  newId: string;
}

/** PatchModelIdsRequest */
export interface PatchModelIdsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Array containing 1 entry */
  ids: IdUpdateSource[];
  /**
   * The action to perform on the patched objects
   * Only 'overwrite' is supported
   */
  action: string;
}

/** DeleteModelRequest */
export interface DeleteModelRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteModelsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
  deleteAll: boolean;
}

/** Search over the available models. */
export interface PostModelsSearchesRequest {
  /** Ids present in the url of the request. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The body of the request. */
  modelQuery:
    | ModelQuery
    | undefined;
  /**
   * Pagination parameters here since there are no url args in this
   * POST request.
   */
  pagination: Pagination | undefined;
}

/** SingleModelResponse */
export interface SingleModelResponse {
  status: Status | undefined;
  model: Model | undefined;
  workflowCount: number;
}

/** MultiModelResponse */
export interface MultiModelResponse {
  status: Status | undefined;
  models: Model[];
}

/** PatchModelVersionsRequest */
export interface PatchModelVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersions: ModelVersion[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

/** request for different endpoints currently. */
export interface GetModelVersionRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
}

/** ListModelVersionsRequest */
export interface ListModelVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * Filtering options:
   * To list only the model versions that have these concept ids present in them.
   */
  conceptIds: string[];
  /** To list only the model versions that have been trained. */
  trainedOnly: boolean;
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the status code */
  sortByStatusCode?:
    | boolean
    | undefined;
  /** Whether to order by the number of training inputs */
  sortByNumInputs?:
    | boolean
    | undefined;
  /** Whether to sort by the description */
  sortByDescription?:
    | boolean
    | undefined;
  /**
   * Whether to order by the created_at time
   * If neither sort option is set to true, will sort by created_at.
   */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Filter by model versions runners with replicas >= min_replicas. */
  minReplicas: number;
}

/** DeleteModelVersionRequest */
export interface DeleteModelVersionRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
}

/** SingleModelVersionResponse */
export interface SingleModelVersionResponse {
  status: Status | undefined;
  modelVersion: ModelVersion | undefined;
}

/** MultiModelVersionResponse */
export interface MultiModelVersionResponse {
  status: Status | undefined;
  modelVersions: ModelVersion[];
}

/** Create (train) a new model version. */
export interface PostModelVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersions: ModelVersion[];
  /** Description about this training run */
  description: string;
  /**
   * When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
   * We will merge this with default_eval_info.
   */
  evalInfo:
    | EvalInfo
    | undefined;
  /** When set to true, we will convert the model into a containerized model after training. */
  doMigration: boolean;
}

export interface PostModelVersionsUploadRequest {
  uploadConfig?: PostModelVersionsUploadConfig | undefined;
  contentPart?: UploadContentPart | undefined;
}

export interface PostModelVersionsUploadResponse {
  status: Status | undefined;
  bytesRemaining: number;
  /** ID of the model version being uploaded */
  modelVersionId: string;
}

export interface PostModelVersionsUploadConfig {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Model to create version for */
  modelId: string;
  /** Specification for the model version to be uploaded */
  modelVersion:
    | ModelVersion
    | undefined;
  /** Number of bytes in the model files to be uploaded */
  totalSize: number;
  /** Whether the uploaded package will be a .tar.gz which contains a Dockerfile or the standard .zip */
  isV3: boolean;
  /** Number of bytes requested for the build process. */
  storageRequestSize: number;
}

/** PutModelVersionExportsRequest */
export interface PutModelVersionExportsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
}

/** GetModelVersionExportRequest */
export interface GetModelVersionExportRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
}

/** SingleModelVersionExportResponse */
export interface SingleModelVersionExportResponse {
  status: Status | undefined;
  export: ModelVersionExport | undefined;
}

export interface PostWorkflowVersionsUnPublishRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  publications: WorkflowVersionUnPublishRequest[];
}

export interface PostWorkflowVersionsPublishRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  publications: WorkflowVersionPublishRequest[];
}

export interface WorkflowVersionPublishRequest {
  versionId: string;
}

export interface WorkflowVersionUnPublishRequest {
  versionId: string;
}

/** ModelVersionPublishRequest */
export interface ModelVersionPublishRequest {
  versionId: string;
}

/** PostModelVersionsPublishRequest */
export interface PostModelVersionsPublishRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  publications: ModelVersionPublishRequest[];
}

/** ModelVersionUnpublishRequest */
export interface ModelVersionUnpublishRequest {
  versionId: string;
}

/** PostModelVersionsUnPublishRequest */
export interface PostModelVersionsUnPublishRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  publications: ModelVersionUnpublishRequest[];
}

/** Evaluate this model vesion */
export interface PostEvaluationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
   * If no dataset is provided, all app data that is annotated with concepts from the model will be used.
   */
  evalMetrics: EvalMetrics[];
}

export interface ListEvaluationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** If true, sort in ascending order, otherwise sort in descending order. */
  sortAscending: boolean;
  /** Whether to order by application id */
  sortByAppId?:
    | boolean
    | undefined;
  /** Whether to order by eval metric summary.macro_avg_roc_auc */
  sortByRocAuc?:
    | boolean
    | undefined;
  /** Whether to order by eval metric summary.f1 */
  sortByF1?:
    | boolean
    | undefined;
  /** Whether to order by when the metric was created */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by eval metric summary.mean_avg_precision_iou_50 */
  sortByMeanAvgPrecision?:
    | boolean
    | undefined;
  /** Whether to order by eval metric summary.macro_avg_precision */
  sortByPrecision?:
    | boolean
    | undefined;
  /** Whether to order by eval metric summary.macro_avg_recall */
  sortByRecall?: boolean | undefined;
  sortByModelId?: boolean | undefined;
  sortByEvalDatasetId?: boolean | undefined;
  sortByTrainDatasetId?:
    | boolean
    | undefined;
  /** Filter on model type id */
  modelTypeId: string;
  /** Filter on dataset ID of the dataset version specified in the metric version */
  evalDatasetIds: string[];
  /** Filter on dataset ID of the dataset version specified by the model version */
  trainDatasetIds: string[];
  /** Filter on concept IDs specified in the modele version's output_info */
  conceptIds: string[];
  /** Whether to show failed metrics, defaults to false */
  showFailedMetrics: boolean;
}

export interface GetEvaluationRequest {
  userAppId: UserAppIDSet | undefined;
  evaluationId: string;
  /**
   * Any of the fields you wish to return in the metrics
   * By default, only the summary is returned.
   */
  fields: FieldsValue | undefined;
}

/** Evaluate this model vesion */
export interface PostModelVersionEvaluationsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersionId: string;
  /** EvalInfo and ID will be used when creating the evaluation */
  evalMetrics: EvalMetrics[];
}

export interface ListModelVersionEvaluationsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface GetModelVersionEvaluationRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersionId: string;
  evaluationId: string;
  /**
   * Any of the fields you wish to return from multiclass_metrics
   * By default, only the summary is returned.
   */
  fields: FieldsValue | undefined;
}

export interface SingleEvalMetricsResponse {
  status: Status | undefined;
  evalMetrics: EvalMetrics | undefined;
}

export interface MultiEvalMetricsResponse {
  status: Status | undefined;
  evalMetrics: EvalMetrics[];
}

/** Evaluate this model version. */
export interface PostModelVersionMetricsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
  /** Use this to filter inputs that are used in evaluation */
  testSearch:
    | Search
    | undefined;
  /** evaluation info. Such as dataset used for evaluation. */
  evalInfo: EvalInfo | undefined;
}

/**
 * Get the already computed evaluation metrics for this model
 * version.
 */
export interface GetModelVersionMetricsRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  versionId: string;
  /**
   * Any of the fields you wish to return from multiclass_metrics
   * By default, only the summary will be returned
   */
  fields: FieldsValue | undefined;
}

/** GetModelTypeRequest */
export interface GetModelTypeRequest {
  /** use and app combo. Not really used for this endpoint at this time so may go away in future. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The specific ModelType.Id you want to retrieve. */
  modelTypeId: string;
}

/** ListModelTypesRequest */
export interface ListModelTypesRequest {
  /** use and app combo. Not really used for this endpoint at this time so may go away in future. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** ListOpenSourceLicensesRequest */
export interface ListOpenSourceLicensesRequest {
}

/** ListOpenSourceLicensesResponse */
export interface ListOpenSourceLicensesResponse {
  status: Status | undefined;
  licenses: string[];
}

/** SingleModelTypeResponse */
export interface SingleModelTypeResponse {
  /** Status of the response. */
  status:
    | Status
    | undefined;
  /** The retrieved ModelType object. . */
  modelType: ModelType | undefined;
}

/** MultiModelTypeResponse */
export interface MultiModelTypeResponse {
  /** Status of the response. */
  status:
    | Status
    | undefined;
  /** List of ModelType objects. */
  modelTypes: ModelType[];
  /** List of model importers */
  modelImporters:
    | ModelTypeField
    | undefined;
  /** Triton model envs that can be used for model upload */
  tritonCondaEnvsInfo: TritonCondaEnvInfo[];
}

/** GetModelVersionInputExampleRequest */
export interface GetModelVersionInputExampleRequest {
  /** authorization field  (contains app/user id info) */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** id of model the example belongs to */
  modelId: string;
  /** specific version the example belongs to */
  modelVersionId: string;
  /** Id of example to fetch */
  exampleId: string;
}

/** ListModelVersionInputExamplesRequest */
export interface ListModelVersionInputExamplesRequest {
  /** authorization field  (contains app/user id info) */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** id of model the example belongs to */
  modelId: string;
  /** specific version the example belongs to */
  modelVersionId: string;
  /** Optional, defaults to 1. */
  page: number;
  /** Optional, defaults to 128 references per page. */
  perPage: number;
}

/** SingleModelVersionInputExampleResponse */
export interface SingleModelVersionInputExampleResponse {
  /** status of response */
  status:
    | Status
    | undefined;
  /** model input example message */
  modelVersionInputExample: ModelVersionInputExample | undefined;
}

/** MultiModelVersionInputExampleResponse */
export interface MultiModelVersionInputExampleResponse {
  /** status of response */
  status:
    | Status
    | undefined;
  /** model input example messages */
  modelVersionInputExamples: ModelVersionInputExample[];
}

/** ListModelReferencesRequest */
export interface ListModelReferencesRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  /** Optional, defaults to 1. */
  page: number;
  /** Optional, defaults to 128 references per page. */
  perPage: number;
}

/** MultiModelReferenceResponse */
export interface MultiModelReferenceResponse {
  status: Status | undefined;
  modelReferences: ModelReference[];
}

/** MultiOutputResponse */
export interface MultiOutputResponse {
  status:
    | Status
    | undefined;
  /** For each input processed during model prediction we create one output. */
  outputs: Output[];
  /** Information on where the computation is executed down to specific Deployment, Nodepool and ComputeCluster */
  runnerSelector: RunnerSelector | undefined;
}

export interface MultiLogEntryResponse {
  status:
    | Status
    | undefined;
  /** Log entries. */
  logEntries: LogEntry[];
  /** The page the log entries are from. If the request's page was omitted or greater than the total pages, then this is set to the last page. */
  page: number;
  /** The number of results contained in each page. */
  perPage: number;
}

/** ListScopesRequest */
export interface ListScopesRequest {
  /**
   * If "personal_access_token" include scopes and endpoints available to personal access tokens.
   * If "app_specific_key" include scopes and endpoints available to app-specific keys. (default)
   */
  keyType: string;
  /** For all user specific information we include user_app_id to get the user_id in a consistent way */
  userAppId: UserAppIDSet | undefined;
}

/** MyScopesRequest */
export interface MyScopesRequest {
  userAppId: UserAppIDSet | undefined;
}

/** MyScopesUserRequest */
export interface MyScopesUserRequest {
  userAppId: UserAppIDSet | undefined;
}

/** MyScopesRootRequest */
export interface MyScopesRootRequest {
}

/** MultiScopeDepsResponse */
export interface MultiScopeDepsResponse {
  /** The status of the request. */
  status:
    | Status
    | undefined;
  /** scopes is a list of low-level scopes and their dependencies. */
  scopeDeps: ScopeDeps[];
  /**
   * endpoint_scopes is a listof all the publicly available endponts which can be
   * used as scopes as well. A call to each of those endpoint depends on a subset
   * of the above "scopes"
   */
  endpointDeps: EndpointDeps[];
}

/** MultiScopeResponse */
export interface MultiScopeResponse {
  /** The status of the request. */
  status:
    | Status
    | undefined;
  /** This is a list of the scopes that your key has. */
  scopes: string[];
  /** The app that the key has access to. */
  app:
    | App
    | undefined;
  /** This is a list of endpoint permissions that your key has. */
  endpoints: string[];
  userFeatureFlags: string;
}

/** MultiScopeUserResponse */
export interface MultiScopeUserResponse {
  /** The status of the request. */
  status:
    | Status
    | undefined;
  /** This is a list of the scopes that your key has. */
  scopes: string[];
  /** This is a list of endpoint permissions that your key has. */
  endpoints: string[];
  userFeatureFlags: string;
}

/** MultiScopeRootResponse */
export interface MultiScopeRootResponse {
  /** The status of the request. */
  status:
    | Status
    | undefined;
  /** This is a list of the scopes that your key has. */
  scopes: string[];
  /** This is a list of endpoint permissions that your key has. */
  endpoints: string[];
  userFeatureFlags: string;
}

/** GetSearchRequest */
export interface GetSearchRequest {
  userAppId: UserAppIDSet | undefined;
  id: string;
}

/** ListSearchesRequest */
export interface ListSearchesRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PostSearchesRequest */
export interface PostSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * The query; this specifies how the data to be searched
   * this will be replaced by "Searches"
   *
   * @deprecated
   */
  query:
    | Query
    | undefined;
  /**
   * The searched to be executed or saved
   * Eventually the request level fields will be deprecated in favor of this object
   */
  searches: Search[];
  /** Pagination information to paginate through search result Hits. */
  pagination: Pagination | undefined;
}

export interface PatchInputsSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The searches to be patched */
  searches: Search[];
  /**
   * The action to perform on the patched Search objects
   * For now only action 'overwrite' is supported
   */
  action: string;
}

export interface PatchAnnotationsSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The searches to be patched */
  searches: Search[];
  /**
   * The action to perform on the patched Search objects
   * For now only action 'overwrite' is supported
   */
  action: string;
}

/** PatchSearchesRequest */
export interface PatchSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The searches to be patched */
  searches: Search[];
  /**
   * The action to perform on the patched Search objects
   * For now only action 'overwrite' is supported
   */
  action: string;
}

/** PostSearchesByIDRequest performs returns results of a saved search given its ID */
export interface PostSearchesByIDRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** ID for saves search to be executed */
  id: string;
  /** Pagination information to paginate through search result Hits. */
  pagination: Pagination | undefined;
}

/** DeleteSearchRequest */
export interface DeleteSearchRequest {
  userAppId: UserAppIDSet | undefined;
  id: string;
}

/**
 * Execute a new annotation search and optionally save it
 * annotation search over annotations using rank and filter proto
 */
export interface PostAnnotationsSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The searched to be executed or saved */
  searches: Search[];
  /** Pagination information to paginate through search result Hits. */
  pagination: Pagination | undefined;
}

/** DeleteAnnotationSearchMetricsRequest */
export interface DeleteAnnotationSearchMetricsRequest {
  userAppId: UserAppIDSet | undefined;
  id: string;
}

/** Execute a new input search and optionally save it */
export interface PostInputsSearchesRequest {
  /** The user_id and app_id to query from. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The searched to be executed or saved */
  searches: Search[];
  /** Pagination information to paginate through search result Hits. */
  pagination:
    | Pagination
    | undefined;
  /**
   * If only_count is set, then the response will not contain hits,
   * but hit_counts instead.
   */
  onlyCount: boolean;
}

/** SingleSearchResponse returns saved search in response to GetSearchRequest */
export interface SingleSearchResponse {
  /** Status of whether the search was successful. */
  status: Status | undefined;
  search: Search | undefined;
}

/** MultiSearchResponse */
export interface MultiSearchResponse {
  /** Status of whether the search was successful. */
  status:
    | Status
    | undefined;
  /** A unique id which uniquely identifies a search */
  id: string;
  /** The list of search result Hits. */
  hits: Hit[];
  /** The original query provided in the request. */
  query:
    | Query
    | undefined;
  /** The original Searches provided in the request. */
  searches: Search[];
  /**
   * The counts of hits for each search, in the same order as searches.
   * Only returned if the request set only_count.
   */
  hitCounts: HitCount[];
}

/** PostAnnotationSearchMetricsRequest */
export interface PostAnnotationSearchMetricsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** A unique customer facing id to identify this eval request */
  id: string;
  /** The ground truth we are evaluating against */
  groundTruth:
    | Search
    | undefined;
  /** The set we are evaluating */
  searchToEval:
    | Search
    | undefined;
  /**
   * List of concepts to evaluate are expected to be in data.concepts
   * If nil, then all app concepts are used
   */
  data:
    | Data
    | undefined;
  /** The type of evaluation to use */
  evaluationType: EvaluationType;
}

/** GetAnnotationSearchMetricsRequest */
export interface GetAnnotationSearchMetricsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Unique custom facing id that identifies the eval to get */
  id: string;
}

/** ListAnnotationSearchMetricsRequest */
export interface ListAnnotationSearchMetricsRequest {
  userAppId: UserAppIDSet | undefined;
}

/** MultiAnnotationSearchMetricsResponse */
export interface MultiAnnotationSearchMetricsResponse {
  /** Status of the request */
  status: Status | undefined;
  annotationSearchMetrics: AnnotationSearchMetrics[];
}

/** ListAnnotationFiltersRequest */
export interface ListAnnotationFiltersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** GetAnnotationFilterRequest */
export interface GetAnnotationFilterRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Identify annotation filter by id. */
  annotationFilterId: string;
}

/** Request to add one or more annotation filters. */
export interface PostAnnotationFiltersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of annotation filters that are requested to be added. */
  annotationFilters: AnnotationFilter[];
}

/** Request to patch several annotation filters. */
export interface PatchAnnotationFiltersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of annotation filters that are requested to be updated. */
  annotationFilters: AnnotationFilter[];
  /**
   * The action to perform on the patched objects
   * For now, only 'overwrite' action is supported
   */
  action: string;
}

/** Request to delete several annotation filters by list of ids. */
export interface DeleteAnnotationFiltersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Specify which filters to delete. */
  annotationFilterIds: string[];
}

/** MultiAnnotationFilterResponse */
export interface MultiAnnotationFilterResponse {
  status: Status | undefined;
  annotationFilters: AnnotationFilter[];
}

/** SingleAnnotationFilterResponse */
export interface SingleAnnotationFilterResponse {
  status: Status | undefined;
  annotationFilter: AnnotationFilter | undefined;
}

/** GetUserRequest */
export interface GetUserRequest {
  /**
   * we used to have user_id but moved to the standard convention. Since this endpoint
   * hasn't been exposed and only used by portal as a url this won't effect anything external.
   */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars */
  additionalFields: string[];
}

/** SingleUserResponse */
export interface SingleUserResponse {
  status: Status | undefined;
  user: User | undefined;
}

/** PostValidatePasswordRequest */
export interface PostValidatePasswordRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** password to be validated */
  password: Password | undefined;
}

/** SinglePasswordValidationResponse */
export interface SinglePasswordValidationResponse {
  /** Standard clarifai status code */
  status: Status | undefined;
  passwordViolations: PasswordViolations | undefined;
}

/** GetWorkflowRequest */
export interface GetWorkflowRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * Workflow ID to retrieve
   * If no ID is specified we return default workflow of the application
   * If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
   */
  workflowId: string;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars */
  additionalFields: string[];
}

/** ListWorkflowsRequest */
export interface ListWorkflowsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars */
  additionalFields: string[];
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the name */
  sortById?:
    | boolean
    | undefined;
  /**
   * Whether to order by the modified_at time.
   * If none of the sort options is set to true, will sort by modified_at.
   */
  sortByModifiedAt?:
    | boolean
    | undefined;
  /** Whether to order by the created_at time. */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by the number of users stared the workflow */
  sortByStarCount?:
    | boolean
    | undefined;
  /**
   * Filtering options:
   * If true, we only return workflows that are handpicked by clarifai staff
   */
  featuredOnly: boolean;
  /** If true, we only return workflows that are starred by the requesting user */
  starredOnly: boolean;
  /** Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only. */
  bookmark: boolean;
  /** Filter by visibility of the workflow. If set, only return workflows with the specified visibility. */
  visibility:
    | Visibility
    | undefined;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the workflow:
   *   - id
   *   - description
   *   - notes
   *   - user_id (unless user_app_id.user_id is already set)
   *
   * Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
   * and used for partial prefix-matching (so searching for "clari" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
  /**
   * Query various text fields (id, description and notes) that can contain the words in the query string.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  query: string;
  /**
   * Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  id: string;
  /**
   * Full text and prefix matching on id, owner id, description and notes. Searchable fields may be added
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  searchTerm: string;
}

/** PostWorkflowsRequest */
export interface PostWorkflowsRequest {
  userAppId: UserAppIDSet | undefined;
  workflows: Workflow[];
}

/** PatchWorkflowsRequest */
export interface PatchWorkflowsRequest {
  userAppId: UserAppIDSet | undefined;
  workflows: Workflow[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   *
   * Note that 'remove' can be used to remove the workflow image by setting
   * 'image.url' in the request to the current value returned for that workflow.
   * This cannot be used in a request that is patching other fields as well.
   */
  action: string;
}

/** PatchWorkflowIdsRequest */
export interface PatchWorkflowIdsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Array containing 1 entry */
  ids: IdUpdateSource[];
  /**
   * The action to perform on the patched objects
   * Only 'overwrite' is supported
   */
  action: string;
}

/** DeleteWorkflowRequest */
export interface DeleteWorkflowRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteWorkflowsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
  deleteAll: boolean;
}

/** SingleWorkflowResponse */
export interface SingleWorkflowResponse {
  status: Status | undefined;
  workflow: Workflow | undefined;
}

/** MultiWorkflowResponse */
export interface MultiWorkflowResponse {
  status: Status | undefined;
  workflows: Workflow[];
}

/** PostWorkflowResultsRequest */
export interface PostWorkflowResultsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * Workflow ID to retrieve
   * If no ID is specified we return default workflow of the application
   * If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
   */
  workflowId: string;
  /**
   * Workflow version ID to retrieve
   * If no ID is specified, latest workflow version is used
   */
  versionId: string;
  inputs: Input[];
  /**
   * FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
   * to be within models. This is not consistent with setting this on the request for post model
   * outputs where it is inside a model object. To make this consistent we would send in the
   * workflow object so that each model can have it's own output config. If nobody is setting
   * this OutputConfig it would probably be easier to just remove it for now to keep things simpler
   * and then it's more consistent we just don't support the OutputConfig on workflows.
   */
  outputConfig:
    | OutputConfig
    | undefined;
  /**
   * Use this flag to look into clarifai published workflows first for a Workflow ID
   *
   * @deprecated
   */
  favorClarifaiWorkflows: boolean;
  /**
   * A workflow state to be maintained across PostWorkflowResults requests/responses.
   * If it is not sent in the initial request with workflow_state.id = "init" then no
   * state will be saved or returned in PostWorkflowResultsResponse.
   */
  workflowState:
    | WorkflowState
    | undefined;
  /**
   * Specify which compute to use for processing each node of the workflow:
   * The key is the node.id from the loaded workflow.
   * The value is a RunnerSelector in which you can specify the deployment or specific nodepool
   * that you'd like that node to run on.
   * This allows for use cases like some light models could run on a CPU-only nodepool
   * while other models in the workflow require large GPUs.
   *
   * If node.id is not in the provided map, it will fall back to searching for
   * an adequate deployment the model owner owns or fall back to
   * the shared nodepools provided by Clarifai.
   * We recommend you specify these RunnerSelectors so that you have better understanding of where
   * processing occurs.
   */
  nodeRunnerSelectors: { [key: string]: RunnerSelector };
}

export interface PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
  key: string;
  value: RunnerSelector | undefined;
}

/** PostWorkflowResultsResponse */
export interface PostWorkflowResultsResponse {
  /** The status of the request. */
  status:
    | Status
    | undefined;
  /** The workflow that was used in predictions with PostWorkflowResults */
  workflow:
    | Workflow
    | undefined;
  /** The resulting predictions of all models in the workflow. */
  results: WorkflowResult[];
  /**
   * A workflow state to be maintained across PostWorkflowResults requests/responses.
   * This WorkflowState should be passed in to subsequent PostWorkflowResults calls
   * if you want to keep track of state across requests.
   * If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
   * response.
   */
  workflowState: WorkflowState | undefined;
}

/** ListWorkflowVersionsRequest */
export interface ListWorkflowVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List versions for the workflow identified by this id */
  workflowId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** GetWorkflowVersionRequest */
export interface GetWorkflowVersionRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the workflow that has the requested version. */
  workflowId: string;
  /** Get the identified by this id */
  workflowVersionId: string;
}

/** DeleteWorkflowVersionsRequest */
export interface DeleteWorkflowVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the workflow that has the requested versions to delete. */
  workflowId: string;
  /** Delete the versions identified by these ids */
  workflowVersionIds: string[];
}

/** PatchWorkflowVersionsRequest */
export interface PatchWorkflowVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the workflow that has the requested versions to patch. */
  workflowId: string;
  /** Patch these versions. */
  workflowVersions: WorkflowVersion[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

/** MultiWorkflowVersionResponse */
export interface MultiWorkflowVersionResponse {
  status: Status | undefined;
  workflowVersions: WorkflowVersion[];
}

/** SingleWorkflowVersionResponse */
export interface SingleWorkflowVersionResponse {
  status: Status | undefined;
  workflowVersion: WorkflowVersion | undefined;
}

/** Request to start app duplication jobs. */
export interface PostAppDuplicationsRequest {
  /** The user and application ID of the source application to duplicate. */
  userAppId: UserAppIDSet | undefined;
  appDuplications: AppDuplication[];
}

/** Request to get an app duplication job. */
export interface GetAppDuplicationRequest {
  /** The ID of the user that created the app duplication job. */
  userAppId: UserAppIDSet | undefined;
  appDuplicationId: string;
}

/** Request to list all the app duplication jobs that a user created. */
export interface ListAppDuplicationsRequest {
  /** The ID of the user whose app duplication jobs to list. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** MultiAppDuplicationsResponse */
export interface MultiAppDuplicationsResponse {
  status: Status | undefined;
  appDuplications: AppDuplication[];
}

/** SingleAppDuplicationResponse */
export interface SingleAppDuplicationResponse {
  status: Status | undefined;
  appDuplication: AppDuplication | undefined;
}

/** Request to create Tasks. */
export interface PostTasksRequest {
  userAppId: UserAppIDSet | undefined;
  tasks: Task[];
}

/** Request to get one task. */
export interface GetTaskRequest {
  userAppId: UserAppIDSet | undefined;
  taskId: string;
  /**
   * (optional URL parameter) List of additional fields to be included in the response.
   * Currently supported additional fields:
   * - all
   * - worker.users
   * - review.users
   * - metrics.input_source.inputs_count_estimated
   * - metrics.work.inputs_count_estimated
   * - metrics.work.inputs_percent_estimated
   * - metrics.review.inputs_count_estimated
   * - metrics.review.inputs_count_estimated_per_reviewer
   * - metrics.review.inputs_percent_estimated
   * - metrics.review.inputs_percent_estimated_per_reviewer
   * - metrics.review.inputs_reviewable_count_estimated_per_reviewer
   */
  additionalFields: string[];
}

/** Request to list multiple tasks. */
export interface ListTasksRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Get tasks that have ANY user from this list assigned as worker. */
  workerUserIds: string[];
  /** Get tasks that have ANY user from this list assigned as reviewer. */
  reviewUserIds: string[];
  /** Get tasks that are associated to ANY label order from this list. */
  labelOrderIds: string[];
  /**
   * Get label order tasks as well
   * It is automatically set to true if label_order_ids is set.
   */
  includingLabelOrderTasks: boolean;
  /**
   * (optional URL parameter) List of additional fields to be included in the response.
   * Currently supported additional fields:
   * - all
   * - worker.users
   * - review.users
   * - metrics.input_source.inputs_count_estimated
   * - metrics.work.inputs_count_estimated
   * - metrics.work.inputs_percent_estimated
   * - metrics.review.inputs_count_estimated
   * - metrics.review.inputs_count_estimated_per_reviewer
   * - metrics.review.inputs_percent_estimated
   * - metrics.review.inputs_percent_estimated_per_reviewer
   * - metrics.review.inputs_reviewable_count_estimated_per_reviewer
   */
  additionalFields: string[];
  /** (optional) task IDs to filter on */
  ids: string[];
  /** (optional) input source type to filter */
  inputSourceType: TaskInputSource_TaskInputSourceType;
  /** (optional) ids of input source to be filtered */
  inputSourceIds: string[];
}

/** Request to patch a list of tasks. */
export interface PatchTasksRequest {
  userAppId: UserAppIDSet | undefined;
  tasks: Task[];
  /**
   * The action to perform on the patched objects
   * For now, only 'overwrite' action is supported
   */
  action: string;
}

/** Request to delete a list of tasks. */
export interface DeleteTasksRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

/** Response with multiple Tasks. */
export interface MultiTaskResponse {
  status: Status | undefined;
  tasks: Task[];
}

/** Response with a single Task. */
export interface SingleTaskResponse {
  status: Status | undefined;
  task: Task | undefined;
}

/**
 * GetTaskCountRequest can be used for fetching -
 * 1. Task annotation count per user, per status
 * 1. Task input count per user (i.e. task assignment count), per status
 */
export interface GetTaskCountRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** task_id for which count per user per status is needed */
  taskId: string;
  /**
   * Only return counts for these user IDs, effectively operating as an
   * OR among them to filter down the results.
   * If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) counts in the results.
   */
  userIds: string[];
  /**
   * Only return counts for these model version IDs, effectively operating as an
   * OR among them to filter down the results.
   * If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) counts in the results.
   */
  modelVersionIds: string[];
  /**
   * Only return counts for these workflow version IDs, effectively operating as an
   * OR among them to filter down the results.
   * If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
   * we want the union of all worker (user, model or workflow) counts in the results.
   */
  workflowVersionIds: string[];
}

/** SingleTaskCountResponse represents counts of task annotations or inputs (i.e. task assignments) for labelers in given task */
export interface SingleTaskCountResponse {
  status: Status | undefined;
  appId: string;
  taskId: string;
  counts: TaskStatusCountPerUser[];
}

/** Request to create label orders. */
export interface PostLabelOrdersRequest {
  userAppId: UserAppIDSet | undefined;
  labelOrders: LabelOrder[];
}

/** Request to get one label order. */
export interface GetLabelOrderRequest {
  userAppId: UserAppIDSet | undefined;
  labelOrderId: string;
}

/** Request to list multiple label orders. */
export interface ListLabelOrdersRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** Request to patch a list of label orders. */
export interface PatchLabelOrdersRequest {
  userAppId: UserAppIDSet | undefined;
  labelOrders: LabelOrder[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

/** Request to delete a list of label orders. */
export interface DeleteLabelOrdersRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

/** Response with multiple label order. */
export interface MultiLabelOrderResponse {
  status: Status | undefined;
  labelOrders: LabelOrder[];
}

/** Response with a label order. */
export interface SingleLabelOrderResponse {
  status: Status | undefined;
  labelOrder: LabelOrder | undefined;
}

/** Request to create Collectors. */
export interface PostCollectorsRequest {
  userAppId: UserAppIDSet | undefined;
  collectors: Collector[];
}

/** PatchCollectorsRequest */
export interface PatchCollectorsRequest {
  userAppId: UserAppIDSet | undefined;
  collectors: Collector[];
  /**
   * The action to perform on the patched objects
   * Only 'overwrite' is supported
   */
  action: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteCollectorsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
  deleteAll: boolean;
}

/** Request to GET a single Collector. */
export interface GetCollectorRequest {
  userAppId: UserAppIDSet | undefined;
  collectorId: string;
}

/** Request to GET all the Collectors. */
export interface ListCollectorsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** Response with multiple Collectors. */
export interface MultiCollectorResponse {
  status: Status | undefined;
  collectors: Collector[];
}

/** Response with a single Collector. */
export interface SingleCollectorResponse {
  status: Status | undefined;
  collector: Collector | undefined;
}

/** PostStatValuesRequest */
export interface PostStatValuesRequest {
  /** The user and app information for the request. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The stats to post, can post more than one at a time. */
  statValues: StatValue[];
}

/** MultiStatValueResponse */
export interface MultiStatValueResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The returned stats values. */
  statValues: StatValue[];
}

/** PostStatValuesAggregateRequest */
export interface PostStatValuesAggregateRequest {
  /** Ids present in the url of the request. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Query to retrieve aggregate values. */
  statValueAggregateQueries: StatValueAggregateQuery[];
}

/** MultiStatValueAggregateResponse */
export interface MultiStatValueAggregateResponse {
  /** The response status. */
  status:
    | Status
    | undefined;
  /** The aggregate results for each query passedin. */
  statValueAggregateResults: StatValueAggregateResult[];
}

/** GetModuleRequest */
export interface GetModuleRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  additionalFields: string[];
}

/** ListModulesRequest */
export interface ListModulesRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  additionalFields: string[];
  /**
   * Sorting options:
   * Whether to sort in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  /** Whether to order by the created_at time. */
  sortByCreatedAt?:
    | boolean
    | undefined;
  /** Whether to order by the number of users stared the app */
  sortByStarCount?:
    | boolean
    | undefined;
  /** If neither sort option is set to true, will sort by modified_at. */
  sortByModifiedAt?:
    | boolean
    | undefined;
  /** Whether to order by the external id */
  sortById?:
    | boolean
    | undefined;
  /** Filtering options: */
  starredOnly: boolean;
  /** Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only. */
  bookmark: boolean;
  /**
   * Searching options:
   * Specify a search parameter in order to perform keyword search on the
   * following fields of the module:
   *   - id
   *   - description
   *   - user_id (unless user_app_id.user_id is already set)
   *
   * Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
   * and used for partial prefix-matching (so searching for "clari" matches "clarifai").
   *
   * NOTE: Both the list of fields searched and the exact keyword matching
   * rules are subject to change and not guaranteed to be backwards-compatible.
   */
  search: string;
  /**
   * Filter by the id and description of the module. This supports wildcard queries like "gen*" to match "general" as an example.
   * Deprecated: use search instead.
   *
   * @deprecated
   */
  name: string;
  /**
   * Filter by the application owner whose this module belongs to
   * Deprecated: use search instead of name.
   *
   * @deprecated
   */
  filterByUserId: boolean;
  /** Filter by visibility of the modules. If set, only return modules with the specified visibility. */
  visibility: Visibility | undefined;
}

/** PostModulesRequest */
export interface PostModulesRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** This allows you to create one or more module by posting it to the API. */
  modules: Module[];
}

/** PatchModulesRequest */
export interface PatchModulesRequest {
  userAppId: UserAppIDSet | undefined;
  modules: Module[];
  /**
   * The action to perform on the patched objects
   * Supported values: 'overwrite' and 'remove'.
   *
   * Note that 'remove' can only be used to remove the module image by setting
   * 'image.url' in the request to the current value returned for that module.
   */
  action: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteModulesRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

/** SingleModuleResponse */
export interface SingleModuleResponse {
  status: Status | undefined;
  module: Module | undefined;
}

/** MultiModuleResponse */
export interface MultiModuleResponse {
  status: Status | undefined;
  modules: Module[];
}

/** request for different endpoints currently. */
export interface GetModuleVersionRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  moduleVersionId: string;
}

/** ListModuleVersionsRequest */
export interface ListModuleVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PostModuleVersionsRequest */
export interface PostModuleVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  /** This allows you to create one or more module by posting it to the API. */
  moduleVersions: ModuleVersion[];
}

/** PatchModuleVersionsRequest */
export interface PatchModuleVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  /**
   * This allows you to modify the module version details.
   * ########## Supported fields ##########
   * - description
   * - id
   * - metadata.fields
   * - module_nav.module_sub_navs[].query_key
   * - module_nav.module_sub_navs[].query_value
   * - module_nav.module_sub_navs[].title
   * - module_nav.title
   * - notes
   * - visibility.gettable
   */
  moduleVersions: ModuleVersion[];
  /**
   * The action to perform on the patched objects
   * For now only action 'merge' is supported
   */
  action: string;
}

/** Request to delete several module versions by the list of ids. */
export interface DeleteModuleVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  ids: string[];
}

/** Request to get the number of installations (by all users) for the module version */
export interface GetModuleVersionUsageCountRequest {
  userAppId: UserAppIDSet | undefined;
  moduleId: string;
  moduleVersionId: string;
}

/** SingleModuleVersionResponse */
export interface SingleModuleVersionResponse {
  status: Status | undefined;
  moduleVersion: ModuleVersion | undefined;
}

/** MultiModuleVersionResponse */
export interface MultiModuleVersionResponse {
  status: Status | undefined;
  moduleVersions: ModuleVersion[];
}

/** SingleModuleVersionUsageCountResponse */
export interface SingleModuleVersionUsageCountResponse {
  status: Status | undefined;
  usageCount: number;
}

/** GetInstalledModuleVersionRequest */
export interface GetInstalledModuleVersionRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** the ID to get of the install module version. */
  installedModuleVersionId: string;
}

/** ListInstalledModuleVersionsRequest */
export interface ListInstalledModuleVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** PostInstalledModuleVersionsRequest to install a module version into the app in the URL */
export interface PostInstalledModuleVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** This allows you to create one or more module by posting it to the API. */
  installedModuleVersions: InstalledModuleVersion[];
}

/**
 * PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
 * version.
 */
export interface PostInstalledModuleVersionsKeyRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** the ID to get of the install module version. */
  installedModuleVersionId: string;
}

/** Request to delete several installed module versions by the list of ids. */
export interface DeleteInstalledModuleVersionsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

/** SingleInstalledModuleVersionResponse */
export interface SingleInstalledModuleVersionResponse {
  status: Status | undefined;
  installedModuleVersion: InstalledModuleVersion | undefined;
}

/** MultiInstalledModuleVersionResponse */
export interface MultiInstalledModuleVersionResponse {
  status: Status | undefined;
  installedModuleVersions: InstalledModuleVersion[];
}

/** ListNextTaskAssignmentsRequest */
export interface ListNextTaskAssignmentsRequest {
  userAppId: UserAppIDSet | undefined;
  taskId: string;
}

/** Request to perform bulk operations on a list of inputs based on input source. */
export interface PostBulkOperationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc. */
  bulkOperations: BulkOperation[];
}

/** Request to list all the bulk operations. */
export interface ListBulkOperationsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

/** Request to get the details of a bulk operation by ID. */
export interface GetBulkOperationRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The bulk operation id */
  id: string;
}

/** Cancel a list of bulk operation ids */
export interface CancelBulkOperationRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of bulk operation ids to be cancelled */
  ids: string[];
}

/**
 * Request to delete the terminated bulk operations by ID
 * Only operations in terminated state can be deleted.
 */
export interface DeleteBulkOperationRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of bulk operation ids to be deleted */
  ids: string[];
}

/** SingleBulkOperationsResponse */
export interface SingleBulkOperationsResponse {
  status: Status | undefined;
  bulkOperation: BulkOperation | undefined;
}

/** MultiBulkOperationsResponse */
export interface MultiBulkOperationsResponse {
  status: Status | undefined;
  bulkOperation: BulkOperation[];
}

/** PutTaskAssignmentsRequest */
export interface PutTaskAssignmentsRequest {
  userAppId: UserAppIDSet | undefined;
  taskId: string;
  /**
   * Deprecated: use action and action_config instead.
   * Supported for backwards compatibility: setting this field is equivalent with
   * * action = LABEL_SUBMIT
   * * label_submit_config = [{"task_assignments": {{"id": "<task-assignment-id-for-input-id>"}}]
   */
  inputId: string;
  /** Action to perform on selected task. */
  action: PutTaskAssignmentsRequestAction;
  /** LabelStartConfig label_start_config = 5; // no config for label start action */
  labelSubmitConfig?: LabelSubmitConfig | undefined;
  reviewStartConfig?: ReviewStartConfig | undefined;
  reviewApproveConfig?: ReviewApproveConfig | undefined;
  reviewRequestChangesConfig?: ReviewRequestChangesConfig | undefined;
  reviewRejectConfig?: ReviewRejectConfig | undefined;
}

export interface LabelSubmitConfig {
  taskAssignments: TaskAssignment[];
}

export interface ReviewStartConfig {
  /**
   * Review the work done by these workers.
   * If empty, review the work for all workers.
   */
  workers: Worker[];
}

export interface ReviewApproveConfig {
  taskAssignments: TaskAssignment[];
  workers: Worker[];
}

export interface ReviewRequestChangesConfig {
  taskAssignments: TaskAssignment[];
  workers: Worker[];
}

export interface ReviewRejectConfig {
  taskAssignments: TaskAssignment[];
  workers: Worker[];
}

export interface MultiTaskAssignmentResponse {
  status: Status | undefined;
  taskAssignments: TaskAssignment[];
}

/** List all the input ingestion jobs */
export interface ListInputsAddJobsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface GetInputsAddJobRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** id of add inputs job */
  id: string;
}

export interface CancelInputsAddJobRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** id of add inputs job to be cancelled */
  id: string;
}

/** MultiInputsAddJobResponse */
export interface MultiInputsAddJobResponse {
  status: Status | undefined;
  inputsAddJobs: InputsAddJob[];
}

/** SingleInputsAddJobResponse */
export interface SingleInputsAddJobResponse {
  status: Status | undefined;
  inputsAddJob: InputsAddJob | undefined;
}

/** Start a multipart upload */
export interface PostUploadsRequest {
  userAppId: UserAppIDSet | undefined;
  uploads: Upload[];
}

/** Stops or deletes multipart upload */
export interface DeleteUploadsRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

export interface ListUploadsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface GetUploadRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Upload ID */
  uploadId: string;
}

export interface SingleUploadResponse {
  status: Status | undefined;
  upload: Upload | undefined;
}

export interface MultiUploadResponse {
  status: Status | undefined;
  uploads: Upload[];
}

/**
 * Upload a part of a multipart upload.
 * Behaviour on completion depends on the endpoint that was used to initiate the upload.
 */
export interface PutUploadContentPartsRequest {
  userAppId: UserAppIDSet | undefined;
  uploadId: string;
  contentParts: UploadContentPart[];
}

/**
 * Initiates retrieval of inputs from cloud storage from a user provided data source.
 * Will create and return an inputs-add-job for tracking progress.
 * Archives will be extracted and their contents will be processed as inputs.
 *
 * The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
 * files in the images_folder beginning with abc or in a subfolder beginning with abc.
 * For example:
 * bucket/images_folder/abcImage.png
 * bucket/images_folder/abc-1/Data.zip
 *
 * If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
 * Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
 * in which case it only requires rights to access that particular file.
 */
export interface PostInputsDataSourcesRequest {
  userAppId: UserAppIDSet | undefined;
  dataSources: InputsDataSource[];
  /** If call back url is set, we will send a Post request to this endpoint with job status. */
  callBackUrl: string;
  /**
   * Personal Access Token to the application to which inputs are added
   * Deprecated: No need to send app_pat, it will be generated internally if not present
   *
   * @deprecated
   */
  appPat: string;
}

export interface GetInputsExtractionJobRequest {
  userAppId: UserAppIDSet | undefined;
  inputsExtractionJobId: string;
}

export interface ListInputsExtractionJobsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface SingleInputsExtractionJobResponse {
  status: Status | undefined;
  inputsExtractionJob: InputsExtractionJob | undefined;
}

export interface MultiInputsExtractionJobResponse {
  status: Status | undefined;
  inputsExtractionJobs: InputsExtractionJob[];
}

/** Cancel a list of extraction job ids */
export interface CancelInputsExtractionJobsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of extraction job ids to be cancelled */
  ids: string[];
}

/**
 * Start uploading a file archive containing inputs.
 * Will create and return an inputs-add-job for tracking progress.
 *
 * Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
 * Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
 */
export interface PostInputsUploadsRequest {
  userAppId: UserAppIDSet | undefined;
  inputsUploads: InputsUpload[];
}

/** GetRunnerRequest */
export interface GetRunnerRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  runnerId: string;
  computeClusterId: string;
}

/** ListRunnersRequest */
export interface ListRunnersRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  computeClusterId: string;
  /** Only return runners whose replicas are >= min_replicas. */
  minReplicas: number;
  /** (optional URL parameter) ModelVersion IDs. To list all runners for the model version */
  modelVersionIds: string[];
}

/** PostRunnersRequest */
export interface PostRunnersRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  /** This allows you to create one or more runner by posting it to the API. */
  runners: Runner[];
  computeClusterId: string;
}

/** PatchRunnersRequest */
export interface PatchRunnersRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  /** This allows you to create one or more runner by posting it to the API. */
  runners: Runner[];
  computeClusterId: string;
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

/** Request to delete several things by the list of ids. */
export interface DeleteRunnersRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  ids: string[];
  computeClusterId: string;
}

/** SingleRunnerResponse */
export interface SingleRunnerResponse {
  status: Status | undefined;
  runner: Runner | undefined;
}

/** MultiRunnerResponse */
export interface MultiRunnerResponse {
  status: Status | undefined;
  runners: Runner[];
}

export interface ListRunnerItemsRequest {
  userAppId: UserAppIDSet | undefined;
  nodepoolId: string;
  runnerId: string;
  computeClusterId: string;
}

/**
 * PostRunnerItemOutputsRequest
 * This is the message that runners send to the API to communicate.
 * At the end of the request it will have the RunnerItemOutput filled in
 * with results of the workload the runner is processing. Other messages
 * from the runner use this same proto to communicate over to the API
 * and do handshakes.
 */
export interface PostRunnerItemOutputsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The particular nodepool that runner belongs to */
  nodepoolId: string;
  /** The particular runner that processed the work. */
  runnerId: string;
  /** The particular item of work processed. */
  runnerItemId: string;
  /** This allows you to create one or more runner by posting it to the API. */
  runnerItemOutputs: RunnerItemOutput[];
  /**
   * This request has a status so that it can communicate to the API from runners and
   * communicate status, errors, etc. This is on the request since runners operate
   * in a reverse protocol. This status is also used to initiate the
   * ProcessRunnerItems request with RUNNER_STREAM_START code.
   */
  status:
    | Status
    | undefined;
  /**
   * A unique ID to represent the runner. This may be tied to an underlying compute instance
   * information or just an UUID.
   */
  runnerReplicaId: string;
  computeClusterId: string;
  /** Used by agent runners to specify their cloud provider. */
  cloudProviderId: string;
  /** Used by agent runners to specify their region. */
  region: string;
}

/**
 * SyncStateRequest is a message that the control plane sends to the agent runner to notify it of
 * changes to objects.
 */
export interface SyncStateRequest {
  /** The operation that was performed: create, update, delete. */
  operationType: string;
  /** Objects that were affected. */
  computeClusters: ComputeCluster[];
  nodepools: Nodepool[];
  runners: Runner[];
  pipelineVersionRuns: PipelineVersionRun[];
  secrets: Secret[];
}

/** MultiRunnerItemResponse */
export interface MultiRunnerItemResponse {
  status: Status | undefined;
  runnerItems: RunnerItem[];
}

/**
 * This is a unit of work for a runner to process. This comes from the API
 * in the MultiRunnerItemResponse and contains the user's requests
 * to process.
 */
export interface RunnerItem {
  /** A UUID hash for this work item. */
  id: string;
  /** A description of the work to be done in case needed for UIs. */
  description: string;
  /** Information on how to process the given RunnerItem. */
  processingInfo:
    | ProcessingInfo
    | undefined;
  /** Model prediction request from a user. */
  postModelOutputsRequest?:
    | PostModelOutputsRequest
    | undefined;
  /** Agent sync request from control plane. */
  syncStateRequest?: SyncStateRequest | undefined;
}

/**
 * This contains the response of the user's request once processing is done.
 * The runner should fill in the matching output to the RunnerItem.request
 * oneof field. This is sent to the API within PostRunnerItemOutputsRequest
 */
export interface RunnerItemOutput {
  /** The output of a model prediction request. */
  multiOutputResponse?: MultiOutputResponse | undefined;
}

export interface MultiRunnerItemOutputResponse {
  status: Status | undefined;
  runnerItemOutputs: RunnerItemOutput[];
}

/** Get the estimated training time for a model version */
export interface PostModelVersionsTrainingTimeEstimateRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
  modelVersions: ModelVersion[];
  estimatedInputCount: number;
}

/** Estimated training time in seconds */
export interface MultiTrainingTimeEstimateResponse {
  status: Status | undefined;
  trainingTimeEstimates: Duration[];
}

/** List Cloud Providers */
export interface ListCloudProvidersRequest {
}

export interface MultiCloudProviderResponse {
  status: Status | undefined;
  cloudProviders: CloudProvider[];
}

/** List CloudProvider Regions */
export interface ListCloudRegionsRequest {
  /** The cloud provider to list compute clusters for. */
  cloudProvider: CloudProvider | undefined;
}

export interface MultiCloudRegionResponse {
  status: Status | undefined;
  regions: string[];
}

/** List InstanceTypes */
export interface ListInstanceTypesRequest {
  /** The cloud provider to list compute clusters for. */
  cloudProvider:
    | CloudProvider
    | undefined;
  /**
   * The region to list for so when there are multiple regions we get only the clusters
   * that are supposed to be up in that region.
   */
  region: string;
}

export interface MultiInstanceTypeResponse {
  status: Status | undefined;
  instanceTypes: InstanceType[];
}

/** ComputeCLuster CRUD requests and responses */
export interface GetComputeClusterRequest {
  /** Only the user_id is used from this. */
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
}

export interface ListComputeClustersRequest {
  /** Only the user_id is used from this. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostComputeClustersRequest {
  /** Only the user_id is used from this. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** This allows you to create one or more compute_clusters by posting it to the API. */
  computeClusters: ComputeCluster[];
}

export interface DeleteComputeClustersRequest {
  /** Only the user_id is used from this. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of compute cluster ids to be deleted */
  ids: string[];
}

export interface SingleComputeClusterResponse {
  status: Status | undefined;
  computeCluster: ComputeCluster | undefined;
}

export interface MultiComputeClusterResponse {
  status: Status | undefined;
  computeClusters: ComputeCluster[];
}

/**
 * TODO(zeiler): these might not be 100% correct and will be updated as we uncomment the endpoints.
 * Nodepool CRUD requests and responses
 */
export interface GetNodepoolRequest {
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
  nodepoolId: string;
}

export interface ListNodepoolsRequest {
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /**
   * Only return nodepools that are actively being used (having runners with
   * replicas >= threshold and pipeline versions scheduled to run)
   */
  activeUsage: boolean;
}

export interface PostNodepoolsRequest {
  /** Only the user_id is used from this. */
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
  /** This allows you to create one or more nodepools by posting it to the API. */
  nodepools: Nodepool[];
}

/** PatchNodepoolsRequest */
export interface PatchNodepoolsRequest {
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
  nodepools: Nodepool[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

export interface DeleteNodepoolsRequest {
  /** Only the user_id is used from this. */
  userAppId: UserAppIDSet | undefined;
  computeClusterId: string;
  /** List of nodepool ids to be deleted */
  ids: string[];
}

export interface SingleNodepoolResponse {
  status: Status | undefined;
  nodepool: Nodepool | undefined;
}

export interface MultiNodepoolResponse {
  status: Status | undefined;
  nodepools: Nodepool[];
}

/** Deployments CRUD requests and responses */
export interface GetDeploymentRequest {
  userAppId: UserAppIDSet | undefined;
  deploymentId: string;
}

export interface ListDeploymentsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** (optional URL parameter) Nodepool ID. To list all deployed workers in a Nodepool */
  nodepoolId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** (optional URL parameter) ModelVersion IDs. To list all deployments for the model version */
  modelVersionIds: string[];
  /** (optional URL parameter) WorkflowVersion IDs. To list all deployments for the workflow version */
  workflowVersionIds: string[];
  /** (optional URL parameter) ComputeCluster ID. To list all deployed workers in a ComputeCluster */
  computeClusterId: string;
}

export interface PostDeploymentsRequest {
  /** Only the user_id is used from this. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** This allows you to create one or more deployments by posting it to the API. */
  deployments: Deployment[];
}

export interface DeleteDeploymentsRequest {
  /** Only the user_id is used from this. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of deployment ids to be deleted */
  ids: string[];
}

export interface PostAuditLogSearchesRequest {
  /** Only the user_id is used from this. */
  userAppId: UserAppIDSet | undefined;
  query:
    | AuditLogQuery
    | undefined;
  /**
   * Sorting options:
   * Whether to sort by timestamp in ascending order. If false, will order in descending order.
   */
  sortAscending: boolean;
  pagination: Pagination | undefined;
}

export interface MultiAuditLogEntryResponse {
  status: Status | undefined;
  entries: AuditLogEntry[];
}

export interface PatchDeploymentsRequest {
  /** Only the user_id is used from this. */
  userAppId: UserAppIDSet | undefined;
  deployments: Deployment[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

export interface SingleDeploymentResponse {
  status: Status | undefined;
  deployment: Deployment | undefined;
}

export interface MultiDeploymentResponse {
  status: Status | undefined;
  deployments: Deployment[];
}

export interface ListWorkflowEvaluationTemplatesRequest {
}

export interface MultiWorkflowEvaluationTemplateResponse {
  status: Status | undefined;
  workflowVersionEvaluationTemplates: WorkflowVersionEvaluationTemplate[];
}

export interface PostWorkflowVersionEvaluationsRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  /**
   * ########## Supported fields ##########
   * - ground_truth_dataset_version.app_id
   * - ground_truth_dataset_version.dataset_id
   * - ground_truth_dataset_version.id
   * - id
   * - target_node_id
   * - workflow_version_evaluation_template.id
   */
  workflowVersionEvaluations: WorkflowVersionEvaluation[];
  runnerSelectors: RunnerSelector[];
}

export interface PatchWorkflowVersionEvaluationsRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  /**
   * ########## Supported fields ##########
   * - id
   * - predictions_dataset_version.dataset_id
   * - predictions_dataset_version.id
   * - status.code
   * - status.details
   * - workflow_evaluation_result.summary.evaluation_metric_values[].evaluation_metric_id
   * - workflow_evaluation_result.summary.evaluation_metric_values[].explanation
   * - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.float_value
   * - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.int_value
   * - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.string_value
   * - workflow_evaluation_result.summary.evaluation_metric_values[].per_concept_values
   */
  workflowVersionEvaluations: WorkflowVersionEvaluation[];
  /** only overwrite supported */
  action: string;
}

export interface MultiWorkflowVersionEvaluationResponse {
  status: Status | undefined;
  workflowVersionEvaluations: WorkflowVersionEvaluation[];
}

export interface SingleWorkflowVersionEvaluationResponse {
  status: Status | undefined;
  workflowVersionEvaluation: WorkflowVersionEvaluation | undefined;
}

export interface GetWorkflowVersionEvaluationRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  workflowVersionEvaluationId: string;
}

export interface ListWorkflowVersionEvaluationsRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostModelMigrationRequest {
  userAppId: UserAppIDSet | undefined;
  modelId: string;
}

export interface ListWorkflowVersionEvaluationDataRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  workflowVersionEvaluationId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostWorkflowVersionEvaluationDataRequest {
  userAppId: UserAppIDSet | undefined;
  workflowId: string;
  workflowVersionId: string;
  workflowVersionEvaluationId: string;
  /**
   * ########## Supported fields ##########
   * - id
   * - workflow_evaluation_sample_result
   */
  workflowVersionEvaluationData: WorkflowVersionEvaluationData[];
}

export interface MultiListWorkflowVersionEvaluationDataResponse {
  status: Status | undefined;
  workflowVersionEvaluationData: WorkflowVersionEvaluationData[];
}

export interface GetPipelineRequest {
  userAppId: UserAppIDSet | undefined;
  pipelineId: string;
}

export interface ListPipelinesRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostPipelinesRequest {
  userAppId: UserAppIDSet | undefined;
  pipelines: Pipeline[];
}

export interface PatchPipelinesRequest {
  userAppId: UserAppIDSet | undefined;
  pipelines: Pipeline[];
  /**
   * The action to perform on the patched objects
   * For now actions 'overwrite' are supported
   */
  action: string;
}

export interface DeletePipelinesRequest {
  userAppId: UserAppIDSet | undefined;
  ids: string[];
}

export interface SinglePipelineResponse {
  status: Status | undefined;
  pipeline: Pipeline | undefined;
}

export interface MultiPipelineResponse {
  status: Status | undefined;
  pipelines: Pipeline[];
}

export interface GetPipelineVersionRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the pipeline that has the requested version. */
  pipelineId: string;
  /** Get the identified by this id */
  pipelineVersionId: string;
}

export interface ListPipelineVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List versions for the pipeline identified by this id */
  pipelineId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PatchPipelineVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the Pipeline that has the requested versions to patch. */
  pipelineId: string;
  /** Patch these versions */
  pipelineVersions: PipelineVersion[];
  /**
   * The action to perform on the patched objects
   * For now actions 'merge', 'overwrite', and 'remove' are supported
   */
  action: string;
}

export interface DeletePipelineVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the Pipeline for which versions are being deleted */
  pipelineId: string;
  pipelineVersionIds: string[];
}

export interface SinglePipelineVersionResponse {
  status: Status | undefined;
  pipelineVersion: PipelineVersion | undefined;
}

export interface MultiPipelineVersionResponse {
  status: Status | undefined;
  pipelineVersions: PipelineVersion[];
}

export interface GetPipelineVersionRunRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** the ID of the pipeline */
  pipelineId: string;
  /** The ID of the pipeline version */
  pipelineVersionId: string;
  /** the ID of the pipeline version run */
  pipelineVersionRunId: string;
}

export interface ListPipelineVersionRunsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The ID of the pipeline */
  pipelineId: string;
  /** The ID of the pipeline version */
  pipelineVersionId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Filter based on status */
  statusCodes: StatusCode[];
  /** compute cluster id */
  computeClusterId: string;
  /** nodepool id */
  nodepoolId: string;
}

export interface PostPipelineVersionRunsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The ID of the pipeline */
  pipelineId: string;
  /** The ID of the pipeline-version */
  pipelineVersionId: string;
  pipelineVersionRuns: PipelineVersionRun[];
  /** Allows using specific Nodepools for pipeline version runs */
  runnerSelector: RunnerSelector | undefined;
}

export interface PatchPipelineVersionRunsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The ID of the pipeline */
  pipelineId: string;
  /** The ID of the pipeline-version */
  pipelineVersionId: string;
  /**
   * ########## Supported fields ##########
   * - app_id
   * - id
   * - orchestration_status
   * - pipeline_version.id
   * - pipeline_version.pipeline_id
   * - user_id
   */
  pipelineVersionRuns: PipelineVersionRun[];
  /** Supported action: 'overwrite' -> allows to overwrite WorkflowStatus of PipelineVersionRun */
  action: string;
}

export interface SinglePipelineVersionRunResponse {
  status: Status | undefined;
  pipelineVersionRun: PipelineVersionRun | undefined;
}

export interface MultiPipelineVersionRunResponse {
  status: Status | undefined;
  pipelineVersionRuns: PipelineVersionRun[];
}

export interface PostPipelineStepsRequest {
  userAppId: UserAppIDSet | undefined;
  pipelineSteps: PipelineStep[];
}

export interface MultiPipelineStepResponse {
  status: Status | undefined;
  pipelineSteps: PipelineStep[];
}

export interface ListPipelineStepsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface ListPipelineStepVersionsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List versions for the pipeline step identified by this id */
  pipelineStepId: string;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
  /** Filter based on status */
  statusCodes: StatusCode[];
}

export interface MultiPipelineStepVersionResponse {
  /** The status of the request */
  status:
    | Status
    | undefined;
  /** The pipeline step versions that were requested */
  pipelineStepVersions: PipelineStepVersion[];
}

export interface PostPipelineStepVersionsUploadRequest {
  /** Upload a new pipeline step version. */
  uploadConfig?:
    | PostPipelineStepVersionsUploadConfig
    | undefined;
  /** Upload a part of a multipart upload. */
  contentPart?: UploadContentPart | undefined;
}

export interface PostPipelineStepVersionsUploadResponse {
  /** Status of the upload */
  status:
    | Status
    | undefined;
  /** Bytes remaining to be uploaded - This is total_size - bytes_uploaded */
  bytesRemaining: number;
  /** ID of the pipeline step version being uploaded */
  pipelineStepVersionId: string;
}

export interface PostPipelineStepVersionsUploadConfig {
  /** User ID and App ID of the user uploading the pipeline step */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** Pipeline Step to create version for */
  pipelineStepId: string;
  /** Specification for the pipeline step version to be uploaded */
  pipelineStepVersion:
    | PipelineStepVersion
    | undefined;
  /** Number of bytes in the pipeline step files to be uploaded */
  totalSize: number;
  /** Number of bytes requested for the build process. */
  storageRequestSize: number;
}

export interface GetPipelineStepRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the pipeline step that has the requested version. */
  pipelineStepId: string;
}

export interface SinglePipelineStepResponse {
  /** The status of the request */
  status:
    | Status
    | undefined;
  /** The pipeline step that was requested */
  pipelineStep: PipelineStep | undefined;
}

export interface GetPipelineStepVersionRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the pipeline step that has the requested version. */
  pipelineStepId: string;
  /** Get the identified by this id */
  pipelineStepVersionId: string;
}

export interface SinglePipelineStepVersionResponse {
  /** The status of the request */
  status:
    | Status
    | undefined;
  /** The pipeline step version that was requested */
  pipelineStepVersion: PipelineStepVersion | undefined;
}

export interface GetSecretRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The id of the secret to get */
  id: string;
}

export interface ListSecretsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /**
   * (optional URL parameter) The page number. Pagination is used to split the results into chunks.
   * Defaults to 1.
   */
  page: number;
  /**
   * (optional URL parameter) The number of results that will be contained in each page. Defaults
   * to 128.
   */
  perPage: number;
}

export interface PostSecretsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The secrets to create */
  secrets: Secret[];
}

export interface PatchSecretsRequest {
  userAppId: UserAppIDSet | undefined;
  secret: Secret[];
  action: string;
}

export interface DeleteSecretsRequest {
  userAppId:
    | UserAppIDSet
    | undefined;
  /** List of secret ids to be deleted */
  ids: string[];
}

export interface SingleSecretResponse {
  status: Status | undefined;
  secret: Secret | undefined;
}

export interface MultiSecretResponse {
  status: Status | undefined;
  secrets: Secret[];
}

function createBasePagination(): Pagination {
  return { page: 0, perPage: 0 };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(16).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pagination {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetAnnotationRequest(): GetAnnotationRequest {
  return { userAppId: undefined, annotationId: "", inputId: "" };
}

export const GetAnnotationRequest: MessageFns<GetAnnotationRequest> = {
  encode(message: GetAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.annotationId !== "") {
      writer.uint32(18).string(message.annotationId);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "",
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: GetAnnotationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAnnotationRequest>, I>>(base?: I): GetAnnotationRequest {
    return GetAnnotationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAnnotationRequest>, I>>(object: I): GetAnnotationRequest {
    const message = createBaseGetAnnotationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationId = object.annotationId ?? "";
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBaseListAnnotationsRequest(): ListAnnotationsRequest {
  return {
    userAppId: undefined,
    ids: [],
    inputIds: [],
    userIds: [],
    modelVersionIds: [],
    workflowVersionIds: [],
    statuses: [],
    listAllAnnotations: false,
    returnModelOutput: false,
    page: 0,
    perPage: 0,
    taskId: "",
  };
}

export const ListAnnotationsRequest: MessageFns<ListAnnotationsRequest> = {
  encode(message: ListAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.inputIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.userIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.modelVersionIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.workflowVersionIds) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.listAllAnnotations !== false) {
      writer.uint32(48).bool(message.listAllAnnotations);
    }
    if (message.returnModelOutput !== false) {
      writer.uint32(96).bool(message.returnModelOutput);
    }
    if (message.page !== 0) {
      writer.uint32(56).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(64).uint32(message.perPage);
    }
    if (message.taskId !== "") {
      writer.uint32(90).string(message.taskId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputIds.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modelVersionIds.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.workflowVersionIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.listAllAnnotations = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.returnModelOutput = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e: any) => globalThis.String(e)) : [],
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      modelVersionIds: globalThis.Array.isArray(object?.modelVersionIds)
        ? object.modelVersionIds.map((e: any) => globalThis.String(e))
        : [],
      workflowVersionIds: globalThis.Array.isArray(object?.workflowVersionIds)
        ? object.workflowVersionIds.map((e: any) => globalThis.String(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
      listAllAnnotations: isSet(object.listAllAnnotations) ? globalThis.Boolean(object.listAllAnnotations) : false,
      returnModelOutput: isSet(object.returnModelOutput) ? globalThis.Boolean(object.returnModelOutput) : false,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
    };
  },

  toJSON(message: ListAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.modelVersionIds?.length) {
      obj.modelVersionIds = message.modelVersionIds;
    }
    if (message.workflowVersionIds?.length) {
      obj.workflowVersionIds = message.workflowVersionIds;
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    if (message.listAllAnnotations !== false) {
      obj.listAllAnnotations = message.listAllAnnotations;
    }
    if (message.returnModelOutput !== false) {
      obj.returnModelOutput = message.returnModelOutput;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAnnotationsRequest>, I>>(base?: I): ListAnnotationsRequest {
    return ListAnnotationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAnnotationsRequest>, I>>(object: I): ListAnnotationsRequest {
    const message = createBaseListAnnotationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.inputIds = object.inputIds?.map((e) => e) || [];
    message.userIds = object.userIds?.map((e) => e) || [];
    message.modelVersionIds = object.modelVersionIds?.map((e) => e) || [];
    message.workflowVersionIds = object.workflowVersionIds?.map((e) => e) || [];
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    message.listAllAnnotations = object.listAllAnnotations ?? false;
    message.returnModelOutput = object.returnModelOutput ?? false;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBasePostAnnotationsRequest(): PostAnnotationsRequest {
  return { userAppId: undefined, annotations: [] };
}

export const PostAnnotationsRequest: MessageFns<PostAnnotationsRequest> = {
  encode(message: PostAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAnnotationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAnnotationsRequest>, I>>(base?: I): PostAnnotationsRequest {
    return PostAnnotationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAnnotationsRequest>, I>>(object: I): PostAnnotationsRequest {
    const message = createBasePostAnnotationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchAnnotationsRequest(): PatchAnnotationsRequest {
  return { userAppId: undefined, annotations: [], action: "", deleteIfEmptyData: false };
}

export const PatchAnnotationsRequest: MessageFns<PatchAnnotationsRequest> = {
  encode(message: PatchAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.deleteIfEmptyData !== false) {
      writer.uint32(32).bool(message.deleteIfEmptyData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deleteIfEmptyData = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      deleteIfEmptyData: isSet(object.deleteIfEmptyData) ? globalThis.Boolean(object.deleteIfEmptyData) : false,
    };
  },

  toJSON(message: PatchAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.deleteIfEmptyData !== false) {
      obj.deleteIfEmptyData = message.deleteIfEmptyData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationsRequest>, I>>(base?: I): PatchAnnotationsRequest {
    return PatchAnnotationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationsRequest>, I>>(object: I): PatchAnnotationsRequest {
    const message = createBasePatchAnnotationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.action = object.action ?? "";
    message.deleteIfEmptyData = object.deleteIfEmptyData ?? false;
    return message;
  },
};

function createBasePatchAnnotationsStatusRequest(): PatchAnnotationsStatusRequest {
  return { userAppId: undefined, userIds: [], taskId: "", statusCodes: [], action: "", statusCode: 0 };
}

export const PatchAnnotationsStatusRequest: MessageFns<PatchAnnotationsStatusRequest> = {
  encode(message: PatchAnnotationsStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    if (message.taskId !== "") {
      writer.uint32(34).string(message.taskId);
    }
    writer.uint32(50).fork();
    for (const v of message.statusCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.statusCode !== 0) {
      writer.uint32(16).int32(message.statusCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationsStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationsStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.statusCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statusCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusCode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationsStatusRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      statusCodes: globalThis.Array.isArray(object?.statusCodes)
        ? object.statusCodes.map((e: any) => statusCodeFromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      statusCode: isSet(object.statusCode) ? statusCodeFromJSON(object.statusCode) : 0,
    };
  },

  toJSON(message: PatchAnnotationsStatusRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.statusCodes?.length) {
      obj.statusCodes = message.statusCodes.map((e) => statusCodeToJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = statusCodeToJSON(message.statusCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationsStatusRequest>, I>>(base?: I): PatchAnnotationsStatusRequest {
    return PatchAnnotationsStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationsStatusRequest>, I>>(
    object: I,
  ): PatchAnnotationsStatusRequest {
    const message = createBasePatchAnnotationsStatusRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.taskId = object.taskId ?? "";
    message.statusCodes = object.statusCodes?.map((e) => e) || [];
    message.action = object.action ?? "";
    message.statusCode = object.statusCode ?? 0;
    return message;
  },
};

function createBasePatchAnnotationsStatusResponse(): PatchAnnotationsStatusResponse {
  return { status: undefined, userIds: [], updatedCount: 0 };
}

export const PatchAnnotationsStatusResponse: MessageFns<PatchAnnotationsStatusResponse> = {
  encode(message: PatchAnnotationsStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    if (message.updatedCount !== 0) {
      writer.uint32(24).uint32(message.updatedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationsStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationsStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updatedCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationsStatusResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      updatedCount: isSet(object.updatedCount) ? globalThis.Number(object.updatedCount) : 0,
    };
  },

  toJSON(message: PatchAnnotationsStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.updatedCount !== 0) {
      obj.updatedCount = Math.round(message.updatedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationsStatusResponse>, I>>(base?: I): PatchAnnotationsStatusResponse {
    return PatchAnnotationsStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationsStatusResponse>, I>>(
    object: I,
  ): PatchAnnotationsStatusResponse {
    const message = createBasePatchAnnotationsStatusResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.updatedCount = object.updatedCount ?? 0;
    return message;
  },
};

function createBaseDeleteAnnotationRequest(): DeleteAnnotationRequest {
  return { userAppId: undefined, inputId: "", annotationId: "" };
}

export const DeleteAnnotationRequest: MessageFns<DeleteAnnotationRequest> = {
  encode(message: DeleteAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    if (message.annotationId !== "") {
      writer.uint32(26).string(message.annotationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.annotationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "",
    };
  },

  toJSON(message: DeleteAnnotationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotationRequest>, I>>(base?: I): DeleteAnnotationRequest {
    return DeleteAnnotationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotationRequest>, I>>(object: I): DeleteAnnotationRequest {
    const message = createBaseDeleteAnnotationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputId = object.inputId ?? "";
    message.annotationId = object.annotationId ?? "";
    return message;
  },
};

function createBaseDeleteAnnotationsRequest(): DeleteAnnotationsRequest {
  return { userAppId: undefined, ids: [], inputIds: [] };
}

export const DeleteAnnotationsRequest: MessageFns<DeleteAnnotationsRequest> = {
  encode(message: DeleteAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.inputIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotationsRequest>, I>>(base?: I): DeleteAnnotationsRequest {
    return DeleteAnnotationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotationsRequest>, I>>(object: I): DeleteAnnotationsRequest {
    const message = createBaseDeleteAnnotationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.inputIds = object.inputIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListAnnotationTracksRequest(): ListAnnotationTracksRequest {
  return { userAppId: undefined, ids: [], inputId: "", page: 0, perPage: 0 };
}

export const ListAnnotationTracksRequest: MessageFns<ListAnnotationTracksRequest> = {
  encode(message: ListAnnotationTracksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationTracksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationTracksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationTracksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListAnnotationTracksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAnnotationTracksRequest>, I>>(base?: I): ListAnnotationTracksRequest {
    return ListAnnotationTracksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAnnotationTracksRequest>, I>>(object: I): ListAnnotationTracksRequest {
    const message = createBaseListAnnotationTracksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.inputId = object.inputId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostAnnotationTracksRequest(): PostAnnotationTracksRequest {
  return { userAppId: undefined, annotationTracks: [], inputId: "" };
}

export const PostAnnotationTracksRequest: MessageFns<PostAnnotationTracksRequest> = {
  encode(message: PostAnnotationTracksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationTracks) {
      AnnotationTrack.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAnnotationTracksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAnnotationTracksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationTracks.push(AnnotationTrack.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAnnotationTracksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationTracks: globalThis.Array.isArray(object?.annotationTracks)
        ? object.annotationTracks.map((e: any) => AnnotationTrack.fromJSON(e))
        : [],
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: PostAnnotationTracksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationTracks?.length) {
      obj.annotationTracks = message.annotationTracks.map((e) => AnnotationTrack.toJSON(e));
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAnnotationTracksRequest>, I>>(base?: I): PostAnnotationTracksRequest {
    return PostAnnotationTracksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAnnotationTracksRequest>, I>>(object: I): PostAnnotationTracksRequest {
    const message = createBasePostAnnotationTracksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationTracks = object.annotationTracks?.map((e) => AnnotationTrack.fromPartial(e)) || [];
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBasePatchAnnotationTracksRequest(): PatchAnnotationTracksRequest {
  return { userAppId: undefined, annotationTracks: [], inputId: "", action: "" };
}

export const PatchAnnotationTracksRequest: MessageFns<PatchAnnotationTracksRequest> = {
  encode(message: PatchAnnotationTracksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationTracks) {
      AnnotationTrack.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationTracksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationTracksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationTracks.push(AnnotationTrack.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationTracksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationTracks: globalThis.Array.isArray(object?.annotationTracks)
        ? object.annotationTracks.map((e: any) => AnnotationTrack.fromJSON(e))
        : [],
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchAnnotationTracksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationTracks?.length) {
      obj.annotationTracks = message.annotationTracks.map((e) => AnnotationTrack.toJSON(e));
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationTracksRequest>, I>>(base?: I): PatchAnnotationTracksRequest {
    return PatchAnnotationTracksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationTracksRequest>, I>>(object: I): PatchAnnotationTracksRequest {
    const message = createBasePatchAnnotationTracksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationTracks = object.annotationTracks?.map((e) => AnnotationTrack.fromPartial(e)) || [];
    message.inputId = object.inputId ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteAnnotationTracksRequest(): DeleteAnnotationTracksRequest {
  return { userAppId: undefined, ids: [], inputId: "" };
}

export const DeleteAnnotationTracksRequest: MessageFns<DeleteAnnotationTracksRequest> = {
  encode(message: DeleteAnnotationTracksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationTracksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationTracksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationTracksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: DeleteAnnotationTracksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotationTracksRequest>, I>>(base?: I): DeleteAnnotationTracksRequest {
    return DeleteAnnotationTracksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotationTracksRequest>, I>>(
    object: I,
  ): DeleteAnnotationTracksRequest {
    const message = createBaseDeleteAnnotationTracksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBaseMultiAnnotationTrackResponse(): MultiAnnotationTrackResponse {
  return { status: undefined, annotationTracks: [] };
}

export const MultiAnnotationTrackResponse: MessageFns<MultiAnnotationTrackResponse> = {
  encode(message: MultiAnnotationTrackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationTracks) {
      AnnotationTrack.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAnnotationTrackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAnnotationTrackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationTracks.push(AnnotationTrack.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAnnotationTrackResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotationTracks: globalThis.Array.isArray(object?.annotationTracks)
        ? object.annotationTracks.map((e: any) => AnnotationTrack.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAnnotationTrackResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotationTracks?.length) {
      obj.annotationTracks = message.annotationTracks.map((e) => AnnotationTrack.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAnnotationTrackResponse>, I>>(base?: I): MultiAnnotationTrackResponse {
    return MultiAnnotationTrackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAnnotationTrackResponse>, I>>(object: I): MultiAnnotationTrackResponse {
    const message = createBaseMultiAnnotationTrackResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotationTracks = object.annotationTracks?.map((e) => AnnotationTrack.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleAnnotationResponse(): SingleAnnotationResponse {
  return { status: undefined, annotation: undefined };
}

export const SingleAnnotationResponse: MessageFns<SingleAnnotationResponse> = {
  encode(message: SingleAnnotationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleAnnotationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleAnnotationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleAnnotationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
    };
  },

  toJSON(message: SingleAnnotationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleAnnotationResponse>, I>>(base?: I): SingleAnnotationResponse {
    return SingleAnnotationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleAnnotationResponse>, I>>(object: I): SingleAnnotationResponse {
    const message = createBaseSingleAnnotationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    return message;
  },
};

function createBaseMultiAnnotationResponse(): MultiAnnotationResponse {
  return { status: undefined, annotations: [] };
}

export const MultiAnnotationResponse: MessageFns<MultiAnnotationResponse> = {
  encode(message: MultiAnnotationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAnnotationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAnnotationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAnnotationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAnnotationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAnnotationResponse>, I>>(base?: I): MultiAnnotationResponse {
    return MultiAnnotationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAnnotationResponse>, I>>(object: I): MultiAnnotationResponse {
    const message = createBaseMultiAnnotationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListAnnotationWorkersRequest(): ListAnnotationWorkersRequest {
  return { userAppId: undefined, page: 0, perPage: 0, additionalFields: [], trustedOnly: false };
}

export const ListAnnotationWorkersRequest: MessageFns<ListAnnotationWorkersRequest> = {
  encode(message: ListAnnotationWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(34).string(v!);
    }
    if (message.trustedOnly !== false) {
      writer.uint32(40).bool(message.trustedOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.trustedOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationWorkersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      trustedOnly: isSet(object.trustedOnly) ? globalThis.Boolean(object.trustedOnly) : false,
    };
  },

  toJSON(message: ListAnnotationWorkersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.trustedOnly !== false) {
      obj.trustedOnly = message.trustedOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAnnotationWorkersRequest>, I>>(base?: I): ListAnnotationWorkersRequest {
    return ListAnnotationWorkersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAnnotationWorkersRequest>, I>>(object: I): ListAnnotationWorkersRequest {
    const message = createBaseListAnnotationWorkersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.trustedOnly = object.trustedOnly ?? false;
    return message;
  },
};

function createBaseMultiWorkerResponse(): MultiWorkerResponse {
  return { status: undefined, workers: [] };
}

export const MultiWorkerResponse: MessageFns<MultiWorkerResponse> = {
  encode(message: MultiWorkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiWorkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiWorkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiWorkerResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiWorkerResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiWorkerResponse>, I>>(base?: I): MultiWorkerResponse {
    return MultiWorkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiWorkerResponse>, I>>(object: I): MultiWorkerResponse {
    const message = createBaseMultiWorkerResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAppRequest(): GetAppRequest {
  return { userAppId: undefined, additionalFields: [] };
}

export const GetAppRequest: MessageFns<GetAppRequest> = {
  encode(message: GetAppRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.additionalFields) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAppRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAppRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetAppRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAppRequest>, I>>(base?: I): GetAppRequest {
    return GetAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAppRequest>, I>>(object: I): GetAppRequest {
    const message = createBaseGetAppRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseListAppsRequest(): ListAppsRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    additionalFields: [],
    sortAscending: false,
    sortByName: undefined,
    sortByModifiedAt: undefined,
    sortByCreatedAt: undefined,
    sortByStarCount: undefined,
    sortById: undefined,
    featuredOnly: false,
    starredOnly: false,
    templateOnly: false,
    visibility: undefined,
    search: "",
    query: "",
    name: "",
    id: "",
  };
}

export const ListAppsRequest: MessageFns<ListAppsRequest> = {
  encode(message: ListAppsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(82).string(v!);
    }
    if (message.sortAscending !== false) {
      writer.uint32(40).bool(message.sortAscending);
    }
    if (message.sortByName !== undefined) {
      writer.uint32(48).bool(message.sortByName);
    }
    if (message.sortByModifiedAt !== undefined) {
      writer.uint32(56).bool(message.sortByModifiedAt);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(96).bool(message.sortByCreatedAt);
    }
    if (message.sortByStarCount !== undefined) {
      writer.uint32(104).bool(message.sortByStarCount);
    }
    if (message.sortById !== undefined) {
      writer.uint32(136).bool(message.sortById);
    }
    if (message.featuredOnly !== false) {
      writer.uint32(72).bool(message.featuredOnly);
    }
    if (message.starredOnly !== false) {
      writer.uint32(88).bool(message.starredOnly);
    }
    if (message.templateOnly !== false) {
      writer.uint32(128).bool(message.templateOnly);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(146).fork()).join();
    }
    if (message.search !== "") {
      writer.uint32(122).string(message.search);
    }
    if (message.query !== "") {
      writer.uint32(66).string(message.query);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(114).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAppsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sortByName = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortByModifiedAt = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.sortByStarCount = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sortById = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.featuredOnly = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.starredOnly = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.templateOnly = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAppsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByName: isSet(object.sortByName) ? globalThis.Boolean(object.sortByName) : undefined,
      sortByModifiedAt: isSet(object.sortByModifiedAt) ? globalThis.Boolean(object.sortByModifiedAt) : undefined,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByStarCount: isSet(object.sortByStarCount) ? globalThis.Boolean(object.sortByStarCount) : undefined,
      sortById: isSet(object.sortById) ? globalThis.Boolean(object.sortById) : undefined,
      featuredOnly: isSet(object.featuredOnly) ? globalThis.Boolean(object.featuredOnly) : false,
      starredOnly: isSet(object.starredOnly) ? globalThis.Boolean(object.starredOnly) : false,
      templateOnly: isSet(object.templateOnly) ? globalThis.Boolean(object.templateOnly) : false,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ListAppsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByName !== undefined) {
      obj.sortByName = message.sortByName;
    }
    if (message.sortByModifiedAt !== undefined) {
      obj.sortByModifiedAt = message.sortByModifiedAt;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByStarCount !== undefined) {
      obj.sortByStarCount = message.sortByStarCount;
    }
    if (message.sortById !== undefined) {
      obj.sortById = message.sortById;
    }
    if (message.featuredOnly !== false) {
      obj.featuredOnly = message.featuredOnly;
    }
    if (message.starredOnly !== false) {
      obj.starredOnly = message.starredOnly;
    }
    if (message.templateOnly !== false) {
      obj.templateOnly = message.templateOnly;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAppsRequest>, I>>(base?: I): ListAppsRequest {
    return ListAppsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAppsRequest>, I>>(object: I): ListAppsRequest {
    const message = createBaseListAppsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.sortAscending = object.sortAscending ?? false;
    message.sortByName = object.sortByName ?? undefined;
    message.sortByModifiedAt = object.sortByModifiedAt ?? undefined;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByStarCount = object.sortByStarCount ?? undefined;
    message.sortById = object.sortById ?? undefined;
    message.featuredOnly = object.featuredOnly ?? false;
    message.starredOnly = object.starredOnly ?? false;
    message.templateOnly = object.templateOnly ?? false;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.search = object.search ?? "";
    message.query = object.query ?? "";
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePostAppsRequest(): PostAppsRequest {
  return { userAppId: undefined, apps: [] };
}

export const PostAppsRequest: MessageFns<PostAppsRequest> = {
  encode(message: PostAppsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAppsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAppsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostAppsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAppsRequest>, I>>(base?: I): PostAppsRequest {
    return PostAppsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAppsRequest>, I>>(object: I): PostAppsRequest {
    const message = createBasePostAppsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteAppRequest(): DeleteAppRequest {
  return { userAppId: undefined };
}

export const DeleteAppRequest: MessageFns<DeleteAppRequest> = {
  encode(message: DeleteAppRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAppRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAppRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: DeleteAppRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAppRequest>, I>>(base?: I): DeleteAppRequest {
    return DeleteAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAppRequest>, I>>(object: I): DeleteAppRequest {
    const message = createBaseDeleteAppRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBasePatchAppsRequest(): PatchAppsRequest {
  return { userAppId: undefined, apps: [], action: "", metadataAction: undefined, reindex: false };
}

export const PatchAppsRequest: MessageFns<PatchAppsRequest> = {
  encode(message: PatchAppsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.metadataAction !== undefined) {
      PatchAction.encode(message.metadataAction, writer.uint32(34).fork()).join();
    }
    if (message.reindex !== false) {
      writer.uint32(40).bool(message.reindex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAppsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadataAction = PatchAction.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reindex = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAppsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      metadataAction: isSet(object.metadataAction) ? PatchAction.fromJSON(object.metadataAction) : undefined,
      reindex: isSet(object.reindex) ? globalThis.Boolean(object.reindex) : false,
    };
  },

  toJSON(message: PatchAppsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.metadataAction !== undefined) {
      obj.metadataAction = PatchAction.toJSON(message.metadataAction);
    }
    if (message.reindex !== false) {
      obj.reindex = message.reindex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAppsRequest>, I>>(base?: I): PatchAppsRequest {
    return PatchAppsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAppsRequest>, I>>(object: I): PatchAppsRequest {
    const message = createBasePatchAppsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    message.action = object.action ?? "";
    message.metadataAction = (object.metadataAction !== undefined && object.metadataAction !== null)
      ? PatchAction.fromPartial(object.metadataAction)
      : undefined;
    message.reindex = object.reindex ?? false;
    return message;
  },
};

function createBasePatchAppsDetailsRequest(): PatchAppsDetailsRequest {
  return { userAppId: undefined, apps: [], action: "" };
}

export const PatchAppsDetailsRequest: MessageFns<PatchAppsDetailsRequest> = {
  encode(message: PatchAppsDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAppsDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAppsDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAppsDetailsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchAppsDetailsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAppsDetailsRequest>, I>>(base?: I): PatchAppsDetailsRequest {
    return PatchAppsDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAppsDetailsRequest>, I>>(object: I): PatchAppsDetailsRequest {
    const message = createBasePatchAppsDetailsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchAppRequest(): PatchAppRequest {
  return { userAppId: undefined, app: undefined, action: "", metadataAction: undefined, reindex: false };
}

export const PatchAppRequest: MessageFns<PatchAppRequest> = {
  encode(message: PatchAppRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.metadataAction !== undefined) {
      PatchAction.encode(message.metadataAction, writer.uint32(34).fork()).join();
    }
    if (message.reindex !== false) {
      writer.uint32(40).bool(message.reindex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAppRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadataAction = PatchAction.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reindex = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAppRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      metadataAction: isSet(object.metadataAction) ? PatchAction.fromJSON(object.metadataAction) : undefined,
      reindex: isSet(object.reindex) ? globalThis.Boolean(object.reindex) : false,
    };
  },

  toJSON(message: PatchAppRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.metadataAction !== undefined) {
      obj.metadataAction = PatchAction.toJSON(message.metadataAction);
    }
    if (message.reindex !== false) {
      obj.reindex = message.reindex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAppRequest>, I>>(base?: I): PatchAppRequest {
    return PatchAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAppRequest>, I>>(object: I): PatchAppRequest {
    const message = createBasePatchAppRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    message.action = object.action ?? "";
    message.metadataAction = (object.metadataAction !== undefined && object.metadataAction !== null)
      ? PatchAction.fromPartial(object.metadataAction)
      : undefined;
    message.reindex = object.reindex ?? false;
    return message;
  },
};

function createBasePatchAppsIdsRequest(): PatchAppsIdsRequest {
  return { userAppId: undefined, ids: [], action: "" };
}

export const PatchAppsIdsRequest: MessageFns<PatchAppsIdsRequest> = {
  encode(message: PatchAppsIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      IdUpdateSource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAppsIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAppsIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(IdUpdateSource.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAppsIdsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => IdUpdateSource.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchAppsIdsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => IdUpdateSource.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAppsIdsRequest>, I>>(base?: I): PatchAppsIdsRequest {
    return PatchAppsIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAppsIdsRequest>, I>>(object: I): PatchAppsIdsRequest {
    const message = createBasePatchAppsIdsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => IdUpdateSource.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePostAppsSearchesRequest(): PostAppsSearchesRequest {
  return { userAppId: undefined, appQuery: undefined, pagination: undefined };
}

export const PostAppsSearchesRequest: MessageFns<PostAppsSearchesRequest> = {
  encode(message: PostAppsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.appQuery !== undefined) {
      AppQuery.encode(message.appQuery, writer.uint32(18).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAppsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAppsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appQuery = AppQuery.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAppsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      appQuery: isSet(object.appQuery) ? AppQuery.fromJSON(object.appQuery) : undefined,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostAppsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.appQuery !== undefined) {
      obj.appQuery = AppQuery.toJSON(message.appQuery);
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAppsSearchesRequest>, I>>(base?: I): PostAppsSearchesRequest {
    return PostAppsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAppsSearchesRequest>, I>>(object: I): PostAppsSearchesRequest {
    const message = createBasePostAppsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.appQuery = (object.appQuery !== undefined && object.appQuery !== null)
      ? AppQuery.fromPartial(object.appQuery)
      : undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSingleAppResponse(): SingleAppResponse {
  return { status: undefined, app: undefined };
}

export const SingleAppResponse: MessageFns<SingleAppResponse> = {
  encode(message: SingleAppResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleAppResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleAppResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
    };
  },

  toJSON(message: SingleAppResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleAppResponse>, I>>(base?: I): SingleAppResponse {
    return SingleAppResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleAppResponse>, I>>(object: I): SingleAppResponse {
    const message = createBaseSingleAppResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    return message;
  },
};

function createBaseMultiAppResponse(): MultiAppResponse {
  return { status: undefined, apps: [] };
}

export const MultiAppResponse: MessageFns<MultiAppResponse> = {
  encode(message: MultiAppResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAppResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAppResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiAppResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAppResponse>, I>>(base?: I): MultiAppResponse {
    return MultiAppResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAppResponse>, I>>(object: I): MultiAppResponse {
    const message = createBaseMultiAppResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListCollaboratorsRequest(): ListCollaboratorsRequest {
  return { userAppId: undefined, listAllCollaborators: false, page: 0, perPage: 0 };
}

export const ListCollaboratorsRequest: MessageFns<ListCollaboratorsRequest> = {
  encode(message: ListCollaboratorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.listAllCollaborators !== false) {
      writer.uint32(16).bool(message.listAllCollaborators);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollaboratorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollaboratorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.listAllCollaborators = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollaboratorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      listAllCollaborators: isSet(object.listAllCollaborators)
        ? globalThis.Boolean(object.listAllCollaborators)
        : false,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListCollaboratorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.listAllCollaborators !== false) {
      obj.listAllCollaborators = message.listAllCollaborators;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollaboratorsRequest>, I>>(base?: I): ListCollaboratorsRequest {
    return ListCollaboratorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollaboratorsRequest>, I>>(object: I): ListCollaboratorsRequest {
    const message = createBaseListCollaboratorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.listAllCollaborators = object.listAllCollaborators ?? false;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostCollaboratorsRequest(): PostCollaboratorsRequest {
  return { userAppId: undefined, collaborators: [] };
}

export const PostCollaboratorsRequest: MessageFns<PostCollaboratorsRequest> = {
  encode(message: PostCollaboratorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.collaborators) {
      Collaborator.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostCollaboratorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostCollaboratorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collaborators.push(Collaborator.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostCollaboratorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collaborators: globalThis.Array.isArray(object?.collaborators)
        ? object.collaborators.map((e: any) => Collaborator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostCollaboratorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collaborators?.length) {
      obj.collaborators = message.collaborators.map((e) => Collaborator.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostCollaboratorsRequest>, I>>(base?: I): PostCollaboratorsRequest {
    return PostCollaboratorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostCollaboratorsRequest>, I>>(object: I): PostCollaboratorsRequest {
    const message = createBasePostCollaboratorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collaborators = object.collaborators?.map((e) => Collaborator.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchCollaboratorsRequest(): PatchCollaboratorsRequest {
  return { userAppId: undefined, collaborators: [], action: "" };
}

export const PatchCollaboratorsRequest: MessageFns<PatchCollaboratorsRequest> = {
  encode(message: PatchCollaboratorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.collaborators) {
      Collaborator.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchCollaboratorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchCollaboratorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collaborators.push(Collaborator.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchCollaboratorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collaborators: globalThis.Array.isArray(object?.collaborators)
        ? object.collaborators.map((e: any) => Collaborator.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchCollaboratorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collaborators?.length) {
      obj.collaborators = message.collaborators.map((e) => Collaborator.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchCollaboratorsRequest>, I>>(base?: I): PatchCollaboratorsRequest {
    return PatchCollaboratorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchCollaboratorsRequest>, I>>(object: I): PatchCollaboratorsRequest {
    const message = createBasePatchCollaboratorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collaborators = object.collaborators?.map((e) => Collaborator.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteCollaboratorsRequest(): DeleteCollaboratorsRequest {
  return { userAppId: undefined, collaboratorIds: [], userEmails: [] };
}

export const DeleteCollaboratorsRequest: MessageFns<DeleteCollaboratorsRequest> = {
  encode(message: DeleteCollaboratorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.collaboratorIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.userEmails) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollaboratorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollaboratorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collaboratorIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userEmails.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollaboratorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collaboratorIds: globalThis.Array.isArray(object?.collaboratorIds)
        ? object.collaboratorIds.map((e: any) => globalThis.String(e))
        : [],
      userEmails: globalThis.Array.isArray(object?.userEmails)
        ? object.userEmails.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteCollaboratorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collaboratorIds?.length) {
      obj.collaboratorIds = message.collaboratorIds;
    }
    if (message.userEmails?.length) {
      obj.userEmails = message.userEmails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollaboratorsRequest>, I>>(base?: I): DeleteCollaboratorsRequest {
    return DeleteCollaboratorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollaboratorsRequest>, I>>(object: I): DeleteCollaboratorsRequest {
    const message = createBaseDeleteCollaboratorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collaboratorIds = object.collaboratorIds?.map((e) => e) || [];
    message.userEmails = object.userEmails?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiCollaboratorsResponse(): MultiCollaboratorsResponse {
  return { status: undefined, collaborators: [], appOwner: undefined };
}

export const MultiCollaboratorsResponse: MessageFns<MultiCollaboratorsResponse> = {
  encode(message: MultiCollaboratorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.collaborators) {
      Collaborator.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.appOwner !== undefined) {
      User.encode(message.appOwner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCollaboratorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCollaboratorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collaborators.push(Collaborator.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appOwner = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCollaboratorsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      collaborators: globalThis.Array.isArray(object?.collaborators)
        ? object.collaborators.map((e: any) => Collaborator.fromJSON(e))
        : [],
      appOwner: isSet(object.appOwner) ? User.fromJSON(object.appOwner) : undefined,
    };
  },

  toJSON(message: MultiCollaboratorsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.collaborators?.length) {
      obj.collaborators = message.collaborators.map((e) => Collaborator.toJSON(e));
    }
    if (message.appOwner !== undefined) {
      obj.appOwner = User.toJSON(message.appOwner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCollaboratorsResponse>, I>>(base?: I): MultiCollaboratorsResponse {
    return MultiCollaboratorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCollaboratorsResponse>, I>>(object: I): MultiCollaboratorsResponse {
    const message = createBaseMultiCollaboratorsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.collaborators = object.collaborators?.map((e) => Collaborator.fromPartial(e)) || [];
    message.appOwner = (object.appOwner !== undefined && object.appOwner !== null)
      ? User.fromPartial(object.appOwner)
      : undefined;
    return message;
  },
};

function createBaseListCollaborationsRequest(): ListCollaborationsRequest {
  return { userAppId: undefined, page: 0, perPage: 0, templateOnly: false };
}

export const ListCollaborationsRequest: MessageFns<ListCollaborationsRequest> = {
  encode(message: ListCollaborationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    if (message.templateOnly !== false) {
      writer.uint32(32).bool(message.templateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollaborationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollaborationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.templateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollaborationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      templateOnly: isSet(object.templateOnly) ? globalThis.Boolean(object.templateOnly) : false,
    };
  },

  toJSON(message: ListCollaborationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.templateOnly !== false) {
      obj.templateOnly = message.templateOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollaborationsRequest>, I>>(base?: I): ListCollaborationsRequest {
    return ListCollaborationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollaborationsRequest>, I>>(object: I): ListCollaborationsRequest {
    const message = createBaseListCollaborationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.templateOnly = object.templateOnly ?? false;
    return message;
  },
};

function createBaseMultiCollaborationsResponse(): MultiCollaborationsResponse {
  return { status: undefined, collaborations: [] };
}

export const MultiCollaborationsResponse: MessageFns<MultiCollaborationsResponse> = {
  encode(message: MultiCollaborationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.collaborations) {
      Collaboration.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCollaborationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCollaborationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collaborations.push(Collaboration.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCollaborationsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      collaborations: globalThis.Array.isArray(object?.collaborations)
        ? object.collaborations.map((e: any) => Collaboration.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiCollaborationsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.collaborations?.length) {
      obj.collaborations = message.collaborations.map((e) => Collaboration.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCollaborationsResponse>, I>>(base?: I): MultiCollaborationsResponse {
    return MultiCollaborationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCollaborationsResponse>, I>>(object: I): MultiCollaborationsResponse {
    const message = createBaseMultiCollaborationsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.collaborations = object.collaborations?.map((e) => Collaboration.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStatusCodeRequest(): GetStatusCodeRequest {
  return { statusCodeId: "" };
}

export const GetStatusCodeRequest: MessageFns<GetStatusCodeRequest> = {
  encode(message: GetStatusCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusCodeId !== "") {
      writer.uint32(10).string(message.statusCodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatusCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatusCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statusCodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatusCodeRequest {
    return { statusCodeId: isSet(object.statusCodeId) ? globalThis.String(object.statusCodeId) : "" };
  },

  toJSON(message: GetStatusCodeRequest): unknown {
    const obj: any = {};
    if (message.statusCodeId !== "") {
      obj.statusCodeId = message.statusCodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatusCodeRequest>, I>>(base?: I): GetStatusCodeRequest {
    return GetStatusCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatusCodeRequest>, I>>(object: I): GetStatusCodeRequest {
    const message = createBaseGetStatusCodeRequest();
    message.statusCodeId = object.statusCodeId ?? "";
    return message;
  },
};

function createBaseListStatusCodesRequest(): ListStatusCodesRequest {
  return {};
}

export const ListStatusCodesRequest: MessageFns<ListStatusCodesRequest> = {
  encode(_: ListStatusCodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatusCodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatusCodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListStatusCodesRequest {
    return {};
  },

  toJSON(_: ListStatusCodesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStatusCodesRequest>, I>>(base?: I): ListStatusCodesRequest {
    return ListStatusCodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStatusCodesRequest>, I>>(_: I): ListStatusCodesRequest {
    const message = createBaseListStatusCodesRequest();
    return message;
  },
};

function createBaseSingleStatusCodeResponse(): SingleStatusCodeResponse {
  return { status: undefined };
}

export const SingleStatusCodeResponse: MessageFns<SingleStatusCodeResponse> = {
  encode(message: SingleStatusCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleStatusCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleStatusCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleStatusCodeResponse {
    return { status: isSet(object.status) ? Status.fromJSON(object.status) : undefined };
  },

  toJSON(message: SingleStatusCodeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleStatusCodeResponse>, I>>(base?: I): SingleStatusCodeResponse {
    return SingleStatusCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleStatusCodeResponse>, I>>(object: I): SingleStatusCodeResponse {
    const message = createBaseSingleStatusCodeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseMultiStatusCodeResponse(): MultiStatusCodeResponse {
  return { status: undefined, statuses: [] };
}

export const MultiStatusCodeResponse: MessageFns<MultiStatusCodeResponse> = {
  encode(message: MultiStatusCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiStatusCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiStatusCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiStatusCodeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiStatusCodeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiStatusCodeResponse>, I>>(base?: I): MultiStatusCodeResponse {
    return MultiStatusCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiStatusCodeResponse>, I>>(object: I): MultiStatusCodeResponse {
    const message = createBaseMultiStatusCodeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetConceptRequest(): GetConceptRequest {
  return { userAppId: undefined, conceptId: "" };
}

export const GetConceptRequest: MessageFns<GetConceptRequest> = {
  encode(message: GetConceptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConceptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConceptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConceptRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
    };
  },

  toJSON(message: GetConceptRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConceptRequest>, I>>(base?: I): GetConceptRequest {
    return GetConceptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConceptRequest>, I>>(object: I): GetConceptRequest {
    const message = createBaseGetConceptRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    return message;
  },
};

function createBaseListConceptsRequest(): ListConceptsRequest {
  return { userAppId: undefined, page: 0, perPage: 0, id: "" };
}

export const ListConceptsRequest: MessageFns<ListConceptsRequest> = {
  encode(message: ListConceptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConceptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConceptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConceptsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ListConceptsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConceptsRequest>, I>>(base?: I): ListConceptsRequest {
    return ListConceptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConceptsRequest>, I>>(object: I): ListConceptsRequest {
    const message = createBaseListConceptsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListModelConceptsRequest(): ListModelConceptsRequest {
  return { userAppId: undefined, modelId: "", versionId: "", page: 0, perPage: 0, search: "" };
}

export const ListModelConceptsRequest: MessageFns<ListModelConceptsRequest> = {
  encode(message: ListModelConceptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    if (message.search !== "") {
      writer.uint32(50).string(message.search);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelConceptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelConceptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.search = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelConceptsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
    };
  },

  toJSON(message: ListModelConceptsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelConceptsRequest>, I>>(base?: I): ListModelConceptsRequest {
    return ListModelConceptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelConceptsRequest>, I>>(object: I): ListModelConceptsRequest {
    const message = createBaseListModelConceptsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.search = object.search ?? "";
    return message;
  },
};

function createBasePostConceptsSearchesRequest(): PostConceptsSearchesRequest {
  return { userAppId: undefined, conceptQuery: undefined, extraInfo: undefined, pagination: undefined };
}

export const PostConceptsSearchesRequest: MessageFns<PostConceptsSearchesRequest> = {
  encode(message: PostConceptsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptQuery !== undefined) {
      ConceptQuery.encode(message.conceptQuery, writer.uint32(18).fork()).join();
    }
    if (message.extraInfo !== undefined) {
      ConceptExtraInfoRequest.encode(message.extraInfo, writer.uint32(34).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostConceptsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostConceptsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptQuery = ConceptQuery.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraInfo = ConceptExtraInfoRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostConceptsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptQuery: isSet(object.conceptQuery) ? ConceptQuery.fromJSON(object.conceptQuery) : undefined,
      extraInfo: isSet(object.extraInfo) ? ConceptExtraInfoRequest.fromJSON(object.extraInfo) : undefined,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostConceptsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptQuery !== undefined) {
      obj.conceptQuery = ConceptQuery.toJSON(message.conceptQuery);
    }
    if (message.extraInfo !== undefined) {
      obj.extraInfo = ConceptExtraInfoRequest.toJSON(message.extraInfo);
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostConceptsSearchesRequest>, I>>(base?: I): PostConceptsSearchesRequest {
    return PostConceptsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostConceptsSearchesRequest>, I>>(object: I): PostConceptsSearchesRequest {
    const message = createBasePostConceptsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptQuery = (object.conceptQuery !== undefined && object.conceptQuery !== null)
      ? ConceptQuery.fromPartial(object.conceptQuery)
      : undefined;
    message.extraInfo = (object.extraInfo !== undefined && object.extraInfo !== null)
      ? ConceptExtraInfoRequest.fromPartial(object.extraInfo)
      : undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseConceptExtraInfoRequest(): ConceptExtraInfoRequest {
  return { rankableModel: undefined };
}

export const ConceptExtraInfoRequest: MessageFns<ConceptExtraInfoRequest> = {
  encode(message: ConceptExtraInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankableModel !== undefined) {
      Model.encode(message.rankableModel, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptExtraInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptExtraInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankableModel = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptExtraInfoRequest {
    return { rankableModel: isSet(object.rankableModel) ? Model.fromJSON(object.rankableModel) : undefined };
  },

  toJSON(message: ConceptExtraInfoRequest): unknown {
    const obj: any = {};
    if (message.rankableModel !== undefined) {
      obj.rankableModel = Model.toJSON(message.rankableModel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptExtraInfoRequest>, I>>(base?: I): ConceptExtraInfoRequest {
    return ConceptExtraInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptExtraInfoRequest>, I>>(object: I): ConceptExtraInfoRequest {
    const message = createBaseConceptExtraInfoRequest();
    message.rankableModel = (object.rankableModel !== undefined && object.rankableModel !== null)
      ? Model.fromPartial(object.rankableModel)
      : undefined;
    return message;
  },
};

function createBasePostConceptsRequest(): PostConceptsRequest {
  return { userAppId: undefined, concepts: [] };
}

export const PostConceptsRequest: MessageFns<PostConceptsRequest> = {
  encode(message: PostConceptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostConceptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostConceptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostConceptsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostConceptsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostConceptsRequest>, I>>(base?: I): PostConceptsRequest {
    return PostConceptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostConceptsRequest>, I>>(object: I): PostConceptsRequest {
    const message = createBasePostConceptsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchConceptsRequest(): PatchConceptsRequest {
  return { userAppId: undefined, concepts: [], action: "" };
}

export const PatchConceptsRequest: MessageFns<PatchConceptsRequest> = {
  encode(message: PatchConceptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchConceptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchConceptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchConceptsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchConceptsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchConceptsRequest>, I>>(base?: I): PatchConceptsRequest {
    return PatchConceptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchConceptsRequest>, I>>(object: I): PatchConceptsRequest {
    const message = createBasePatchConceptsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseGetConceptCountsRequest(): GetConceptCountsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const GetConceptCountsRequest: MessageFns<GetConceptCountsRequest> = {
  encode(message: GetConceptCountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConceptCountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConceptCountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConceptCountsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: GetConceptCountsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConceptCountsRequest>, I>>(base?: I): GetConceptCountsRequest {
    return GetConceptCountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConceptCountsRequest>, I>>(object: I): GetConceptCountsRequest {
    const message = createBaseGetConceptCountsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseSingleConceptResponse(): SingleConceptResponse {
  return { status: undefined, concept: undefined };
}

export const SingleConceptResponse: MessageFns<SingleConceptResponse> = {
  encode(message: SingleConceptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.concept !== undefined) {
      Concept.encode(message.concept, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleConceptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleConceptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concept = Concept.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleConceptResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      concept: isSet(object.concept) ? Concept.fromJSON(object.concept) : undefined,
    };
  },

  toJSON(message: SingleConceptResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.concept !== undefined) {
      obj.concept = Concept.toJSON(message.concept);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleConceptResponse>, I>>(base?: I): SingleConceptResponse {
    return SingleConceptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleConceptResponse>, I>>(object: I): SingleConceptResponse {
    const message = createBaseSingleConceptResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.concept = (object.concept !== undefined && object.concept !== null)
      ? Concept.fromPartial(object.concept)
      : undefined;
    return message;
  },
};

function createBaseMultiConceptResponse(): MultiConceptResponse {
  return { status: undefined, concepts: [] };
}

export const MultiConceptResponse: MessageFns<MultiConceptResponse> = {
  encode(message: MultiConceptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiConceptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiConceptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiConceptResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiConceptResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiConceptResponse>, I>>(base?: I): MultiConceptResponse {
    return MultiConceptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiConceptResponse>, I>>(object: I): MultiConceptResponse {
    const message = createBaseMultiConceptResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiConceptCountResponse(): MultiConceptCountResponse {
  return { status: undefined, conceptCounts: [] };
}

export const MultiConceptCountResponse: MessageFns<MultiConceptCountResponse> = {
  encode(message: MultiConceptCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.conceptCounts) {
      ConceptCount.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiConceptCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiConceptCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptCounts.push(ConceptCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiConceptCountResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      conceptCounts: globalThis.Array.isArray(object?.conceptCounts)
        ? object.conceptCounts.map((e: any) => ConceptCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiConceptCountResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.conceptCounts?.length) {
      obj.conceptCounts = message.conceptCounts.map((e) => ConceptCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiConceptCountResponse>, I>>(base?: I): MultiConceptCountResponse {
    return MultiConceptCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiConceptCountResponse>, I>>(object: I): MultiConceptCountResponse {
    const message = createBaseMultiConceptCountResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.conceptCounts = object.conceptCounts?.map((e) => ConceptCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListConceptRelationsRequest(): ListConceptRelationsRequest {
  return { userAppId: undefined, conceptId: "", predicate: "", knowledgeGraphId: "", page: 0, perPage: 0 };
}

export const ListConceptRelationsRequest: MessageFns<ListConceptRelationsRequest> = {
  encode(message: ListConceptRelationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    if (message.predicate !== "") {
      writer.uint32(26).string(message.predicate);
    }
    if (message.knowledgeGraphId !== "") {
      writer.uint32(34).string(message.knowledgeGraphId);
    }
    if (message.page !== 0) {
      writer.uint32(40).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(48).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConceptRelationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConceptRelationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predicate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.knowledgeGraphId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConceptRelationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      predicate: isSet(object.predicate) ? globalThis.String(object.predicate) : "",
      knowledgeGraphId: isSet(object.knowledgeGraphId) ? globalThis.String(object.knowledgeGraphId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListConceptRelationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.predicate !== "") {
      obj.predicate = message.predicate;
    }
    if (message.knowledgeGraphId !== "") {
      obj.knowledgeGraphId = message.knowledgeGraphId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConceptRelationsRequest>, I>>(base?: I): ListConceptRelationsRequest {
    return ListConceptRelationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConceptRelationsRequest>, I>>(object: I): ListConceptRelationsRequest {
    const message = createBaseListConceptRelationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.predicate = object.predicate ?? "";
    message.knowledgeGraphId = object.knowledgeGraphId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostConceptRelationsRequest(): PostConceptRelationsRequest {
  return { userAppId: undefined, conceptId: "", conceptRelations: [] };
}

export const PostConceptRelationsRequest: MessageFns<PostConceptRelationsRequest> = {
  encode(message: PostConceptRelationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    for (const v of message.conceptRelations) {
      ConceptRelation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostConceptRelationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostConceptRelationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conceptRelations.push(ConceptRelation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostConceptRelationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      conceptRelations: globalThis.Array.isArray(object?.conceptRelations)
        ? object.conceptRelations.map((e: any) => ConceptRelation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostConceptRelationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.conceptRelations?.length) {
      obj.conceptRelations = message.conceptRelations.map((e) => ConceptRelation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostConceptRelationsRequest>, I>>(base?: I): PostConceptRelationsRequest {
    return PostConceptRelationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostConceptRelationsRequest>, I>>(object: I): PostConceptRelationsRequest {
    const message = createBasePostConceptRelationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.conceptRelations = object.conceptRelations?.map((e) => ConceptRelation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteConceptRelationsRequest(): DeleteConceptRelationsRequest {
  return { userAppId: undefined, conceptId: "", ids: [] };
}

export const DeleteConceptRelationsRequest: MessageFns<DeleteConceptRelationsRequest> = {
  encode(message: DeleteConceptRelationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    for (const v of message.ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConceptRelationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConceptRelationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConceptRelationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteConceptRelationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConceptRelationsRequest>, I>>(base?: I): DeleteConceptRelationsRequest {
    return DeleteConceptRelationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConceptRelationsRequest>, I>>(
    object: I,
  ): DeleteConceptRelationsRequest {
    const message = createBaseDeleteConceptRelationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseListKnowledgeGraphsRequest(): ListKnowledgeGraphsRequest {
  return { userAppId: undefined };
}

export const ListKnowledgeGraphsRequest: MessageFns<ListKnowledgeGraphsRequest> = {
  encode(message: ListKnowledgeGraphsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKnowledgeGraphsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKnowledgeGraphsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKnowledgeGraphsRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: ListKnowledgeGraphsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKnowledgeGraphsRequest>, I>>(base?: I): ListKnowledgeGraphsRequest {
    return ListKnowledgeGraphsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKnowledgeGraphsRequest>, I>>(object: I): ListKnowledgeGraphsRequest {
    const message = createBaseListKnowledgeGraphsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBasePostKnowledgeGraphsRequest(): PostKnowledgeGraphsRequest {
  return { userAppId: undefined, knowledgeGraphs: [] };
}

export const PostKnowledgeGraphsRequest: MessageFns<PostKnowledgeGraphsRequest> = {
  encode(message: PostKnowledgeGraphsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.knowledgeGraphs) {
      KnowledgeGraph.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostKnowledgeGraphsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostKnowledgeGraphsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.knowledgeGraphs.push(KnowledgeGraph.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostKnowledgeGraphsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      knowledgeGraphs: globalThis.Array.isArray(object?.knowledgeGraphs)
        ? object.knowledgeGraphs.map((e: any) => KnowledgeGraph.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostKnowledgeGraphsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.knowledgeGraphs?.length) {
      obj.knowledgeGraphs = message.knowledgeGraphs.map((e) => KnowledgeGraph.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostKnowledgeGraphsRequest>, I>>(base?: I): PostKnowledgeGraphsRequest {
    return PostKnowledgeGraphsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostKnowledgeGraphsRequest>, I>>(object: I): PostKnowledgeGraphsRequest {
    const message = createBasePostKnowledgeGraphsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.knowledgeGraphs = object.knowledgeGraphs?.map((e) => KnowledgeGraph.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiConceptRelationResponse(): MultiConceptRelationResponse {
  return { status: undefined, conceptRelations: [] };
}

export const MultiConceptRelationResponse: MessageFns<MultiConceptRelationResponse> = {
  encode(message: MultiConceptRelationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.conceptRelations) {
      ConceptRelation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiConceptRelationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiConceptRelationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptRelations.push(ConceptRelation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiConceptRelationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      conceptRelations: globalThis.Array.isArray(object?.conceptRelations)
        ? object.conceptRelations.map((e: any) => ConceptRelation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiConceptRelationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.conceptRelations?.length) {
      obj.conceptRelations = message.conceptRelations.map((e) => ConceptRelation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiConceptRelationResponse>, I>>(base?: I): MultiConceptRelationResponse {
    return MultiConceptRelationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiConceptRelationResponse>, I>>(object: I): MultiConceptRelationResponse {
    const message = createBaseMultiConceptRelationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.conceptRelations = object.conceptRelations?.map((e) => ConceptRelation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiKnowledgeGraphResponse(): MultiKnowledgeGraphResponse {
  return { status: undefined, knowledgeGraphs: [] };
}

export const MultiKnowledgeGraphResponse: MessageFns<MultiKnowledgeGraphResponse> = {
  encode(message: MultiKnowledgeGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.knowledgeGraphs) {
      KnowledgeGraph.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiKnowledgeGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiKnowledgeGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.knowledgeGraphs.push(KnowledgeGraph.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiKnowledgeGraphResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      knowledgeGraphs: globalThis.Array.isArray(object?.knowledgeGraphs)
        ? object.knowledgeGraphs.map((e: any) => KnowledgeGraph.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiKnowledgeGraphResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.knowledgeGraphs?.length) {
      obj.knowledgeGraphs = message.knowledgeGraphs.map((e) => KnowledgeGraph.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiKnowledgeGraphResponse>, I>>(base?: I): MultiKnowledgeGraphResponse {
    return MultiKnowledgeGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiKnowledgeGraphResponse>, I>>(object: I): MultiKnowledgeGraphResponse {
    const message = createBaseMultiKnowledgeGraphResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.knowledgeGraphs = object.knowledgeGraphs?.map((e) => KnowledgeGraph.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetConceptLanguageRequest(): GetConceptLanguageRequest {
  return { userAppId: undefined, conceptId: "", language: "" };
}

export const GetConceptLanguageRequest: MessageFns<GetConceptLanguageRequest> = {
  encode(message: GetConceptLanguageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConceptLanguageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConceptLanguageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConceptLanguageRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: GetConceptLanguageRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConceptLanguageRequest>, I>>(base?: I): GetConceptLanguageRequest {
    return GetConceptLanguageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConceptLanguageRequest>, I>>(object: I): GetConceptLanguageRequest {
    const message = createBaseGetConceptLanguageRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseListConceptLanguagesRequest(): ListConceptLanguagesRequest {
  return { userAppId: undefined, conceptId: "", page: 0, perPage: 0 };
}

export const ListConceptLanguagesRequest: MessageFns<ListConceptLanguagesRequest> = {
  encode(message: ListConceptLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConceptLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConceptLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConceptLanguagesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListConceptLanguagesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConceptLanguagesRequest>, I>>(base?: I): ListConceptLanguagesRequest {
    return ListConceptLanguagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConceptLanguagesRequest>, I>>(object: I): ListConceptLanguagesRequest {
    const message = createBaseListConceptLanguagesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePatchConceptLanguagesRequest(): PatchConceptLanguagesRequest {
  return { userAppId: undefined, conceptId: "", conceptLanguages: [], action: "" };
}

export const PatchConceptLanguagesRequest: MessageFns<PatchConceptLanguagesRequest> = {
  encode(message: PatchConceptLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    for (const v of message.conceptLanguages) {
      ConceptLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchConceptLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchConceptLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conceptLanguages.push(ConceptLanguage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchConceptLanguagesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      conceptLanguages: globalThis.Array.isArray(object?.conceptLanguages)
        ? object.conceptLanguages.map((e: any) => ConceptLanguage.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchConceptLanguagesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.conceptLanguages?.length) {
      obj.conceptLanguages = message.conceptLanguages.map((e) => ConceptLanguage.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchConceptLanguagesRequest>, I>>(base?: I): PatchConceptLanguagesRequest {
    return PatchConceptLanguagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchConceptLanguagesRequest>, I>>(object: I): PatchConceptLanguagesRequest {
    const message = createBasePatchConceptLanguagesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.conceptLanguages = object.conceptLanguages?.map((e) => ConceptLanguage.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePostConceptLanguagesRequest(): PostConceptLanguagesRequest {
  return { userAppId: undefined, conceptId: "", conceptLanguages: [] };
}

export const PostConceptLanguagesRequest: MessageFns<PostConceptLanguagesRequest> = {
  encode(message: PostConceptLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.conceptId !== "") {
      writer.uint32(18).string(message.conceptId);
    }
    for (const v of message.conceptLanguages) {
      ConceptLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostConceptLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostConceptLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conceptLanguages.push(ConceptLanguage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostConceptLanguagesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      conceptId: isSet(object.conceptId) ? globalThis.String(object.conceptId) : "",
      conceptLanguages: globalThis.Array.isArray(object?.conceptLanguages)
        ? object.conceptLanguages.map((e: any) => ConceptLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostConceptLanguagesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.conceptId !== "") {
      obj.conceptId = message.conceptId;
    }
    if (message.conceptLanguages?.length) {
      obj.conceptLanguages = message.conceptLanguages.map((e) => ConceptLanguage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostConceptLanguagesRequest>, I>>(base?: I): PostConceptLanguagesRequest {
    return PostConceptLanguagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostConceptLanguagesRequest>, I>>(object: I): PostConceptLanguagesRequest {
    const message = createBasePostConceptLanguagesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.conceptId = object.conceptId ?? "";
    message.conceptLanguages = object.conceptLanguages?.map((e) => ConceptLanguage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleConceptLanguageResponse(): SingleConceptLanguageResponse {
  return { status: undefined, conceptLanguage: undefined };
}

export const SingleConceptLanguageResponse: MessageFns<SingleConceptLanguageResponse> = {
  encode(message: SingleConceptLanguageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.conceptLanguage !== undefined) {
      ConceptLanguage.encode(message.conceptLanguage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleConceptLanguageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleConceptLanguageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptLanguage = ConceptLanguage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleConceptLanguageResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      conceptLanguage: isSet(object.conceptLanguage) ? ConceptLanguage.fromJSON(object.conceptLanguage) : undefined,
    };
  },

  toJSON(message: SingleConceptLanguageResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.conceptLanguage !== undefined) {
      obj.conceptLanguage = ConceptLanguage.toJSON(message.conceptLanguage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleConceptLanguageResponse>, I>>(base?: I): SingleConceptLanguageResponse {
    return SingleConceptLanguageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleConceptLanguageResponse>, I>>(
    object: I,
  ): SingleConceptLanguageResponse {
    const message = createBaseSingleConceptLanguageResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.conceptLanguage = (object.conceptLanguage !== undefined && object.conceptLanguage !== null)
      ? ConceptLanguage.fromPartial(object.conceptLanguage)
      : undefined;
    return message;
  },
};

function createBaseMultiConceptLanguageResponse(): MultiConceptLanguageResponse {
  return { status: undefined, conceptLanguages: [] };
}

export const MultiConceptLanguageResponse: MessageFns<MultiConceptLanguageResponse> = {
  encode(message: MultiConceptLanguageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.conceptLanguages) {
      ConceptLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiConceptLanguageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiConceptLanguageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptLanguages.push(ConceptLanguage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiConceptLanguageResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      conceptLanguages: globalThis.Array.isArray(object?.conceptLanguages)
        ? object.conceptLanguages.map((e: any) => ConceptLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiConceptLanguageResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.conceptLanguages?.length) {
      obj.conceptLanguages = message.conceptLanguages.map((e) => ConceptLanguage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiConceptLanguageResponse>, I>>(base?: I): MultiConceptLanguageResponse {
    return MultiConceptLanguageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiConceptLanguageResponse>, I>>(object: I): MultiConceptLanguageResponse {
    const message = createBaseMultiConceptLanguageResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.conceptLanguages = object.conceptLanguages?.map((e) => ConceptLanguage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInputRequest(): GetInputRequest {
  return { userAppId: undefined, inputId: "" };
}

export const GetInputRequest: MessageFns<GetInputRequest> = {
  encode(message: GetInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: GetInputRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInputRequest>, I>>(base?: I): GetInputRequest {
    return GetInputRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInputRequest>, I>>(object: I): GetInputRequest {
    const message = createBaseGetInputRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBaseGetVideoManifestRequest(): GetVideoManifestRequest {
  return { userAppId: undefined, inputId: "" };
}

export const GetVideoManifestRequest: MessageFns<GetVideoManifestRequest> = {
  encode(message: GetVideoManifestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVideoManifestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVideoManifestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVideoManifestRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: GetVideoManifestRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVideoManifestRequest>, I>>(base?: I): GetVideoManifestRequest {
    return GetVideoManifestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVideoManifestRequest>, I>>(object: I): GetVideoManifestRequest {
    const message = createBaseGetVideoManifestRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBaseGetInputSamplesRequest(): GetInputSamplesRequest {
  return { userAppId: undefined, taskId: "", userIds: [] };
}

export const GetInputSamplesRequest: MessageFns<GetInputSamplesRequest> = {
  encode(message: GetInputSamplesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputSamplesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputSamplesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputSamplesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetInputSamplesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInputSamplesRequest>, I>>(base?: I): GetInputSamplesRequest {
    return GetInputSamplesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInputSamplesRequest>, I>>(object: I): GetInputSamplesRequest {
    const message = createBaseGetInputSamplesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.taskId = object.taskId ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListInputsRequest(): ListInputsRequest {
  return { userAppId: undefined, page: 0, perPage: 0, status: undefined, ids: [] };
}

export const ListInputsRequest: MessageFns<ListInputsRequest> = {
  encode(message: ListInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(42).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInputsRequest>, I>>(base?: I): ListInputsRequest {
    return ListInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInputsRequest>, I>>(object: I): ListInputsRequest {
    const message = createBaseListInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamInputsRequest(): StreamInputsRequest {
  return { userAppId: undefined, perPage: 0, lastId: "", orderById: false, descending: false };
}

export const StreamInputsRequest: MessageFns<StreamInputsRequest> = {
  encode(message: StreamInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.perPage !== 0) {
      writer.uint32(16).uint32(message.perPage);
    }
    if (message.lastId !== "") {
      writer.uint32(26).string(message.lastId);
    }
    if (message.orderById !== false) {
      writer.uint32(40).bool(message.orderById);
    }
    if (message.descending !== false) {
      writer.uint32(32).bool(message.descending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.orderById = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.descending = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      lastId: isSet(object.lastId) ? globalThis.String(object.lastId) : "",
      orderById: isSet(object.orderById) ? globalThis.Boolean(object.orderById) : false,
      descending: isSet(object.descending) ? globalThis.Boolean(object.descending) : false,
    };
  },

  toJSON(message: StreamInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.lastId !== "") {
      obj.lastId = message.lastId;
    }
    if (message.orderById !== false) {
      obj.orderById = message.orderById;
    }
    if (message.descending !== false) {
      obj.descending = message.descending;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamInputsRequest>, I>>(base?: I): StreamInputsRequest {
    return StreamInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamInputsRequest>, I>>(object: I): StreamInputsRequest {
    const message = createBaseStreamInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.perPage = object.perPage ?? 0;
    message.lastId = object.lastId ?? "";
    message.orderById = object.orderById ?? false;
    message.descending = object.descending ?? false;
    return message;
  },
};

function createBasePostInputsRequest(): PostInputsRequest {
  return { userAppId: undefined, inputs: [], inputsAddJobId: "", inputIdConflictResolution: 0 };
}

export const PostInputsRequest: MessageFns<PostInputsRequest> = {
  encode(message: PostInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.inputsAddJobId !== "") {
      writer.uint32(26).string(message.inputsAddJobId);
    }
    if (message.inputIdConflictResolution !== 0) {
      writer.uint32(32).int32(message.inputIdConflictResolution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputsAddJobId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inputIdConflictResolution = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      inputsAddJobId: isSet(object.inputsAddJobId) ? globalThis.String(object.inputsAddJobId) : "",
      inputIdConflictResolution: isSet(object.inputIdConflictResolution)
        ? inputIDConflictResolutionFromJSON(object.inputIdConflictResolution)
        : 0,
    };
  },

  toJSON(message: PostInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.inputsAddJobId !== "") {
      obj.inputsAddJobId = message.inputsAddJobId;
    }
    if (message.inputIdConflictResolution !== 0) {
      obj.inputIdConflictResolution = inputIDConflictResolutionToJSON(message.inputIdConflictResolution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInputsRequest>, I>>(base?: I): PostInputsRequest {
    return PostInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInputsRequest>, I>>(object: I): PostInputsRequest {
    const message = createBasePostInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.inputsAddJobId = object.inputsAddJobId ?? "";
    message.inputIdConflictResolution = object.inputIdConflictResolution ?? 0;
    return message;
  },
};

function createBasePatchInputsRequest(): PatchInputsRequest {
  return { userAppId: undefined, inputs: [], action: "" };
}

export const PatchInputsRequest: MessageFns<PatchInputsRequest> = {
  encode(message: PatchInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchInputsRequest>, I>>(base?: I): PatchInputsRequest {
    return PatchInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchInputsRequest>, I>>(object: I): PatchInputsRequest {
    const message = createBasePatchInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteInputRequest(): DeleteInputRequest {
  return { userAppId: undefined, inputId: "" };
}

export const DeleteInputRequest: MessageFns<DeleteInputRequest> = {
  encode(message: DeleteInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInputRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: DeleteInputRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteInputRequest>, I>>(base?: I): DeleteInputRequest {
    return DeleteInputRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteInputRequest>, I>>(object: I): DeleteInputRequest {
    const message = createBaseDeleteInputRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBaseDeleteInputsRequest(): DeleteInputsRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteInputsRequest: MessageFns<DeleteInputsRequest> = {
  encode(message: DeleteInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteInputsRequest>, I>>(base?: I): DeleteInputsRequest {
    return DeleteInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteInputsRequest>, I>>(object: I): DeleteInputsRequest {
    const message = createBaseDeleteInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleInputResponse(): SingleInputResponse {
  return { status: undefined, input: undefined };
}

export const SingleInputResponse: MessageFns<SingleInputResponse> = {
  encode(message: SingleInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleInputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: SingleInputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleInputResponse>, I>>(base?: I): SingleInputResponse {
    return SingleInputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleInputResponse>, I>>(object: I): SingleInputResponse {
    const message = createBaseSingleInputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    return message;
  },
};

function createBaseGetVideoManifestResponse(): GetVideoManifestResponse {
  return { status: undefined, manifestUrl: "" };
}

export const GetVideoManifestResponse: MessageFns<GetVideoManifestResponse> = {
  encode(message: GetVideoManifestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.manifestUrl !== "") {
      writer.uint32(18).string(message.manifestUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVideoManifestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVideoManifestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.manifestUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVideoManifestResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      manifestUrl: isSet(object.manifestUrl) ? globalThis.String(object.manifestUrl) : "",
    };
  },

  toJSON(message: GetVideoManifestResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.manifestUrl !== "") {
      obj.manifestUrl = message.manifestUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVideoManifestResponse>, I>>(base?: I): GetVideoManifestResponse {
    return GetVideoManifestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVideoManifestResponse>, I>>(object: I): GetVideoManifestResponse {
    const message = createBaseGetVideoManifestResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.manifestUrl = object.manifestUrl ?? "";
    return message;
  },
};

function createBaseMultiInputResponse(): MultiInputResponse {
  return { status: undefined, inputs: [], inputsAddJob: undefined };
}

export const MultiInputResponse: MessageFns<MultiInputResponse> = {
  encode(message: MultiInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.inputsAddJob !== undefined) {
      InputsAddJob.encode(message.inputsAddJob, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputsAddJob = InputsAddJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      inputsAddJob: isSet(object.inputsAddJob) ? InputsAddJob.fromJSON(object.inputsAddJob) : undefined,
    };
  },

  toJSON(message: MultiInputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.inputsAddJob !== undefined) {
      obj.inputsAddJob = InputsAddJob.toJSON(message.inputsAddJob);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInputResponse>, I>>(base?: I): MultiInputResponse {
    return MultiInputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInputResponse>, I>>(object: I): MultiInputResponse {
    const message = createBaseMultiInputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.inputsAddJob = (object.inputsAddJob !== undefined && object.inputsAddJob !== null)
      ? InputsAddJob.fromPartial(object.inputsAddJob)
      : undefined;
    return message;
  },
};

function createBaseMultiInputAnnotationResponse(): MultiInputAnnotationResponse {
  return { status: undefined, hits: [] };
}

export const MultiInputAnnotationResponse: MessageFns<MultiInputAnnotationResponse> = {
  encode(message: MultiInputAnnotationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.hits) {
      Hit.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInputAnnotationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInputAnnotationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hits.push(Hit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInputAnnotationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      hits: globalThis.Array.isArray(object?.hits) ? object.hits.map((e: any) => Hit.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiInputAnnotationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.hits?.length) {
      obj.hits = message.hits.map((e) => Hit.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInputAnnotationResponse>, I>>(base?: I): MultiInputAnnotationResponse {
    return MultiInputAnnotationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInputAnnotationResponse>, I>>(object: I): MultiInputAnnotationResponse {
    const message = createBaseMultiInputAnnotationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.hits = object.hits?.map((e) => Hit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleInputCountResponse(): SingleInputCountResponse {
  return { status: undefined, counts: undefined };
}

export const SingleInputCountResponse: MessageFns<SingleInputCountResponse> = {
  encode(message: SingleInputCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.counts !== undefined) {
      InputCount.encode(message.counts, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleInputCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleInputCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counts = InputCount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleInputCountResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      counts: isSet(object.counts) ? InputCount.fromJSON(object.counts) : undefined,
    };
  },

  toJSON(message: SingleInputCountResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.counts !== undefined) {
      obj.counts = InputCount.toJSON(message.counts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleInputCountResponse>, I>>(base?: I): SingleInputCountResponse {
    return SingleInputCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleInputCountResponse>, I>>(object: I): SingleInputCountResponse {
    const message = createBaseSingleInputCountResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.counts = (object.counts !== undefined && object.counts !== null)
      ? InputCount.fromPartial(object.counts)
      : undefined;
    return message;
  },
};

function createBaseGetInputCountRequest(): GetInputCountRequest {
  return { userAppId: undefined };
}

export const GetInputCountRequest: MessageFns<GetInputCountRequest> = {
  encode(message: GetInputCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputCountRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: GetInputCountRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInputCountRequest>, I>>(base?: I): GetInputCountRequest {
    return GetInputCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInputCountRequest>, I>>(object: I): GetInputCountRequest {
    const message = createBaseGetInputCountRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseListDatasetsRequest(): ListDatasetsRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    additionalFields: [],
    sortAscending: false,
    sortByCreatedAt: undefined,
    sortByStarCount: undefined,
    sortByModifiedAt: undefined,
    sortById: undefined,
    starredOnly: false,
    bookmark: false,
    search: "",
    id: "",
  };
}

export const ListDatasetsRequest: MessageFns<ListDatasetsRequest> = {
  encode(message: ListDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(42).string(v!);
    }
    if (message.sortAscending !== false) {
      writer.uint32(48).bool(message.sortAscending);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(56).bool(message.sortByCreatedAt);
    }
    if (message.sortByStarCount !== undefined) {
      writer.uint32(64).bool(message.sortByStarCount);
    }
    if (message.sortByModifiedAt !== undefined) {
      writer.uint32(72).bool(message.sortByModifiedAt);
    }
    if (message.sortById !== undefined) {
      writer.uint32(88).bool(message.sortById);
    }
    if (message.starredOnly !== false) {
      writer.uint32(32).bool(message.starredOnly);
    }
    if (message.bookmark !== false) {
      writer.uint32(80).bool(message.bookmark);
    }
    if (message.search !== "") {
      writer.uint32(106).string(message.search);
    }
    if (message.id !== "") {
      writer.uint32(98).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sortByStarCount = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sortByModifiedAt = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sortById = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.starredOnly = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.bookmark = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByStarCount: isSet(object.sortByStarCount) ? globalThis.Boolean(object.sortByStarCount) : undefined,
      sortByModifiedAt: isSet(object.sortByModifiedAt) ? globalThis.Boolean(object.sortByModifiedAt) : undefined,
      sortById: isSet(object.sortById) ? globalThis.Boolean(object.sortById) : undefined,
      starredOnly: isSet(object.starredOnly) ? globalThis.Boolean(object.starredOnly) : false,
      bookmark: isSet(object.bookmark) ? globalThis.Boolean(object.bookmark) : false,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ListDatasetsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByStarCount !== undefined) {
      obj.sortByStarCount = message.sortByStarCount;
    }
    if (message.sortByModifiedAt !== undefined) {
      obj.sortByModifiedAt = message.sortByModifiedAt;
    }
    if (message.sortById !== undefined) {
      obj.sortById = message.sortById;
    }
    if (message.starredOnly !== false) {
      obj.starredOnly = message.starredOnly;
    }
    if (message.bookmark !== false) {
      obj.bookmark = message.bookmark;
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatasetsRequest>, I>>(base?: I): ListDatasetsRequest {
    return ListDatasetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatasetsRequest>, I>>(object: I): ListDatasetsRequest {
    const message = createBaseListDatasetsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.sortAscending = object.sortAscending ?? false;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByStarCount = object.sortByStarCount ?? undefined;
    message.sortByModifiedAt = object.sortByModifiedAt ?? undefined;
    message.sortById = object.sortById ?? undefined;
    message.starredOnly = object.starredOnly ?? false;
    message.bookmark = object.bookmark ?? false;
    message.search = object.search ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetDatasetRequest(): GetDatasetRequest {
  return { userAppId: undefined, datasetId: "", additionalFields: [] };
}

export const GetDatasetRequest: MessageFns<GetDatasetRequest> = {
  encode(message: GetDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.additionalFields) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatasetRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetDatasetRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDatasetRequest>, I>>(base?: I): GetDatasetRequest {
    return GetDatasetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDatasetRequest>, I>>(object: I): GetDatasetRequest {
    const message = createBaseGetDatasetRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBasePostDatasetsRequest(): PostDatasetsRequest {
  return { userAppId: undefined, datasets: [] };
}

export const PostDatasetsRequest: MessageFns<PostDatasetsRequest> = {
  encode(message: PostDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasets) {
      Dataset.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasets.push(Dataset.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostDatasetsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => Dataset.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostDatasetsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => Dataset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostDatasetsRequest>, I>>(base?: I): PostDatasetsRequest {
    return PostDatasetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostDatasetsRequest>, I>>(object: I): PostDatasetsRequest {
    const message = createBasePostDatasetsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasets = object.datasets?.map((e) => Dataset.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchDatasetsRequest(): PatchDatasetsRequest {
  return { userAppId: undefined, datasets: [], action: "" };
}

export const PatchDatasetsRequest: MessageFns<PatchDatasetsRequest> = {
  encode(message: PatchDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasets) {
      Dataset.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasets.push(Dataset.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchDatasetsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => Dataset.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchDatasetsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => Dataset.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchDatasetsRequest>, I>>(base?: I): PatchDatasetsRequest {
    return PatchDatasetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchDatasetsRequest>, I>>(object: I): PatchDatasetsRequest {
    const message = createBasePatchDatasetsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasets = object.datasets?.map((e) => Dataset.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteDatasetsRequest(): DeleteDatasetsRequest {
  return { userAppId: undefined, datasetIds: [] };
}

export const DeleteDatasetsRequest: MessageFns<DeleteDatasetsRequest> = {
  encode(message: DeleteDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasetIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetIds: globalThis.Array.isArray(object?.datasetIds)
        ? object.datasetIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteDatasetsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetIds?.length) {
      obj.datasetIds = message.datasetIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDatasetsRequest>, I>>(base?: I): DeleteDatasetsRequest {
    return DeleteDatasetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDatasetsRequest>, I>>(object: I): DeleteDatasetsRequest {
    const message = createBaseDeleteDatasetsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetIds = object.datasetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiDatasetResponse(): MultiDatasetResponse {
  return { status: undefined, datasets: [] };
}

export const MultiDatasetResponse: MessageFns<MultiDatasetResponse> = {
  encode(message: MultiDatasetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasets) {
      Dataset.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDatasetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDatasetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasets.push(Dataset.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDatasetResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => Dataset.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiDatasetResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => Dataset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDatasetResponse>, I>>(base?: I): MultiDatasetResponse {
    return MultiDatasetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDatasetResponse>, I>>(object: I): MultiDatasetResponse {
    const message = createBaseMultiDatasetResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasets = object.datasets?.map((e) => Dataset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleDatasetResponse(): SingleDatasetResponse {
  return { status: undefined, dataset: undefined };
}

export const SingleDatasetResponse: MessageFns<SingleDatasetResponse> = {
  encode(message: SingleDatasetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleDatasetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDatasetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleDatasetResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
    };
  },

  toJSON(message: SingleDatasetResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleDatasetResponse>, I>>(base?: I): SingleDatasetResponse {
    return SingleDatasetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleDatasetResponse>, I>>(object: I): SingleDatasetResponse {
    const message = createBaseSingleDatasetResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    return message;
  },
};

function createBaseListDatasetInputsRequest(): ListDatasetInputsRequest {
  return { userAppId: undefined, datasetId: "", page: 0, perPage: 0 };
}

export const ListDatasetInputsRequest: MessageFns<ListDatasetInputsRequest> = {
  encode(message: ListDatasetInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListDatasetInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatasetInputsRequest>, I>>(base?: I): ListDatasetInputsRequest {
    return ListDatasetInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatasetInputsRequest>, I>>(object: I): ListDatasetInputsRequest {
    const message = createBaseListDatasetInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetDatasetInputRequest(): GetDatasetInputRequest {
  return { userAppId: undefined, datasetId: "", inputId: "" };
}

export const GetDatasetInputRequest: MessageFns<GetDatasetInputRequest> = {
  encode(message: GetDatasetInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatasetInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatasetInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatasetInputRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
    };
  },

  toJSON(message: GetDatasetInputRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDatasetInputRequest>, I>>(base?: I): GetDatasetInputRequest {
    return GetDatasetInputRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDatasetInputRequest>, I>>(object: I): GetDatasetInputRequest {
    const message = createBaseGetDatasetInputRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.inputId = object.inputId ?? "";
    return message;
  },
};

function createBasePostDatasetInputsRequest(): PostDatasetInputsRequest {
  return { userAppId: undefined, datasetId: "", datasetInputs: [], search: undefined };
}

export const PostDatasetInputsRequest: MessageFns<PostDatasetInputsRequest> = {
  encode(message: PostDatasetInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.datasetInputs) {
      DatasetInput.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.search !== undefined) {
      Search.encode(message.search, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostDatasetInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostDatasetInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetInputs.push(DatasetInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.search = Search.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostDatasetInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetInputs: globalThis.Array.isArray(object?.datasetInputs)
        ? object.datasetInputs.map((e: any) => DatasetInput.fromJSON(e))
        : [],
      search: isSet(object.search) ? Search.fromJSON(object.search) : undefined,
    };
  },

  toJSON(message: PostDatasetInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetInputs?.length) {
      obj.datasetInputs = message.datasetInputs.map((e) => DatasetInput.toJSON(e));
    }
    if (message.search !== undefined) {
      obj.search = Search.toJSON(message.search);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostDatasetInputsRequest>, I>>(base?: I): PostDatasetInputsRequest {
    return PostDatasetInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostDatasetInputsRequest>, I>>(object: I): PostDatasetInputsRequest {
    const message = createBasePostDatasetInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetInputs = object.datasetInputs?.map((e) => DatasetInput.fromPartial(e)) || [];
    message.search = (object.search !== undefined && object.search !== null)
      ? Search.fromPartial(object.search)
      : undefined;
    return message;
  },
};

function createBaseDeleteDatasetInputsRequest(): DeleteDatasetInputsRequest {
  return { userAppId: undefined, datasetId: "", inputIds: [] };
}

export const DeleteDatasetInputsRequest: MessageFns<DeleteDatasetInputsRequest> = {
  encode(message: DeleteDatasetInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.inputIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteDatasetInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDatasetInputsRequest>, I>>(base?: I): DeleteDatasetInputsRequest {
    return DeleteDatasetInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDatasetInputsRequest>, I>>(object: I): DeleteDatasetInputsRequest {
    const message = createBaseDeleteDatasetInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.inputIds = object.inputIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiDatasetInputResponse(): MultiDatasetInputResponse {
  return { status: undefined, datasetInputs: [], bulkOperation: undefined };
}

export const MultiDatasetInputResponse: MessageFns<MultiDatasetInputResponse> = {
  encode(message: MultiDatasetInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasetInputs) {
      DatasetInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.bulkOperation !== undefined) {
      BulkOperation.encode(message.bulkOperation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDatasetInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDatasetInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetInputs.push(DatasetInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bulkOperation = BulkOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDatasetInputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetInputs: globalThis.Array.isArray(object?.datasetInputs)
        ? object.datasetInputs.map((e: any) => DatasetInput.fromJSON(e))
        : [],
      bulkOperation: isSet(object.bulkOperation) ? BulkOperation.fromJSON(object.bulkOperation) : undefined,
    };
  },

  toJSON(message: MultiDatasetInputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetInputs?.length) {
      obj.datasetInputs = message.datasetInputs.map((e) => DatasetInput.toJSON(e));
    }
    if (message.bulkOperation !== undefined) {
      obj.bulkOperation = BulkOperation.toJSON(message.bulkOperation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDatasetInputResponse>, I>>(base?: I): MultiDatasetInputResponse {
    return MultiDatasetInputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDatasetInputResponse>, I>>(object: I): MultiDatasetInputResponse {
    const message = createBaseMultiDatasetInputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetInputs = object.datasetInputs?.map((e) => DatasetInput.fromPartial(e)) || [];
    message.bulkOperation = (object.bulkOperation !== undefined && object.bulkOperation !== null)
      ? BulkOperation.fromPartial(object.bulkOperation)
      : undefined;
    return message;
  },
};

function createBaseSingleDatasetInputResponse(): SingleDatasetInputResponse {
  return { status: undefined, datasetInput: undefined };
}

export const SingleDatasetInputResponse: MessageFns<SingleDatasetInputResponse> = {
  encode(message: SingleDatasetInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.datasetInput !== undefined) {
      DatasetInput.encode(message.datasetInput, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleDatasetInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDatasetInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetInput = DatasetInput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleDatasetInputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetInput: isSet(object.datasetInput) ? DatasetInput.fromJSON(object.datasetInput) : undefined,
    };
  },

  toJSON(message: SingleDatasetInputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetInput !== undefined) {
      obj.datasetInput = DatasetInput.toJSON(message.datasetInput);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleDatasetInputResponse>, I>>(base?: I): SingleDatasetInputResponse {
    return SingleDatasetInputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleDatasetInputResponse>, I>>(object: I): SingleDatasetInputResponse {
    const message = createBaseSingleDatasetInputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetInput = (object.datasetInput !== undefined && object.datasetInput !== null)
      ? DatasetInput.fromPartial(object.datasetInput)
      : undefined;
    return message;
  },
};

function createBaseListDatasetVersionsRequest(): ListDatasetVersionsRequest {
  return { userAppId: undefined, datasetId: "", page: 0, perPage: 0, requestOrigins: [] };
}

export const ListDatasetVersionsRequest: MessageFns<ListDatasetVersionsRequest> = {
  encode(message: ListDatasetVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    writer.uint32(42).fork();
    for (const v of message.requestOrigins) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.requestOrigins.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestOrigins.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      requestOrigins: globalThis.Array.isArray(object?.requestOrigins)
        ? object.requestOrigins.map((e: any) => datasetVersionRequestOriginFromJSON(e))
        : [],
    };
  },

  toJSON(message: ListDatasetVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.requestOrigins?.length) {
      obj.requestOrigins = message.requestOrigins.map((e) => datasetVersionRequestOriginToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatasetVersionsRequest>, I>>(base?: I): ListDatasetVersionsRequest {
    return ListDatasetVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatasetVersionsRequest>, I>>(object: I): ListDatasetVersionsRequest {
    const message = createBaseListDatasetVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.requestOrigins = object.requestOrigins?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDatasetVersionRequest(): GetDatasetVersionRequest {
  return { userAppId: undefined, datasetId: "", datasetVersionId: "" };
}

export const GetDatasetVersionRequest: MessageFns<GetDatasetVersionRequest> = {
  encode(message: GetDatasetVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.datasetVersionId !== "") {
      writer.uint32(26).string(message.datasetVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatasetVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatasetVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatasetVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersionId: isSet(object.datasetVersionId) ? globalThis.String(object.datasetVersionId) : "",
    };
  },

  toJSON(message: GetDatasetVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersionId !== "") {
      obj.datasetVersionId = message.datasetVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDatasetVersionRequest>, I>>(base?: I): GetDatasetVersionRequest {
    return GetDatasetVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDatasetVersionRequest>, I>>(object: I): GetDatasetVersionRequest {
    const message = createBaseGetDatasetVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersionId = object.datasetVersionId ?? "";
    return message;
  },
};

function createBaseListDatasetVersionMetricsGroupsRequest(): ListDatasetVersionMetricsGroupsRequest {
  return {
    userAppId: undefined,
    datasetId: "",
    datasetVersionId: "",
    page: 0,
    perPage: 0,
    parentPaths: [],
    types: [],
    values: [],
  };
}

export const ListDatasetVersionMetricsGroupsRequest: MessageFns<ListDatasetVersionMetricsGroupsRequest> = {
  encode(message: ListDatasetVersionMetricsGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.datasetVersionId !== "") {
      writer.uint32(26).string(message.datasetVersionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    for (const v of message.parentPaths) {
      writer.uint32(50).string(v!);
    }
    writer.uint32(58).fork();
    for (const v of message.types) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.values) {
      Value.encode(Value.wrap(v!), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetVersionMetricsGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetVersionMetricsGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parentPaths.push(reader.string());
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.types.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetVersionMetricsGroupsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersionId: isSet(object.datasetVersionId) ? globalThis.String(object.datasetVersionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      parentPaths: globalThis.Array.isArray(object?.parentPaths)
        ? object.parentPaths.map((e: any) => globalThis.String(e))
        : [],
      types: globalThis.Array.isArray(object?.types)
        ? object.types.map((e: any) => datasetVersionMetricsGroupTypeFromJSON(e))
        : [],
      values: globalThis.Array.isArray(object?.values) ? [...object.values] : [],
    };
  },

  toJSON(message: ListDatasetVersionMetricsGroupsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersionId !== "") {
      obj.datasetVersionId = message.datasetVersionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.parentPaths?.length) {
      obj.parentPaths = message.parentPaths;
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => datasetVersionMetricsGroupTypeToJSON(e));
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDatasetVersionMetricsGroupsRequest>, I>>(
    base?: I,
  ): ListDatasetVersionMetricsGroupsRequest {
    return ListDatasetVersionMetricsGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDatasetVersionMetricsGroupsRequest>, I>>(
    object: I,
  ): ListDatasetVersionMetricsGroupsRequest {
    const message = createBaseListDatasetVersionMetricsGroupsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersionId = object.datasetVersionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.parentPaths = object.parentPaths?.map((e) => e) || [];
    message.types = object.types?.map((e) => e) || [];
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBasePostDatasetVersionsRequest(): PostDatasetVersionsRequest {
  return { userAppId: undefined, datasetId: "", datasetVersions: [] };
}

export const PostDatasetVersionsRequest: MessageFns<PostDatasetVersionsRequest> = {
  encode(message: PostDatasetVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.datasetVersions) {
      DatasetVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostDatasetVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostDatasetVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersions.push(DatasetVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostDatasetVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersions: globalThis.Array.isArray(object?.datasetVersions)
        ? object.datasetVersions.map((e: any) => DatasetVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostDatasetVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersions?.length) {
      obj.datasetVersions = message.datasetVersions.map((e) => DatasetVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostDatasetVersionsRequest>, I>>(base?: I): PostDatasetVersionsRequest {
    return PostDatasetVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostDatasetVersionsRequest>, I>>(object: I): PostDatasetVersionsRequest {
    const message = createBasePostDatasetVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersions = object.datasetVersions?.map((e) => DatasetVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchDatasetVersionsRequest(): PatchDatasetVersionsRequest {
  return { userAppId: undefined, datasetId: "", datasetVersions: [], action: "" };
}

export const PatchDatasetVersionsRequest: MessageFns<PatchDatasetVersionsRequest> = {
  encode(message: PatchDatasetVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.datasetVersions) {
      DatasetVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchDatasetVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchDatasetVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersions.push(DatasetVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchDatasetVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersions: globalThis.Array.isArray(object?.datasetVersions)
        ? object.datasetVersions.map((e: any) => DatasetVersion.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchDatasetVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersions?.length) {
      obj.datasetVersions = message.datasetVersions.map((e) => DatasetVersion.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchDatasetVersionsRequest>, I>>(base?: I): PatchDatasetVersionsRequest {
    return PatchDatasetVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchDatasetVersionsRequest>, I>>(object: I): PatchDatasetVersionsRequest {
    const message = createBasePatchDatasetVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersions = object.datasetVersions?.map((e) => DatasetVersion.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteDatasetVersionsRequest(): DeleteDatasetVersionsRequest {
  return { userAppId: undefined, datasetId: "", datasetVersionIds: [] };
}

export const DeleteDatasetVersionsRequest: MessageFns<DeleteDatasetVersionsRequest> = {
  encode(message: DeleteDatasetVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    for (const v of message.datasetVersionIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersionIds: globalThis.Array.isArray(object?.datasetVersionIds)
        ? object.datasetVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteDatasetVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersionIds?.length) {
      obj.datasetVersionIds = message.datasetVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDatasetVersionsRequest>, I>>(base?: I): DeleteDatasetVersionsRequest {
    return DeleteDatasetVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDatasetVersionsRequest>, I>>(object: I): DeleteDatasetVersionsRequest {
    const message = createBaseDeleteDatasetVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersionIds = object.datasetVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePutDatasetVersionExportsRequest(): PutDatasetVersionExportsRequest {
  return { userAppId: undefined, datasetId: "", datasetVersionId: "", exports: [] };
}

export const PutDatasetVersionExportsRequest: MessageFns<PutDatasetVersionExportsRequest> = {
  encode(message: PutDatasetVersionExportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.datasetVersionId !== "") {
      writer.uint32(26).string(message.datasetVersionId);
    }
    for (const v of message.exports) {
      DatasetVersionExport.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutDatasetVersionExportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDatasetVersionExportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exports.push(DatasetVersionExport.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDatasetVersionExportsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetVersionId: isSet(object.datasetVersionId) ? globalThis.String(object.datasetVersionId) : "",
      exports: globalThis.Array.isArray(object?.exports)
        ? object.exports.map((e: any) => DatasetVersionExport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PutDatasetVersionExportsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetVersionId !== "") {
      obj.datasetVersionId = message.datasetVersionId;
    }
    if (message.exports?.length) {
      obj.exports = message.exports.map((e) => DatasetVersionExport.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDatasetVersionExportsRequest>, I>>(base?: I): PutDatasetVersionExportsRequest {
    return PutDatasetVersionExportsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDatasetVersionExportsRequest>, I>>(
    object: I,
  ): PutDatasetVersionExportsRequest {
    const message = createBasePutDatasetVersionExportsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.datasetId = object.datasetId ?? "";
    message.datasetVersionId = object.datasetVersionId ?? "";
    message.exports = object.exports?.map((e) => DatasetVersionExport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiDatasetVersionResponse(): MultiDatasetVersionResponse {
  return { status: undefined, datasetVersions: [] };
}

export const MultiDatasetVersionResponse: MessageFns<MultiDatasetVersionResponse> = {
  encode(message: MultiDatasetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasetVersions) {
      DatasetVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDatasetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDatasetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetVersions.push(DatasetVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDatasetVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetVersions: globalThis.Array.isArray(object?.datasetVersions)
        ? object.datasetVersions.map((e: any) => DatasetVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiDatasetVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetVersions?.length) {
      obj.datasetVersions = message.datasetVersions.map((e) => DatasetVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDatasetVersionResponse>, I>>(base?: I): MultiDatasetVersionResponse {
    return MultiDatasetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDatasetVersionResponse>, I>>(object: I): MultiDatasetVersionResponse {
    const message = createBaseMultiDatasetVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetVersions = object.datasetVersions?.map((e) => DatasetVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiDatasetVersionExportResponse(): MultiDatasetVersionExportResponse {
  return { status: undefined, exports: [] };
}

export const MultiDatasetVersionExportResponse: MessageFns<MultiDatasetVersionExportResponse> = {
  encode(message: MultiDatasetVersionExportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.exports) {
      DatasetVersionExport.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDatasetVersionExportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDatasetVersionExportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exports.push(DatasetVersionExport.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDatasetVersionExportResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      exports: globalThis.Array.isArray(object?.exports)
        ? object.exports.map((e: any) => DatasetVersionExport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiDatasetVersionExportResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.exports?.length) {
      obj.exports = message.exports.map((e) => DatasetVersionExport.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDatasetVersionExportResponse>, I>>(
    base?: I,
  ): MultiDatasetVersionExportResponse {
    return MultiDatasetVersionExportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDatasetVersionExportResponse>, I>>(
    object: I,
  ): MultiDatasetVersionExportResponse {
    const message = createBaseMultiDatasetVersionExportResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.exports = object.exports?.map((e) => DatasetVersionExport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiDatasetVersionMetricsGroupResponse(): MultiDatasetVersionMetricsGroupResponse {
  return { status: undefined, datasetVersionMetricsGroups: [] };
}

export const MultiDatasetVersionMetricsGroupResponse: MessageFns<MultiDatasetVersionMetricsGroupResponse> = {
  encode(message: MultiDatasetVersionMetricsGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.datasetVersionMetricsGroups) {
      DatasetVersionMetricsGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDatasetVersionMetricsGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDatasetVersionMetricsGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetVersionMetricsGroups.push(DatasetVersionMetricsGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDatasetVersionMetricsGroupResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetVersionMetricsGroups: globalThis.Array.isArray(object?.datasetVersionMetricsGroups)
        ? object.datasetVersionMetricsGroups.map((e: any) => DatasetVersionMetricsGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiDatasetVersionMetricsGroupResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetVersionMetricsGroups?.length) {
      obj.datasetVersionMetricsGroups = message.datasetVersionMetricsGroups.map((e) =>
        DatasetVersionMetricsGroup.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDatasetVersionMetricsGroupResponse>, I>>(
    base?: I,
  ): MultiDatasetVersionMetricsGroupResponse {
    return MultiDatasetVersionMetricsGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDatasetVersionMetricsGroupResponse>, I>>(
    object: I,
  ): MultiDatasetVersionMetricsGroupResponse {
    const message = createBaseMultiDatasetVersionMetricsGroupResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetVersionMetricsGroups =
      object.datasetVersionMetricsGroups?.map((e) => DatasetVersionMetricsGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleDatasetVersionResponse(): SingleDatasetVersionResponse {
  return { status: undefined, datasetVersion: undefined };
}

export const SingleDatasetVersionResponse: MessageFns<SingleDatasetVersionResponse> = {
  encode(message: SingleDatasetVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.datasetVersion !== undefined) {
      DatasetVersion.encode(message.datasetVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleDatasetVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDatasetVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetVersion = DatasetVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleDatasetVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetVersion: isSet(object.datasetVersion) ? DatasetVersion.fromJSON(object.datasetVersion) : undefined,
    };
  },

  toJSON(message: SingleDatasetVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetVersion !== undefined) {
      obj.datasetVersion = DatasetVersion.toJSON(message.datasetVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleDatasetVersionResponse>, I>>(base?: I): SingleDatasetVersionResponse {
    return SingleDatasetVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleDatasetVersionResponse>, I>>(object: I): SingleDatasetVersionResponse {
    const message = createBaseSingleDatasetVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetVersion = (object.datasetVersion !== undefined && object.datasetVersion !== null)
      ? DatasetVersion.fromPartial(object.datasetVersion)
      : undefined;
    return message;
  },
};

function createBasePostModelOutputsRequest(): PostModelOutputsRequest {
  return {
    userAppId: undefined,
    modelId: "",
    versionId: "",
    inputs: [],
    model: undefined,
    runnerSelector: undefined,
    usePredictCache: false,
    enableLogSummaryOnError: false,
  };
}

export const PostModelOutputsRequest: MessageFns<PostModelOutputsRequest> = {
  encode(message: PostModelOutputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(42).fork()).join();
    }
    if (message.runnerSelector !== undefined) {
      RunnerSelector.encode(message.runnerSelector, writer.uint32(50).fork()).join();
    }
    if (message.usePredictCache !== false) {
      writer.uint32(56).bool(message.usePredictCache);
    }
    if (message.enableLogSummaryOnError !== false) {
      writer.uint32(64).bool(message.enableLogSummaryOnError);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelOutputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runnerSelector = RunnerSelector.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.usePredictCache = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enableLogSummaryOnError = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelOutputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      runnerSelector: isSet(object.runnerSelector) ? RunnerSelector.fromJSON(object.runnerSelector) : undefined,
      usePredictCache: isSet(object.usePredictCache) ? globalThis.Boolean(object.usePredictCache) : false,
      enableLogSummaryOnError: isSet(object.enableLogSummaryOnError)
        ? globalThis.Boolean(object.enableLogSummaryOnError)
        : false,
    };
  },

  toJSON(message: PostModelOutputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.runnerSelector !== undefined) {
      obj.runnerSelector = RunnerSelector.toJSON(message.runnerSelector);
    }
    if (message.usePredictCache !== false) {
      obj.usePredictCache = message.usePredictCache;
    }
    if (message.enableLogSummaryOnError !== false) {
      obj.enableLogSummaryOnError = message.enableLogSummaryOnError;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelOutputsRequest>, I>>(base?: I): PostModelOutputsRequest {
    return PostModelOutputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelOutputsRequest>, I>>(object: I): PostModelOutputsRequest {
    const message = createBasePostModelOutputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.runnerSelector = (object.runnerSelector !== undefined && object.runnerSelector !== null)
      ? RunnerSelector.fromPartial(object.runnerSelector)
      : undefined;
    message.usePredictCache = object.usePredictCache ?? false;
    message.enableLogSummaryOnError = object.enableLogSummaryOnError ?? false;
    return message;
  },
};

function createBaseListModelInputsRequest(): ListModelInputsRequest {
  return { userAppId: undefined, modelId: "", versionId: "", page: 0, perPage: 0 };
}

export const ListModelInputsRequest: MessageFns<ListModelInputsRequest> = {
  encode(message: ListModelInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelInputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModelInputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelInputsRequest>, I>>(base?: I): ListModelInputsRequest {
    return ListModelInputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelInputsRequest>, I>>(object: I): ListModelInputsRequest {
    const message = createBaseListModelInputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostComputePlaneMetricsRequest(): PostComputePlaneMetricsRequest {
  return { computePlaneMetrics: [] };
}

export const PostComputePlaneMetricsRequest: MessageFns<PostComputePlaneMetricsRequest> = {
  encode(message: PostComputePlaneMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.computePlaneMetrics) {
      ComputePlaneMetrics.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostComputePlaneMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostComputePlaneMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.computePlaneMetrics.push(ComputePlaneMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostComputePlaneMetricsRequest {
    return {
      computePlaneMetrics: globalThis.Array.isArray(object?.computePlaneMetrics)
        ? object.computePlaneMetrics.map((e: any) => ComputePlaneMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostComputePlaneMetricsRequest): unknown {
    const obj: any = {};
    if (message.computePlaneMetrics?.length) {
      obj.computePlaneMetrics = message.computePlaneMetrics.map((e) => ComputePlaneMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostComputePlaneMetricsRequest>, I>>(base?: I): PostComputePlaneMetricsRequest {
    return PostComputePlaneMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostComputePlaneMetricsRequest>, I>>(
    object: I,
  ): PostComputePlaneMetricsRequest {
    const message = createBasePostComputePlaneMetricsRequest();
    message.computePlaneMetrics = object.computePlaneMetrics?.map((e) => ComputePlaneMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostLogEntriesRequest(): PostLogEntriesRequest {
  return { logEntries: [] };
}

export const PostLogEntriesRequest: MessageFns<PostLogEntriesRequest> = {
  encode(message: PostLogEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logEntries) {
      LogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostLogEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostLogEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logEntries.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostLogEntriesRequest {
    return {
      logEntries: globalThis.Array.isArray(object?.logEntries)
        ? object.logEntries.map((e: any) => LogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostLogEntriesRequest): unknown {
    const obj: any = {};
    if (message.logEntries?.length) {
      obj.logEntries = message.logEntries.map((e) => LogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostLogEntriesRequest>, I>>(base?: I): PostLogEntriesRequest {
    return PostLogEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostLogEntriesRequest>, I>>(object: I): PostLogEntriesRequest {
    const message = createBasePostLogEntriesRequest();
    message.logEntries = object.logEntries?.map((e) => LogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListLogEntriesRequest(): ListLogEntriesRequest {
  return {
    page: 0,
    perPage: 0,
    logType: "",
    userAppId: undefined,
    modelId: "",
    modelVersionId: "",
    workflowId: "",
    computeClusterUserId: "",
    computeClusterId: "",
    nodepoolId: "",
    runnerId: "",
    pipelineId: "",
    pipelineVersionId: "",
    pipelineVersionRunId: "",
    pipelineStepId: "",
    pipelineStepVersionId: "",
  };
}

export const ListLogEntriesRequest: MessageFns<ListLogEntriesRequest> = {
  encode(message: ListLogEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(16).uint32(message.perPage);
    }
    if (message.logType !== "") {
      writer.uint32(26).string(message.logType);
    }
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(34).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(42).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(50).string(message.modelVersionId);
    }
    if (message.workflowId !== "") {
      writer.uint32(58).string(message.workflowId);
    }
    if (message.computeClusterUserId !== "") {
      writer.uint32(138).string(message.computeClusterUserId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(74).string(message.computeClusterId);
    }
    if (message.nodepoolId !== "") {
      writer.uint32(82).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(90).string(message.runnerId);
    }
    if (message.pipelineId !== "") {
      writer.uint32(98).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(106).string(message.pipelineVersionId);
    }
    if (message.pipelineVersionRunId !== "") {
      writer.uint32(114).string(message.pipelineVersionRunId);
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(122).string(message.pipelineStepId);
    }
    if (message.pipelineStepVersionId !== "") {
      writer.uint32(130).string(message.pipelineStepVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLogEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLogEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.computeClusterUserId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pipelineVersionRunId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.pipelineStepVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLogEntriesRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      logType: isSet(object.logType) ? globalThis.String(object.logType) : "",
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      computeClusterUserId: isSet(object.computeClusterUserId) ? globalThis.String(object.computeClusterUserId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRunId: isSet(object.pipelineVersionRunId) ? globalThis.String(object.pipelineVersionRunId) : "",
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      pipelineStepVersionId: isSet(object.pipelineStepVersionId) ? globalThis.String(object.pipelineStepVersionId) : "",
    };
  },

  toJSON(message: ListLogEntriesRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.logType !== "") {
      obj.logType = message.logType;
    }
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.computeClusterUserId !== "") {
      obj.computeClusterUserId = message.computeClusterUserId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRunId !== "") {
      obj.pipelineVersionRunId = message.pipelineVersionRunId;
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.pipelineStepVersionId !== "") {
      obj.pipelineStepVersionId = message.pipelineStepVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListLogEntriesRequest>, I>>(base?: I): ListLogEntriesRequest {
    return ListLogEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListLogEntriesRequest>, I>>(object: I): ListLogEntriesRequest {
    const message = createBaseListLogEntriesRequest();
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.logType = object.logType ?? "";
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.computeClusterUserId = object.computeClusterUserId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRunId = object.pipelineVersionRunId ?? "";
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.pipelineStepVersionId = object.pipelineStepVersionId ?? "";
    return message;
  },
};

function createBaseStreamLogEntriesRequest(): StreamLogEntriesRequest {
  return {
    logType: "",
    userAppId: undefined,
    modelId: "",
    modelVersionId: "",
    workflowId: "",
    computeClusterUserId: "",
    computeClusterId: "",
    nodepoolId: "",
    runnerId: "",
    pipelineId: "",
    pipelineVersionId: "",
    pipelineVersionRunId: "",
    pipelineStepId: "",
    pipelineStepVersionId: "",
  };
}

export const StreamLogEntriesRequest: MessageFns<StreamLogEntriesRequest> = {
  encode(message: StreamLogEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logType !== "") {
      writer.uint32(10).string(message.logType);
    }
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(18).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(26).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(34).string(message.modelVersionId);
    }
    if (message.workflowId !== "") {
      writer.uint32(42).string(message.workflowId);
    }
    if (message.computeClusterUserId !== "") {
      writer.uint32(138).string(message.computeClusterUserId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(50).string(message.computeClusterId);
    }
    if (message.nodepoolId !== "") {
      writer.uint32(58).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(66).string(message.runnerId);
    }
    if (message.pipelineId !== "") {
      writer.uint32(98).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(106).string(message.pipelineVersionId);
    }
    if (message.pipelineVersionRunId !== "") {
      writer.uint32(114).string(message.pipelineVersionRunId);
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(122).string(message.pipelineStepId);
    }
    if (message.pipelineStepVersionId !== "") {
      writer.uint32(130).string(message.pipelineStepVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamLogEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamLogEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.computeClusterUserId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pipelineVersionRunId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.pipelineStepVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamLogEntriesRequest {
    return {
      logType: isSet(object.logType) ? globalThis.String(object.logType) : "",
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      computeClusterUserId: isSet(object.computeClusterUserId) ? globalThis.String(object.computeClusterUserId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRunId: isSet(object.pipelineVersionRunId) ? globalThis.String(object.pipelineVersionRunId) : "",
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      pipelineStepVersionId: isSet(object.pipelineStepVersionId) ? globalThis.String(object.pipelineStepVersionId) : "",
    };
  },

  toJSON(message: StreamLogEntriesRequest): unknown {
    const obj: any = {};
    if (message.logType !== "") {
      obj.logType = message.logType;
    }
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.computeClusterUserId !== "") {
      obj.computeClusterUserId = message.computeClusterUserId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRunId !== "") {
      obj.pipelineVersionRunId = message.pipelineVersionRunId;
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.pipelineStepVersionId !== "") {
      obj.pipelineStepVersionId = message.pipelineStepVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamLogEntriesRequest>, I>>(base?: I): StreamLogEntriesRequest {
    return StreamLogEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamLogEntriesRequest>, I>>(object: I): StreamLogEntriesRequest {
    const message = createBaseStreamLogEntriesRequest();
    message.logType = object.logType ?? "";
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.computeClusterUserId = object.computeClusterUserId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRunId = object.pipelineVersionRunId ?? "";
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.pipelineStepVersionId = object.pipelineStepVersionId ?? "";
    return message;
  },
};

function createBaseGetKeyRequest(): GetKeyRequest {
  return { userAppId: undefined, keyId: "" };
}

export const GetKeyRequest: MessageFns<GetKeyRequest> = {
  encode(message: GetKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
    };
  },

  toJSON(message: GetKeyRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyRequest>, I>>(base?: I): GetKeyRequest {
    return GetKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyRequest>, I>>(object: I): GetKeyRequest {
    const message = createBaseGetKeyRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { userAppId: undefined, page: 0, perPage: 0, notExpired: false, scopes: [], endpoints: [], type: "" };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    if (message.notExpired !== false) {
      writer.uint32(32).bool(message.notExpired);
    }
    for (const v of message.scopes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(50).string(v!);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.notExpired = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      notExpired: isSet(object.notExpired) ? globalThis.Boolean(object.notExpired) : false,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.notExpired !== false) {
      obj.notExpired = message.notExpired;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysRequest>, I>>(base?: I): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysRequest>, I>>(object: I): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.notExpired = object.notExpired ?? false;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseListAppKeysRequest(): ListAppKeysRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListAppKeysRequest: MessageFns<ListAppKeysRequest> = {
  encode(message: ListAppKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAppKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAppKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAppKeysRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListAppKeysRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAppKeysRequest>, I>>(base?: I): ListAppKeysRequest {
    return ListAppKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAppKeysRequest>, I>>(object: I): ListAppKeysRequest {
    const message = createBaseListAppKeysRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostKeysRequest(): PostKeysRequest {
  return { userAppId: undefined, keys: [] };
}

export const PostKeysRequest: MessageFns<PostKeysRequest> = {
  encode(message: PostKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostKeysRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostKeysRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostKeysRequest>, I>>(base?: I): PostKeysRequest {
    return PostKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostKeysRequest>, I>>(object: I): PostKeysRequest {
    const message = createBasePostKeysRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteKeyRequest(): DeleteKeyRequest {
  return { userAppId: undefined, keyId: "" };
}

export const DeleteKeyRequest: MessageFns<DeleteKeyRequest> = {
  encode(message: DeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
    };
  },

  toJSON(message: DeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(base?: I): DeleteKeyRequest {
    return DeleteKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(object: I): DeleteKeyRequest {
    const message = createBaseDeleteKeyRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBasePatchKeysRequest(): PatchKeysRequest {
  return { userAppId: undefined, keys: [], action: "" };
}

export const PatchKeysRequest: MessageFns<PatchKeysRequest> = {
  encode(message: PatchKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchKeysRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchKeysRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchKeysRequest>, I>>(base?: I): PatchKeysRequest {
    return PatchKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchKeysRequest>, I>>(object: I): PatchKeysRequest {
    const message = createBasePatchKeysRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseSingleKeyResponse(): SingleKeyResponse {
  return { status: undefined, key: undefined };
}

export const SingleKeyResponse: MessageFns<SingleKeyResponse> = {
  encode(message: SingleKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleKeyResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: SingleKeyResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleKeyResponse>, I>>(base?: I): SingleKeyResponse {
    return SingleKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleKeyResponse>, I>>(object: I): SingleKeyResponse {
    const message = createBaseSingleKeyResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseMultiKeyResponse(): MultiKeyResponse {
  return { status: undefined, keys: [] };
}

export const MultiKeyResponse: MessageFns<MultiKeyResponse> = {
  encode(message: MultiKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiKeyResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiKeyResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiKeyResponse>, I>>(base?: I): MultiKeyResponse {
    return MultiKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiKeyResponse>, I>>(object: I): MultiKeyResponse {
    const message = createBaseMultiKeyResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetModelRequest(): GetModelRequest {
  return { userAppId: undefined, modelId: "", versionId: "", language: "", trainedBefore: false, additionalFields: [] };
}

export const GetModelRequest: MessageFns<GetModelRequest> = {
  encode(message: GetModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    if (message.language !== "") {
      writer.uint32(34).string(message.language);
    }
    if (message.trainedBefore !== false) {
      writer.uint32(40).bool(message.trainedBefore);
    }
    for (const v of message.additionalFields) {
      writer.uint32(154).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.trainedBefore = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      trainedBefore: isSet(object.trainedBefore) ? globalThis.Boolean(object.trainedBefore) : false,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetModelRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.trainedBefore !== false) {
      obj.trainedBefore = message.trainedBefore;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelRequest>, I>>(base?: I): GetModelRequest {
    return GetModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelRequest>, I>>(object: I): GetModelRequest {
    const message = createBaseGetModelRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.language = object.language ?? "";
    message.trainedBefore = object.trainedBefore ?? false;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseListModelsRequest(): ListModelsRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    additionalFields: [],
    sortAscending: false,
    sortByName: undefined,
    sortByNumInputs: undefined,
    sortByModifiedAt: undefined,
    sortByCreatedAt: undefined,
    sortByStarCount: undefined,
    modelTypeId: "",
    trainedOnly: false,
    inputFields: [],
    outputFields: [],
    license: "",
    featuredOnly: false,
    starredOnly: false,
    toolkits: [],
    useCases: [],
    languages: [],
    dontFetchFromMain: false,
    bookmark: false,
    search: "",
    query: "",
    name: "",
    filterByUserId: false,
    modelVersionIds: [],
    licenseType: 0,
    source: 0,
    creator: "",
    minReplicas: 0,
    showReplicas: false,
    visibility: undefined,
  };
}

export const ListModelsRequest: MessageFns<ListModelsRequest> = {
  encode(message: ListModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(154).string(v!);
    }
    if (message.sortAscending !== false) {
      writer.uint32(80).bool(message.sortAscending);
    }
    if (message.sortByName !== undefined) {
      writer.uint32(88).bool(message.sortByName);
    }
    if (message.sortByNumInputs !== undefined) {
      writer.uint32(96).bool(message.sortByNumInputs);
    }
    if (message.sortByModifiedAt !== undefined) {
      writer.uint32(104).bool(message.sortByModifiedAt);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(192).bool(message.sortByCreatedAt);
    }
    if (message.sortByStarCount !== undefined) {
      writer.uint32(200).bool(message.sortByStarCount);
    }
    if (message.modelTypeId !== "") {
      writer.uint32(50).string(message.modelTypeId);
    }
    if (message.trainedOnly !== false) {
      writer.uint32(56).bool(message.trainedOnly);
    }
    for (const v of message.inputFields) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.outputFields) {
      writer.uint32(74).string(v!);
    }
    if (message.license !== "") {
      writer.uint32(122).string(message.license);
    }
    if (message.featuredOnly !== false) {
      writer.uint32(128).bool(message.featuredOnly);
    }
    if (message.starredOnly !== false) {
      writer.uint32(160).bool(message.starredOnly);
    }
    for (const v of message.toolkits) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.useCases) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.languages) {
      writer.uint32(170).string(v!);
    }
    if (message.dontFetchFromMain !== false) {
      writer.uint32(184).bool(message.dontFetchFromMain);
    }
    if (message.bookmark !== false) {
      writer.uint32(208).bool(message.bookmark);
    }
    if (message.search !== "") {
      writer.uint32(218).string(message.search);
    }
    if (message.query !== "") {
      writer.uint32(114).string(message.query);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.filterByUserId !== false) {
      writer.uint32(176).bool(message.filterByUserId);
    }
    for (const v of message.modelVersionIds) {
      writer.uint32(226).string(v!);
    }
    if (message.licenseType !== 0) {
      writer.uint32(232).int32(message.licenseType);
    }
    if (message.source !== 0) {
      writer.uint32(240).uint32(message.source);
    }
    if (message.creator !== "") {
      writer.uint32(250).string(message.creator);
    }
    if (message.minReplicas !== 0) {
      writer.uint32(264).uint32(message.minReplicas);
    }
    if (message.showReplicas !== false) {
      writer.uint32(272).bool(message.showReplicas);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sortByName = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.sortByNumInputs = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.sortByModifiedAt = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.sortByStarCount = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelTypeId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.trainedOnly = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputFields.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.outputFields.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.license = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.featuredOnly = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.starredOnly = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.toolkits.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.useCases.push(reader.string());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.languages.push(reader.string());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.dontFetchFromMain = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.bookmark = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.filterByUserId = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.modelVersionIds.push(reader.string());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.source = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.minReplicas = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.showReplicas = reader.bool();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByName: isSet(object.sortByName) ? globalThis.Boolean(object.sortByName) : undefined,
      sortByNumInputs: isSet(object.sortByNumInputs) ? globalThis.Boolean(object.sortByNumInputs) : undefined,
      sortByModifiedAt: isSet(object.sortByModifiedAt) ? globalThis.Boolean(object.sortByModifiedAt) : undefined,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByStarCount: isSet(object.sortByStarCount) ? globalThis.Boolean(object.sortByStarCount) : undefined,
      modelTypeId: isSet(object.modelTypeId) ? globalThis.String(object.modelTypeId) : "",
      trainedOnly: isSet(object.trainedOnly) ? globalThis.Boolean(object.trainedOnly) : false,
      inputFields: globalThis.Array.isArray(object?.inputFields)
        ? object.inputFields.map((e: any) => globalThis.String(e))
        : [],
      outputFields: globalThis.Array.isArray(object?.outputFields)
        ? object.outputFields.map((e: any) => globalThis.String(e))
        : [],
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      featuredOnly: isSet(object.featuredOnly) ? globalThis.Boolean(object.featuredOnly) : false,
      starredOnly: isSet(object.starredOnly) ? globalThis.Boolean(object.starredOnly) : false,
      toolkits: globalThis.Array.isArray(object?.toolkits) ? object.toolkits.map((e: any) => globalThis.String(e)) : [],
      useCases: globalThis.Array.isArray(object?.useCases) ? object.useCases.map((e: any) => globalThis.String(e)) : [],
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => globalThis.String(e))
        : [],
      dontFetchFromMain: isSet(object.dontFetchFromMain) ? globalThis.Boolean(object.dontFetchFromMain) : false,
      bookmark: isSet(object.bookmark) ? globalThis.Boolean(object.bookmark) : false,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filterByUserId: isSet(object.filterByUserId) ? globalThis.Boolean(object.filterByUserId) : false,
      modelVersionIds: globalThis.Array.isArray(object?.modelVersionIds)
        ? object.modelVersionIds.map((e: any) => globalThis.String(e))
        : [],
      licenseType: isSet(object.licenseType) ? licenseTypeFromJSON(object.licenseType) : 0,
      source: isSet(object.source) ? globalThis.Number(object.source) : 0,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      minReplicas: isSet(object.minReplicas) ? globalThis.Number(object.minReplicas) : 0,
      showReplicas: isSet(object.showReplicas) ? globalThis.Boolean(object.showReplicas) : false,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
    };
  },

  toJSON(message: ListModelsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByName !== undefined) {
      obj.sortByName = message.sortByName;
    }
    if (message.sortByNumInputs !== undefined) {
      obj.sortByNumInputs = message.sortByNumInputs;
    }
    if (message.sortByModifiedAt !== undefined) {
      obj.sortByModifiedAt = message.sortByModifiedAt;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByStarCount !== undefined) {
      obj.sortByStarCount = message.sortByStarCount;
    }
    if (message.modelTypeId !== "") {
      obj.modelTypeId = message.modelTypeId;
    }
    if (message.trainedOnly !== false) {
      obj.trainedOnly = message.trainedOnly;
    }
    if (message.inputFields?.length) {
      obj.inputFields = message.inputFields;
    }
    if (message.outputFields?.length) {
      obj.outputFields = message.outputFields;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.featuredOnly !== false) {
      obj.featuredOnly = message.featuredOnly;
    }
    if (message.starredOnly !== false) {
      obj.starredOnly = message.starredOnly;
    }
    if (message.toolkits?.length) {
      obj.toolkits = message.toolkits;
    }
    if (message.useCases?.length) {
      obj.useCases = message.useCases;
    }
    if (message.languages?.length) {
      obj.languages = message.languages;
    }
    if (message.dontFetchFromMain !== false) {
      obj.dontFetchFromMain = message.dontFetchFromMain;
    }
    if (message.bookmark !== false) {
      obj.bookmark = message.bookmark;
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filterByUserId !== false) {
      obj.filterByUserId = message.filterByUserId;
    }
    if (message.modelVersionIds?.length) {
      obj.modelVersionIds = message.modelVersionIds;
    }
    if (message.licenseType !== 0) {
      obj.licenseType = licenseTypeToJSON(message.licenseType);
    }
    if (message.source !== 0) {
      obj.source = Math.round(message.source);
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.minReplicas !== 0) {
      obj.minReplicas = Math.round(message.minReplicas);
    }
    if (message.showReplicas !== false) {
      obj.showReplicas = message.showReplicas;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelsRequest>, I>>(base?: I): ListModelsRequest {
    return ListModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelsRequest>, I>>(object: I): ListModelsRequest {
    const message = createBaseListModelsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.sortAscending = object.sortAscending ?? false;
    message.sortByName = object.sortByName ?? undefined;
    message.sortByNumInputs = object.sortByNumInputs ?? undefined;
    message.sortByModifiedAt = object.sortByModifiedAt ?? undefined;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByStarCount = object.sortByStarCount ?? undefined;
    message.modelTypeId = object.modelTypeId ?? "";
    message.trainedOnly = object.trainedOnly ?? false;
    message.inputFields = object.inputFields?.map((e) => e) || [];
    message.outputFields = object.outputFields?.map((e) => e) || [];
    message.license = object.license ?? "";
    message.featuredOnly = object.featuredOnly ?? false;
    message.starredOnly = object.starredOnly ?? false;
    message.toolkits = object.toolkits?.map((e) => e) || [];
    message.useCases = object.useCases?.map((e) => e) || [];
    message.languages = object.languages?.map((e) => e) || [];
    message.dontFetchFromMain = object.dontFetchFromMain ?? false;
    message.bookmark = object.bookmark ?? false;
    message.search = object.search ?? "";
    message.query = object.query ?? "";
    message.name = object.name ?? "";
    message.filterByUserId = object.filterByUserId ?? false;
    message.modelVersionIds = object.modelVersionIds?.map((e) => e) || [];
    message.licenseType = object.licenseType ?? 0;
    message.source = object.source ?? 0;
    message.creator = object.creator ?? "";
    message.minReplicas = object.minReplicas ?? 0;
    message.showReplicas = object.showReplicas ?? false;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    return message;
  },
};

function createBaseGetResourceCountsRequest(): GetResourceCountsRequest {
  return { userAppId: undefined };
}

export const GetResourceCountsRequest: MessageFns<GetResourceCountsRequest> = {
  encode(message: GetResourceCountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceCountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceCountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceCountsRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: GetResourceCountsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourceCountsRequest>, I>>(base?: I): GetResourceCountsRequest {
    return GetResourceCountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourceCountsRequest>, I>>(object: I): GetResourceCountsRequest {
    const message = createBaseGetResourceCountsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseGetResourceCountsResponse(): GetResourceCountsResponse {
  return { status: undefined, datasets: 0, models: 0, workflows: 0, modules: 0, inputs: 0 };
}

export const GetResourceCountsResponse: MessageFns<GetResourceCountsResponse> = {
  encode(message: GetResourceCountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.datasets !== 0) {
      writer.uint32(16).int64(message.datasets);
    }
    if (message.models !== 0) {
      writer.uint32(24).int64(message.models);
    }
    if (message.workflows !== 0) {
      writer.uint32(32).int64(message.workflows);
    }
    if (message.modules !== 0) {
      writer.uint32(40).int64(message.modules);
    }
    if (message.inputs !== 0) {
      writer.uint32(48).int64(message.inputs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceCountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceCountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.datasets = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.models = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.workflows = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.modules = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.inputs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceCountsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasets: isSet(object.datasets) ? globalThis.Number(object.datasets) : 0,
      models: isSet(object.models) ? globalThis.Number(object.models) : 0,
      workflows: isSet(object.workflows) ? globalThis.Number(object.workflows) : 0,
      modules: isSet(object.modules) ? globalThis.Number(object.modules) : 0,
      inputs: isSet(object.inputs) ? globalThis.Number(object.inputs) : 0,
    };
  },

  toJSON(message: GetResourceCountsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasets !== 0) {
      obj.datasets = Math.round(message.datasets);
    }
    if (message.models !== 0) {
      obj.models = Math.round(message.models);
    }
    if (message.workflows !== 0) {
      obj.workflows = Math.round(message.workflows);
    }
    if (message.modules !== 0) {
      obj.modules = Math.round(message.modules);
    }
    if (message.inputs !== 0) {
      obj.inputs = Math.round(message.inputs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourceCountsResponse>, I>>(base?: I): GetResourceCountsResponse {
    return GetResourceCountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResourceCountsResponse>, I>>(object: I): GetResourceCountsResponse {
    const message = createBaseGetResourceCountsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasets = object.datasets ?? 0;
    message.models = object.models ?? 0;
    message.workflows = object.workflows ?? 0;
    message.modules = object.modules ?? 0;
    message.inputs = object.inputs ?? 0;
    return message;
  },
};

function createBasePatchModelToolkitsRequest(): PatchModelToolkitsRequest {
  return { userAppId: undefined, modelId: "", toolkits: [], action: "" };
}

export const PatchModelToolkitsRequest: MessageFns<PatchModelToolkitsRequest> = {
  encode(message: PatchModelToolkitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.toolkits) {
      writer.uint32(26).string(v!);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelToolkitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelToolkitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolkits.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelToolkitsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      toolkits: globalThis.Array.isArray(object?.toolkits) ? object.toolkits.map((e: any) => globalThis.String(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelToolkitsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.toolkits?.length) {
      obj.toolkits = message.toolkits;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelToolkitsRequest>, I>>(base?: I): PatchModelToolkitsRequest {
    return PatchModelToolkitsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelToolkitsRequest>, I>>(object: I): PatchModelToolkitsRequest {
    const message = createBasePatchModelToolkitsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.toolkits = object.toolkits?.map((e) => e) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchModelCheckConsentsRequest(): PatchModelCheckConsentsRequest {
  return { userAppId: undefined, modelId: "", checkConsents: [], action: "" };
}

export const PatchModelCheckConsentsRequest: MessageFns<PatchModelCheckConsentsRequest> = {
  encode(message: PatchModelCheckConsentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.checkConsents) {
      writer.uint32(26).string(v!);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelCheckConsentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelCheckConsentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkConsents.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelCheckConsentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      checkConsents: globalThis.Array.isArray(object?.checkConsents)
        ? object.checkConsents.map((e: any) => globalThis.String(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelCheckConsentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.checkConsents?.length) {
      obj.checkConsents = message.checkConsents;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelCheckConsentsRequest>, I>>(base?: I): PatchModelCheckConsentsRequest {
    return PatchModelCheckConsentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelCheckConsentsRequest>, I>>(
    object: I,
  ): PatchModelCheckConsentsRequest {
    const message = createBasePatchModelCheckConsentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.checkConsents = object.checkConsents?.map((e) => e) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchModelUseCasesRequest(): PatchModelUseCasesRequest {
  return { userAppId: undefined, modelId: "", usecases: [], action: "" };
}

export const PatchModelUseCasesRequest: MessageFns<PatchModelUseCasesRequest> = {
  encode(message: PatchModelUseCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.usecases) {
      writer.uint32(26).string(v!);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelUseCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelUseCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.usecases.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelUseCasesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      usecases: globalThis.Array.isArray(object?.usecases) ? object.usecases.map((e: any) => globalThis.String(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelUseCasesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.usecases?.length) {
      obj.usecases = message.usecases;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelUseCasesRequest>, I>>(base?: I): PatchModelUseCasesRequest {
    return PatchModelUseCasesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelUseCasesRequest>, I>>(object: I): PatchModelUseCasesRequest {
    const message = createBasePatchModelUseCasesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.usecases = object.usecases?.map((e) => e) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchModelLanguagesRequest(): PatchModelLanguagesRequest {
  return { userAppId: undefined, modelId: "", languages: [], action: "" };
}

export const PatchModelLanguagesRequest: MessageFns<PatchModelLanguagesRequest> = {
  encode(message: PatchModelLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.languages) {
      writer.uint32(26).string(v!);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languages.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelLanguagesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => globalThis.String(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelLanguagesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.languages?.length) {
      obj.languages = message.languages;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelLanguagesRequest>, I>>(base?: I): PatchModelLanguagesRequest {
    return PatchModelLanguagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelLanguagesRequest>, I>>(object: I): PatchModelLanguagesRequest {
    const message = createBasePatchModelLanguagesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.languages = object.languages?.map((e) => e) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseMultiModelToolkitResponse(): MultiModelToolkitResponse {
  return { status: undefined, toolkits: [] };
}

export const MultiModelToolkitResponse: MessageFns<MultiModelToolkitResponse> = {
  encode(message: MultiModelToolkitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.toolkits) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelToolkitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelToolkitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolkits.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelToolkitResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      toolkits: globalThis.Array.isArray(object?.toolkits) ? object.toolkits.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MultiModelToolkitResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.toolkits?.length) {
      obj.toolkits = message.toolkits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelToolkitResponse>, I>>(base?: I): MultiModelToolkitResponse {
    return MultiModelToolkitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelToolkitResponse>, I>>(object: I): MultiModelToolkitResponse {
    const message = createBaseMultiModelToolkitResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.toolkits = object.toolkits?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiModelCheckConsentResponse(): MultiModelCheckConsentResponse {
  return { status: undefined, checkConsents: [] };
}

export const MultiModelCheckConsentResponse: MessageFns<MultiModelCheckConsentResponse> = {
  encode(message: MultiModelCheckConsentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.checkConsents) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelCheckConsentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelCheckConsentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkConsents.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelCheckConsentResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      checkConsents: globalThis.Array.isArray(object?.checkConsents)
        ? object.checkConsents.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MultiModelCheckConsentResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.checkConsents?.length) {
      obj.checkConsents = message.checkConsents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelCheckConsentResponse>, I>>(base?: I): MultiModelCheckConsentResponse {
    return MultiModelCheckConsentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelCheckConsentResponse>, I>>(
    object: I,
  ): MultiModelCheckConsentResponse {
    const message = createBaseMultiModelCheckConsentResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.checkConsents = object.checkConsents?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiModelUseCaseResponse(): MultiModelUseCaseResponse {
  return { status: undefined, usecases: [] };
}

export const MultiModelUseCaseResponse: MessageFns<MultiModelUseCaseResponse> = {
  encode(message: MultiModelUseCaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.usecases) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelUseCaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelUseCaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usecases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelUseCaseResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      usecases: globalThis.Array.isArray(object?.usecases) ? object.usecases.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MultiModelUseCaseResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.usecases?.length) {
      obj.usecases = message.usecases;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelUseCaseResponse>, I>>(base?: I): MultiModelUseCaseResponse {
    return MultiModelUseCaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelUseCaseResponse>, I>>(object: I): MultiModelUseCaseResponse {
    const message = createBaseMultiModelUseCaseResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.usecases = object.usecases?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiModelLanguageResponse(): MultiModelLanguageResponse {
  return { status: undefined, languages: [] };
}

export const MultiModelLanguageResponse: MessageFns<MultiModelLanguageResponse> = {
  encode(message: MultiModelLanguageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.languages) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelLanguageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelLanguageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.languages.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelLanguageResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MultiModelLanguageResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.languages?.length) {
      obj.languages = message.languages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelLanguageResponse>, I>>(base?: I): MultiModelLanguageResponse {
    return MultiModelLanguageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelLanguageResponse>, I>>(object: I): MultiModelLanguageResponse {
    const message = createBaseMultiModelLanguageResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.languages = object.languages?.map((e) => e) || [];
    return message;
  },
};

function createBasePostModelsRequest(): PostModelsRequest {
  return { userAppId: undefined, model: undefined, models: [] };
}

export const PostModelsRequest: MessageFns<PostModelsRequest> = {
  encode(message: PostModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).join();
    }
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostModelsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelsRequest>, I>>(base?: I): PostModelsRequest {
    return PostModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelsRequest>, I>>(object: I): PostModelsRequest {
    const message = createBasePostModelsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchModelsRequest(): PatchModelsRequest {
  return { userAppId: undefined, models: [], action: "" };
}

export const PatchModelsRequest: MessageFns<PatchModelsRequest> = {
  encode(message: PatchModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelsRequest>, I>>(base?: I): PatchModelsRequest {
    return PatchModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelsRequest>, I>>(object: I): PatchModelsRequest {
    const message = createBasePatchModelsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseIdUpdateSource(): IdUpdateSource {
  return { id: "", newId: "" };
}

export const IdUpdateSource: MessageFns<IdUpdateSource> = {
  encode(message: IdUpdateSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newId !== "") {
      writer.uint32(18).string(message.newId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdUpdateSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdUpdateSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdUpdateSource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newId: isSet(object.newId) ? globalThis.String(object.newId) : "",
    };
  },

  toJSON(message: IdUpdateSource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newId !== "") {
      obj.newId = message.newId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdUpdateSource>, I>>(base?: I): IdUpdateSource {
    return IdUpdateSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdUpdateSource>, I>>(object: I): IdUpdateSource {
    const message = createBaseIdUpdateSource();
    message.id = object.id ?? "";
    message.newId = object.newId ?? "";
    return message;
  },
};

function createBasePatchModelIdsRequest(): PatchModelIdsRequest {
  return { userAppId: undefined, ids: [], action: "" };
}

export const PatchModelIdsRequest: MessageFns<PatchModelIdsRequest> = {
  encode(message: PatchModelIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      IdUpdateSource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(IdUpdateSource.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelIdsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => IdUpdateSource.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelIdsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => IdUpdateSource.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelIdsRequest>, I>>(base?: I): PatchModelIdsRequest {
    return PatchModelIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelIdsRequest>, I>>(object: I): PatchModelIdsRequest {
    const message = createBasePatchModelIdsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => IdUpdateSource.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteModelRequest(): DeleteModelRequest {
  return { userAppId: undefined, modelId: "" };
}

export const DeleteModelRequest: MessageFns<DeleteModelRequest> = {
  encode(message: DeleteModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModelRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
    };
  },

  toJSON(message: DeleteModelRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteModelRequest>, I>>(base?: I): DeleteModelRequest {
    return DeleteModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteModelRequest>, I>>(object: I): DeleteModelRequest {
    const message = createBaseDeleteModelRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    return message;
  },
};

function createBaseDeleteModelsRequest(): DeleteModelsRequest {
  return { userAppId: undefined, ids: [], deleteAll: false };
}

export const DeleteModelsRequest: MessageFns<DeleteModelsRequest> = {
  encode(message: DeleteModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    if (message.deleteAll !== false) {
      writer.uint32(24).bool(message.deleteAll);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deleteAll = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModelsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      deleteAll: isSet(object.deleteAll) ? globalThis.Boolean(object.deleteAll) : false,
    };
  },

  toJSON(message: DeleteModelsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.deleteAll !== false) {
      obj.deleteAll = message.deleteAll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteModelsRequest>, I>>(base?: I): DeleteModelsRequest {
    return DeleteModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteModelsRequest>, I>>(object: I): DeleteModelsRequest {
    const message = createBaseDeleteModelsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.deleteAll = object.deleteAll ?? false;
    return message;
  },
};

function createBasePostModelsSearchesRequest(): PostModelsSearchesRequest {
  return { userAppId: undefined, modelQuery: undefined, pagination: undefined };
}

export const PostModelsSearchesRequest: MessageFns<PostModelsSearchesRequest> = {
  encode(message: PostModelsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelQuery !== undefined) {
      ModelQuery.encode(message.modelQuery, writer.uint32(18).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelQuery = ModelQuery.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelQuery: isSet(object.modelQuery) ? ModelQuery.fromJSON(object.modelQuery) : undefined,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostModelsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelQuery !== undefined) {
      obj.modelQuery = ModelQuery.toJSON(message.modelQuery);
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelsSearchesRequest>, I>>(base?: I): PostModelsSearchesRequest {
    return PostModelsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelsSearchesRequest>, I>>(object: I): PostModelsSearchesRequest {
    const message = createBasePostModelsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelQuery = (object.modelQuery !== undefined && object.modelQuery !== null)
      ? ModelQuery.fromPartial(object.modelQuery)
      : undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSingleModelResponse(): SingleModelResponse {
  return { status: undefined, model: undefined, workflowCount: 0 };
}

export const SingleModelResponse: MessageFns<SingleModelResponse> = {
  encode(message: SingleModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).join();
    }
    if (message.workflowCount !== 0) {
      writer.uint32(32).int32(message.workflowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.workflowCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModelResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      workflowCount: isSet(object.workflowCount) ? globalThis.Number(object.workflowCount) : 0,
    };
  },

  toJSON(message: SingleModelResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.workflowCount !== 0) {
      obj.workflowCount = Math.round(message.workflowCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModelResponse>, I>>(base?: I): SingleModelResponse {
    return SingleModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModelResponse>, I>>(object: I): SingleModelResponse {
    const message = createBaseSingleModelResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.workflowCount = object.workflowCount ?? 0;
    return message;
  },
};

function createBaseMultiModelResponse(): MultiModelResponse {
  return { status: undefined, models: [] };
}

export const MultiModelResponse: MessageFns<MultiModelResponse> = {
  encode(message: MultiModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiModelResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelResponse>, I>>(base?: I): MultiModelResponse {
    return MultiModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelResponse>, I>>(object: I): MultiModelResponse {
    const message = createBaseMultiModelResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchModelVersionsRequest(): PatchModelVersionsRequest {
  return { userAppId: undefined, modelId: "", modelVersions: [], action: "" };
}

export const PatchModelVersionsRequest: MessageFns<PatchModelVersionsRequest> = {
  encode(message: PatchModelVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModelVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModelVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersions.push(ModelVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModelVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersions: globalThis.Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModelVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersions?.length) {
      obj.modelVersions = message.modelVersions.map((e) => ModelVersion.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModelVersionsRequest>, I>>(base?: I): PatchModelVersionsRequest {
    return PatchModelVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModelVersionsRequest>, I>>(object: I): PatchModelVersionsRequest {
    const message = createBasePatchModelVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersions = object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseGetModelVersionRequest(): GetModelVersionRequest {
  return { userAppId: undefined, modelId: "", versionId: "" };
}

export const GetModelVersionRequest: MessageFns<GetModelVersionRequest> = {
  encode(message: GetModelVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
    };
  },

  toJSON(message: GetModelVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelVersionRequest>, I>>(base?: I): GetModelVersionRequest {
    return GetModelVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelVersionRequest>, I>>(object: I): GetModelVersionRequest {
    const message = createBaseGetModelVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseListModelVersionsRequest(): ListModelVersionsRequest {
  return {
    userAppId: undefined,
    modelId: "",
    page: 0,
    perPage: 0,
    conceptIds: [],
    trainedOnly: false,
    sortAscending: false,
    sortByStatusCode: undefined,
    sortByNumInputs: undefined,
    sortByDescription: undefined,
    sortByCreatedAt: undefined,
    minReplicas: 0,
  };
}

export const ListModelVersionsRequest: MessageFns<ListModelVersionsRequest> = {
  encode(message: ListModelVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    for (const v of message.conceptIds) {
      writer.uint32(42).string(v!);
    }
    if (message.trainedOnly !== false) {
      writer.uint32(48).bool(message.trainedOnly);
    }
    if (message.sortAscending !== false) {
      writer.uint32(56).bool(message.sortAscending);
    }
    if (message.sortByStatusCode !== undefined) {
      writer.uint32(64).bool(message.sortByStatusCode);
    }
    if (message.sortByNumInputs !== undefined) {
      writer.uint32(72).bool(message.sortByNumInputs);
    }
    if (message.sortByDescription !== undefined) {
      writer.uint32(80).bool(message.sortByDescription);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(88).bool(message.sortByCreatedAt);
    }
    if (message.minReplicas !== 0) {
      writer.uint32(96).uint32(message.minReplicas);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.conceptIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.trainedOnly = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sortByStatusCode = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sortByNumInputs = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sortByDescription = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.minReplicas = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      conceptIds: globalThis.Array.isArray(object?.conceptIds)
        ? object.conceptIds.map((e: any) => globalThis.String(e))
        : [],
      trainedOnly: isSet(object.trainedOnly) ? globalThis.Boolean(object.trainedOnly) : false,
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByStatusCode: isSet(object.sortByStatusCode) ? globalThis.Boolean(object.sortByStatusCode) : undefined,
      sortByNumInputs: isSet(object.sortByNumInputs) ? globalThis.Boolean(object.sortByNumInputs) : undefined,
      sortByDescription: isSet(object.sortByDescription) ? globalThis.Boolean(object.sortByDescription) : undefined,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      minReplicas: isSet(object.minReplicas) ? globalThis.Number(object.minReplicas) : 0,
    };
  },

  toJSON(message: ListModelVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.conceptIds?.length) {
      obj.conceptIds = message.conceptIds;
    }
    if (message.trainedOnly !== false) {
      obj.trainedOnly = message.trainedOnly;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByStatusCode !== undefined) {
      obj.sortByStatusCode = message.sortByStatusCode;
    }
    if (message.sortByNumInputs !== undefined) {
      obj.sortByNumInputs = message.sortByNumInputs;
    }
    if (message.sortByDescription !== undefined) {
      obj.sortByDescription = message.sortByDescription;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.minReplicas !== 0) {
      obj.minReplicas = Math.round(message.minReplicas);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelVersionsRequest>, I>>(base?: I): ListModelVersionsRequest {
    return ListModelVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelVersionsRequest>, I>>(object: I): ListModelVersionsRequest {
    const message = createBaseListModelVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.conceptIds = object.conceptIds?.map((e) => e) || [];
    message.trainedOnly = object.trainedOnly ?? false;
    message.sortAscending = object.sortAscending ?? false;
    message.sortByStatusCode = object.sortByStatusCode ?? undefined;
    message.sortByNumInputs = object.sortByNumInputs ?? undefined;
    message.sortByDescription = object.sortByDescription ?? undefined;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.minReplicas = object.minReplicas ?? 0;
    return message;
  },
};

function createBaseDeleteModelVersionRequest(): DeleteModelVersionRequest {
  return { userAppId: undefined, modelId: "", versionId: "" };
}

export const DeleteModelVersionRequest: MessageFns<DeleteModelVersionRequest> = {
  encode(message: DeleteModelVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(26).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(34).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModelVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModelVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
    };
  },

  toJSON(message: DeleteModelVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteModelVersionRequest>, I>>(base?: I): DeleteModelVersionRequest {
    return DeleteModelVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteModelVersionRequest>, I>>(object: I): DeleteModelVersionRequest {
    const message = createBaseDeleteModelVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseSingleModelVersionResponse(): SingleModelVersionResponse {
  return { status: undefined, modelVersion: undefined };
}

export const SingleModelVersionResponse: MessageFns<SingleModelVersionResponse> = {
  encode(message: SingleModelVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(message.modelVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModelVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModelVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModelVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelVersion: isSet(object.modelVersion) ? ModelVersion.fromJSON(object.modelVersion) : undefined,
    };
  },

  toJSON(message: SingleModelVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelVersion !== undefined) {
      obj.modelVersion = ModelVersion.toJSON(message.modelVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModelVersionResponse>, I>>(base?: I): SingleModelVersionResponse {
    return SingleModelVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModelVersionResponse>, I>>(object: I): SingleModelVersionResponse {
    const message = createBaseSingleModelVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelVersion = (object.modelVersion !== undefined && object.modelVersion !== null)
      ? ModelVersion.fromPartial(object.modelVersion)
      : undefined;
    return message;
  },
};

function createBaseMultiModelVersionResponse(): MultiModelVersionResponse {
  return { status: undefined, modelVersions: [] };
}

export const MultiModelVersionResponse: MessageFns<MultiModelVersionResponse> = {
  encode(message: MultiModelVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelVersions.push(ModelVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelVersions: globalThis.Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiModelVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelVersions?.length) {
      obj.modelVersions = message.modelVersions.map((e) => ModelVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelVersionResponse>, I>>(base?: I): MultiModelVersionResponse {
    return MultiModelVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelVersionResponse>, I>>(object: I): MultiModelVersionResponse {
    const message = createBaseMultiModelVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelVersions = object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostModelVersionsRequest(): PostModelVersionsRequest {
  return {
    userAppId: undefined,
    modelId: "",
    modelVersions: [],
    description: "",
    evalInfo: undefined,
    doMigration: false,
  };
}

export const PostModelVersionsRequest: MessageFns<PostModelVersionsRequest> = {
  encode(message: PostModelVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.evalInfo !== undefined) {
      EvalInfo.encode(message.evalInfo, writer.uint32(82).fork()).join();
    }
    if (message.doMigration !== false) {
      writer.uint32(88).bool(message.doMigration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersions.push(ModelVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.evalInfo = EvalInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.doMigration = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersions: globalThis.Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      evalInfo: isSet(object.evalInfo) ? EvalInfo.fromJSON(object.evalInfo) : undefined,
      doMigration: isSet(object.doMigration) ? globalThis.Boolean(object.doMigration) : false,
    };
  },

  toJSON(message: PostModelVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersions?.length) {
      obj.modelVersions = message.modelVersions.map((e) => ModelVersion.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.evalInfo !== undefined) {
      obj.evalInfo = EvalInfo.toJSON(message.evalInfo);
    }
    if (message.doMigration !== false) {
      obj.doMigration = message.doMigration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsRequest>, I>>(base?: I): PostModelVersionsRequest {
    return PostModelVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsRequest>, I>>(object: I): PostModelVersionsRequest {
    const message = createBasePostModelVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersions = object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.evalInfo = (object.evalInfo !== undefined && object.evalInfo !== null)
      ? EvalInfo.fromPartial(object.evalInfo)
      : undefined;
    message.doMigration = object.doMigration ?? false;
    return message;
  },
};

function createBasePostModelVersionsUploadRequest(): PostModelVersionsUploadRequest {
  return { uploadConfig: undefined, contentPart: undefined };
}

export const PostModelVersionsUploadRequest: MessageFns<PostModelVersionsUploadRequest> = {
  encode(message: PostModelVersionsUploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadConfig !== undefined) {
      PostModelVersionsUploadConfig.encode(message.uploadConfig, writer.uint32(10).fork()).join();
    }
    if (message.contentPart !== undefined) {
      UploadContentPart.encode(message.contentPart, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsUploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uploadConfig = PostModelVersionsUploadConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentPart = UploadContentPart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsUploadRequest {
    return {
      uploadConfig: isSet(object.uploadConfig)
        ? PostModelVersionsUploadConfig.fromJSON(object.uploadConfig)
        : undefined,
      contentPart: isSet(object.contentPart) ? UploadContentPart.fromJSON(object.contentPart) : undefined,
    };
  },

  toJSON(message: PostModelVersionsUploadRequest): unknown {
    const obj: any = {};
    if (message.uploadConfig !== undefined) {
      obj.uploadConfig = PostModelVersionsUploadConfig.toJSON(message.uploadConfig);
    }
    if (message.contentPart !== undefined) {
      obj.contentPart = UploadContentPart.toJSON(message.contentPart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsUploadRequest>, I>>(base?: I): PostModelVersionsUploadRequest {
    return PostModelVersionsUploadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsUploadRequest>, I>>(
    object: I,
  ): PostModelVersionsUploadRequest {
    const message = createBasePostModelVersionsUploadRequest();
    message.uploadConfig = (object.uploadConfig !== undefined && object.uploadConfig !== null)
      ? PostModelVersionsUploadConfig.fromPartial(object.uploadConfig)
      : undefined;
    message.contentPart = (object.contentPart !== undefined && object.contentPart !== null)
      ? UploadContentPart.fromPartial(object.contentPart)
      : undefined;
    return message;
  },
};

function createBasePostModelVersionsUploadResponse(): PostModelVersionsUploadResponse {
  return { status: undefined, bytesRemaining: 0, modelVersionId: "" };
}

export const PostModelVersionsUploadResponse: MessageFns<PostModelVersionsUploadResponse> = {
  encode(message: PostModelVersionsUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.bytesRemaining !== 0) {
      writer.uint32(16).uint64(message.bytesRemaining);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesRemaining = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsUploadResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      bytesRemaining: isSet(object.bytesRemaining) ? globalThis.Number(object.bytesRemaining) : 0,
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
    };
  },

  toJSON(message: PostModelVersionsUploadResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.bytesRemaining !== 0) {
      obj.bytesRemaining = Math.round(message.bytesRemaining);
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsUploadResponse>, I>>(base?: I): PostModelVersionsUploadResponse {
    return PostModelVersionsUploadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsUploadResponse>, I>>(
    object: I,
  ): PostModelVersionsUploadResponse {
    const message = createBasePostModelVersionsUploadResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.bytesRemaining = object.bytesRemaining ?? 0;
    message.modelVersionId = object.modelVersionId ?? "";
    return message;
  },
};

function createBasePostModelVersionsUploadConfig(): PostModelVersionsUploadConfig {
  return {
    userAppId: undefined,
    modelId: "",
    modelVersion: undefined,
    totalSize: 0,
    isV3: false,
    storageRequestSize: 0,
  };
}

export const PostModelVersionsUploadConfig: MessageFns<PostModelVersionsUploadConfig> = {
  encode(message: PostModelVersionsUploadConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(message.modelVersion, writer.uint32(26).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).uint64(message.totalSize);
    }
    if (message.isV3 !== false) {
      writer.uint32(40).bool(message.isV3);
    }
    if (message.storageRequestSize !== 0) {
      writer.uint32(48).uint64(message.storageRequestSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsUploadConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsUploadConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalSize = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isV3 = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.storageRequestSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsUploadConfig {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersion: isSet(object.modelVersion) ? ModelVersion.fromJSON(object.modelVersion) : undefined,
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      isV3: isSet(object.isV3) ? globalThis.Boolean(object.isV3) : false,
      storageRequestSize: isSet(object.storageRequestSize) ? globalThis.Number(object.storageRequestSize) : 0,
    };
  },

  toJSON(message: PostModelVersionsUploadConfig): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersion !== undefined) {
      obj.modelVersion = ModelVersion.toJSON(message.modelVersion);
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.isV3 !== false) {
      obj.isV3 = message.isV3;
    }
    if (message.storageRequestSize !== 0) {
      obj.storageRequestSize = Math.round(message.storageRequestSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsUploadConfig>, I>>(base?: I): PostModelVersionsUploadConfig {
    return PostModelVersionsUploadConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsUploadConfig>, I>>(
    object: I,
  ): PostModelVersionsUploadConfig {
    const message = createBasePostModelVersionsUploadConfig();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersion = (object.modelVersion !== undefined && object.modelVersion !== null)
      ? ModelVersion.fromPartial(object.modelVersion)
      : undefined;
    message.totalSize = object.totalSize ?? 0;
    message.isV3 = object.isV3 ?? false;
    message.storageRequestSize = object.storageRequestSize ?? 0;
    return message;
  },
};

function createBasePutModelVersionExportsRequest(): PutModelVersionExportsRequest {
  return { userAppId: undefined, modelId: "", versionId: "" };
}

export const PutModelVersionExportsRequest: MessageFns<PutModelVersionExportsRequest> = {
  encode(message: PutModelVersionExportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutModelVersionExportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutModelVersionExportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutModelVersionExportsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
    };
  },

  toJSON(message: PutModelVersionExportsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutModelVersionExportsRequest>, I>>(base?: I): PutModelVersionExportsRequest {
    return PutModelVersionExportsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutModelVersionExportsRequest>, I>>(
    object: I,
  ): PutModelVersionExportsRequest {
    const message = createBasePutModelVersionExportsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseGetModelVersionExportRequest(): GetModelVersionExportRequest {
  return { userAppId: undefined, modelId: "", versionId: "" };
}

export const GetModelVersionExportRequest: MessageFns<GetModelVersionExportRequest> = {
  encode(message: GetModelVersionExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelVersionExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionExportRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
    };
  },

  toJSON(message: GetModelVersionExportRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelVersionExportRequest>, I>>(base?: I): GetModelVersionExportRequest {
    return GetModelVersionExportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelVersionExportRequest>, I>>(object: I): GetModelVersionExportRequest {
    const message = createBaseGetModelVersionExportRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseSingleModelVersionExportResponse(): SingleModelVersionExportResponse {
  return { status: undefined, export: undefined };
}

export const SingleModelVersionExportResponse: MessageFns<SingleModelVersionExportResponse> = {
  encode(message: SingleModelVersionExportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.export !== undefined) {
      ModelVersionExport.encode(message.export, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModelVersionExportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModelVersionExportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.export = ModelVersionExport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModelVersionExportResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      export: isSet(object.export) ? ModelVersionExport.fromJSON(object.export) : undefined,
    };
  },

  toJSON(message: SingleModelVersionExportResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.export !== undefined) {
      obj.export = ModelVersionExport.toJSON(message.export);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModelVersionExportResponse>, I>>(
    base?: I,
  ): SingleModelVersionExportResponse {
    return SingleModelVersionExportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModelVersionExportResponse>, I>>(
    object: I,
  ): SingleModelVersionExportResponse {
    const message = createBaseSingleModelVersionExportResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.export = (object.export !== undefined && object.export !== null)
      ? ModelVersionExport.fromPartial(object.export)
      : undefined;
    return message;
  },
};

function createBasePostWorkflowVersionsUnPublishRequest(): PostWorkflowVersionsUnPublishRequest {
  return { userAppId: undefined, workflowId: "", publications: [] };
}

export const PostWorkflowVersionsUnPublishRequest: MessageFns<PostWorkflowVersionsUnPublishRequest> = {
  encode(message: PostWorkflowVersionsUnPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    for (const v of message.publications) {
      WorkflowVersionUnPublishRequest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowVersionsUnPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowVersionsUnPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publications.push(WorkflowVersionUnPublishRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowVersionsUnPublishRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      publications: globalThis.Array.isArray(object?.publications)
        ? object.publications.map((e: any) => WorkflowVersionUnPublishRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostWorkflowVersionsUnPublishRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.publications?.length) {
      obj.publications = message.publications.map((e) => WorkflowVersionUnPublishRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowVersionsUnPublishRequest>, I>>(
    base?: I,
  ): PostWorkflowVersionsUnPublishRequest {
    return PostWorkflowVersionsUnPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowVersionsUnPublishRequest>, I>>(
    object: I,
  ): PostWorkflowVersionsUnPublishRequest {
    const message = createBasePostWorkflowVersionsUnPublishRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.publications = object.publications?.map((e) => WorkflowVersionUnPublishRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostWorkflowVersionsPublishRequest(): PostWorkflowVersionsPublishRequest {
  return { userAppId: undefined, workflowId: "", publications: [] };
}

export const PostWorkflowVersionsPublishRequest: MessageFns<PostWorkflowVersionsPublishRequest> = {
  encode(message: PostWorkflowVersionsPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    for (const v of message.publications) {
      WorkflowVersionPublishRequest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowVersionsPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowVersionsPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publications.push(WorkflowVersionPublishRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowVersionsPublishRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      publications: globalThis.Array.isArray(object?.publications)
        ? object.publications.map((e: any) => WorkflowVersionPublishRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostWorkflowVersionsPublishRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.publications?.length) {
      obj.publications = message.publications.map((e) => WorkflowVersionPublishRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowVersionsPublishRequest>, I>>(
    base?: I,
  ): PostWorkflowVersionsPublishRequest {
    return PostWorkflowVersionsPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowVersionsPublishRequest>, I>>(
    object: I,
  ): PostWorkflowVersionsPublishRequest {
    const message = createBasePostWorkflowVersionsPublishRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.publications = object.publications?.map((e) => WorkflowVersionPublishRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkflowVersionPublishRequest(): WorkflowVersionPublishRequest {
  return { versionId: "" };
}

export const WorkflowVersionPublishRequest: MessageFns<WorkflowVersionPublishRequest> = {
  encode(message: WorkflowVersionPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionPublishRequest {
    return { versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "" };
  },

  toJSON(message: WorkflowVersionPublishRequest): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionPublishRequest>, I>>(base?: I): WorkflowVersionPublishRequest {
    return WorkflowVersionPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionPublishRequest>, I>>(
    object: I,
  ): WorkflowVersionPublishRequest {
    const message = createBaseWorkflowVersionPublishRequest();
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseWorkflowVersionUnPublishRequest(): WorkflowVersionUnPublishRequest {
  return { versionId: "" };
}

export const WorkflowVersionUnPublishRequest: MessageFns<WorkflowVersionUnPublishRequest> = {
  encode(message: WorkflowVersionUnPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionUnPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionUnPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionUnPublishRequest {
    return { versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "" };
  },

  toJSON(message: WorkflowVersionUnPublishRequest): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionUnPublishRequest>, I>>(base?: I): WorkflowVersionUnPublishRequest {
    return WorkflowVersionUnPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionUnPublishRequest>, I>>(
    object: I,
  ): WorkflowVersionUnPublishRequest {
    const message = createBaseWorkflowVersionUnPublishRequest();
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBaseModelVersionPublishRequest(): ModelVersionPublishRequest {
  return { versionId: "" };
}

export const ModelVersionPublishRequest: MessageFns<ModelVersionPublishRequest> = {
  encode(message: ModelVersionPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionPublishRequest {
    return { versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "" };
  },

  toJSON(message: ModelVersionPublishRequest): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelVersionPublishRequest>, I>>(base?: I): ModelVersionPublishRequest {
    return ModelVersionPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelVersionPublishRequest>, I>>(object: I): ModelVersionPublishRequest {
    const message = createBaseModelVersionPublishRequest();
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBasePostModelVersionsPublishRequest(): PostModelVersionsPublishRequest {
  return { userAppId: undefined, modelId: "", publications: [] };
}

export const PostModelVersionsPublishRequest: MessageFns<PostModelVersionsPublishRequest> = {
  encode(message: PostModelVersionsPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.publications) {
      ModelVersionPublishRequest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publications.push(ModelVersionPublishRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsPublishRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      publications: globalThis.Array.isArray(object?.publications)
        ? object.publications.map((e: any) => ModelVersionPublishRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostModelVersionsPublishRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.publications?.length) {
      obj.publications = message.publications.map((e) => ModelVersionPublishRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsPublishRequest>, I>>(base?: I): PostModelVersionsPublishRequest {
    return PostModelVersionsPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsPublishRequest>, I>>(
    object: I,
  ): PostModelVersionsPublishRequest {
    const message = createBasePostModelVersionsPublishRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.publications = object.publications?.map((e) => ModelVersionPublishRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelVersionUnpublishRequest(): ModelVersionUnpublishRequest {
  return { versionId: "" };
}

export const ModelVersionUnpublishRequest: MessageFns<ModelVersionUnpublishRequest> = {
  encode(message: ModelVersionUnpublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionId !== "") {
      writer.uint32(10).string(message.versionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionUnpublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionUnpublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionUnpublishRequest {
    return { versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "" };
  },

  toJSON(message: ModelVersionUnpublishRequest): unknown {
    const obj: any = {};
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelVersionUnpublishRequest>, I>>(base?: I): ModelVersionUnpublishRequest {
    return ModelVersionUnpublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelVersionUnpublishRequest>, I>>(object: I): ModelVersionUnpublishRequest {
    const message = createBaseModelVersionUnpublishRequest();
    message.versionId = object.versionId ?? "";
    return message;
  },
};

function createBasePostModelVersionsUnPublishRequest(): PostModelVersionsUnPublishRequest {
  return { userAppId: undefined, modelId: "", publications: [] };
}

export const PostModelVersionsUnPublishRequest: MessageFns<PostModelVersionsUnPublishRequest> = {
  encode(message: PostModelVersionsUnPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.publications) {
      ModelVersionUnpublishRequest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsUnPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsUnPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publications.push(ModelVersionUnpublishRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsUnPublishRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      publications: globalThis.Array.isArray(object?.publications)
        ? object.publications.map((e: any) => ModelVersionUnpublishRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostModelVersionsUnPublishRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.publications?.length) {
      obj.publications = message.publications.map((e) => ModelVersionUnpublishRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsUnPublishRequest>, I>>(
    base?: I,
  ): PostModelVersionsUnPublishRequest {
    return PostModelVersionsUnPublishRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsUnPublishRequest>, I>>(
    object: I,
  ): PostModelVersionsUnPublishRequest {
    const message = createBasePostModelVersionsUnPublishRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.publications = object.publications?.map((e) => ModelVersionUnpublishRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostEvaluationsRequest(): PostEvaluationsRequest {
  return { userAppId: undefined, evalMetrics: [] };
}

export const PostEvaluationsRequest: MessageFns<PostEvaluationsRequest> = {
  encode(message: PostEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.evalMetrics) {
      EvalMetrics.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evalMetrics.push(EvalMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      evalMetrics: globalThis.Array.isArray(object?.evalMetrics)
        ? object.evalMetrics.map((e: any) => EvalMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.evalMetrics?.length) {
      obj.evalMetrics = message.evalMetrics.map((e) => EvalMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostEvaluationsRequest>, I>>(base?: I): PostEvaluationsRequest {
    return PostEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostEvaluationsRequest>, I>>(object: I): PostEvaluationsRequest {
    const message = createBasePostEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.evalMetrics = object.evalMetrics?.map((e) => EvalMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListEvaluationsRequest(): ListEvaluationsRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    sortAscending: false,
    sortByAppId: undefined,
    sortByRocAuc: undefined,
    sortByF1: undefined,
    sortByCreatedAt: undefined,
    sortByMeanAvgPrecision: undefined,
    sortByPrecision: undefined,
    sortByRecall: undefined,
    sortByModelId: undefined,
    sortByEvalDatasetId: undefined,
    sortByTrainDatasetId: undefined,
    modelTypeId: "",
    evalDatasetIds: [],
    trainDatasetIds: [],
    conceptIds: [],
    showFailedMetrics: false,
  };
}

export const ListEvaluationsRequest: MessageFns<ListEvaluationsRequest> = {
  encode(message: ListEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    if (message.sortAscending !== false) {
      writer.uint32(32).bool(message.sortAscending);
    }
    if (message.sortByAppId !== undefined) {
      writer.uint32(40).bool(message.sortByAppId);
    }
    if (message.sortByRocAuc !== undefined) {
      writer.uint32(48).bool(message.sortByRocAuc);
    }
    if (message.sortByF1 !== undefined) {
      writer.uint32(56).bool(message.sortByF1);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(64).bool(message.sortByCreatedAt);
    }
    if (message.sortByMeanAvgPrecision !== undefined) {
      writer.uint32(72).bool(message.sortByMeanAvgPrecision);
    }
    if (message.sortByPrecision !== undefined) {
      writer.uint32(80).bool(message.sortByPrecision);
    }
    if (message.sortByRecall !== undefined) {
      writer.uint32(88).bool(message.sortByRecall);
    }
    if (message.sortByModelId !== undefined) {
      writer.uint32(128).bool(message.sortByModelId);
    }
    if (message.sortByEvalDatasetId !== undefined) {
      writer.uint32(136).bool(message.sortByEvalDatasetId);
    }
    if (message.sortByTrainDatasetId !== undefined) {
      writer.uint32(144).bool(message.sortByTrainDatasetId);
    }
    if (message.modelTypeId !== "") {
      writer.uint32(98).string(message.modelTypeId);
    }
    for (const v of message.evalDatasetIds) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.trainDatasetIds) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.conceptIds) {
      writer.uint32(122).string(v!);
    }
    if (message.showFailedMetrics !== false) {
      writer.uint32(152).bool(message.showFailedMetrics);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sortByAppId = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sortByRocAuc = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortByF1 = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sortByMeanAvgPrecision = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sortByPrecision = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sortByRecall = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.sortByModelId = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sortByEvalDatasetId = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.sortByTrainDatasetId = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.modelTypeId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.evalDatasetIds.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.trainDatasetIds.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.conceptIds.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.showFailedMetrics = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByAppId: isSet(object.sortByAppId) ? globalThis.Boolean(object.sortByAppId) : undefined,
      sortByRocAuc: isSet(object.sortByRocAuc) ? globalThis.Boolean(object.sortByRocAuc) : undefined,
      sortByF1: isSet(object.sortByF1) ? globalThis.Boolean(object.sortByF1) : undefined,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByMeanAvgPrecision: isSet(object.sortByMeanAvgPrecision)
        ? globalThis.Boolean(object.sortByMeanAvgPrecision)
        : undefined,
      sortByPrecision: isSet(object.sortByPrecision) ? globalThis.Boolean(object.sortByPrecision) : undefined,
      sortByRecall: isSet(object.sortByRecall) ? globalThis.Boolean(object.sortByRecall) : undefined,
      sortByModelId: isSet(object.sortByModelId) ? globalThis.Boolean(object.sortByModelId) : undefined,
      sortByEvalDatasetId: isSet(object.sortByEvalDatasetId)
        ? globalThis.Boolean(object.sortByEvalDatasetId)
        : undefined,
      sortByTrainDatasetId: isSet(object.sortByTrainDatasetId)
        ? globalThis.Boolean(object.sortByTrainDatasetId)
        : undefined,
      modelTypeId: isSet(object.modelTypeId) ? globalThis.String(object.modelTypeId) : "",
      evalDatasetIds: globalThis.Array.isArray(object?.evalDatasetIds)
        ? object.evalDatasetIds.map((e: any) => globalThis.String(e))
        : [],
      trainDatasetIds: globalThis.Array.isArray(object?.trainDatasetIds)
        ? object.trainDatasetIds.map((e: any) => globalThis.String(e))
        : [],
      conceptIds: globalThis.Array.isArray(object?.conceptIds)
        ? object.conceptIds.map((e: any) => globalThis.String(e))
        : [],
      showFailedMetrics: isSet(object.showFailedMetrics) ? globalThis.Boolean(object.showFailedMetrics) : false,
    };
  },

  toJSON(message: ListEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByAppId !== undefined) {
      obj.sortByAppId = message.sortByAppId;
    }
    if (message.sortByRocAuc !== undefined) {
      obj.sortByRocAuc = message.sortByRocAuc;
    }
    if (message.sortByF1 !== undefined) {
      obj.sortByF1 = message.sortByF1;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByMeanAvgPrecision !== undefined) {
      obj.sortByMeanAvgPrecision = message.sortByMeanAvgPrecision;
    }
    if (message.sortByPrecision !== undefined) {
      obj.sortByPrecision = message.sortByPrecision;
    }
    if (message.sortByRecall !== undefined) {
      obj.sortByRecall = message.sortByRecall;
    }
    if (message.sortByModelId !== undefined) {
      obj.sortByModelId = message.sortByModelId;
    }
    if (message.sortByEvalDatasetId !== undefined) {
      obj.sortByEvalDatasetId = message.sortByEvalDatasetId;
    }
    if (message.sortByTrainDatasetId !== undefined) {
      obj.sortByTrainDatasetId = message.sortByTrainDatasetId;
    }
    if (message.modelTypeId !== "") {
      obj.modelTypeId = message.modelTypeId;
    }
    if (message.evalDatasetIds?.length) {
      obj.evalDatasetIds = message.evalDatasetIds;
    }
    if (message.trainDatasetIds?.length) {
      obj.trainDatasetIds = message.trainDatasetIds;
    }
    if (message.conceptIds?.length) {
      obj.conceptIds = message.conceptIds;
    }
    if (message.showFailedMetrics !== false) {
      obj.showFailedMetrics = message.showFailedMetrics;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEvaluationsRequest>, I>>(base?: I): ListEvaluationsRequest {
    return ListEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEvaluationsRequest>, I>>(object: I): ListEvaluationsRequest {
    const message = createBaseListEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.sortAscending = object.sortAscending ?? false;
    message.sortByAppId = object.sortByAppId ?? undefined;
    message.sortByRocAuc = object.sortByRocAuc ?? undefined;
    message.sortByF1 = object.sortByF1 ?? undefined;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByMeanAvgPrecision = object.sortByMeanAvgPrecision ?? undefined;
    message.sortByPrecision = object.sortByPrecision ?? undefined;
    message.sortByRecall = object.sortByRecall ?? undefined;
    message.sortByModelId = object.sortByModelId ?? undefined;
    message.sortByEvalDatasetId = object.sortByEvalDatasetId ?? undefined;
    message.sortByTrainDatasetId = object.sortByTrainDatasetId ?? undefined;
    message.modelTypeId = object.modelTypeId ?? "";
    message.evalDatasetIds = object.evalDatasetIds?.map((e) => e) || [];
    message.trainDatasetIds = object.trainDatasetIds?.map((e) => e) || [];
    message.conceptIds = object.conceptIds?.map((e) => e) || [];
    message.showFailedMetrics = object.showFailedMetrics ?? false;
    return message;
  },
};

function createBaseGetEvaluationRequest(): GetEvaluationRequest {
  return { userAppId: undefined, evaluationId: "", fields: undefined };
}

export const GetEvaluationRequest: MessageFns<GetEvaluationRequest> = {
  encode(message: GetEvaluationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.evaluationId !== "") {
      writer.uint32(18).string(message.evaluationId);
    }
    if (message.fields !== undefined) {
      FieldsValue.encode(message.fields, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEvaluationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEvaluationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fields = FieldsValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEvaluationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      evaluationId: isSet(object.evaluationId) ? globalThis.String(object.evaluationId) : "",
      fields: isSet(object.fields) ? FieldsValue.fromJSON(object.fields) : undefined,
    };
  },

  toJSON(message: GetEvaluationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.evaluationId !== "") {
      obj.evaluationId = message.evaluationId;
    }
    if (message.fields !== undefined) {
      obj.fields = FieldsValue.toJSON(message.fields);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEvaluationRequest>, I>>(base?: I): GetEvaluationRequest {
    return GetEvaluationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEvaluationRequest>, I>>(object: I): GetEvaluationRequest {
    const message = createBaseGetEvaluationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.evaluationId = object.evaluationId ?? "";
    message.fields = (object.fields !== undefined && object.fields !== null)
      ? FieldsValue.fromPartial(object.fields)
      : undefined;
    return message;
  },
};

function createBasePostModelVersionEvaluationsRequest(): PostModelVersionEvaluationsRequest {
  return { userAppId: undefined, modelId: "", modelVersionId: "", evalMetrics: [] };
}

export const PostModelVersionEvaluationsRequest: MessageFns<PostModelVersionEvaluationsRequest> = {
  encode(message: PostModelVersionEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    for (const v of message.evalMetrics) {
      EvalMetrics.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.evalMetrics.push(EvalMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      evalMetrics: globalThis.Array.isArray(object?.evalMetrics)
        ? object.evalMetrics.map((e: any) => EvalMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostModelVersionEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.evalMetrics?.length) {
      obj.evalMetrics = message.evalMetrics.map((e) => EvalMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionEvaluationsRequest>, I>>(
    base?: I,
  ): PostModelVersionEvaluationsRequest {
    return PostModelVersionEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionEvaluationsRequest>, I>>(
    object: I,
  ): PostModelVersionEvaluationsRequest {
    const message = createBasePostModelVersionEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.evalMetrics = object.evalMetrics?.map((e) => EvalMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListModelVersionEvaluationsRequest(): ListModelVersionEvaluationsRequest {
  return { userAppId: undefined, modelId: "", modelVersionId: "", page: 0, perPage: 0 };
}

export const ListModelVersionEvaluationsRequest: MessageFns<ListModelVersionEvaluationsRequest> = {
  encode(message: ListModelVersionEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelVersionEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelVersionEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelVersionEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModelVersionEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelVersionEvaluationsRequest>, I>>(
    base?: I,
  ): ListModelVersionEvaluationsRequest {
    return ListModelVersionEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelVersionEvaluationsRequest>, I>>(
    object: I,
  ): ListModelVersionEvaluationsRequest {
    const message = createBaseListModelVersionEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetModelVersionEvaluationRequest(): GetModelVersionEvaluationRequest {
  return { userAppId: undefined, modelId: "", modelVersionId: "", evaluationId: "", fields: undefined };
}

export const GetModelVersionEvaluationRequest: MessageFns<GetModelVersionEvaluationRequest> = {
  encode(message: GetModelVersionEvaluationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.evaluationId !== "") {
      writer.uint32(34).string(message.evaluationId);
    }
    if (message.fields !== undefined) {
      FieldsValue.encode(message.fields, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelVersionEvaluationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionEvaluationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.evaluationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fields = FieldsValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionEvaluationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      evaluationId: isSet(object.evaluationId) ? globalThis.String(object.evaluationId) : "",
      fields: isSet(object.fields) ? FieldsValue.fromJSON(object.fields) : undefined,
    };
  },

  toJSON(message: GetModelVersionEvaluationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.evaluationId !== "") {
      obj.evaluationId = message.evaluationId;
    }
    if (message.fields !== undefined) {
      obj.fields = FieldsValue.toJSON(message.fields);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelVersionEvaluationRequest>, I>>(
    base?: I,
  ): GetModelVersionEvaluationRequest {
    return GetModelVersionEvaluationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelVersionEvaluationRequest>, I>>(
    object: I,
  ): GetModelVersionEvaluationRequest {
    const message = createBaseGetModelVersionEvaluationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.evaluationId = object.evaluationId ?? "";
    message.fields = (object.fields !== undefined && object.fields !== null)
      ? FieldsValue.fromPartial(object.fields)
      : undefined;
    return message;
  },
};

function createBaseSingleEvalMetricsResponse(): SingleEvalMetricsResponse {
  return { status: undefined, evalMetrics: undefined };
}

export const SingleEvalMetricsResponse: MessageFns<SingleEvalMetricsResponse> = {
  encode(message: SingleEvalMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.evalMetrics !== undefined) {
      EvalMetrics.encode(message.evalMetrics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleEvalMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleEvalMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evalMetrics = EvalMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleEvalMetricsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      evalMetrics: isSet(object.evalMetrics) ? EvalMetrics.fromJSON(object.evalMetrics) : undefined,
    };
  },

  toJSON(message: SingleEvalMetricsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.evalMetrics !== undefined) {
      obj.evalMetrics = EvalMetrics.toJSON(message.evalMetrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleEvalMetricsResponse>, I>>(base?: I): SingleEvalMetricsResponse {
    return SingleEvalMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleEvalMetricsResponse>, I>>(object: I): SingleEvalMetricsResponse {
    const message = createBaseSingleEvalMetricsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.evalMetrics = (object.evalMetrics !== undefined && object.evalMetrics !== null)
      ? EvalMetrics.fromPartial(object.evalMetrics)
      : undefined;
    return message;
  },
};

function createBaseMultiEvalMetricsResponse(): MultiEvalMetricsResponse {
  return { status: undefined, evalMetrics: [] };
}

export const MultiEvalMetricsResponse: MessageFns<MultiEvalMetricsResponse> = {
  encode(message: MultiEvalMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.evalMetrics) {
      EvalMetrics.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiEvalMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiEvalMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evalMetrics.push(EvalMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiEvalMetricsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      evalMetrics: globalThis.Array.isArray(object?.evalMetrics)
        ? object.evalMetrics.map((e: any) => EvalMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiEvalMetricsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.evalMetrics?.length) {
      obj.evalMetrics = message.evalMetrics.map((e) => EvalMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiEvalMetricsResponse>, I>>(base?: I): MultiEvalMetricsResponse {
    return MultiEvalMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiEvalMetricsResponse>, I>>(object: I): MultiEvalMetricsResponse {
    const message = createBaseMultiEvalMetricsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.evalMetrics = object.evalMetrics?.map((e) => EvalMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostModelVersionMetricsRequest(): PostModelVersionMetricsRequest {
  return { userAppId: undefined, modelId: "", versionId: "", testSearch: undefined, evalInfo: undefined };
}

export const PostModelVersionMetricsRequest: MessageFns<PostModelVersionMetricsRequest> = {
  encode(message: PostModelVersionMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    if (message.testSearch !== undefined) {
      Search.encode(message.testSearch, writer.uint32(42).fork()).join();
    }
    if (message.evalInfo !== undefined) {
      EvalInfo.encode(message.evalInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.testSearch = Search.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.evalInfo = EvalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionMetricsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      testSearch: isSet(object.testSearch) ? Search.fromJSON(object.testSearch) : undefined,
      evalInfo: isSet(object.evalInfo) ? EvalInfo.fromJSON(object.evalInfo) : undefined,
    };
  },

  toJSON(message: PostModelVersionMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.testSearch !== undefined) {
      obj.testSearch = Search.toJSON(message.testSearch);
    }
    if (message.evalInfo !== undefined) {
      obj.evalInfo = EvalInfo.toJSON(message.evalInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionMetricsRequest>, I>>(base?: I): PostModelVersionMetricsRequest {
    return PostModelVersionMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionMetricsRequest>, I>>(
    object: I,
  ): PostModelVersionMetricsRequest {
    const message = createBasePostModelVersionMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.testSearch = (object.testSearch !== undefined && object.testSearch !== null)
      ? Search.fromPartial(object.testSearch)
      : undefined;
    message.evalInfo = (object.evalInfo !== undefined && object.evalInfo !== null)
      ? EvalInfo.fromPartial(object.evalInfo)
      : undefined;
    return message;
  },
};

function createBaseGetModelVersionMetricsRequest(): GetModelVersionMetricsRequest {
  return { userAppId: undefined, modelId: "", versionId: "", fields: undefined };
}

export const GetModelVersionMetricsRequest: MessageFns<GetModelVersionMetricsRequest> = {
  encode(message: GetModelVersionMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.versionId !== "") {
      writer.uint32(26).string(message.versionId);
    }
    if (message.fields !== undefined) {
      FieldsValue.encode(message.fields, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelVersionMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields = FieldsValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionMetricsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      fields: isSet(object.fields) ? FieldsValue.fromJSON(object.fields) : undefined,
    };
  },

  toJSON(message: GetModelVersionMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.fields !== undefined) {
      obj.fields = FieldsValue.toJSON(message.fields);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelVersionMetricsRequest>, I>>(base?: I): GetModelVersionMetricsRequest {
    return GetModelVersionMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelVersionMetricsRequest>, I>>(
    object: I,
  ): GetModelVersionMetricsRequest {
    const message = createBaseGetModelVersionMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.versionId = object.versionId ?? "";
    message.fields = (object.fields !== undefined && object.fields !== null)
      ? FieldsValue.fromPartial(object.fields)
      : undefined;
    return message;
  },
};

function createBaseGetModelTypeRequest(): GetModelTypeRequest {
  return { userAppId: undefined, modelTypeId: "" };
}

export const GetModelTypeRequest: MessageFns<GetModelTypeRequest> = {
  encode(message: GetModelTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelTypeId !== "") {
      writer.uint32(18).string(message.modelTypeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelTypeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelTypeRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelTypeId: isSet(object.modelTypeId) ? globalThis.String(object.modelTypeId) : "",
    };
  },

  toJSON(message: GetModelTypeRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelTypeId !== "") {
      obj.modelTypeId = message.modelTypeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelTypeRequest>, I>>(base?: I): GetModelTypeRequest {
    return GetModelTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelTypeRequest>, I>>(object: I): GetModelTypeRequest {
    const message = createBaseGetModelTypeRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelTypeId = object.modelTypeId ?? "";
    return message;
  },
};

function createBaseListModelTypesRequest(): ListModelTypesRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListModelTypesRequest: MessageFns<ListModelTypesRequest> = {
  encode(message: ListModelTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelTypesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModelTypesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelTypesRequest>, I>>(base?: I): ListModelTypesRequest {
    return ListModelTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelTypesRequest>, I>>(object: I): ListModelTypesRequest {
    const message = createBaseListModelTypesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseListOpenSourceLicensesRequest(): ListOpenSourceLicensesRequest {
  return {};
}

export const ListOpenSourceLicensesRequest: MessageFns<ListOpenSourceLicensesRequest> = {
  encode(_: ListOpenSourceLicensesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOpenSourceLicensesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOpenSourceLicensesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListOpenSourceLicensesRequest {
    return {};
  },

  toJSON(_: ListOpenSourceLicensesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOpenSourceLicensesRequest>, I>>(base?: I): ListOpenSourceLicensesRequest {
    return ListOpenSourceLicensesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOpenSourceLicensesRequest>, I>>(_: I): ListOpenSourceLicensesRequest {
    const message = createBaseListOpenSourceLicensesRequest();
    return message;
  },
};

function createBaseListOpenSourceLicensesResponse(): ListOpenSourceLicensesResponse {
  return { status: undefined, licenses: [] };
}

export const ListOpenSourceLicensesResponse: MessageFns<ListOpenSourceLicensesResponse> = {
  encode(message: ListOpenSourceLicensesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.licenses) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOpenSourceLicensesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOpenSourceLicensesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.licenses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOpenSourceLicensesResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListOpenSourceLicensesResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOpenSourceLicensesResponse>, I>>(base?: I): ListOpenSourceLicensesResponse {
    return ListOpenSourceLicensesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOpenSourceLicensesResponse>, I>>(
    object: I,
  ): ListOpenSourceLicensesResponse {
    const message = createBaseListOpenSourceLicensesResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.licenses = object.licenses?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleModelTypeResponse(): SingleModelTypeResponse {
  return { status: undefined, modelType: undefined };
}

export const SingleModelTypeResponse: MessageFns<SingleModelTypeResponse> = {
  encode(message: SingleModelTypeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.modelType !== undefined) {
      ModelType.encode(message.modelType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModelTypeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModelTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelType = ModelType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModelTypeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelType: isSet(object.modelType) ? ModelType.fromJSON(object.modelType) : undefined,
    };
  },

  toJSON(message: SingleModelTypeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelType !== undefined) {
      obj.modelType = ModelType.toJSON(message.modelType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModelTypeResponse>, I>>(base?: I): SingleModelTypeResponse {
    return SingleModelTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModelTypeResponse>, I>>(object: I): SingleModelTypeResponse {
    const message = createBaseSingleModelTypeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelType = (object.modelType !== undefined && object.modelType !== null)
      ? ModelType.fromPartial(object.modelType)
      : undefined;
    return message;
  },
};

function createBaseMultiModelTypeResponse(): MultiModelTypeResponse {
  return { status: undefined, modelTypes: [], modelImporters: undefined, tritonCondaEnvsInfo: [] };
}

export const MultiModelTypeResponse: MessageFns<MultiModelTypeResponse> = {
  encode(message: MultiModelTypeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.modelTypes) {
      ModelType.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.modelImporters !== undefined) {
      ModelTypeField.encode(message.modelImporters, writer.uint32(26).fork()).join();
    }
    for (const v of message.tritonCondaEnvsInfo) {
      TritonCondaEnvInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelTypeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelTypes.push(ModelType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelImporters = ModelTypeField.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tritonCondaEnvsInfo.push(TritonCondaEnvInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelTypeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelTypes: globalThis.Array.isArray(object?.modelTypes)
        ? object.modelTypes.map((e: any) => ModelType.fromJSON(e))
        : [],
      modelImporters: isSet(object.modelImporters) ? ModelTypeField.fromJSON(object.modelImporters) : undefined,
      tritonCondaEnvsInfo: globalThis.Array.isArray(object?.tritonCondaEnvsInfo)
        ? object.tritonCondaEnvsInfo.map((e: any) => TritonCondaEnvInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiModelTypeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelTypes?.length) {
      obj.modelTypes = message.modelTypes.map((e) => ModelType.toJSON(e));
    }
    if (message.modelImporters !== undefined) {
      obj.modelImporters = ModelTypeField.toJSON(message.modelImporters);
    }
    if (message.tritonCondaEnvsInfo?.length) {
      obj.tritonCondaEnvsInfo = message.tritonCondaEnvsInfo.map((e) => TritonCondaEnvInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelTypeResponse>, I>>(base?: I): MultiModelTypeResponse {
    return MultiModelTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelTypeResponse>, I>>(object: I): MultiModelTypeResponse {
    const message = createBaseMultiModelTypeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelTypes = object.modelTypes?.map((e) => ModelType.fromPartial(e)) || [];
    message.modelImporters = (object.modelImporters !== undefined && object.modelImporters !== null)
      ? ModelTypeField.fromPartial(object.modelImporters)
      : undefined;
    message.tritonCondaEnvsInfo = object.tritonCondaEnvsInfo?.map((e) => TritonCondaEnvInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetModelVersionInputExampleRequest(): GetModelVersionInputExampleRequest {
  return { userAppId: undefined, modelId: "", modelVersionId: "", exampleId: "" };
}

export const GetModelVersionInputExampleRequest: MessageFns<GetModelVersionInputExampleRequest> = {
  encode(message: GetModelVersionInputExampleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.exampleId !== "") {
      writer.uint32(34).string(message.exampleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelVersionInputExampleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelVersionInputExampleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exampleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelVersionInputExampleRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      exampleId: isSet(object.exampleId) ? globalThis.String(object.exampleId) : "",
    };
  },

  toJSON(message: GetModelVersionInputExampleRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.exampleId !== "") {
      obj.exampleId = message.exampleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelVersionInputExampleRequest>, I>>(
    base?: I,
  ): GetModelVersionInputExampleRequest {
    return GetModelVersionInputExampleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelVersionInputExampleRequest>, I>>(
    object: I,
  ): GetModelVersionInputExampleRequest {
    const message = createBaseGetModelVersionInputExampleRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.exampleId = object.exampleId ?? "";
    return message;
  },
};

function createBaseListModelVersionInputExamplesRequest(): ListModelVersionInputExamplesRequest {
  return { userAppId: undefined, modelId: "", modelVersionId: "", page: 0, perPage: 0 };
}

export const ListModelVersionInputExamplesRequest: MessageFns<ListModelVersionInputExamplesRequest> = {
  encode(message: ListModelVersionInputExamplesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelVersionInputExamplesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelVersionInputExamplesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelVersionInputExamplesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModelVersionInputExamplesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelVersionInputExamplesRequest>, I>>(
    base?: I,
  ): ListModelVersionInputExamplesRequest {
    return ListModelVersionInputExamplesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelVersionInputExamplesRequest>, I>>(
    object: I,
  ): ListModelVersionInputExamplesRequest {
    const message = createBaseListModelVersionInputExamplesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseSingleModelVersionInputExampleResponse(): SingleModelVersionInputExampleResponse {
  return { status: undefined, modelVersionInputExample: undefined };
}

export const SingleModelVersionInputExampleResponse: MessageFns<SingleModelVersionInputExampleResponse> = {
  encode(message: SingleModelVersionInputExampleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.modelVersionInputExample !== undefined) {
      ModelVersionInputExample.encode(message.modelVersionInputExample, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModelVersionInputExampleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModelVersionInputExampleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelVersionInputExample = ModelVersionInputExample.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModelVersionInputExampleResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelVersionInputExample: isSet(object.modelVersionInputExample)
        ? ModelVersionInputExample.fromJSON(object.modelVersionInputExample)
        : undefined,
    };
  },

  toJSON(message: SingleModelVersionInputExampleResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelVersionInputExample !== undefined) {
      obj.modelVersionInputExample = ModelVersionInputExample.toJSON(message.modelVersionInputExample);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModelVersionInputExampleResponse>, I>>(
    base?: I,
  ): SingleModelVersionInputExampleResponse {
    return SingleModelVersionInputExampleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModelVersionInputExampleResponse>, I>>(
    object: I,
  ): SingleModelVersionInputExampleResponse {
    const message = createBaseSingleModelVersionInputExampleResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelVersionInputExample =
      (object.modelVersionInputExample !== undefined && object.modelVersionInputExample !== null)
        ? ModelVersionInputExample.fromPartial(object.modelVersionInputExample)
        : undefined;
    return message;
  },
};

function createBaseMultiModelVersionInputExampleResponse(): MultiModelVersionInputExampleResponse {
  return { status: undefined, modelVersionInputExamples: [] };
}

export const MultiModelVersionInputExampleResponse: MessageFns<MultiModelVersionInputExampleResponse> = {
  encode(message: MultiModelVersionInputExampleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.modelVersionInputExamples) {
      ModelVersionInputExample.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelVersionInputExampleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelVersionInputExampleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelVersionInputExamples.push(ModelVersionInputExample.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelVersionInputExampleResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelVersionInputExamples: globalThis.Array.isArray(object?.modelVersionInputExamples)
        ? object.modelVersionInputExamples.map((e: any) => ModelVersionInputExample.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiModelVersionInputExampleResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelVersionInputExamples?.length) {
      obj.modelVersionInputExamples = message.modelVersionInputExamples.map((e) => ModelVersionInputExample.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelVersionInputExampleResponse>, I>>(
    base?: I,
  ): MultiModelVersionInputExampleResponse {
    return MultiModelVersionInputExampleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelVersionInputExampleResponse>, I>>(
    object: I,
  ): MultiModelVersionInputExampleResponse {
    const message = createBaseMultiModelVersionInputExampleResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelVersionInputExamples =
      object.modelVersionInputExamples?.map((e) => ModelVersionInputExample.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListModelReferencesRequest(): ListModelReferencesRequest {
  return { userAppId: undefined, modelId: "", page: 0, perPage: 0 };
}

export const ListModelReferencesRequest: MessageFns<ListModelReferencesRequest> = {
  encode(message: ListModelReferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelReferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelReferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelReferencesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModelReferencesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelReferencesRequest>, I>>(base?: I): ListModelReferencesRequest {
    return ListModelReferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelReferencesRequest>, I>>(object: I): ListModelReferencesRequest {
    const message = createBaseListModelReferencesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseMultiModelReferenceResponse(): MultiModelReferenceResponse {
  return { status: undefined, modelReferences: [] };
}

export const MultiModelReferenceResponse: MessageFns<MultiModelReferenceResponse> = {
  encode(message: MultiModelReferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.modelReferences) {
      ModelReference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModelReferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModelReferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelReferences.push(ModelReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModelReferenceResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modelReferences: globalThis.Array.isArray(object?.modelReferences)
        ? object.modelReferences.map((e: any) => ModelReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiModelReferenceResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modelReferences?.length) {
      obj.modelReferences = message.modelReferences.map((e) => ModelReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModelReferenceResponse>, I>>(base?: I): MultiModelReferenceResponse {
    return MultiModelReferenceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModelReferenceResponse>, I>>(object: I): MultiModelReferenceResponse {
    const message = createBaseMultiModelReferenceResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modelReferences = object.modelReferences?.map((e) => ModelReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiOutputResponse(): MultiOutputResponse {
  return { status: undefined, outputs: [], runnerSelector: undefined };
}

export const MultiOutputResponse: MessageFns<MultiOutputResponse> = {
  encode(message: MultiOutputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.outputs) {
      Output.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.runnerSelector !== undefined) {
      RunnerSelector.encode(message.runnerSelector, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiOutputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiOutputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputs.push(Output.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runnerSelector = RunnerSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiOutputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => Output.fromJSON(e)) : [],
      runnerSelector: isSet(object.runnerSelector) ? RunnerSelector.fromJSON(object.runnerSelector) : undefined,
    };
  },

  toJSON(message: MultiOutputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => Output.toJSON(e));
    }
    if (message.runnerSelector !== undefined) {
      obj.runnerSelector = RunnerSelector.toJSON(message.runnerSelector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiOutputResponse>, I>>(base?: I): MultiOutputResponse {
    return MultiOutputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiOutputResponse>, I>>(object: I): MultiOutputResponse {
    const message = createBaseMultiOutputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];
    message.runnerSelector = (object.runnerSelector !== undefined && object.runnerSelector !== null)
      ? RunnerSelector.fromPartial(object.runnerSelector)
      : undefined;
    return message;
  },
};

function createBaseMultiLogEntryResponse(): MultiLogEntryResponse {
  return { status: undefined, logEntries: [], page: 0, perPage: 0 };
}

export const MultiLogEntryResponse: MessageFns<MultiLogEntryResponse> = {
  encode(message: MultiLogEntryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.logEntries) {
      LogEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLogEntryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLogEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logEntries.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiLogEntryResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      logEntries: globalThis.Array.isArray(object?.logEntries)
        ? object.logEntries.map((e: any) => LogEntry.fromJSON(e))
        : [],
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: MultiLogEntryResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.logEntries?.length) {
      obj.logEntries = message.logEntries.map((e) => LogEntry.toJSON(e));
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiLogEntryResponse>, I>>(base?: I): MultiLogEntryResponse {
    return MultiLogEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLogEntryResponse>, I>>(object: I): MultiLogEntryResponse {
    const message = createBaseMultiLogEntryResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.logEntries = object.logEntries?.map((e) => LogEntry.fromPartial(e)) || [];
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseListScopesRequest(): ListScopesRequest {
  return { keyType: "", userAppId: undefined };
}

export const ListScopesRequest: MessageFns<ListScopesRequest> = {
  encode(message: ListScopesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyType !== "") {
      writer.uint32(10).string(message.keyType);
    }
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListScopesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListScopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListScopesRequest {
    return {
      keyType: isSet(object.keyType) ? globalThis.String(object.keyType) : "",
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
    };
  },

  toJSON(message: ListScopesRequest): unknown {
    const obj: any = {};
    if (message.keyType !== "") {
      obj.keyType = message.keyType;
    }
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListScopesRequest>, I>>(base?: I): ListScopesRequest {
    return ListScopesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListScopesRequest>, I>>(object: I): ListScopesRequest {
    const message = createBaseListScopesRequest();
    message.keyType = object.keyType ?? "";
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseMyScopesRequest(): MyScopesRequest {
  return { userAppId: undefined };
}

export const MyScopesRequest: MessageFns<MyScopesRequest> = {
  encode(message: MyScopesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MyScopesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMyScopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MyScopesRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: MyScopesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MyScopesRequest>, I>>(base?: I): MyScopesRequest {
    return MyScopesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MyScopesRequest>, I>>(object: I): MyScopesRequest {
    const message = createBaseMyScopesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseMyScopesUserRequest(): MyScopesUserRequest {
  return { userAppId: undefined };
}

export const MyScopesUserRequest: MessageFns<MyScopesUserRequest> = {
  encode(message: MyScopesUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MyScopesUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMyScopesUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MyScopesUserRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: MyScopesUserRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MyScopesUserRequest>, I>>(base?: I): MyScopesUserRequest {
    return MyScopesUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MyScopesUserRequest>, I>>(object: I): MyScopesUserRequest {
    const message = createBaseMyScopesUserRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseMyScopesRootRequest(): MyScopesRootRequest {
  return {};
}

export const MyScopesRootRequest: MessageFns<MyScopesRootRequest> = {
  encode(_: MyScopesRootRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MyScopesRootRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMyScopesRootRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MyScopesRootRequest {
    return {};
  },

  toJSON(_: MyScopesRootRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MyScopesRootRequest>, I>>(base?: I): MyScopesRootRequest {
    return MyScopesRootRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MyScopesRootRequest>, I>>(_: I): MyScopesRootRequest {
    const message = createBaseMyScopesRootRequest();
    return message;
  },
};

function createBaseMultiScopeDepsResponse(): MultiScopeDepsResponse {
  return { status: undefined, scopeDeps: [], endpointDeps: [] };
}

export const MultiScopeDepsResponse: MessageFns<MultiScopeDepsResponse> = {
  encode(message: MultiScopeDepsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopeDeps) {
      ScopeDeps.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.endpointDeps) {
      EndpointDeps.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiScopeDepsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiScopeDepsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeDeps.push(ScopeDeps.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endpointDeps.push(EndpointDeps.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiScopeDepsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scopeDeps: globalThis.Array.isArray(object?.scopeDeps)
        ? object.scopeDeps.map((e: any) => ScopeDeps.fromJSON(e))
        : [],
      endpointDeps: globalThis.Array.isArray(object?.endpointDeps)
        ? object.endpointDeps.map((e: any) => EndpointDeps.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiScopeDepsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scopeDeps?.length) {
      obj.scopeDeps = message.scopeDeps.map((e) => ScopeDeps.toJSON(e));
    }
    if (message.endpointDeps?.length) {
      obj.endpointDeps = message.endpointDeps.map((e) => EndpointDeps.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiScopeDepsResponse>, I>>(base?: I): MultiScopeDepsResponse {
    return MultiScopeDepsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiScopeDepsResponse>, I>>(object: I): MultiScopeDepsResponse {
    const message = createBaseMultiScopeDepsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scopeDeps = object.scopeDeps?.map((e) => ScopeDeps.fromPartial(e)) || [];
    message.endpointDeps = object.endpointDeps?.map((e) => EndpointDeps.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiScopeResponse(): MultiScopeResponse {
  return { status: undefined, scopes: [], app: undefined, endpoints: [], userFeatureFlags: "" };
}

export const MultiScopeResponse: MessageFns<MultiScopeResponse> = {
  encode(message: MultiScopeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(26).fork()).join();
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    if (message.userFeatureFlags !== "") {
      writer.uint32(42).string(message.userFeatureFlags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiScopeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiScopeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userFeatureFlags = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiScopeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      userFeatureFlags: isSet(object.userFeatureFlags) ? globalThis.String(object.userFeatureFlags) : "",
    };
  },

  toJSON(message: MultiScopeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.userFeatureFlags !== "") {
      obj.userFeatureFlags = message.userFeatureFlags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiScopeResponse>, I>>(base?: I): MultiScopeResponse {
    return MultiScopeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiScopeResponse>, I>>(object: I): MultiScopeResponse {
    const message = createBaseMultiScopeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.userFeatureFlags = object.userFeatureFlags ?? "";
    return message;
  },
};

function createBaseMultiScopeUserResponse(): MultiScopeUserResponse {
  return { status: undefined, scopes: [], endpoints: [], userFeatureFlags: "" };
}

export const MultiScopeUserResponse: MessageFns<MultiScopeUserResponse> = {
  encode(message: MultiScopeUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    if (message.userFeatureFlags !== "") {
      writer.uint32(42).string(message.userFeatureFlags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiScopeUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiScopeUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userFeatureFlags = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiScopeUserResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      userFeatureFlags: isSet(object.userFeatureFlags) ? globalThis.String(object.userFeatureFlags) : "",
    };
  },

  toJSON(message: MultiScopeUserResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.userFeatureFlags !== "") {
      obj.userFeatureFlags = message.userFeatureFlags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiScopeUserResponse>, I>>(base?: I): MultiScopeUserResponse {
    return MultiScopeUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiScopeUserResponse>, I>>(object: I): MultiScopeUserResponse {
    const message = createBaseMultiScopeUserResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.userFeatureFlags = object.userFeatureFlags ?? "";
    return message;
  },
};

function createBaseMultiScopeRootResponse(): MultiScopeRootResponse {
  return { status: undefined, scopes: [], endpoints: [], userFeatureFlags: "" };
}

export const MultiScopeRootResponse: MessageFns<MultiScopeRootResponse> = {
  encode(message: MultiScopeRootResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    if (message.userFeatureFlags !== "") {
      writer.uint32(42).string(message.userFeatureFlags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiScopeRootResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiScopeRootResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userFeatureFlags = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiScopeRootResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      userFeatureFlags: isSet(object.userFeatureFlags) ? globalThis.String(object.userFeatureFlags) : "",
    };
  },

  toJSON(message: MultiScopeRootResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.userFeatureFlags !== "") {
      obj.userFeatureFlags = message.userFeatureFlags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiScopeRootResponse>, I>>(base?: I): MultiScopeRootResponse {
    return MultiScopeRootResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiScopeRootResponse>, I>>(object: I): MultiScopeRootResponse {
    const message = createBaseMultiScopeRootResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.userFeatureFlags = object.userFeatureFlags ?? "";
    return message;
  },
};

function createBaseGetSearchRequest(): GetSearchRequest {
  return { userAppId: undefined, id: "" };
}

export const GetSearchRequest: MessageFns<GetSearchRequest> = {
  encode(message: GetSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetSearchRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSearchRequest>, I>>(base?: I): GetSearchRequest {
    return GetSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSearchRequest>, I>>(object: I): GetSearchRequest {
    const message = createBaseGetSearchRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListSearchesRequest(): ListSearchesRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListSearchesRequest: MessageFns<ListSearchesRequest> = {
  encode(message: ListSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSearchesRequest>, I>>(base?: I): ListSearchesRequest {
    return ListSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSearchesRequest>, I>>(object: I): ListSearchesRequest {
    const message = createBaseListSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostSearchesRequest(): PostSearchesRequest {
  return { userAppId: undefined, query: undefined, searches: [], pagination: undefined };
}

export const PostSearchesRequest: MessageFns<PostSearchesRequest> = {
  encode(message: PostSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(18).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostSearchesRequest>, I>>(base?: I): PostSearchesRequest {
    return PostSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostSearchesRequest>, I>>(object: I): PostSearchesRequest {
    const message = createBasePostSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBasePatchInputsSearchesRequest(): PatchInputsSearchesRequest {
  return { userAppId: undefined, searches: [], action: "" };
}

export const PatchInputsSearchesRequest: MessageFns<PatchInputsSearchesRequest> = {
  encode(message: PatchInputsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInputsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInputsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInputsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchInputsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchInputsSearchesRequest>, I>>(base?: I): PatchInputsSearchesRequest {
    return PatchInputsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchInputsSearchesRequest>, I>>(object: I): PatchInputsSearchesRequest {
    const message = createBasePatchInputsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchAnnotationsSearchesRequest(): PatchAnnotationsSearchesRequest {
  return { userAppId: undefined, searches: [], action: "" };
}

export const PatchAnnotationsSearchesRequest: MessageFns<PatchAnnotationsSearchesRequest> = {
  encode(message: PatchAnnotationsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchAnnotationsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationsSearchesRequest>, I>>(base?: I): PatchAnnotationsSearchesRequest {
    return PatchAnnotationsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationsSearchesRequest>, I>>(
    object: I,
  ): PatchAnnotationsSearchesRequest {
    const message = createBasePatchAnnotationsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchSearchesRequest(): PatchSearchesRequest {
  return { userAppId: undefined, searches: [], action: "" };
}

export const PatchSearchesRequest: MessageFns<PatchSearchesRequest> = {
  encode(message: PatchSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchSearchesRequest>, I>>(base?: I): PatchSearchesRequest {
    return PatchSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchSearchesRequest>, I>>(object: I): PatchSearchesRequest {
    const message = createBasePatchSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePostSearchesByIDRequest(): PostSearchesByIDRequest {
  return { userAppId: undefined, id: "", pagination: undefined };
}

export const PostSearchesByIDRequest: MessageFns<PostSearchesByIDRequest> = {
  encode(message: PostSearchesByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostSearchesByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostSearchesByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostSearchesByIDRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostSearchesByIDRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostSearchesByIDRequest>, I>>(base?: I): PostSearchesByIDRequest {
    return PostSearchesByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostSearchesByIDRequest>, I>>(object: I): PostSearchesByIDRequest {
    const message = createBasePostSearchesByIDRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteSearchRequest(): DeleteSearchRequest {
  return { userAppId: undefined, id: "" };
}

export const DeleteSearchRequest: MessageFns<DeleteSearchRequest> = {
  encode(message: DeleteSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSearchRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeleteSearchRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSearchRequest>, I>>(base?: I): DeleteSearchRequest {
    return DeleteSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSearchRequest>, I>>(object: I): DeleteSearchRequest {
    const message = createBaseDeleteSearchRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePostAnnotationsSearchesRequest(): PostAnnotationsSearchesRequest {
  return { userAppId: undefined, searches: [], pagination: undefined };
}

export const PostAnnotationsSearchesRequest: MessageFns<PostAnnotationsSearchesRequest> = {
  encode(message: PostAnnotationsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAnnotationsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAnnotationsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAnnotationsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostAnnotationsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAnnotationsSearchesRequest>, I>>(base?: I): PostAnnotationsSearchesRequest {
    return PostAnnotationsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAnnotationsSearchesRequest>, I>>(
    object: I,
  ): PostAnnotationsSearchesRequest {
    const message = createBasePostAnnotationsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteAnnotationSearchMetricsRequest(): DeleteAnnotationSearchMetricsRequest {
  return { userAppId: undefined, id: "" };
}

export const DeleteAnnotationSearchMetricsRequest: MessageFns<DeleteAnnotationSearchMetricsRequest> = {
  encode(message: DeleteAnnotationSearchMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationSearchMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationSearchMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationSearchMetricsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeleteAnnotationSearchMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotationSearchMetricsRequest>, I>>(
    base?: I,
  ): DeleteAnnotationSearchMetricsRequest {
    return DeleteAnnotationSearchMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotationSearchMetricsRequest>, I>>(
    object: I,
  ): DeleteAnnotationSearchMetricsRequest {
    const message = createBaseDeleteAnnotationSearchMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePostInputsSearchesRequest(): PostInputsSearchesRequest {
  return { userAppId: undefined, searches: [], pagination: undefined, onlyCount: false };
}

export const PostInputsSearchesRequest: MessageFns<PostInputsSearchesRequest> = {
  encode(message: PostInputsSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    if (message.onlyCount !== false) {
      writer.uint32(32).bool(message.onlyCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInputsSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInputsSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.onlyCount = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInputsSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
      onlyCount: isSet(object.onlyCount) ? globalThis.Boolean(object.onlyCount) : false,
    };
  },

  toJSON(message: PostInputsSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    if (message.onlyCount !== false) {
      obj.onlyCount = message.onlyCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInputsSearchesRequest>, I>>(base?: I): PostInputsSearchesRequest {
    return PostInputsSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInputsSearchesRequest>, I>>(object: I): PostInputsSearchesRequest {
    const message = createBasePostInputsSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    message.onlyCount = object.onlyCount ?? false;
    return message;
  },
};

function createBaseSingleSearchResponse(): SingleSearchResponse {
  return { status: undefined, search: undefined };
}

export const SingleSearchResponse: MessageFns<SingleSearchResponse> = {
  encode(message: SingleSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.search !== undefined) {
      Search.encode(message.search, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.search = Search.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleSearchResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      search: isSet(object.search) ? Search.fromJSON(object.search) : undefined,
    };
  },

  toJSON(message: SingleSearchResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.search !== undefined) {
      obj.search = Search.toJSON(message.search);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleSearchResponse>, I>>(base?: I): SingleSearchResponse {
    return SingleSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleSearchResponse>, I>>(object: I): SingleSearchResponse {
    const message = createBaseSingleSearchResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.search = (object.search !== undefined && object.search !== null)
      ? Search.fromPartial(object.search)
      : undefined;
    return message;
  },
};

function createBaseMultiSearchResponse(): MultiSearchResponse {
  return { status: undefined, id: "", hits: [], query: undefined, searches: [], hitCounts: [] };
}

export const MultiSearchResponse: MessageFns<MultiSearchResponse> = {
  encode(message: MultiSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    for (const v of message.hits) {
      Hit.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(34).fork()).join();
    }
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.hitCounts) {
      HitCount.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hits.push(Hit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hitCounts.push(HitCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiSearchResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      hits: globalThis.Array.isArray(object?.hits) ? object.hits.map((e: any) => Hit.fromJSON(e)) : [],
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
      hitCounts: globalThis.Array.isArray(object?.hitCounts)
        ? object.hitCounts.map((e: any) => HitCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiSearchResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.hits?.length) {
      obj.hits = message.hits.map((e) => Hit.toJSON(e));
    }
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    if (message.hitCounts?.length) {
      obj.hitCounts = message.hitCounts.map((e) => HitCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiSearchResponse>, I>>(base?: I): MultiSearchResponse {
    return MultiSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiSearchResponse>, I>>(object: I): MultiSearchResponse {
    const message = createBaseMultiSearchResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.id = object.id ?? "";
    message.hits = object.hits?.map((e) => Hit.fromPartial(e)) || [];
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    message.hitCounts = object.hitCounts?.map((e) => HitCount.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostAnnotationSearchMetricsRequest(): PostAnnotationSearchMetricsRequest {
  return {
    userAppId: undefined,
    id: "",
    groundTruth: undefined,
    searchToEval: undefined,
    data: undefined,
    evaluationType: 0,
  };
}

export const PostAnnotationSearchMetricsRequest: MessageFns<PostAnnotationSearchMetricsRequest> = {
  encode(message: PostAnnotationSearchMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.groundTruth !== undefined) {
      Search.encode(message.groundTruth, writer.uint32(26).fork()).join();
    }
    if (message.searchToEval !== undefined) {
      Search.encode(message.searchToEval, writer.uint32(34).fork()).join();
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(42).fork()).join();
    }
    if (message.evaluationType !== 0) {
      writer.uint32(48).int32(message.evaluationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAnnotationSearchMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAnnotationSearchMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groundTruth = Search.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.searchToEval = Search.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.evaluationType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAnnotationSearchMetricsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      groundTruth: isSet(object.groundTruth) ? Search.fromJSON(object.groundTruth) : undefined,
      searchToEval: isSet(object.searchToEval) ? Search.fromJSON(object.searchToEval) : undefined,
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      evaluationType: isSet(object.evaluationType) ? evaluationTypeFromJSON(object.evaluationType) : 0,
    };
  },

  toJSON(message: PostAnnotationSearchMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.groundTruth !== undefined) {
      obj.groundTruth = Search.toJSON(message.groundTruth);
    }
    if (message.searchToEval !== undefined) {
      obj.searchToEval = Search.toJSON(message.searchToEval);
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.evaluationType !== 0) {
      obj.evaluationType = evaluationTypeToJSON(message.evaluationType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAnnotationSearchMetricsRequest>, I>>(
    base?: I,
  ): PostAnnotationSearchMetricsRequest {
    return PostAnnotationSearchMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAnnotationSearchMetricsRequest>, I>>(
    object: I,
  ): PostAnnotationSearchMetricsRequest {
    const message = createBasePostAnnotationSearchMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    message.groundTruth = (object.groundTruth !== undefined && object.groundTruth !== null)
      ? Search.fromPartial(object.groundTruth)
      : undefined;
    message.searchToEval = (object.searchToEval !== undefined && object.searchToEval !== null)
      ? Search.fromPartial(object.searchToEval)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.evaluationType = object.evaluationType ?? 0;
    return message;
  },
};

function createBaseGetAnnotationSearchMetricsRequest(): GetAnnotationSearchMetricsRequest {
  return { userAppId: undefined, id: "" };
}

export const GetAnnotationSearchMetricsRequest: MessageFns<GetAnnotationSearchMetricsRequest> = {
  encode(message: GetAnnotationSearchMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationSearchMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationSearchMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationSearchMetricsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetAnnotationSearchMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAnnotationSearchMetricsRequest>, I>>(
    base?: I,
  ): GetAnnotationSearchMetricsRequest {
    return GetAnnotationSearchMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAnnotationSearchMetricsRequest>, I>>(
    object: I,
  ): GetAnnotationSearchMetricsRequest {
    const message = createBaseGetAnnotationSearchMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListAnnotationSearchMetricsRequest(): ListAnnotationSearchMetricsRequest {
  return { userAppId: undefined };
}

export const ListAnnotationSearchMetricsRequest: MessageFns<ListAnnotationSearchMetricsRequest> = {
  encode(message: ListAnnotationSearchMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationSearchMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationSearchMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationSearchMetricsRequest {
    return { userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined };
  },

  toJSON(message: ListAnnotationSearchMetricsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAnnotationSearchMetricsRequest>, I>>(
    base?: I,
  ): ListAnnotationSearchMetricsRequest {
    return ListAnnotationSearchMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAnnotationSearchMetricsRequest>, I>>(
    object: I,
  ): ListAnnotationSearchMetricsRequest {
    const message = createBaseListAnnotationSearchMetricsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    return message;
  },
};

function createBaseMultiAnnotationSearchMetricsResponse(): MultiAnnotationSearchMetricsResponse {
  return { status: undefined, annotationSearchMetrics: [] };
}

export const MultiAnnotationSearchMetricsResponse: MessageFns<MultiAnnotationSearchMetricsResponse> = {
  encode(message: MultiAnnotationSearchMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationSearchMetrics) {
      AnnotationSearchMetrics.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAnnotationSearchMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAnnotationSearchMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationSearchMetrics.push(AnnotationSearchMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAnnotationSearchMetricsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotationSearchMetrics: globalThis.Array.isArray(object?.annotationSearchMetrics)
        ? object.annotationSearchMetrics.map((e: any) => AnnotationSearchMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAnnotationSearchMetricsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotationSearchMetrics?.length) {
      obj.annotationSearchMetrics = message.annotationSearchMetrics.map((e) => AnnotationSearchMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAnnotationSearchMetricsResponse>, I>>(
    base?: I,
  ): MultiAnnotationSearchMetricsResponse {
    return MultiAnnotationSearchMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAnnotationSearchMetricsResponse>, I>>(
    object: I,
  ): MultiAnnotationSearchMetricsResponse {
    const message = createBaseMultiAnnotationSearchMetricsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotationSearchMetrics =
      object.annotationSearchMetrics?.map((e) => AnnotationSearchMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListAnnotationFiltersRequest(): ListAnnotationFiltersRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListAnnotationFiltersRequest: MessageFns<ListAnnotationFiltersRequest> = {
  encode(message: ListAnnotationFiltersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationFiltersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationFiltersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationFiltersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListAnnotationFiltersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAnnotationFiltersRequest>, I>>(base?: I): ListAnnotationFiltersRequest {
    return ListAnnotationFiltersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAnnotationFiltersRequest>, I>>(object: I): ListAnnotationFiltersRequest {
    const message = createBaseListAnnotationFiltersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetAnnotationFilterRequest(): GetAnnotationFilterRequest {
  return { userAppId: undefined, annotationFilterId: "" };
}

export const GetAnnotationFilterRequest: MessageFns<GetAnnotationFilterRequest> = {
  encode(message: GetAnnotationFilterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.annotationFilterId !== "") {
      writer.uint32(18).string(message.annotationFilterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationFilterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationFilterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationFilterRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationFilterId: isSet(object.annotationFilterId) ? globalThis.String(object.annotationFilterId) : "",
    };
  },

  toJSON(message: GetAnnotationFilterRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationFilterId !== "") {
      obj.annotationFilterId = message.annotationFilterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAnnotationFilterRequest>, I>>(base?: I): GetAnnotationFilterRequest {
    return GetAnnotationFilterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAnnotationFilterRequest>, I>>(object: I): GetAnnotationFilterRequest {
    const message = createBaseGetAnnotationFilterRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationFilterId = object.annotationFilterId ?? "";
    return message;
  },
};

function createBasePostAnnotationFiltersRequest(): PostAnnotationFiltersRequest {
  return { userAppId: undefined, annotationFilters: [] };
}

export const PostAnnotationFiltersRequest: MessageFns<PostAnnotationFiltersRequest> = {
  encode(message: PostAnnotationFiltersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationFilters) {
      AnnotationFilter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAnnotationFiltersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAnnotationFiltersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilters.push(AnnotationFilter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAnnotationFiltersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationFilters: globalThis.Array.isArray(object?.annotationFilters)
        ? object.annotationFilters.map((e: any) => AnnotationFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostAnnotationFiltersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationFilters?.length) {
      obj.annotationFilters = message.annotationFilters.map((e) => AnnotationFilter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAnnotationFiltersRequest>, I>>(base?: I): PostAnnotationFiltersRequest {
    return PostAnnotationFiltersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAnnotationFiltersRequest>, I>>(object: I): PostAnnotationFiltersRequest {
    const message = createBasePostAnnotationFiltersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationFilters = object.annotationFilters?.map((e) => AnnotationFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchAnnotationFiltersRequest(): PatchAnnotationFiltersRequest {
  return { userAppId: undefined, annotationFilters: [], action: "" };
}

export const PatchAnnotationFiltersRequest: MessageFns<PatchAnnotationFiltersRequest> = {
  encode(message: PatchAnnotationFiltersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationFilters) {
      AnnotationFilter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAnnotationFiltersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAnnotationFiltersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilters.push(AnnotationFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAnnotationFiltersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationFilters: globalThis.Array.isArray(object?.annotationFilters)
        ? object.annotationFilters.map((e: any) => AnnotationFilter.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchAnnotationFiltersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationFilters?.length) {
      obj.annotationFilters = message.annotationFilters.map((e) => AnnotationFilter.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAnnotationFiltersRequest>, I>>(base?: I): PatchAnnotationFiltersRequest {
    return PatchAnnotationFiltersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAnnotationFiltersRequest>, I>>(
    object: I,
  ): PatchAnnotationFiltersRequest {
    const message = createBasePatchAnnotationFiltersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationFilters = object.annotationFilters?.map((e) => AnnotationFilter.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteAnnotationFiltersRequest(): DeleteAnnotationFiltersRequest {
  return { userAppId: undefined, annotationFilterIds: [] };
}

export const DeleteAnnotationFiltersRequest: MessageFns<DeleteAnnotationFiltersRequest> = {
  encode(message: DeleteAnnotationFiltersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationFilterIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationFiltersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationFiltersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilterIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationFiltersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      annotationFilterIds: globalThis.Array.isArray(object?.annotationFilterIds)
        ? object.annotationFilterIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteAnnotationFiltersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.annotationFilterIds?.length) {
      obj.annotationFilterIds = message.annotationFilterIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotationFiltersRequest>, I>>(base?: I): DeleteAnnotationFiltersRequest {
    return DeleteAnnotationFiltersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotationFiltersRequest>, I>>(
    object: I,
  ): DeleteAnnotationFiltersRequest {
    const message = createBaseDeleteAnnotationFiltersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.annotationFilterIds = object.annotationFilterIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiAnnotationFilterResponse(): MultiAnnotationFilterResponse {
  return { status: undefined, annotationFilters: [] };
}

export const MultiAnnotationFilterResponse: MessageFns<MultiAnnotationFilterResponse> = {
  encode(message: MultiAnnotationFilterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotationFilters) {
      AnnotationFilter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAnnotationFilterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAnnotationFilterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilters.push(AnnotationFilter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAnnotationFilterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotationFilters: globalThis.Array.isArray(object?.annotationFilters)
        ? object.annotationFilters.map((e: any) => AnnotationFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAnnotationFilterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotationFilters?.length) {
      obj.annotationFilters = message.annotationFilters.map((e) => AnnotationFilter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAnnotationFilterResponse>, I>>(base?: I): MultiAnnotationFilterResponse {
    return MultiAnnotationFilterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAnnotationFilterResponse>, I>>(
    object: I,
  ): MultiAnnotationFilterResponse {
    const message = createBaseMultiAnnotationFilterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotationFilters = object.annotationFilters?.map((e) => AnnotationFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleAnnotationFilterResponse(): SingleAnnotationFilterResponse {
  return { status: undefined, annotationFilter: undefined };
}

export const SingleAnnotationFilterResponse: MessageFns<SingleAnnotationFilterResponse> = {
  encode(message: SingleAnnotationFilterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.annotationFilter !== undefined) {
      AnnotationFilter.encode(message.annotationFilter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleAnnotationFilterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleAnnotationFilterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annotationFilter = AnnotationFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleAnnotationFilterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      annotationFilter: isSet(object.annotationFilter) ? AnnotationFilter.fromJSON(object.annotationFilter) : undefined,
    };
  },

  toJSON(message: SingleAnnotationFilterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.annotationFilter !== undefined) {
      obj.annotationFilter = AnnotationFilter.toJSON(message.annotationFilter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleAnnotationFilterResponse>, I>>(base?: I): SingleAnnotationFilterResponse {
    return SingleAnnotationFilterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleAnnotationFilterResponse>, I>>(
    object: I,
  ): SingleAnnotationFilterResponse {
    const message = createBaseSingleAnnotationFilterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.annotationFilter = (object.annotationFilter !== undefined && object.annotationFilter !== null)
      ? AnnotationFilter.fromPartial(object.annotationFilter)
      : undefined;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { userAppId: undefined, additionalFields: [] };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.additionalFields) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleUserResponse(): SingleUserResponse {
  return { status: undefined, user: undefined };
}

export const SingleUserResponse: MessageFns<SingleUserResponse> = {
  encode(message: SingleUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleUserResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: SingleUserResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleUserResponse>, I>>(base?: I): SingleUserResponse {
    return SingleUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleUserResponse>, I>>(object: I): SingleUserResponse {
    const message = createBaseSingleUserResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBasePostValidatePasswordRequest(): PostValidatePasswordRequest {
  return { userAppId: undefined, password: undefined };
}

export const PostValidatePasswordRequest: MessageFns<PostValidatePasswordRequest> = {
  encode(message: PostValidatePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.password !== undefined) {
      Password.encode(message.password, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostValidatePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostValidatePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = Password.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostValidatePasswordRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      password: isSet(object.password) ? Password.fromJSON(object.password) : undefined,
    };
  },

  toJSON(message: PostValidatePasswordRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.password !== undefined) {
      obj.password = Password.toJSON(message.password);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostValidatePasswordRequest>, I>>(base?: I): PostValidatePasswordRequest {
    return PostValidatePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostValidatePasswordRequest>, I>>(object: I): PostValidatePasswordRequest {
    const message = createBasePostValidatePasswordRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.password = (object.password !== undefined && object.password !== null)
      ? Password.fromPartial(object.password)
      : undefined;
    return message;
  },
};

function createBaseSinglePasswordValidationResponse(): SinglePasswordValidationResponse {
  return { status: undefined, passwordViolations: undefined };
}

export const SinglePasswordValidationResponse: MessageFns<SinglePasswordValidationResponse> = {
  encode(message: SinglePasswordValidationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.passwordViolations !== undefined) {
      PasswordViolations.encode(message.passwordViolations, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePasswordValidationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePasswordValidationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.passwordViolations = PasswordViolations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePasswordValidationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      passwordViolations: isSet(object.passwordViolations)
        ? PasswordViolations.fromJSON(object.passwordViolations)
        : undefined,
    };
  },

  toJSON(message: SinglePasswordValidationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.passwordViolations !== undefined) {
      obj.passwordViolations = PasswordViolations.toJSON(message.passwordViolations);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePasswordValidationResponse>, I>>(
    base?: I,
  ): SinglePasswordValidationResponse {
    return SinglePasswordValidationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePasswordValidationResponse>, I>>(
    object: I,
  ): SinglePasswordValidationResponse {
    const message = createBaseSinglePasswordValidationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.passwordViolations = (object.passwordViolations !== undefined && object.passwordViolations !== null)
      ? PasswordViolations.fromPartial(object.passwordViolations)
      : undefined;
    return message;
  },
};

function createBaseGetWorkflowRequest(): GetWorkflowRequest {
  return { userAppId: undefined, workflowId: "", additionalFields: [] };
}

export const GetWorkflowRequest: MessageFns<GetWorkflowRequest> = {
  encode(message: GetWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    for (const v of message.additionalFields) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetWorkflowRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWorkflowRequest>, I>>(base?: I): GetWorkflowRequest {
    return GetWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWorkflowRequest>, I>>(object: I): GetWorkflowRequest {
    const message = createBaseGetWorkflowRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseListWorkflowsRequest(): ListWorkflowsRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    additionalFields: [],
    sortAscending: false,
    sortById: undefined,
    sortByModifiedAt: undefined,
    sortByCreatedAt: undefined,
    sortByStarCount: undefined,
    featuredOnly: false,
    starredOnly: false,
    bookmark: false,
    visibility: undefined,
    search: "",
    query: "",
    id: "",
    searchTerm: "",
  };
}

export const ListWorkflowsRequest: MessageFns<ListWorkflowsRequest> = {
  encode(message: ListWorkflowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(82).string(v!);
    }
    if (message.sortAscending !== false) {
      writer.uint32(40).bool(message.sortAscending);
    }
    if (message.sortById !== undefined) {
      writer.uint32(48).bool(message.sortById);
    }
    if (message.sortByModifiedAt !== undefined) {
      writer.uint32(56).bool(message.sortByModifiedAt);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(104).bool(message.sortByCreatedAt);
    }
    if (message.sortByStarCount !== undefined) {
      writer.uint32(112).bool(message.sortByStarCount);
    }
    if (message.featuredOnly !== false) {
      writer.uint32(72).bool(message.featuredOnly);
    }
    if (message.starredOnly !== false) {
      writer.uint32(88).bool(message.starredOnly);
    }
    if (message.bookmark !== false) {
      writer.uint32(120).bool(message.bookmark);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(138).fork()).join();
    }
    if (message.search !== "") {
      writer.uint32(130).string(message.search);
    }
    if (message.query !== "") {
      writer.uint32(66).string(message.query);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.searchTerm !== "") {
      writer.uint32(98).string(message.searchTerm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sortById = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortByModifiedAt = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.sortByStarCount = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.featuredOnly = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.starredOnly = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.bookmark = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.searchTerm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkflowsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortById: isSet(object.sortById) ? globalThis.Boolean(object.sortById) : undefined,
      sortByModifiedAt: isSet(object.sortByModifiedAt) ? globalThis.Boolean(object.sortByModifiedAt) : undefined,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByStarCount: isSet(object.sortByStarCount) ? globalThis.Boolean(object.sortByStarCount) : undefined,
      featuredOnly: isSet(object.featuredOnly) ? globalThis.Boolean(object.featuredOnly) : false,
      starredOnly: isSet(object.starredOnly) ? globalThis.Boolean(object.starredOnly) : false,
      bookmark: isSet(object.bookmark) ? globalThis.Boolean(object.bookmark) : false,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      searchTerm: isSet(object.searchTerm) ? globalThis.String(object.searchTerm) : "",
    };
  },

  toJSON(message: ListWorkflowsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortById !== undefined) {
      obj.sortById = message.sortById;
    }
    if (message.sortByModifiedAt !== undefined) {
      obj.sortByModifiedAt = message.sortByModifiedAt;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByStarCount !== undefined) {
      obj.sortByStarCount = message.sortByStarCount;
    }
    if (message.featuredOnly !== false) {
      obj.featuredOnly = message.featuredOnly;
    }
    if (message.starredOnly !== false) {
      obj.starredOnly = message.starredOnly;
    }
    if (message.bookmark !== false) {
      obj.bookmark = message.bookmark;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.searchTerm !== "") {
      obj.searchTerm = message.searchTerm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkflowsRequest>, I>>(base?: I): ListWorkflowsRequest {
    return ListWorkflowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkflowsRequest>, I>>(object: I): ListWorkflowsRequest {
    const message = createBaseListWorkflowsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.sortAscending = object.sortAscending ?? false;
    message.sortById = object.sortById ?? undefined;
    message.sortByModifiedAt = object.sortByModifiedAt ?? undefined;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByStarCount = object.sortByStarCount ?? undefined;
    message.featuredOnly = object.featuredOnly ?? false;
    message.starredOnly = object.starredOnly ?? false;
    message.bookmark = object.bookmark ?? false;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.search = object.search ?? "";
    message.query = object.query ?? "";
    message.id = object.id ?? "";
    message.searchTerm = object.searchTerm ?? "";
    return message;
  },
};

function createBasePostWorkflowsRequest(): PostWorkflowsRequest {
  return { userAppId: undefined, workflows: [] };
}

export const PostWorkflowsRequest: MessageFns<PostWorkflowsRequest> = {
  encode(message: PostWorkflowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflows) {
      Workflow.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflows.push(Workflow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflows: globalThis.Array.isArray(object?.workflows)
        ? object.workflows.map((e: any) => Workflow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostWorkflowsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflows?.length) {
      obj.workflows = message.workflows.map((e) => Workflow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowsRequest>, I>>(base?: I): PostWorkflowsRequest {
    return PostWorkflowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowsRequest>, I>>(object: I): PostWorkflowsRequest {
    const message = createBasePostWorkflowsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflows = object.workflows?.map((e) => Workflow.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchWorkflowsRequest(): PatchWorkflowsRequest {
  return { userAppId: undefined, workflows: [], action: "" };
}

export const PatchWorkflowsRequest: MessageFns<PatchWorkflowsRequest> = {
  encode(message: PatchWorkflowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflows) {
      Workflow.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchWorkflowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflows.push(Workflow.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchWorkflowsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflows: globalThis.Array.isArray(object?.workflows)
        ? object.workflows.map((e: any) => Workflow.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchWorkflowsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflows?.length) {
      obj.workflows = message.workflows.map((e) => Workflow.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchWorkflowsRequest>, I>>(base?: I): PatchWorkflowsRequest {
    return PatchWorkflowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchWorkflowsRequest>, I>>(object: I): PatchWorkflowsRequest {
    const message = createBasePatchWorkflowsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflows = object.workflows?.map((e) => Workflow.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBasePatchWorkflowIdsRequest(): PatchWorkflowIdsRequest {
  return { userAppId: undefined, ids: [], action: "" };
}

export const PatchWorkflowIdsRequest: MessageFns<PatchWorkflowIdsRequest> = {
  encode(message: PatchWorkflowIdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      IdUpdateSource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchWorkflowIdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchWorkflowIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(IdUpdateSource.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchWorkflowIdsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => IdUpdateSource.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchWorkflowIdsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => IdUpdateSource.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchWorkflowIdsRequest>, I>>(base?: I): PatchWorkflowIdsRequest {
    return PatchWorkflowIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchWorkflowIdsRequest>, I>>(object: I): PatchWorkflowIdsRequest {
    const message = createBasePatchWorkflowIdsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => IdUpdateSource.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteWorkflowRequest(): DeleteWorkflowRequest {
  return { userAppId: undefined, workflowId: "" };
}

export const DeleteWorkflowRequest: MessageFns<DeleteWorkflowRequest> = {
  encode(message: DeleteWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkflowRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
    };
  },

  toJSON(message: DeleteWorkflowRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteWorkflowRequest>, I>>(base?: I): DeleteWorkflowRequest {
    return DeleteWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteWorkflowRequest>, I>>(object: I): DeleteWorkflowRequest {
    const message = createBaseDeleteWorkflowRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    return message;
  },
};

function createBaseDeleteWorkflowsRequest(): DeleteWorkflowsRequest {
  return { userAppId: undefined, ids: [], deleteAll: false };
}

export const DeleteWorkflowsRequest: MessageFns<DeleteWorkflowsRequest> = {
  encode(message: DeleteWorkflowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    if (message.deleteAll !== false) {
      writer.uint32(24).bool(message.deleteAll);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkflowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deleteAll = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkflowsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      deleteAll: isSet(object.deleteAll) ? globalThis.Boolean(object.deleteAll) : false,
    };
  },

  toJSON(message: DeleteWorkflowsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.deleteAll !== false) {
      obj.deleteAll = message.deleteAll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteWorkflowsRequest>, I>>(base?: I): DeleteWorkflowsRequest {
    return DeleteWorkflowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteWorkflowsRequest>, I>>(object: I): DeleteWorkflowsRequest {
    const message = createBaseDeleteWorkflowsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.deleteAll = object.deleteAll ?? false;
    return message;
  },
};

function createBaseSingleWorkflowResponse(): SingleWorkflowResponse {
  return { status: undefined, workflow: undefined };
}

export const SingleWorkflowResponse: MessageFns<SingleWorkflowResponse> = {
  encode(message: SingleWorkflowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleWorkflowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleWorkflowResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
    };
  },

  toJSON(message: SingleWorkflowResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleWorkflowResponse>, I>>(base?: I): SingleWorkflowResponse {
    return SingleWorkflowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleWorkflowResponse>, I>>(object: I): SingleWorkflowResponse {
    const message = createBaseSingleWorkflowResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    return message;
  },
};

function createBaseMultiWorkflowResponse(): MultiWorkflowResponse {
  return { status: undefined, workflows: [] };
}

export const MultiWorkflowResponse: MessageFns<MultiWorkflowResponse> = {
  encode(message: MultiWorkflowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflows) {
      Workflow.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiWorkflowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflows.push(Workflow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiWorkflowResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflows: globalThis.Array.isArray(object?.workflows)
        ? object.workflows.map((e: any) => Workflow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiWorkflowResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflows?.length) {
      obj.workflows = message.workflows.map((e) => Workflow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiWorkflowResponse>, I>>(base?: I): MultiWorkflowResponse {
    return MultiWorkflowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiWorkflowResponse>, I>>(object: I): MultiWorkflowResponse {
    const message = createBaseMultiWorkflowResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflows = object.workflows?.map((e) => Workflow.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostWorkflowResultsRequest(): PostWorkflowResultsRequest {
  return {
    userAppId: undefined,
    workflowId: "",
    versionId: "",
    inputs: [],
    outputConfig: undefined,
    favorClarifaiWorkflows: false,
    workflowState: undefined,
    nodeRunnerSelectors: {},
  };
}

export const PostWorkflowResultsRequest: MessageFns<PostWorkflowResultsRequest> = {
  encode(message: PostWorkflowResultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.versionId !== "") {
      writer.uint32(58).string(message.versionId);
    }
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(34).fork()).join();
    }
    if (message.favorClarifaiWorkflows !== false) {
      writer.uint32(40).bool(message.favorClarifaiWorkflows);
    }
    if (message.workflowState !== undefined) {
      WorkflowState.encode(message.workflowState, writer.uint32(50).fork()).join();
    }
    Object.entries(message.nodeRunnerSelectors).forEach(([key, value]) => {
      PostWorkflowResultsRequest_NodeRunnerSelectorsEntry.encode({ key: key as any, value }, writer.uint32(66).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowResultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.favorClarifaiWorkflows = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workflowState = WorkflowState.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = PostWorkflowResultsRequest_NodeRunnerSelectorsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.nodeRunnerSelectors[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowResultsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
      favorClarifaiWorkflows: isSet(object.favorClarifaiWorkflows)
        ? globalThis.Boolean(object.favorClarifaiWorkflows)
        : false,
      workflowState: isSet(object.workflowState) ? WorkflowState.fromJSON(object.workflowState) : undefined,
      nodeRunnerSelectors: isObject(object.nodeRunnerSelectors)
        ? Object.entries(object.nodeRunnerSelectors).reduce<{ [key: string]: RunnerSelector }>((acc, [key, value]) => {
          acc[key] = RunnerSelector.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PostWorkflowResultsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    if (message.favorClarifaiWorkflows !== false) {
      obj.favorClarifaiWorkflows = message.favorClarifaiWorkflows;
    }
    if (message.workflowState !== undefined) {
      obj.workflowState = WorkflowState.toJSON(message.workflowState);
    }
    if (message.nodeRunnerSelectors) {
      const entries = Object.entries(message.nodeRunnerSelectors);
      if (entries.length > 0) {
        obj.nodeRunnerSelectors = {};
        entries.forEach(([k, v]) => {
          obj.nodeRunnerSelectors[k] = RunnerSelector.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowResultsRequest>, I>>(base?: I): PostWorkflowResultsRequest {
    return PostWorkflowResultsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowResultsRequest>, I>>(object: I): PostWorkflowResultsRequest {
    const message = createBasePostWorkflowResultsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.versionId = object.versionId ?? "";
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.favorClarifaiWorkflows = object.favorClarifaiWorkflows ?? false;
    message.workflowState = (object.workflowState !== undefined && object.workflowState !== null)
      ? WorkflowState.fromPartial(object.workflowState)
      : undefined;
    message.nodeRunnerSelectors = Object.entries(object.nodeRunnerSelectors ?? {}).reduce<
      { [key: string]: RunnerSelector }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = RunnerSelector.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePostWorkflowResultsRequest_NodeRunnerSelectorsEntry(): PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
  return { key: "", value: undefined };
}

export const PostWorkflowResultsRequest_NodeRunnerSelectorsEntry: MessageFns<
  PostWorkflowResultsRequest_NodeRunnerSelectorsEntry
> = {
  encode(
    message: PostWorkflowResultsRequest_NodeRunnerSelectorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RunnerSelector.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowResultsRequest_NodeRunnerSelectorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RunnerSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RunnerSelector.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PostWorkflowResultsRequest_NodeRunnerSelectorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RunnerSelector.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowResultsRequest_NodeRunnerSelectorsEntry>, I>>(
    base?: I,
  ): PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
    return PostWorkflowResultsRequest_NodeRunnerSelectorsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowResultsRequest_NodeRunnerSelectorsEntry>, I>>(
    object: I,
  ): PostWorkflowResultsRequest_NodeRunnerSelectorsEntry {
    const message = createBasePostWorkflowResultsRequest_NodeRunnerSelectorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RunnerSelector.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePostWorkflowResultsResponse(): PostWorkflowResultsResponse {
  return { status: undefined, workflow: undefined, results: [], workflowState: undefined };
}

export const PostWorkflowResultsResponse: MessageFns<PostWorkflowResultsResponse> = {
  encode(message: PostWorkflowResultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(18).fork()).join();
    }
    for (const v of message.results) {
      WorkflowResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.workflowState !== undefined) {
      WorkflowState.encode(message.workflowState, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowResultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowResultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.results.push(WorkflowResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowState = WorkflowState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowResultsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => WorkflowResult.fromJSON(e))
        : [],
      workflowState: isSet(object.workflowState) ? WorkflowState.fromJSON(object.workflowState) : undefined,
    };
  },

  toJSON(message: PostWorkflowResultsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => WorkflowResult.toJSON(e));
    }
    if (message.workflowState !== undefined) {
      obj.workflowState = WorkflowState.toJSON(message.workflowState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowResultsResponse>, I>>(base?: I): PostWorkflowResultsResponse {
    return PostWorkflowResultsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowResultsResponse>, I>>(object: I): PostWorkflowResultsResponse {
    const message = createBasePostWorkflowResultsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    message.results = object.results?.map((e) => WorkflowResult.fromPartial(e)) || [];
    message.workflowState = (object.workflowState !== undefined && object.workflowState !== null)
      ? WorkflowState.fromPartial(object.workflowState)
      : undefined;
    return message;
  },
};

function createBaseListWorkflowVersionsRequest(): ListWorkflowVersionsRequest {
  return { userAppId: undefined, workflowId: "", page: 0, perPage: 0 };
}

export const ListWorkflowVersionsRequest: MessageFns<ListWorkflowVersionsRequest> = {
  encode(message: ListWorkflowVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkflowVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListWorkflowVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkflowVersionsRequest>, I>>(base?: I): ListWorkflowVersionsRequest {
    return ListWorkflowVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkflowVersionsRequest>, I>>(object: I): ListWorkflowVersionsRequest {
    const message = createBaseListWorkflowVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetWorkflowVersionRequest(): GetWorkflowVersionRequest {
  return { userAppId: undefined, workflowId: "", workflowVersionId: "" };
}

export const GetWorkflowVersionRequest: MessageFns<GetWorkflowVersionRequest> = {
  encode(message: GetWorkflowVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkflowVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
    };
  },

  toJSON(message: GetWorkflowVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWorkflowVersionRequest>, I>>(base?: I): GetWorkflowVersionRequest {
    return GetWorkflowVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWorkflowVersionRequest>, I>>(object: I): GetWorkflowVersionRequest {
    const message = createBaseGetWorkflowVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    return message;
  },
};

function createBaseDeleteWorkflowVersionsRequest(): DeleteWorkflowVersionsRequest {
  return { userAppId: undefined, workflowId: "", workflowVersionIds: [] };
}

export const DeleteWorkflowVersionsRequest: MessageFns<DeleteWorkflowVersionsRequest> = {
  encode(message: DeleteWorkflowVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    for (const v of message.workflowVersionIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkflowVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkflowVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkflowVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionIds: globalThis.Array.isArray(object?.workflowVersionIds)
        ? object.workflowVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteWorkflowVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionIds?.length) {
      obj.workflowVersionIds = message.workflowVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteWorkflowVersionsRequest>, I>>(base?: I): DeleteWorkflowVersionsRequest {
    return DeleteWorkflowVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteWorkflowVersionsRequest>, I>>(
    object: I,
  ): DeleteWorkflowVersionsRequest {
    const message = createBaseDeleteWorkflowVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionIds = object.workflowVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePatchWorkflowVersionsRequest(): PatchWorkflowVersionsRequest {
  return { userAppId: undefined, workflowId: "", workflowVersions: [], action: "" };
}

export const PatchWorkflowVersionsRequest: MessageFns<PatchWorkflowVersionsRequest> = {
  encode(message: PatchWorkflowVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    for (const v of message.workflowVersions) {
      WorkflowVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchWorkflowVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchWorkflowVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersions.push(WorkflowVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchWorkflowVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersions: globalThis.Array.isArray(object?.workflowVersions)
        ? object.workflowVersions.map((e: any) => WorkflowVersion.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchWorkflowVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersions?.length) {
      obj.workflowVersions = message.workflowVersions.map((e) => WorkflowVersion.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchWorkflowVersionsRequest>, I>>(base?: I): PatchWorkflowVersionsRequest {
    return PatchWorkflowVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchWorkflowVersionsRequest>, I>>(object: I): PatchWorkflowVersionsRequest {
    const message = createBasePatchWorkflowVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersions = object.workflowVersions?.map((e) => WorkflowVersion.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseMultiWorkflowVersionResponse(): MultiWorkflowVersionResponse {
  return { status: undefined, workflowVersions: [] };
}

export const MultiWorkflowVersionResponse: MessageFns<MultiWorkflowVersionResponse> = {
  encode(message: MultiWorkflowVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflowVersions) {
      WorkflowVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiWorkflowVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiWorkflowVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersions.push(WorkflowVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiWorkflowVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersions: globalThis.Array.isArray(object?.workflowVersions)
        ? object.workflowVersions.map((e: any) => WorkflowVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiWorkflowVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersions?.length) {
      obj.workflowVersions = message.workflowVersions.map((e) => WorkflowVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiWorkflowVersionResponse>, I>>(base?: I): MultiWorkflowVersionResponse {
    return MultiWorkflowVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiWorkflowVersionResponse>, I>>(object: I): MultiWorkflowVersionResponse {
    const message = createBaseMultiWorkflowVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersions = object.workflowVersions?.map((e) => WorkflowVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleWorkflowVersionResponse(): SingleWorkflowVersionResponse {
  return { status: undefined, workflowVersion: undefined };
}

export const SingleWorkflowVersionResponse: MessageFns<SingleWorkflowVersionResponse> = {
  encode(message: SingleWorkflowVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.workflowVersion !== undefined) {
      WorkflowVersion.encode(message.workflowVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleWorkflowVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleWorkflowVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersion = WorkflowVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleWorkflowVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersion: isSet(object.workflowVersion) ? WorkflowVersion.fromJSON(object.workflowVersion) : undefined,
    };
  },

  toJSON(message: SingleWorkflowVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersion !== undefined) {
      obj.workflowVersion = WorkflowVersion.toJSON(message.workflowVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleWorkflowVersionResponse>, I>>(base?: I): SingleWorkflowVersionResponse {
    return SingleWorkflowVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleWorkflowVersionResponse>, I>>(
    object: I,
  ): SingleWorkflowVersionResponse {
    const message = createBaseSingleWorkflowVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersion = (object.workflowVersion !== undefined && object.workflowVersion !== null)
      ? WorkflowVersion.fromPartial(object.workflowVersion)
      : undefined;
    return message;
  },
};

function createBasePostAppDuplicationsRequest(): PostAppDuplicationsRequest {
  return { userAppId: undefined, appDuplications: [] };
}

export const PostAppDuplicationsRequest: MessageFns<PostAppDuplicationsRequest> = {
  encode(message: PostAppDuplicationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.appDuplications) {
      AppDuplication.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAppDuplicationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAppDuplicationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appDuplications.push(AppDuplication.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAppDuplicationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      appDuplications: globalThis.Array.isArray(object?.appDuplications)
        ? object.appDuplications.map((e: any) => AppDuplication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostAppDuplicationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.appDuplications?.length) {
      obj.appDuplications = message.appDuplications.map((e) => AppDuplication.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAppDuplicationsRequest>, I>>(base?: I): PostAppDuplicationsRequest {
    return PostAppDuplicationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAppDuplicationsRequest>, I>>(object: I): PostAppDuplicationsRequest {
    const message = createBasePostAppDuplicationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.appDuplications = object.appDuplications?.map((e) => AppDuplication.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAppDuplicationRequest(): GetAppDuplicationRequest {
  return { userAppId: undefined, appDuplicationId: "" };
}

export const GetAppDuplicationRequest: MessageFns<GetAppDuplicationRequest> = {
  encode(message: GetAppDuplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.appDuplicationId !== "") {
      writer.uint32(18).string(message.appDuplicationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAppDuplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAppDuplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appDuplicationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAppDuplicationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      appDuplicationId: isSet(object.appDuplicationId) ? globalThis.String(object.appDuplicationId) : "",
    };
  },

  toJSON(message: GetAppDuplicationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.appDuplicationId !== "") {
      obj.appDuplicationId = message.appDuplicationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAppDuplicationRequest>, I>>(base?: I): GetAppDuplicationRequest {
    return GetAppDuplicationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAppDuplicationRequest>, I>>(object: I): GetAppDuplicationRequest {
    const message = createBaseGetAppDuplicationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.appDuplicationId = object.appDuplicationId ?? "";
    return message;
  },
};

function createBaseListAppDuplicationsRequest(): ListAppDuplicationsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListAppDuplicationsRequest: MessageFns<ListAppDuplicationsRequest> = {
  encode(message: ListAppDuplicationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAppDuplicationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAppDuplicationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAppDuplicationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListAppDuplicationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAppDuplicationsRequest>, I>>(base?: I): ListAppDuplicationsRequest {
    return ListAppDuplicationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAppDuplicationsRequest>, I>>(object: I): ListAppDuplicationsRequest {
    const message = createBaseListAppDuplicationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseMultiAppDuplicationsResponse(): MultiAppDuplicationsResponse {
  return { status: undefined, appDuplications: [] };
}

export const MultiAppDuplicationsResponse: MessageFns<MultiAppDuplicationsResponse> = {
  encode(message: MultiAppDuplicationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.appDuplications) {
      AppDuplication.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAppDuplicationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAppDuplicationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appDuplications.push(AppDuplication.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAppDuplicationsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      appDuplications: globalThis.Array.isArray(object?.appDuplications)
        ? object.appDuplications.map((e: any) => AppDuplication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAppDuplicationsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.appDuplications?.length) {
      obj.appDuplications = message.appDuplications.map((e) => AppDuplication.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAppDuplicationsResponse>, I>>(base?: I): MultiAppDuplicationsResponse {
    return MultiAppDuplicationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAppDuplicationsResponse>, I>>(object: I): MultiAppDuplicationsResponse {
    const message = createBaseMultiAppDuplicationsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.appDuplications = object.appDuplications?.map((e) => AppDuplication.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleAppDuplicationResponse(): SingleAppDuplicationResponse {
  return { status: undefined, appDuplication: undefined };
}

export const SingleAppDuplicationResponse: MessageFns<SingleAppDuplicationResponse> = {
  encode(message: SingleAppDuplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.appDuplication !== undefined) {
      AppDuplication.encode(message.appDuplication, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleAppDuplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleAppDuplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appDuplication = AppDuplication.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleAppDuplicationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      appDuplication: isSet(object.appDuplication) ? AppDuplication.fromJSON(object.appDuplication) : undefined,
    };
  },

  toJSON(message: SingleAppDuplicationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.appDuplication !== undefined) {
      obj.appDuplication = AppDuplication.toJSON(message.appDuplication);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleAppDuplicationResponse>, I>>(base?: I): SingleAppDuplicationResponse {
    return SingleAppDuplicationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleAppDuplicationResponse>, I>>(object: I): SingleAppDuplicationResponse {
    const message = createBaseSingleAppDuplicationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.appDuplication = (object.appDuplication !== undefined && object.appDuplication !== null)
      ? AppDuplication.fromPartial(object.appDuplication)
      : undefined;
    return message;
  },
};

function createBasePostTasksRequest(): PostTasksRequest {
  return { userAppId: undefined, tasks: [] };
}

export const PostTasksRequest: MessageFns<PostTasksRequest> = {
  encode(message: PostTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostTasksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostTasksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostTasksRequest>, I>>(base?: I): PostTasksRequest {
    return PostTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostTasksRequest>, I>>(object: I): PostTasksRequest {
    const message = createBasePostTasksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { userAppId: undefined, taskId: "", additionalFields: [] };
}

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  encode(message: GetTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    for (const v of message.additionalFields) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetTaskRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskRequest>, I>>(base?: I): GetTaskRequest {
    return GetTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskRequest>, I>>(object: I): GetTaskRequest {
    const message = createBaseGetTaskRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.taskId = object.taskId ?? "";
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseListTasksRequest(): ListTasksRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    workerUserIds: [],
    reviewUserIds: [],
    labelOrderIds: [],
    includingLabelOrderTasks: false,
    additionalFields: [],
    ids: [],
    inputSourceType: 0,
    inputSourceIds: [],
  };
}

export const ListTasksRequest: MessageFns<ListTasksRequest> = {
  encode(message: ListTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.workerUserIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.reviewUserIds) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.labelOrderIds) {
      writer.uint32(66).string(v!);
    }
    if (message.includingLabelOrderTasks !== false) {
      writer.uint32(48).bool(message.includingLabelOrderTasks);
    }
    for (const v of message.additionalFields) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.ids) {
      writer.uint32(74).string(v!);
    }
    if (message.inputSourceType !== 0) {
      writer.uint32(80).int32(message.inputSourceType);
    }
    for (const v of message.inputSourceIds) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workerUserIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reviewUserIds.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.labelOrderIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.includingLabelOrderTasks = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.inputSourceType = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inputSourceIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      workerUserIds: globalThis.Array.isArray(object?.workerUserIds)
        ? object.workerUserIds.map((e: any) => globalThis.String(e))
        : [],
      reviewUserIds: globalThis.Array.isArray(object?.reviewUserIds)
        ? object.reviewUserIds.map((e: any) => globalThis.String(e))
        : [],
      labelOrderIds: globalThis.Array.isArray(object?.labelOrderIds)
        ? object.labelOrderIds.map((e: any) => globalThis.String(e))
        : [],
      includingLabelOrderTasks: isSet(object.includingLabelOrderTasks)
        ? globalThis.Boolean(object.includingLabelOrderTasks)
        : false,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      inputSourceType: isSet(object.inputSourceType)
        ? taskInputSource_TaskInputSourceTypeFromJSON(object.inputSourceType)
        : 0,
      inputSourceIds: globalThis.Array.isArray(object?.inputSourceIds)
        ? object.inputSourceIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListTasksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.workerUserIds?.length) {
      obj.workerUserIds = message.workerUserIds;
    }
    if (message.reviewUserIds?.length) {
      obj.reviewUserIds = message.reviewUserIds;
    }
    if (message.labelOrderIds?.length) {
      obj.labelOrderIds = message.labelOrderIds;
    }
    if (message.includingLabelOrderTasks !== false) {
      obj.includingLabelOrderTasks = message.includingLabelOrderTasks;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.inputSourceType !== 0) {
      obj.inputSourceType = taskInputSource_TaskInputSourceTypeToJSON(message.inputSourceType);
    }
    if (message.inputSourceIds?.length) {
      obj.inputSourceIds = message.inputSourceIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksRequest>, I>>(base?: I): ListTasksRequest {
    return ListTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksRequest>, I>>(object: I): ListTasksRequest {
    const message = createBaseListTasksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.workerUserIds = object.workerUserIds?.map((e) => e) || [];
    message.reviewUserIds = object.reviewUserIds?.map((e) => e) || [];
    message.labelOrderIds = object.labelOrderIds?.map((e) => e) || [];
    message.includingLabelOrderTasks = object.includingLabelOrderTasks ?? false;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.inputSourceType = object.inputSourceType ?? 0;
    message.inputSourceIds = object.inputSourceIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePatchTasksRequest(): PatchTasksRequest {
  return { userAppId: undefined, tasks: [], action: "" };
}

export const PatchTasksRequest: MessageFns<PatchTasksRequest> = {
  encode(message: PatchTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchTasksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchTasksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchTasksRequest>, I>>(base?: I): PatchTasksRequest {
    return PatchTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchTasksRequest>, I>>(object: I): PatchTasksRequest {
    const message = createBasePatchTasksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteTasksRequest(): DeleteTasksRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteTasksRequest: MessageFns<DeleteTasksRequest> = {
  encode(message: DeleteTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTasksRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteTasksRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTasksRequest>, I>>(base?: I): DeleteTasksRequest {
    return DeleteTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTasksRequest>, I>>(object: I): DeleteTasksRequest {
    const message = createBaseDeleteTasksRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiTaskResponse(): MultiTaskResponse {
  return { status: undefined, tasks: [] };
}

export const MultiTaskResponse: MessageFns<MultiTaskResponse> = {
  encode(message: MultiTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiTaskResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiTaskResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiTaskResponse>, I>>(base?: I): MultiTaskResponse {
    return MultiTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiTaskResponse>, I>>(object: I): MultiTaskResponse {
    const message = createBaseMultiTaskResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleTaskResponse(): SingleTaskResponse {
  return { status: undefined, task: undefined };
}

export const SingleTaskResponse: MessageFns<SingleTaskResponse> = {
  encode(message: SingleTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleTaskResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: SingleTaskResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleTaskResponse>, I>>(base?: I): SingleTaskResponse {
    return SingleTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleTaskResponse>, I>>(object: I): SingleTaskResponse {
    const message = createBaseSingleTaskResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    return message;
  },
};

function createBaseGetTaskCountRequest(): GetTaskCountRequest {
  return { userAppId: undefined, taskId: "", userIds: [], modelVersionIds: [], workflowVersionIds: [] };
}

export const GetTaskCountRequest: MessageFns<GetTaskCountRequest> = {
  encode(message: GetTaskCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.modelVersionIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.workflowVersionIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelVersionIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskCountRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      modelVersionIds: globalThis.Array.isArray(object?.modelVersionIds)
        ? object.modelVersionIds.map((e: any) => globalThis.String(e))
        : [],
      workflowVersionIds: globalThis.Array.isArray(object?.workflowVersionIds)
        ? object.workflowVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetTaskCountRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.modelVersionIds?.length) {
      obj.modelVersionIds = message.modelVersionIds;
    }
    if (message.workflowVersionIds?.length) {
      obj.workflowVersionIds = message.workflowVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskCountRequest>, I>>(base?: I): GetTaskCountRequest {
    return GetTaskCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskCountRequest>, I>>(object: I): GetTaskCountRequest {
    const message = createBaseGetTaskCountRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.taskId = object.taskId ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    message.modelVersionIds = object.modelVersionIds?.map((e) => e) || [];
    message.workflowVersionIds = object.workflowVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleTaskCountResponse(): SingleTaskCountResponse {
  return { status: undefined, appId: "", taskId: "", counts: [] };
}

export const SingleTaskCountResponse: MessageFns<SingleTaskCountResponse> = {
  encode(message: SingleTaskCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.taskId !== "") {
      writer.uint32(26).string(message.taskId);
    }
    for (const v of message.counts) {
      TaskStatusCountPerUser.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleTaskCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleTaskCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.counts.push(TaskStatusCountPerUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleTaskCountResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      counts: globalThis.Array.isArray(object?.counts)
        ? object.counts.map((e: any) => TaskStatusCountPerUser.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SingleTaskCountResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.counts?.length) {
      obj.counts = message.counts.map((e) => TaskStatusCountPerUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleTaskCountResponse>, I>>(base?: I): SingleTaskCountResponse {
    return SingleTaskCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleTaskCountResponse>, I>>(object: I): SingleTaskCountResponse {
    const message = createBaseSingleTaskCountResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.appId = object.appId ?? "";
    message.taskId = object.taskId ?? "";
    message.counts = object.counts?.map((e) => TaskStatusCountPerUser.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostLabelOrdersRequest(): PostLabelOrdersRequest {
  return { userAppId: undefined, labelOrders: [] };
}

export const PostLabelOrdersRequest: MessageFns<PostLabelOrdersRequest> = {
  encode(message: PostLabelOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.labelOrders) {
      LabelOrder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostLabelOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostLabelOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelOrders.push(LabelOrder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostLabelOrdersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      labelOrders: globalThis.Array.isArray(object?.labelOrders)
        ? object.labelOrders.map((e: any) => LabelOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostLabelOrdersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.labelOrders?.length) {
      obj.labelOrders = message.labelOrders.map((e) => LabelOrder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostLabelOrdersRequest>, I>>(base?: I): PostLabelOrdersRequest {
    return PostLabelOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostLabelOrdersRequest>, I>>(object: I): PostLabelOrdersRequest {
    const message = createBasePostLabelOrdersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.labelOrders = object.labelOrders?.map((e) => LabelOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetLabelOrderRequest(): GetLabelOrderRequest {
  return { userAppId: undefined, labelOrderId: "" };
}

export const GetLabelOrderRequest: MessageFns<GetLabelOrderRequest> = {
  encode(message: GetLabelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.labelOrderId !== "") {
      writer.uint32(18).string(message.labelOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLabelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLabelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelOrderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLabelOrderRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      labelOrderId: isSet(object.labelOrderId) ? globalThis.String(object.labelOrderId) : "",
    };
  },

  toJSON(message: GetLabelOrderRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.labelOrderId !== "") {
      obj.labelOrderId = message.labelOrderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLabelOrderRequest>, I>>(base?: I): GetLabelOrderRequest {
    return GetLabelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLabelOrderRequest>, I>>(object: I): GetLabelOrderRequest {
    const message = createBaseGetLabelOrderRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.labelOrderId = object.labelOrderId ?? "";
    return message;
  },
};

function createBaseListLabelOrdersRequest(): ListLabelOrdersRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListLabelOrdersRequest: MessageFns<ListLabelOrdersRequest> = {
  encode(message: ListLabelOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLabelOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLabelOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLabelOrdersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListLabelOrdersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListLabelOrdersRequest>, I>>(base?: I): ListLabelOrdersRequest {
    return ListLabelOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListLabelOrdersRequest>, I>>(object: I): ListLabelOrdersRequest {
    const message = createBaseListLabelOrdersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePatchLabelOrdersRequest(): PatchLabelOrdersRequest {
  return { userAppId: undefined, labelOrders: [], action: "" };
}

export const PatchLabelOrdersRequest: MessageFns<PatchLabelOrdersRequest> = {
  encode(message: PatchLabelOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.labelOrders) {
      LabelOrder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchLabelOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchLabelOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelOrders.push(LabelOrder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchLabelOrdersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      labelOrders: globalThis.Array.isArray(object?.labelOrders)
        ? object.labelOrders.map((e: any) => LabelOrder.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchLabelOrdersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.labelOrders?.length) {
      obj.labelOrders = message.labelOrders.map((e) => LabelOrder.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchLabelOrdersRequest>, I>>(base?: I): PatchLabelOrdersRequest {
    return PatchLabelOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchLabelOrdersRequest>, I>>(object: I): PatchLabelOrdersRequest {
    const message = createBasePatchLabelOrdersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.labelOrders = object.labelOrders?.map((e) => LabelOrder.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteLabelOrdersRequest(): DeleteLabelOrdersRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteLabelOrdersRequest: MessageFns<DeleteLabelOrdersRequest> = {
  encode(message: DeleteLabelOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLabelOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLabelOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteLabelOrdersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteLabelOrdersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteLabelOrdersRequest>, I>>(base?: I): DeleteLabelOrdersRequest {
    return DeleteLabelOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteLabelOrdersRequest>, I>>(object: I): DeleteLabelOrdersRequest {
    const message = createBaseDeleteLabelOrdersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiLabelOrderResponse(): MultiLabelOrderResponse {
  return { status: undefined, labelOrders: [] };
}

export const MultiLabelOrderResponse: MessageFns<MultiLabelOrderResponse> = {
  encode(message: MultiLabelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.labelOrders) {
      LabelOrder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLabelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLabelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelOrders.push(LabelOrder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiLabelOrderResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      labelOrders: globalThis.Array.isArray(object?.labelOrders)
        ? object.labelOrders.map((e: any) => LabelOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiLabelOrderResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.labelOrders?.length) {
      obj.labelOrders = message.labelOrders.map((e) => LabelOrder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiLabelOrderResponse>, I>>(base?: I): MultiLabelOrderResponse {
    return MultiLabelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLabelOrderResponse>, I>>(object: I): MultiLabelOrderResponse {
    const message = createBaseMultiLabelOrderResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.labelOrders = object.labelOrders?.map((e) => LabelOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleLabelOrderResponse(): SingleLabelOrderResponse {
  return { status: undefined, labelOrder: undefined };
}

export const SingleLabelOrderResponse: MessageFns<SingleLabelOrderResponse> = {
  encode(message: SingleLabelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.labelOrder !== undefined) {
      LabelOrder.encode(message.labelOrder, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleLabelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleLabelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelOrder = LabelOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleLabelOrderResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      labelOrder: isSet(object.labelOrder) ? LabelOrder.fromJSON(object.labelOrder) : undefined,
    };
  },

  toJSON(message: SingleLabelOrderResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.labelOrder !== undefined) {
      obj.labelOrder = LabelOrder.toJSON(message.labelOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleLabelOrderResponse>, I>>(base?: I): SingleLabelOrderResponse {
    return SingleLabelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleLabelOrderResponse>, I>>(object: I): SingleLabelOrderResponse {
    const message = createBaseSingleLabelOrderResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.labelOrder = (object.labelOrder !== undefined && object.labelOrder !== null)
      ? LabelOrder.fromPartial(object.labelOrder)
      : undefined;
    return message;
  },
};

function createBasePostCollectorsRequest(): PostCollectorsRequest {
  return { userAppId: undefined, collectors: [] };
}

export const PostCollectorsRequest: MessageFns<PostCollectorsRequest> = {
  encode(message: PostCollectorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.collectors) {
      Collector.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostCollectorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostCollectorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectors.push(Collector.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostCollectorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collectors: globalThis.Array.isArray(object?.collectors)
        ? object.collectors.map((e: any) => Collector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostCollectorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collectors?.length) {
      obj.collectors = message.collectors.map((e) => Collector.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostCollectorsRequest>, I>>(base?: I): PostCollectorsRequest {
    return PostCollectorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostCollectorsRequest>, I>>(object: I): PostCollectorsRequest {
    const message = createBasePostCollectorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collectors = object.collectors?.map((e) => Collector.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchCollectorsRequest(): PatchCollectorsRequest {
  return { userAppId: undefined, collectors: [], action: "" };
}

export const PatchCollectorsRequest: MessageFns<PatchCollectorsRequest> = {
  encode(message: PatchCollectorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.collectors) {
      Collector.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchCollectorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchCollectorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectors.push(Collector.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchCollectorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collectors: globalThis.Array.isArray(object?.collectors)
        ? object.collectors.map((e: any) => Collector.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchCollectorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collectors?.length) {
      obj.collectors = message.collectors.map((e) => Collector.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchCollectorsRequest>, I>>(base?: I): PatchCollectorsRequest {
    return PatchCollectorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchCollectorsRequest>, I>>(object: I): PatchCollectorsRequest {
    const message = createBasePatchCollectorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collectors = object.collectors?.map((e) => Collector.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteCollectorsRequest(): DeleteCollectorsRequest {
  return { userAppId: undefined, ids: [], deleteAll: false };
}

export const DeleteCollectorsRequest: MessageFns<DeleteCollectorsRequest> = {
  encode(message: DeleteCollectorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    if (message.deleteAll !== false) {
      writer.uint32(24).bool(message.deleteAll);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deleteAll = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      deleteAll: isSet(object.deleteAll) ? globalThis.Boolean(object.deleteAll) : false,
    };
  },

  toJSON(message: DeleteCollectorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.deleteAll !== false) {
      obj.deleteAll = message.deleteAll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollectorsRequest>, I>>(base?: I): DeleteCollectorsRequest {
    return DeleteCollectorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollectorsRequest>, I>>(object: I): DeleteCollectorsRequest {
    const message = createBaseDeleteCollectorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    message.deleteAll = object.deleteAll ?? false;
    return message;
  },
};

function createBaseGetCollectorRequest(): GetCollectorRequest {
  return { userAppId: undefined, collectorId: "" };
}

export const GetCollectorRequest: MessageFns<GetCollectorRequest> = {
  encode(message: GetCollectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.collectorId !== "") {
      writer.uint32(18).string(message.collectorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectorRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      collectorId: isSet(object.collectorId) ? globalThis.String(object.collectorId) : "",
    };
  },

  toJSON(message: GetCollectorRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.collectorId !== "") {
      obj.collectorId = message.collectorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectorRequest>, I>>(base?: I): GetCollectorRequest {
    return GetCollectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectorRequest>, I>>(object: I): GetCollectorRequest {
    const message = createBaseGetCollectorRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.collectorId = object.collectorId ?? "";
    return message;
  },
};

function createBaseListCollectorsRequest(): ListCollectorsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListCollectorsRequest: MessageFns<ListCollectorsRequest> = {
  encode(message: ListCollectorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectorsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListCollectorsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectorsRequest>, I>>(base?: I): ListCollectorsRequest {
    return ListCollectorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectorsRequest>, I>>(object: I): ListCollectorsRequest {
    const message = createBaseListCollectorsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseMultiCollectorResponse(): MultiCollectorResponse {
  return { status: undefined, collectors: [] };
}

export const MultiCollectorResponse: MessageFns<MultiCollectorResponse> = {
  encode(message: MultiCollectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.collectors) {
      Collector.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCollectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCollectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectors.push(Collector.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCollectorResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      collectors: globalThis.Array.isArray(object?.collectors)
        ? object.collectors.map((e: any) => Collector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiCollectorResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.collectors?.length) {
      obj.collectors = message.collectors.map((e) => Collector.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCollectorResponse>, I>>(base?: I): MultiCollectorResponse {
    return MultiCollectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCollectorResponse>, I>>(object: I): MultiCollectorResponse {
    const message = createBaseMultiCollectorResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.collectors = object.collectors?.map((e) => Collector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleCollectorResponse(): SingleCollectorResponse {
  return { status: undefined, collector: undefined };
}

export const SingleCollectorResponse: MessageFns<SingleCollectorResponse> = {
  encode(message: SingleCollectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.collector !== undefined) {
      Collector.encode(message.collector, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleCollectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleCollectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collector = Collector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleCollectorResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      collector: isSet(object.collector) ? Collector.fromJSON(object.collector) : undefined,
    };
  },

  toJSON(message: SingleCollectorResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.collector !== undefined) {
      obj.collector = Collector.toJSON(message.collector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleCollectorResponse>, I>>(base?: I): SingleCollectorResponse {
    return SingleCollectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleCollectorResponse>, I>>(object: I): SingleCollectorResponse {
    const message = createBaseSingleCollectorResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.collector = (object.collector !== undefined && object.collector !== null)
      ? Collector.fromPartial(object.collector)
      : undefined;
    return message;
  },
};

function createBasePostStatValuesRequest(): PostStatValuesRequest {
  return { userAppId: undefined, statValues: [] };
}

export const PostStatValuesRequest: MessageFns<PostStatValuesRequest> = {
  encode(message: PostStatValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.statValues) {
      StatValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostStatValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostStatValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statValues.push(StatValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostStatValuesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      statValues: globalThis.Array.isArray(object?.statValues)
        ? object.statValues.map((e: any) => StatValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostStatValuesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.statValues?.length) {
      obj.statValues = message.statValues.map((e) => StatValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostStatValuesRequest>, I>>(base?: I): PostStatValuesRequest {
    return PostStatValuesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostStatValuesRequest>, I>>(object: I): PostStatValuesRequest {
    const message = createBasePostStatValuesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.statValues = object.statValues?.map((e) => StatValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiStatValueResponse(): MultiStatValueResponse {
  return { status: undefined, statValues: [] };
}

export const MultiStatValueResponse: MessageFns<MultiStatValueResponse> = {
  encode(message: MultiStatValueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.statValues) {
      StatValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiStatValueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiStatValueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statValues.push(StatValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiStatValueResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      statValues: globalThis.Array.isArray(object?.statValues)
        ? object.statValues.map((e: any) => StatValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiStatValueResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.statValues?.length) {
      obj.statValues = message.statValues.map((e) => StatValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiStatValueResponse>, I>>(base?: I): MultiStatValueResponse {
    return MultiStatValueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiStatValueResponse>, I>>(object: I): MultiStatValueResponse {
    const message = createBaseMultiStatValueResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.statValues = object.statValues?.map((e) => StatValue.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostStatValuesAggregateRequest(): PostStatValuesAggregateRequest {
  return { userAppId: undefined, statValueAggregateQueries: [] };
}

export const PostStatValuesAggregateRequest: MessageFns<PostStatValuesAggregateRequest> = {
  encode(message: PostStatValuesAggregateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.statValueAggregateQueries) {
      StatValueAggregateQuery.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostStatValuesAggregateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostStatValuesAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statValueAggregateQueries.push(StatValueAggregateQuery.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostStatValuesAggregateRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      statValueAggregateQueries: globalThis.Array.isArray(object?.statValueAggregateQueries)
        ? object.statValueAggregateQueries.map((e: any) => StatValueAggregateQuery.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostStatValuesAggregateRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.statValueAggregateQueries?.length) {
      obj.statValueAggregateQueries = message.statValueAggregateQueries.map((e) => StatValueAggregateQuery.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostStatValuesAggregateRequest>, I>>(base?: I): PostStatValuesAggregateRequest {
    return PostStatValuesAggregateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostStatValuesAggregateRequest>, I>>(
    object: I,
  ): PostStatValuesAggregateRequest {
    const message = createBasePostStatValuesAggregateRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.statValueAggregateQueries =
      object.statValueAggregateQueries?.map((e) => StatValueAggregateQuery.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiStatValueAggregateResponse(): MultiStatValueAggregateResponse {
  return { status: undefined, statValueAggregateResults: [] };
}

export const MultiStatValueAggregateResponse: MessageFns<MultiStatValueAggregateResponse> = {
  encode(message: MultiStatValueAggregateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.statValueAggregateResults) {
      StatValueAggregateResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiStatValueAggregateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiStatValueAggregateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statValueAggregateResults.push(StatValueAggregateResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiStatValueAggregateResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      statValueAggregateResults: globalThis.Array.isArray(object?.statValueAggregateResults)
        ? object.statValueAggregateResults.map((e: any) => StatValueAggregateResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiStatValueAggregateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.statValueAggregateResults?.length) {
      obj.statValueAggregateResults = message.statValueAggregateResults.map((e) => StatValueAggregateResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiStatValueAggregateResponse>, I>>(base?: I): MultiStatValueAggregateResponse {
    return MultiStatValueAggregateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiStatValueAggregateResponse>, I>>(
    object: I,
  ): MultiStatValueAggregateResponse {
    const message = createBaseMultiStatValueAggregateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.statValueAggregateResults =
      object.statValueAggregateResults?.map((e) => StatValueAggregateResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetModuleRequest(): GetModuleRequest {
  return { userAppId: undefined, moduleId: "", additionalFields: [] };
}

export const GetModuleRequest: MessageFns<GetModuleRequest> = {
  encode(message: GetModuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    for (const v of message.additionalFields) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModuleRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetModuleRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModuleRequest>, I>>(base?: I): GetModuleRequest {
    return GetModuleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModuleRequest>, I>>(object: I): GetModuleRequest {
    const message = createBaseGetModuleRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseListModulesRequest(): ListModulesRequest {
  return {
    userAppId: undefined,
    page: 0,
    perPage: 0,
    additionalFields: [],
    sortAscending: false,
    sortByCreatedAt: undefined,
    sortByStarCount: undefined,
    sortByModifiedAt: undefined,
    sortById: undefined,
    starredOnly: false,
    bookmark: false,
    search: "",
    name: "",
    filterByUserId: false,
    visibility: undefined,
  };
}

export const ListModulesRequest: MessageFns<ListModulesRequest> = {
  encode(message: ListModulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    for (const v of message.additionalFields) {
      writer.uint32(42).string(v!);
    }
    if (message.sortAscending !== false) {
      writer.uint32(48).bool(message.sortAscending);
    }
    if (message.sortByCreatedAt !== undefined) {
      writer.uint32(56).bool(message.sortByCreatedAt);
    }
    if (message.sortByStarCount !== undefined) {
      writer.uint32(64).bool(message.sortByStarCount);
    }
    if (message.sortByModifiedAt !== undefined) {
      writer.uint32(72).bool(message.sortByModifiedAt);
    }
    if (message.sortById !== undefined) {
      writer.uint32(88).bool(message.sortById);
    }
    if (message.starredOnly !== false) {
      writer.uint32(32).bool(message.starredOnly);
    }
    if (message.bookmark !== false) {
      writer.uint32(80).bool(message.bookmark);
    }
    if (message.search !== "") {
      writer.uint32(114).string(message.search);
    }
    if (message.name !== "") {
      writer.uint32(98).string(message.name);
    }
    if (message.filterByUserId !== false) {
      writer.uint32(104).bool(message.filterByUserId);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.additionalFields.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sortByCreatedAt = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sortByStarCount = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sortByModifiedAt = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sortById = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.starredOnly = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.bookmark = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.filterByUserId = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModulesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      additionalFields: globalThis.Array.isArray(object?.additionalFields)
        ? object.additionalFields.map((e: any) => globalThis.String(e))
        : [],
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      sortByCreatedAt: isSet(object.sortByCreatedAt) ? globalThis.Boolean(object.sortByCreatedAt) : undefined,
      sortByStarCount: isSet(object.sortByStarCount) ? globalThis.Boolean(object.sortByStarCount) : undefined,
      sortByModifiedAt: isSet(object.sortByModifiedAt) ? globalThis.Boolean(object.sortByModifiedAt) : undefined,
      sortById: isSet(object.sortById) ? globalThis.Boolean(object.sortById) : undefined,
      starredOnly: isSet(object.starredOnly) ? globalThis.Boolean(object.starredOnly) : false,
      bookmark: isSet(object.bookmark) ? globalThis.Boolean(object.bookmark) : false,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filterByUserId: isSet(object.filterByUserId) ? globalThis.Boolean(object.filterByUserId) : false,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
    };
  },

  toJSON(message: ListModulesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.additionalFields?.length) {
      obj.additionalFields = message.additionalFields;
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.sortByCreatedAt !== undefined) {
      obj.sortByCreatedAt = message.sortByCreatedAt;
    }
    if (message.sortByStarCount !== undefined) {
      obj.sortByStarCount = message.sortByStarCount;
    }
    if (message.sortByModifiedAt !== undefined) {
      obj.sortByModifiedAt = message.sortByModifiedAt;
    }
    if (message.sortById !== undefined) {
      obj.sortById = message.sortById;
    }
    if (message.starredOnly !== false) {
      obj.starredOnly = message.starredOnly;
    }
    if (message.bookmark !== false) {
      obj.bookmark = message.bookmark;
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filterByUserId !== false) {
      obj.filterByUserId = message.filterByUserId;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModulesRequest>, I>>(base?: I): ListModulesRequest {
    return ListModulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModulesRequest>, I>>(object: I): ListModulesRequest {
    const message = createBaseListModulesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.additionalFields = object.additionalFields?.map((e) => e) || [];
    message.sortAscending = object.sortAscending ?? false;
    message.sortByCreatedAt = object.sortByCreatedAt ?? undefined;
    message.sortByStarCount = object.sortByStarCount ?? undefined;
    message.sortByModifiedAt = object.sortByModifiedAt ?? undefined;
    message.sortById = object.sortById ?? undefined;
    message.starredOnly = object.starredOnly ?? false;
    message.bookmark = object.bookmark ?? false;
    message.search = object.search ?? "";
    message.name = object.name ?? "";
    message.filterByUserId = object.filterByUserId ?? false;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    return message;
  },
};

function createBasePostModulesRequest(): PostModulesRequest {
  return { userAppId: undefined, modules: [] };
}

export const PostModulesRequest: MessageFns<PostModulesRequest> = {
  encode(message: PostModulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.modules) {
      Module.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modules.push(Module.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModulesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modules: globalThis.Array.isArray(object?.modules) ? object.modules.map((e: any) => Module.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostModulesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modules?.length) {
      obj.modules = message.modules.map((e) => Module.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModulesRequest>, I>>(base?: I): PostModulesRequest {
    return PostModulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModulesRequest>, I>>(object: I): PostModulesRequest {
    const message = createBasePostModulesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modules = object.modules?.map((e) => Module.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchModulesRequest(): PatchModulesRequest {
  return { userAppId: undefined, modules: [], action: "" };
}

export const PatchModulesRequest: MessageFns<PatchModulesRequest> = {
  encode(message: PatchModulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.modules) {
      Module.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modules.push(Module.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModulesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modules: globalThis.Array.isArray(object?.modules) ? object.modules.map((e: any) => Module.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModulesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modules?.length) {
      obj.modules = message.modules.map((e) => Module.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModulesRequest>, I>>(base?: I): PatchModulesRequest {
    return PatchModulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModulesRequest>, I>>(object: I): PatchModulesRequest {
    const message = createBasePatchModulesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modules = object.modules?.map((e) => Module.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteModulesRequest(): DeleteModulesRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteModulesRequest: MessageFns<DeleteModulesRequest> = {
  encode(message: DeleteModulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModulesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteModulesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteModulesRequest>, I>>(base?: I): DeleteModulesRequest {
    return DeleteModulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteModulesRequest>, I>>(object: I): DeleteModulesRequest {
    const message = createBaseDeleteModulesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleModuleResponse(): SingleModuleResponse {
  return { status: undefined, module: undefined };
}

export const SingleModuleResponse: MessageFns<SingleModuleResponse> = {
  encode(message: SingleModuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.module !== undefined) {
      Module.encode(message.module, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.module = Module.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModuleResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      module: isSet(object.module) ? Module.fromJSON(object.module) : undefined,
    };
  },

  toJSON(message: SingleModuleResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.module !== undefined) {
      obj.module = Module.toJSON(message.module);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModuleResponse>, I>>(base?: I): SingleModuleResponse {
    return SingleModuleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModuleResponse>, I>>(object: I): SingleModuleResponse {
    const message = createBaseSingleModuleResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.module = (object.module !== undefined && object.module !== null)
      ? Module.fromPartial(object.module)
      : undefined;
    return message;
  },
};

function createBaseMultiModuleResponse(): MultiModuleResponse {
  return { status: undefined, modules: [] };
}

export const MultiModuleResponse: MessageFns<MultiModuleResponse> = {
  encode(message: MultiModuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.modules) {
      Module.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modules.push(Module.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModuleResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      modules: globalThis.Array.isArray(object?.modules) ? object.modules.map((e: any) => Module.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiModuleResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.modules?.length) {
      obj.modules = message.modules.map((e) => Module.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModuleResponse>, I>>(base?: I): MultiModuleResponse {
    return MultiModuleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModuleResponse>, I>>(object: I): MultiModuleResponse {
    const message = createBaseMultiModuleResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.modules = object.modules?.map((e) => Module.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetModuleVersionRequest(): GetModuleVersionRequest {
  return { userAppId: undefined, moduleId: "", moduleVersionId: "" };
}

export const GetModuleVersionRequest: MessageFns<GetModuleVersionRequest> = {
  encode(message: GetModuleVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    if (message.moduleVersionId !== "") {
      writer.uint32(26).string(message.moduleVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModuleVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModuleVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModuleVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      moduleVersionId: isSet(object.moduleVersionId) ? globalThis.String(object.moduleVersionId) : "",
    };
  },

  toJSON(message: GetModuleVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.moduleVersionId !== "") {
      obj.moduleVersionId = message.moduleVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModuleVersionRequest>, I>>(base?: I): GetModuleVersionRequest {
    return GetModuleVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModuleVersionRequest>, I>>(object: I): GetModuleVersionRequest {
    const message = createBaseGetModuleVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.moduleVersionId = object.moduleVersionId ?? "";
    return message;
  },
};

function createBaseListModuleVersionsRequest(): ListModuleVersionsRequest {
  return { userAppId: undefined, moduleId: "", page: 0, perPage: 0 };
}

export const ListModuleVersionsRequest: MessageFns<ListModuleVersionsRequest> = {
  encode(message: ListModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModuleVersionsRequest>, I>>(base?: I): ListModuleVersionsRequest {
    return ListModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModuleVersionsRequest>, I>>(object: I): ListModuleVersionsRequest {
    const message = createBaseListModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostModuleVersionsRequest(): PostModuleVersionsRequest {
  return { userAppId: undefined, moduleId: "", moduleVersions: [] };
}

export const PostModuleVersionsRequest: MessageFns<PostModuleVersionsRequest> = {
  encode(message: PostModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    for (const v of message.moduleVersions) {
      ModuleVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVersions.push(ModuleVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      moduleVersions: globalThis.Array.isArray(object?.moduleVersions)
        ? object.moduleVersions.map((e: any) => ModuleVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.moduleVersions?.length) {
      obj.moduleVersions = message.moduleVersions.map((e) => ModuleVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModuleVersionsRequest>, I>>(base?: I): PostModuleVersionsRequest {
    return PostModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModuleVersionsRequest>, I>>(object: I): PostModuleVersionsRequest {
    const message = createBasePostModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.moduleVersions = object.moduleVersions?.map((e) => ModuleVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchModuleVersionsRequest(): PatchModuleVersionsRequest {
  return { userAppId: undefined, moduleId: "", moduleVersions: [], action: "" };
}

export const PatchModuleVersionsRequest: MessageFns<PatchModuleVersionsRequest> = {
  encode(message: PatchModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    for (const v of message.moduleVersions) {
      ModuleVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVersions.push(ModuleVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      moduleVersions: globalThis.Array.isArray(object?.moduleVersions)
        ? object.moduleVersions.map((e: any) => ModuleVersion.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.moduleVersions?.length) {
      obj.moduleVersions = message.moduleVersions.map((e) => ModuleVersion.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchModuleVersionsRequest>, I>>(base?: I): PatchModuleVersionsRequest {
    return PatchModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchModuleVersionsRequest>, I>>(object: I): PatchModuleVersionsRequest {
    const message = createBasePatchModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.moduleVersions = object.moduleVersions?.map((e) => ModuleVersion.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteModuleVersionsRequest(): DeleteModuleVersionsRequest {
  return { userAppId: undefined, moduleId: "", ids: [] };
}

export const DeleteModuleVersionsRequest: MessageFns<DeleteModuleVersionsRequest> = {
  encode(message: DeleteModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    for (const v of message.ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteModuleVersionsRequest>, I>>(base?: I): DeleteModuleVersionsRequest {
    return DeleteModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteModuleVersionsRequest>, I>>(object: I): DeleteModuleVersionsRequest {
    const message = createBaseDeleteModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetModuleVersionUsageCountRequest(): GetModuleVersionUsageCountRequest {
  return { userAppId: undefined, moduleId: "", moduleVersionId: "" };
}

export const GetModuleVersionUsageCountRequest: MessageFns<GetModuleVersionUsageCountRequest> = {
  encode(message: GetModuleVersionUsageCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    if (message.moduleVersionId !== "") {
      writer.uint32(26).string(message.moduleVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModuleVersionUsageCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModuleVersionUsageCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModuleVersionUsageCountRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      moduleVersionId: isSet(object.moduleVersionId) ? globalThis.String(object.moduleVersionId) : "",
    };
  },

  toJSON(message: GetModuleVersionUsageCountRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.moduleVersionId !== "") {
      obj.moduleVersionId = message.moduleVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModuleVersionUsageCountRequest>, I>>(
    base?: I,
  ): GetModuleVersionUsageCountRequest {
    return GetModuleVersionUsageCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModuleVersionUsageCountRequest>, I>>(
    object: I,
  ): GetModuleVersionUsageCountRequest {
    const message = createBaseGetModuleVersionUsageCountRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.moduleId = object.moduleId ?? "";
    message.moduleVersionId = object.moduleVersionId ?? "";
    return message;
  },
};

function createBaseSingleModuleVersionResponse(): SingleModuleVersionResponse {
  return { status: undefined, moduleVersion: undefined };
}

export const SingleModuleVersionResponse: MessageFns<SingleModuleVersionResponse> = {
  encode(message: SingleModuleVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.moduleVersion !== undefined) {
      ModuleVersion.encode(message.moduleVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModuleVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModuleVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleVersion = ModuleVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModuleVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      moduleVersion: isSet(object.moduleVersion) ? ModuleVersion.fromJSON(object.moduleVersion) : undefined,
    };
  },

  toJSON(message: SingleModuleVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.moduleVersion !== undefined) {
      obj.moduleVersion = ModuleVersion.toJSON(message.moduleVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModuleVersionResponse>, I>>(base?: I): SingleModuleVersionResponse {
    return SingleModuleVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModuleVersionResponse>, I>>(object: I): SingleModuleVersionResponse {
    const message = createBaseSingleModuleVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.moduleVersion = (object.moduleVersion !== undefined && object.moduleVersion !== null)
      ? ModuleVersion.fromPartial(object.moduleVersion)
      : undefined;
    return message;
  },
};

function createBaseMultiModuleVersionResponse(): MultiModuleVersionResponse {
  return { status: undefined, moduleVersions: [] };
}

export const MultiModuleVersionResponse: MessageFns<MultiModuleVersionResponse> = {
  encode(message: MultiModuleVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.moduleVersions) {
      ModuleVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiModuleVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiModuleVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleVersions.push(ModuleVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiModuleVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      moduleVersions: globalThis.Array.isArray(object?.moduleVersions)
        ? object.moduleVersions.map((e: any) => ModuleVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiModuleVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.moduleVersions?.length) {
      obj.moduleVersions = message.moduleVersions.map((e) => ModuleVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiModuleVersionResponse>, I>>(base?: I): MultiModuleVersionResponse {
    return MultiModuleVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiModuleVersionResponse>, I>>(object: I): MultiModuleVersionResponse {
    const message = createBaseMultiModuleVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.moduleVersions = object.moduleVersions?.map((e) => ModuleVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleModuleVersionUsageCountResponse(): SingleModuleVersionUsageCountResponse {
  return { status: undefined, usageCount: 0 };
}

export const SingleModuleVersionUsageCountResponse: MessageFns<SingleModuleVersionUsageCountResponse> = {
  encode(message: SingleModuleVersionUsageCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.usageCount !== 0) {
      writer.uint32(16).uint32(message.usageCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleModuleVersionUsageCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleModuleVersionUsageCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.usageCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleModuleVersionUsageCountResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      usageCount: isSet(object.usageCount) ? globalThis.Number(object.usageCount) : 0,
    };
  },

  toJSON(message: SingleModuleVersionUsageCountResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.usageCount !== 0) {
      obj.usageCount = Math.round(message.usageCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleModuleVersionUsageCountResponse>, I>>(
    base?: I,
  ): SingleModuleVersionUsageCountResponse {
    return SingleModuleVersionUsageCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleModuleVersionUsageCountResponse>, I>>(
    object: I,
  ): SingleModuleVersionUsageCountResponse {
    const message = createBaseSingleModuleVersionUsageCountResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.usageCount = object.usageCount ?? 0;
    return message;
  },
};

function createBaseGetInstalledModuleVersionRequest(): GetInstalledModuleVersionRequest {
  return { userAppId: undefined, installedModuleVersionId: "" };
}

export const GetInstalledModuleVersionRequest: MessageFns<GetInstalledModuleVersionRequest> = {
  encode(message: GetInstalledModuleVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.installedModuleVersionId !== "") {
      writer.uint32(18).string(message.installedModuleVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstalledModuleVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstalledModuleVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.installedModuleVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstalledModuleVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      installedModuleVersionId: isSet(object.installedModuleVersionId)
        ? globalThis.String(object.installedModuleVersionId)
        : "",
    };
  },

  toJSON(message: GetInstalledModuleVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.installedModuleVersionId !== "") {
      obj.installedModuleVersionId = message.installedModuleVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInstalledModuleVersionRequest>, I>>(
    base?: I,
  ): GetInstalledModuleVersionRequest {
    return GetInstalledModuleVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInstalledModuleVersionRequest>, I>>(
    object: I,
  ): GetInstalledModuleVersionRequest {
    const message = createBaseGetInstalledModuleVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.installedModuleVersionId = object.installedModuleVersionId ?? "";
    return message;
  },
};

function createBaseListInstalledModuleVersionsRequest(): ListInstalledModuleVersionsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListInstalledModuleVersionsRequest: MessageFns<ListInstalledModuleVersionsRequest> = {
  encode(message: ListInstalledModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstalledModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstalledModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstalledModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListInstalledModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInstalledModuleVersionsRequest>, I>>(
    base?: I,
  ): ListInstalledModuleVersionsRequest {
    return ListInstalledModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInstalledModuleVersionsRequest>, I>>(
    object: I,
  ): ListInstalledModuleVersionsRequest {
    const message = createBaseListInstalledModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostInstalledModuleVersionsRequest(): PostInstalledModuleVersionsRequest {
  return { userAppId: undefined, installedModuleVersions: [] };
}

export const PostInstalledModuleVersionsRequest: MessageFns<PostInstalledModuleVersionsRequest> = {
  encode(message: PostInstalledModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.installedModuleVersions) {
      InstalledModuleVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInstalledModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInstalledModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.installedModuleVersions.push(InstalledModuleVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInstalledModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      installedModuleVersions: globalThis.Array.isArray(object?.installedModuleVersions)
        ? object.installedModuleVersions.map((e: any) => InstalledModuleVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostInstalledModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.installedModuleVersions?.length) {
      obj.installedModuleVersions = message.installedModuleVersions.map((e) => InstalledModuleVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInstalledModuleVersionsRequest>, I>>(
    base?: I,
  ): PostInstalledModuleVersionsRequest {
    return PostInstalledModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInstalledModuleVersionsRequest>, I>>(
    object: I,
  ): PostInstalledModuleVersionsRequest {
    const message = createBasePostInstalledModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.installedModuleVersions =
      object.installedModuleVersions?.map((e) => InstalledModuleVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostInstalledModuleVersionsKeyRequest(): PostInstalledModuleVersionsKeyRequest {
  return { userAppId: undefined, installedModuleVersionId: "" };
}

export const PostInstalledModuleVersionsKeyRequest: MessageFns<PostInstalledModuleVersionsKeyRequest> = {
  encode(message: PostInstalledModuleVersionsKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.installedModuleVersionId !== "") {
      writer.uint32(18).string(message.installedModuleVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInstalledModuleVersionsKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInstalledModuleVersionsKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.installedModuleVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInstalledModuleVersionsKeyRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      installedModuleVersionId: isSet(object.installedModuleVersionId)
        ? globalThis.String(object.installedModuleVersionId)
        : "",
    };
  },

  toJSON(message: PostInstalledModuleVersionsKeyRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.installedModuleVersionId !== "") {
      obj.installedModuleVersionId = message.installedModuleVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInstalledModuleVersionsKeyRequest>, I>>(
    base?: I,
  ): PostInstalledModuleVersionsKeyRequest {
    return PostInstalledModuleVersionsKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInstalledModuleVersionsKeyRequest>, I>>(
    object: I,
  ): PostInstalledModuleVersionsKeyRequest {
    const message = createBasePostInstalledModuleVersionsKeyRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.installedModuleVersionId = object.installedModuleVersionId ?? "";
    return message;
  },
};

function createBaseDeleteInstalledModuleVersionsRequest(): DeleteInstalledModuleVersionsRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteInstalledModuleVersionsRequest: MessageFns<DeleteInstalledModuleVersionsRequest> = {
  encode(message: DeleteInstalledModuleVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstalledModuleVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstalledModuleVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstalledModuleVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteInstalledModuleVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteInstalledModuleVersionsRequest>, I>>(
    base?: I,
  ): DeleteInstalledModuleVersionsRequest {
    return DeleteInstalledModuleVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteInstalledModuleVersionsRequest>, I>>(
    object: I,
  ): DeleteInstalledModuleVersionsRequest {
    const message = createBaseDeleteInstalledModuleVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleInstalledModuleVersionResponse(): SingleInstalledModuleVersionResponse {
  return { status: undefined, installedModuleVersion: undefined };
}

export const SingleInstalledModuleVersionResponse: MessageFns<SingleInstalledModuleVersionResponse> = {
  encode(message: SingleInstalledModuleVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.installedModuleVersion !== undefined) {
      InstalledModuleVersion.encode(message.installedModuleVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleInstalledModuleVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleInstalledModuleVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.installedModuleVersion = InstalledModuleVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleInstalledModuleVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      installedModuleVersion: isSet(object.installedModuleVersion)
        ? InstalledModuleVersion.fromJSON(object.installedModuleVersion)
        : undefined,
    };
  },

  toJSON(message: SingleInstalledModuleVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.installedModuleVersion !== undefined) {
      obj.installedModuleVersion = InstalledModuleVersion.toJSON(message.installedModuleVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleInstalledModuleVersionResponse>, I>>(
    base?: I,
  ): SingleInstalledModuleVersionResponse {
    return SingleInstalledModuleVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleInstalledModuleVersionResponse>, I>>(
    object: I,
  ): SingleInstalledModuleVersionResponse {
    const message = createBaseSingleInstalledModuleVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.installedModuleVersion =
      (object.installedModuleVersion !== undefined && object.installedModuleVersion !== null)
        ? InstalledModuleVersion.fromPartial(object.installedModuleVersion)
        : undefined;
    return message;
  },
};

function createBaseMultiInstalledModuleVersionResponse(): MultiInstalledModuleVersionResponse {
  return { status: undefined, installedModuleVersions: [] };
}

export const MultiInstalledModuleVersionResponse: MessageFns<MultiInstalledModuleVersionResponse> = {
  encode(message: MultiInstalledModuleVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.installedModuleVersions) {
      InstalledModuleVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInstalledModuleVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInstalledModuleVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.installedModuleVersions.push(InstalledModuleVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInstalledModuleVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      installedModuleVersions: globalThis.Array.isArray(object?.installedModuleVersions)
        ? object.installedModuleVersions.map((e: any) => InstalledModuleVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiInstalledModuleVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.installedModuleVersions?.length) {
      obj.installedModuleVersions = message.installedModuleVersions.map((e) => InstalledModuleVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInstalledModuleVersionResponse>, I>>(
    base?: I,
  ): MultiInstalledModuleVersionResponse {
    return MultiInstalledModuleVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInstalledModuleVersionResponse>, I>>(
    object: I,
  ): MultiInstalledModuleVersionResponse {
    const message = createBaseMultiInstalledModuleVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.installedModuleVersions =
      object.installedModuleVersions?.map((e) => InstalledModuleVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListNextTaskAssignmentsRequest(): ListNextTaskAssignmentsRequest {
  return { userAppId: undefined, taskId: "" };
}

export const ListNextTaskAssignmentsRequest: MessageFns<ListNextTaskAssignmentsRequest> = {
  encode(message: ListNextTaskAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNextTaskAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNextTaskAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNextTaskAssignmentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
    };
  },

  toJSON(message: ListNextTaskAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNextTaskAssignmentsRequest>, I>>(base?: I): ListNextTaskAssignmentsRequest {
    return ListNextTaskAssignmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNextTaskAssignmentsRequest>, I>>(
    object: I,
  ): ListNextTaskAssignmentsRequest {
    const message = createBaseListNextTaskAssignmentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBasePostBulkOperationsRequest(): PostBulkOperationsRequest {
  return { userAppId: undefined, bulkOperations: [] };
}

export const PostBulkOperationsRequest: MessageFns<PostBulkOperationsRequest> = {
  encode(message: PostBulkOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.bulkOperations) {
      BulkOperation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostBulkOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostBulkOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bulkOperations.push(BulkOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostBulkOperationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      bulkOperations: globalThis.Array.isArray(object?.bulkOperations)
        ? object.bulkOperations.map((e: any) => BulkOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostBulkOperationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.bulkOperations?.length) {
      obj.bulkOperations = message.bulkOperations.map((e) => BulkOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostBulkOperationsRequest>, I>>(base?: I): PostBulkOperationsRequest {
    return PostBulkOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostBulkOperationsRequest>, I>>(object: I): PostBulkOperationsRequest {
    const message = createBasePostBulkOperationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.bulkOperations = object.bulkOperations?.map((e) => BulkOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListBulkOperationsRequest(): ListBulkOperationsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListBulkOperationsRequest: MessageFns<ListBulkOperationsRequest> = {
  encode(message: ListBulkOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBulkOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBulkOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBulkOperationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListBulkOperationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBulkOperationsRequest>, I>>(base?: I): ListBulkOperationsRequest {
    return ListBulkOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBulkOperationsRequest>, I>>(object: I): ListBulkOperationsRequest {
    const message = createBaseListBulkOperationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetBulkOperationRequest(): GetBulkOperationRequest {
  return { userAppId: undefined, id: "" };
}

export const GetBulkOperationRequest: MessageFns<GetBulkOperationRequest> = {
  encode(message: GetBulkOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBulkOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkOperationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetBulkOperationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBulkOperationRequest>, I>>(base?: I): GetBulkOperationRequest {
    return GetBulkOperationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBulkOperationRequest>, I>>(object: I): GetBulkOperationRequest {
    const message = createBaseGetBulkOperationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCancelBulkOperationRequest(): CancelBulkOperationRequest {
  return { userAppId: undefined, ids: [] };
}

export const CancelBulkOperationRequest: MessageFns<CancelBulkOperationRequest> = {
  encode(message: CancelBulkOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelBulkOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelBulkOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelBulkOperationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CancelBulkOperationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelBulkOperationRequest>, I>>(base?: I): CancelBulkOperationRequest {
    return CancelBulkOperationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelBulkOperationRequest>, I>>(object: I): CancelBulkOperationRequest {
    const message = createBaseCancelBulkOperationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteBulkOperationRequest(): DeleteBulkOperationRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteBulkOperationRequest: MessageFns<DeleteBulkOperationRequest> = {
  encode(message: DeleteBulkOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBulkOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBulkOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBulkOperationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteBulkOperationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteBulkOperationRequest>, I>>(base?: I): DeleteBulkOperationRequest {
    return DeleteBulkOperationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteBulkOperationRequest>, I>>(object: I): DeleteBulkOperationRequest {
    const message = createBaseDeleteBulkOperationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleBulkOperationsResponse(): SingleBulkOperationsResponse {
  return { status: undefined, bulkOperation: undefined };
}

export const SingleBulkOperationsResponse: MessageFns<SingleBulkOperationsResponse> = {
  encode(message: SingleBulkOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.bulkOperation !== undefined) {
      BulkOperation.encode(message.bulkOperation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleBulkOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleBulkOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bulkOperation = BulkOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleBulkOperationsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      bulkOperation: isSet(object.bulkOperation) ? BulkOperation.fromJSON(object.bulkOperation) : undefined,
    };
  },

  toJSON(message: SingleBulkOperationsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.bulkOperation !== undefined) {
      obj.bulkOperation = BulkOperation.toJSON(message.bulkOperation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleBulkOperationsResponse>, I>>(base?: I): SingleBulkOperationsResponse {
    return SingleBulkOperationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleBulkOperationsResponse>, I>>(object: I): SingleBulkOperationsResponse {
    const message = createBaseSingleBulkOperationsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.bulkOperation = (object.bulkOperation !== undefined && object.bulkOperation !== null)
      ? BulkOperation.fromPartial(object.bulkOperation)
      : undefined;
    return message;
  },
};

function createBaseMultiBulkOperationsResponse(): MultiBulkOperationsResponse {
  return { status: undefined, bulkOperation: [] };
}

export const MultiBulkOperationsResponse: MessageFns<MultiBulkOperationsResponse> = {
  encode(message: MultiBulkOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.bulkOperation) {
      BulkOperation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiBulkOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiBulkOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bulkOperation.push(BulkOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiBulkOperationsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      bulkOperation: globalThis.Array.isArray(object?.bulkOperation)
        ? object.bulkOperation.map((e: any) => BulkOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiBulkOperationsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.bulkOperation?.length) {
      obj.bulkOperation = message.bulkOperation.map((e) => BulkOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiBulkOperationsResponse>, I>>(base?: I): MultiBulkOperationsResponse {
    return MultiBulkOperationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiBulkOperationsResponse>, I>>(object: I): MultiBulkOperationsResponse {
    const message = createBaseMultiBulkOperationsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.bulkOperation = object.bulkOperation?.map((e) => BulkOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBasePutTaskAssignmentsRequest(): PutTaskAssignmentsRequest {
  return {
    userAppId: undefined,
    taskId: "",
    inputId: "",
    action: 0,
    labelSubmitConfig: undefined,
    reviewStartConfig: undefined,
    reviewApproveConfig: undefined,
    reviewRequestChangesConfig: undefined,
    reviewRejectConfig: undefined,
  };
}

export const PutTaskAssignmentsRequest: MessageFns<PutTaskAssignmentsRequest> = {
  encode(message: PutTaskAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.action !== 0) {
      writer.uint32(32).int32(message.action);
    }
    if (message.labelSubmitConfig !== undefined) {
      LabelSubmitConfig.encode(message.labelSubmitConfig, writer.uint32(50).fork()).join();
    }
    if (message.reviewStartConfig !== undefined) {
      ReviewStartConfig.encode(message.reviewStartConfig, writer.uint32(82).fork()).join();
    }
    if (message.reviewApproveConfig !== undefined) {
      ReviewApproveConfig.encode(message.reviewApproveConfig, writer.uint32(58).fork()).join();
    }
    if (message.reviewRequestChangesConfig !== undefined) {
      ReviewRequestChangesConfig.encode(message.reviewRequestChangesConfig, writer.uint32(66).fork()).join();
    }
    if (message.reviewRejectConfig !== undefined) {
      ReviewRejectConfig.encode(message.reviewRejectConfig, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutTaskAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutTaskAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.labelSubmitConfig = LabelSubmitConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reviewStartConfig = ReviewStartConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reviewApproveConfig = ReviewApproveConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reviewRequestChangesConfig = ReviewRequestChangesConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reviewRejectConfig = ReviewRejectConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutTaskAssignmentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      action: isSet(object.action) ? putTaskAssignmentsRequestActionFromJSON(object.action) : 0,
      labelSubmitConfig: isSet(object.labelSubmitConfig)
        ? LabelSubmitConfig.fromJSON(object.labelSubmitConfig)
        : undefined,
      reviewStartConfig: isSet(object.reviewStartConfig)
        ? ReviewStartConfig.fromJSON(object.reviewStartConfig)
        : undefined,
      reviewApproveConfig: isSet(object.reviewApproveConfig)
        ? ReviewApproveConfig.fromJSON(object.reviewApproveConfig)
        : undefined,
      reviewRequestChangesConfig: isSet(object.reviewRequestChangesConfig)
        ? ReviewRequestChangesConfig.fromJSON(object.reviewRequestChangesConfig)
        : undefined,
      reviewRejectConfig: isSet(object.reviewRejectConfig)
        ? ReviewRejectConfig.fromJSON(object.reviewRejectConfig)
        : undefined,
    };
  },

  toJSON(message: PutTaskAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.action !== 0) {
      obj.action = putTaskAssignmentsRequestActionToJSON(message.action);
    }
    if (message.labelSubmitConfig !== undefined) {
      obj.labelSubmitConfig = LabelSubmitConfig.toJSON(message.labelSubmitConfig);
    }
    if (message.reviewStartConfig !== undefined) {
      obj.reviewStartConfig = ReviewStartConfig.toJSON(message.reviewStartConfig);
    }
    if (message.reviewApproveConfig !== undefined) {
      obj.reviewApproveConfig = ReviewApproveConfig.toJSON(message.reviewApproveConfig);
    }
    if (message.reviewRequestChangesConfig !== undefined) {
      obj.reviewRequestChangesConfig = ReviewRequestChangesConfig.toJSON(message.reviewRequestChangesConfig);
    }
    if (message.reviewRejectConfig !== undefined) {
      obj.reviewRejectConfig = ReviewRejectConfig.toJSON(message.reviewRejectConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutTaskAssignmentsRequest>, I>>(base?: I): PutTaskAssignmentsRequest {
    return PutTaskAssignmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutTaskAssignmentsRequest>, I>>(object: I): PutTaskAssignmentsRequest {
    const message = createBasePutTaskAssignmentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.taskId = object.taskId ?? "";
    message.inputId = object.inputId ?? "";
    message.action = object.action ?? 0;
    message.labelSubmitConfig = (object.labelSubmitConfig !== undefined && object.labelSubmitConfig !== null)
      ? LabelSubmitConfig.fromPartial(object.labelSubmitConfig)
      : undefined;
    message.reviewStartConfig = (object.reviewStartConfig !== undefined && object.reviewStartConfig !== null)
      ? ReviewStartConfig.fromPartial(object.reviewStartConfig)
      : undefined;
    message.reviewApproveConfig = (object.reviewApproveConfig !== undefined && object.reviewApproveConfig !== null)
      ? ReviewApproveConfig.fromPartial(object.reviewApproveConfig)
      : undefined;
    message.reviewRequestChangesConfig =
      (object.reviewRequestChangesConfig !== undefined && object.reviewRequestChangesConfig !== null)
        ? ReviewRequestChangesConfig.fromPartial(object.reviewRequestChangesConfig)
        : undefined;
    message.reviewRejectConfig = (object.reviewRejectConfig !== undefined && object.reviewRejectConfig !== null)
      ? ReviewRejectConfig.fromPartial(object.reviewRejectConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelSubmitConfig(): LabelSubmitConfig {
  return { taskAssignments: [] };
}

export const LabelSubmitConfig: MessageFns<LabelSubmitConfig> = {
  encode(message: LabelSubmitConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taskAssignments) {
      TaskAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelSubmitConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelSubmitConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskAssignments.push(TaskAssignment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelSubmitConfig {
    return {
      taskAssignments: globalThis.Array.isArray(object?.taskAssignments)
        ? object.taskAssignments.map((e: any) => TaskAssignment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LabelSubmitConfig): unknown {
    const obj: any = {};
    if (message.taskAssignments?.length) {
      obj.taskAssignments = message.taskAssignments.map((e) => TaskAssignment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LabelSubmitConfig>, I>>(base?: I): LabelSubmitConfig {
    return LabelSubmitConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LabelSubmitConfig>, I>>(object: I): LabelSubmitConfig {
    const message = createBaseLabelSubmitConfig();
    message.taskAssignments = object.taskAssignments?.map((e) => TaskAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReviewStartConfig(): ReviewStartConfig {
  return { workers: [] };
}

export const ReviewStartConfig: MessageFns<ReviewStartConfig> = {
  encode(message: ReviewStartConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReviewStartConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviewStartConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReviewStartConfig {
    return {
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReviewStartConfig): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReviewStartConfig>, I>>(base?: I): ReviewStartConfig {
    return ReviewStartConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReviewStartConfig>, I>>(object: I): ReviewStartConfig {
    const message = createBaseReviewStartConfig();
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReviewApproveConfig(): ReviewApproveConfig {
  return { taskAssignments: [], workers: [] };
}

export const ReviewApproveConfig: MessageFns<ReviewApproveConfig> = {
  encode(message: ReviewApproveConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taskAssignments) {
      TaskAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReviewApproveConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviewApproveConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskAssignments.push(TaskAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReviewApproveConfig {
    return {
      taskAssignments: globalThis.Array.isArray(object?.taskAssignments)
        ? object.taskAssignments.map((e: any) => TaskAssignment.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReviewApproveConfig): unknown {
    const obj: any = {};
    if (message.taskAssignments?.length) {
      obj.taskAssignments = message.taskAssignments.map((e) => TaskAssignment.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReviewApproveConfig>, I>>(base?: I): ReviewApproveConfig {
    return ReviewApproveConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReviewApproveConfig>, I>>(object: I): ReviewApproveConfig {
    const message = createBaseReviewApproveConfig();
    message.taskAssignments = object.taskAssignments?.map((e) => TaskAssignment.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReviewRequestChangesConfig(): ReviewRequestChangesConfig {
  return { taskAssignments: [], workers: [] };
}

export const ReviewRequestChangesConfig: MessageFns<ReviewRequestChangesConfig> = {
  encode(message: ReviewRequestChangesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taskAssignments) {
      TaskAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReviewRequestChangesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviewRequestChangesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskAssignments.push(TaskAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReviewRequestChangesConfig {
    return {
      taskAssignments: globalThis.Array.isArray(object?.taskAssignments)
        ? object.taskAssignments.map((e: any) => TaskAssignment.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReviewRequestChangesConfig): unknown {
    const obj: any = {};
    if (message.taskAssignments?.length) {
      obj.taskAssignments = message.taskAssignments.map((e) => TaskAssignment.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReviewRequestChangesConfig>, I>>(base?: I): ReviewRequestChangesConfig {
    return ReviewRequestChangesConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReviewRequestChangesConfig>, I>>(object: I): ReviewRequestChangesConfig {
    const message = createBaseReviewRequestChangesConfig();
    message.taskAssignments = object.taskAssignments?.map((e) => TaskAssignment.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReviewRejectConfig(): ReviewRejectConfig {
  return { taskAssignments: [], workers: [] };
}

export const ReviewRejectConfig: MessageFns<ReviewRejectConfig> = {
  encode(message: ReviewRejectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taskAssignments) {
      TaskAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReviewRejectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviewRejectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskAssignments.push(TaskAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReviewRejectConfig {
    return {
      taskAssignments: globalThis.Array.isArray(object?.taskAssignments)
        ? object.taskAssignments.map((e: any) => TaskAssignment.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReviewRejectConfig): unknown {
    const obj: any = {};
    if (message.taskAssignments?.length) {
      obj.taskAssignments = message.taskAssignments.map((e) => TaskAssignment.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReviewRejectConfig>, I>>(base?: I): ReviewRejectConfig {
    return ReviewRejectConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReviewRejectConfig>, I>>(object: I): ReviewRejectConfig {
    const message = createBaseReviewRejectConfig();
    message.taskAssignments = object.taskAssignments?.map((e) => TaskAssignment.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiTaskAssignmentResponse(): MultiTaskAssignmentResponse {
  return { status: undefined, taskAssignments: [] };
}

export const MultiTaskAssignmentResponse: MessageFns<MultiTaskAssignmentResponse> = {
  encode(message: MultiTaskAssignmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.taskAssignments) {
      TaskAssignment.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiTaskAssignmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiTaskAssignmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskAssignments.push(TaskAssignment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiTaskAssignmentResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      taskAssignments: globalThis.Array.isArray(object?.taskAssignments)
        ? object.taskAssignments.map((e: any) => TaskAssignment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiTaskAssignmentResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.taskAssignments?.length) {
      obj.taskAssignments = message.taskAssignments.map((e) => TaskAssignment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiTaskAssignmentResponse>, I>>(base?: I): MultiTaskAssignmentResponse {
    return MultiTaskAssignmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiTaskAssignmentResponse>, I>>(object: I): MultiTaskAssignmentResponse {
    const message = createBaseMultiTaskAssignmentResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.taskAssignments = object.taskAssignments?.map((e) => TaskAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListInputsAddJobsRequest(): ListInputsAddJobsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListInputsAddJobsRequest: MessageFns<ListInputsAddJobsRequest> = {
  encode(message: ListInputsAddJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInputsAddJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputsAddJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputsAddJobsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListInputsAddJobsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInputsAddJobsRequest>, I>>(base?: I): ListInputsAddJobsRequest {
    return ListInputsAddJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInputsAddJobsRequest>, I>>(object: I): ListInputsAddJobsRequest {
    const message = createBaseListInputsAddJobsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetInputsAddJobRequest(): GetInputsAddJobRequest {
  return { userAppId: undefined, id: "" };
}

export const GetInputsAddJobRequest: MessageFns<GetInputsAddJobRequest> = {
  encode(message: GetInputsAddJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputsAddJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputsAddJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputsAddJobRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetInputsAddJobRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInputsAddJobRequest>, I>>(base?: I): GetInputsAddJobRequest {
    return GetInputsAddJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInputsAddJobRequest>, I>>(object: I): GetInputsAddJobRequest {
    const message = createBaseGetInputsAddJobRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCancelInputsAddJobRequest(): CancelInputsAddJobRequest {
  return { userAppId: undefined, id: "" };
}

export const CancelInputsAddJobRequest: MessageFns<CancelInputsAddJobRequest> = {
  encode(message: CancelInputsAddJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelInputsAddJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelInputsAddJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelInputsAddJobRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: CancelInputsAddJobRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelInputsAddJobRequest>, I>>(base?: I): CancelInputsAddJobRequest {
    return CancelInputsAddJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelInputsAddJobRequest>, I>>(object: I): CancelInputsAddJobRequest {
    const message = createBaseCancelInputsAddJobRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMultiInputsAddJobResponse(): MultiInputsAddJobResponse {
  return { status: undefined, inputsAddJobs: [] };
}

export const MultiInputsAddJobResponse: MessageFns<MultiInputsAddJobResponse> = {
  encode(message: MultiInputsAddJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputsAddJobs) {
      InputsAddJob.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInputsAddJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInputsAddJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsAddJobs.push(InputsAddJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInputsAddJobResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      inputsAddJobs: globalThis.Array.isArray(object?.inputsAddJobs)
        ? object.inputsAddJobs.map((e: any) => InputsAddJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiInputsAddJobResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.inputsAddJobs?.length) {
      obj.inputsAddJobs = message.inputsAddJobs.map((e) => InputsAddJob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInputsAddJobResponse>, I>>(base?: I): MultiInputsAddJobResponse {
    return MultiInputsAddJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInputsAddJobResponse>, I>>(object: I): MultiInputsAddJobResponse {
    const message = createBaseMultiInputsAddJobResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.inputsAddJobs = object.inputsAddJobs?.map((e) => InputsAddJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleInputsAddJobResponse(): SingleInputsAddJobResponse {
  return { status: undefined, inputsAddJob: undefined };
}

export const SingleInputsAddJobResponse: MessageFns<SingleInputsAddJobResponse> = {
  encode(message: SingleInputsAddJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.inputsAddJob !== undefined) {
      InputsAddJob.encode(message.inputsAddJob, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleInputsAddJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleInputsAddJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsAddJob = InputsAddJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleInputsAddJobResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      inputsAddJob: isSet(object.inputsAddJob) ? InputsAddJob.fromJSON(object.inputsAddJob) : undefined,
    };
  },

  toJSON(message: SingleInputsAddJobResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.inputsAddJob !== undefined) {
      obj.inputsAddJob = InputsAddJob.toJSON(message.inputsAddJob);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleInputsAddJobResponse>, I>>(base?: I): SingleInputsAddJobResponse {
    return SingleInputsAddJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleInputsAddJobResponse>, I>>(object: I): SingleInputsAddJobResponse {
    const message = createBaseSingleInputsAddJobResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.inputsAddJob = (object.inputsAddJob !== undefined && object.inputsAddJob !== null)
      ? InputsAddJob.fromPartial(object.inputsAddJob)
      : undefined;
    return message;
  },
};

function createBasePostUploadsRequest(): PostUploadsRequest {
  return { userAppId: undefined, uploads: [] };
}

export const PostUploadsRequest: MessageFns<PostUploadsRequest> = {
  encode(message: PostUploadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.uploads) {
      Upload.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostUploadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostUploadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uploads.push(Upload.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostUploadsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      uploads: globalThis.Array.isArray(object?.uploads) ? object.uploads.map((e: any) => Upload.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostUploadsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.uploads?.length) {
      obj.uploads = message.uploads.map((e) => Upload.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostUploadsRequest>, I>>(base?: I): PostUploadsRequest {
    return PostUploadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostUploadsRequest>, I>>(object: I): PostUploadsRequest {
    const message = createBasePostUploadsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.uploads = object.uploads?.map((e) => Upload.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteUploadsRequest(): DeleteUploadsRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteUploadsRequest: MessageFns<DeleteUploadsRequest> = {
  encode(message: DeleteUploadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUploadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUploadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUploadsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteUploadsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUploadsRequest>, I>>(base?: I): DeleteUploadsRequest {
    return DeleteUploadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUploadsRequest>, I>>(object: I): DeleteUploadsRequest {
    const message = createBaseDeleteUploadsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseListUploadsRequest(): ListUploadsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListUploadsRequest: MessageFns<ListUploadsRequest> = {
  encode(message: ListUploadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUploadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUploadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUploadsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListUploadsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUploadsRequest>, I>>(base?: I): ListUploadsRequest {
    return ListUploadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUploadsRequest>, I>>(object: I): ListUploadsRequest {
    const message = createBaseListUploadsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseGetUploadRequest(): GetUploadRequest {
  return { userAppId: undefined, uploadId: "" };
}

export const GetUploadRequest: MessageFns<GetUploadRequest> = {
  encode(message: GetUploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.uploadId !== "") {
      writer.uint32(18).string(message.uploadId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uploadId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUploadRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      uploadId: isSet(object.uploadId) ? globalThis.String(object.uploadId) : "",
    };
  },

  toJSON(message: GetUploadRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.uploadId !== "") {
      obj.uploadId = message.uploadId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUploadRequest>, I>>(base?: I): GetUploadRequest {
    return GetUploadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUploadRequest>, I>>(object: I): GetUploadRequest {
    const message = createBaseGetUploadRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.uploadId = object.uploadId ?? "";
    return message;
  },
};

function createBaseSingleUploadResponse(): SingleUploadResponse {
  return { status: undefined, upload: undefined };
}

export const SingleUploadResponse: MessageFns<SingleUploadResponse> = {
  encode(message: SingleUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.upload !== undefined) {
      Upload.encode(message.upload, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upload = Upload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleUploadResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      upload: isSet(object.upload) ? Upload.fromJSON(object.upload) : undefined,
    };
  },

  toJSON(message: SingleUploadResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.upload !== undefined) {
      obj.upload = Upload.toJSON(message.upload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleUploadResponse>, I>>(base?: I): SingleUploadResponse {
    return SingleUploadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleUploadResponse>, I>>(object: I): SingleUploadResponse {
    const message = createBaseSingleUploadResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.upload = (object.upload !== undefined && object.upload !== null)
      ? Upload.fromPartial(object.upload)
      : undefined;
    return message;
  },
};

function createBaseMultiUploadResponse(): MultiUploadResponse {
  return { status: undefined, uploads: [] };
}

export const MultiUploadResponse: MessageFns<MultiUploadResponse> = {
  encode(message: MultiUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.uploads) {
      Upload.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uploads.push(Upload.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiUploadResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      uploads: globalThis.Array.isArray(object?.uploads) ? object.uploads.map((e: any) => Upload.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiUploadResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.uploads?.length) {
      obj.uploads = message.uploads.map((e) => Upload.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiUploadResponse>, I>>(base?: I): MultiUploadResponse {
    return MultiUploadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiUploadResponse>, I>>(object: I): MultiUploadResponse {
    const message = createBaseMultiUploadResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.uploads = object.uploads?.map((e) => Upload.fromPartial(e)) || [];
    return message;
  },
};

function createBasePutUploadContentPartsRequest(): PutUploadContentPartsRequest {
  return { userAppId: undefined, uploadId: "", contentParts: [] };
}

export const PutUploadContentPartsRequest: MessageFns<PutUploadContentPartsRequest> = {
  encode(message: PutUploadContentPartsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.uploadId !== "") {
      writer.uint32(18).string(message.uploadId);
    }
    for (const v of message.contentParts) {
      UploadContentPart.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutUploadContentPartsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutUploadContentPartsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uploadId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentParts.push(UploadContentPart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutUploadContentPartsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      uploadId: isSet(object.uploadId) ? globalThis.String(object.uploadId) : "",
      contentParts: globalThis.Array.isArray(object?.contentParts)
        ? object.contentParts.map((e: any) => UploadContentPart.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PutUploadContentPartsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.uploadId !== "") {
      obj.uploadId = message.uploadId;
    }
    if (message.contentParts?.length) {
      obj.contentParts = message.contentParts.map((e) => UploadContentPart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutUploadContentPartsRequest>, I>>(base?: I): PutUploadContentPartsRequest {
    return PutUploadContentPartsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutUploadContentPartsRequest>, I>>(object: I): PutUploadContentPartsRequest {
    const message = createBasePutUploadContentPartsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.uploadId = object.uploadId ?? "";
    message.contentParts = object.contentParts?.map((e) => UploadContentPart.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostInputsDataSourcesRequest(): PostInputsDataSourcesRequest {
  return { userAppId: undefined, dataSources: [], callBackUrl: "", appPat: "" };
}

export const PostInputsDataSourcesRequest: MessageFns<PostInputsDataSourcesRequest> = {
  encode(message: PostInputsDataSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.dataSources) {
      InputsDataSource.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.callBackUrl !== "") {
      writer.uint32(26).string(message.callBackUrl);
    }
    if (message.appPat !== "") {
      writer.uint32(34).string(message.appPat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInputsDataSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInputsDataSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSources.push(InputsDataSource.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.callBackUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appPat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInputsDataSourcesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => InputsDataSource.fromJSON(e))
        : [],
      callBackUrl: isSet(object.callBackUrl) ? globalThis.String(object.callBackUrl) : "",
      appPat: isSet(object.appPat) ? globalThis.String(object.appPat) : "",
    };
  },

  toJSON(message: PostInputsDataSourcesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => InputsDataSource.toJSON(e));
    }
    if (message.callBackUrl !== "") {
      obj.callBackUrl = message.callBackUrl;
    }
    if (message.appPat !== "") {
      obj.appPat = message.appPat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInputsDataSourcesRequest>, I>>(base?: I): PostInputsDataSourcesRequest {
    return PostInputsDataSourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInputsDataSourcesRequest>, I>>(object: I): PostInputsDataSourcesRequest {
    const message = createBasePostInputsDataSourcesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.dataSources = object.dataSources?.map((e) => InputsDataSource.fromPartial(e)) || [];
    message.callBackUrl = object.callBackUrl ?? "";
    message.appPat = object.appPat ?? "";
    return message;
  },
};

function createBaseGetInputsExtractionJobRequest(): GetInputsExtractionJobRequest {
  return { userAppId: undefined, inputsExtractionJobId: "" };
}

export const GetInputsExtractionJobRequest: MessageFns<GetInputsExtractionJobRequest> = {
  encode(message: GetInputsExtractionJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.inputsExtractionJobId !== "") {
      writer.uint32(18).string(message.inputsExtractionJobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputsExtractionJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputsExtractionJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsExtractionJobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputsExtractionJobRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputsExtractionJobId: isSet(object.inputsExtractionJobId) ? globalThis.String(object.inputsExtractionJobId) : "",
    };
  },

  toJSON(message: GetInputsExtractionJobRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputsExtractionJobId !== "") {
      obj.inputsExtractionJobId = message.inputsExtractionJobId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInputsExtractionJobRequest>, I>>(base?: I): GetInputsExtractionJobRequest {
    return GetInputsExtractionJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInputsExtractionJobRequest>, I>>(
    object: I,
  ): GetInputsExtractionJobRequest {
    const message = createBaseGetInputsExtractionJobRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputsExtractionJobId = object.inputsExtractionJobId ?? "";
    return message;
  },
};

function createBaseListInputsExtractionJobsRequest(): ListInputsExtractionJobsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListInputsExtractionJobsRequest: MessageFns<ListInputsExtractionJobsRequest> = {
  encode(message: ListInputsExtractionJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInputsExtractionJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputsExtractionJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputsExtractionJobsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListInputsExtractionJobsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInputsExtractionJobsRequest>, I>>(base?: I): ListInputsExtractionJobsRequest {
    return ListInputsExtractionJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInputsExtractionJobsRequest>, I>>(
    object: I,
  ): ListInputsExtractionJobsRequest {
    const message = createBaseListInputsExtractionJobsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseSingleInputsExtractionJobResponse(): SingleInputsExtractionJobResponse {
  return { status: undefined, inputsExtractionJob: undefined };
}

export const SingleInputsExtractionJobResponse: MessageFns<SingleInputsExtractionJobResponse> = {
  encode(message: SingleInputsExtractionJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.inputsExtractionJob !== undefined) {
      InputsExtractionJob.encode(message.inputsExtractionJob, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleInputsExtractionJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleInputsExtractionJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsExtractionJob = InputsExtractionJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleInputsExtractionJobResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      inputsExtractionJob: isSet(object.inputsExtractionJob)
        ? InputsExtractionJob.fromJSON(object.inputsExtractionJob)
        : undefined,
    };
  },

  toJSON(message: SingleInputsExtractionJobResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.inputsExtractionJob !== undefined) {
      obj.inputsExtractionJob = InputsExtractionJob.toJSON(message.inputsExtractionJob);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleInputsExtractionJobResponse>, I>>(
    base?: I,
  ): SingleInputsExtractionJobResponse {
    return SingleInputsExtractionJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleInputsExtractionJobResponse>, I>>(
    object: I,
  ): SingleInputsExtractionJobResponse {
    const message = createBaseSingleInputsExtractionJobResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.inputsExtractionJob = (object.inputsExtractionJob !== undefined && object.inputsExtractionJob !== null)
      ? InputsExtractionJob.fromPartial(object.inputsExtractionJob)
      : undefined;
    return message;
  },
};

function createBaseMultiInputsExtractionJobResponse(): MultiInputsExtractionJobResponse {
  return { status: undefined, inputsExtractionJobs: [] };
}

export const MultiInputsExtractionJobResponse: MessageFns<MultiInputsExtractionJobResponse> = {
  encode(message: MultiInputsExtractionJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputsExtractionJobs) {
      InputsExtractionJob.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInputsExtractionJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInputsExtractionJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsExtractionJobs.push(InputsExtractionJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInputsExtractionJobResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      inputsExtractionJobs: globalThis.Array.isArray(object?.inputsExtractionJobs)
        ? object.inputsExtractionJobs.map((e: any) => InputsExtractionJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiInputsExtractionJobResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.inputsExtractionJobs?.length) {
      obj.inputsExtractionJobs = message.inputsExtractionJobs.map((e) => InputsExtractionJob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInputsExtractionJobResponse>, I>>(
    base?: I,
  ): MultiInputsExtractionJobResponse {
    return MultiInputsExtractionJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInputsExtractionJobResponse>, I>>(
    object: I,
  ): MultiInputsExtractionJobResponse {
    const message = createBaseMultiInputsExtractionJobResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.inputsExtractionJobs = object.inputsExtractionJobs?.map((e) => InputsExtractionJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCancelInputsExtractionJobsRequest(): CancelInputsExtractionJobsRequest {
  return { userAppId: undefined, ids: [] };
}

export const CancelInputsExtractionJobsRequest: MessageFns<CancelInputsExtractionJobsRequest> = {
  encode(message: CancelInputsExtractionJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelInputsExtractionJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelInputsExtractionJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelInputsExtractionJobsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CancelInputsExtractionJobsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelInputsExtractionJobsRequest>, I>>(
    base?: I,
  ): CancelInputsExtractionJobsRequest {
    return CancelInputsExtractionJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelInputsExtractionJobsRequest>, I>>(
    object: I,
  ): CancelInputsExtractionJobsRequest {
    const message = createBaseCancelInputsExtractionJobsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBasePostInputsUploadsRequest(): PostInputsUploadsRequest {
  return { userAppId: undefined, inputsUploads: [] };
}

export const PostInputsUploadsRequest: MessageFns<PostInputsUploadsRequest> = {
  encode(message: PostInputsUploadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputsUploads) {
      InputsUpload.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostInputsUploadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostInputsUploadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputsUploads.push(InputsUpload.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostInputsUploadsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      inputsUploads: globalThis.Array.isArray(object?.inputsUploads)
        ? object.inputsUploads.map((e: any) => InputsUpload.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostInputsUploadsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.inputsUploads?.length) {
      obj.inputsUploads = message.inputsUploads.map((e) => InputsUpload.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostInputsUploadsRequest>, I>>(base?: I): PostInputsUploadsRequest {
    return PostInputsUploadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostInputsUploadsRequest>, I>>(object: I): PostInputsUploadsRequest {
    const message = createBasePostInputsUploadsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.inputsUploads = object.inputsUploads?.map((e) => InputsUpload.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRunnerRequest(): GetRunnerRequest {
  return { userAppId: undefined, nodepoolId: "", runnerId: "", computeClusterId: "" };
}

export const GetRunnerRequest: MessageFns<GetRunnerRequest> = {
  encode(message: GetRunnerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(26).string(message.runnerId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(34).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunnerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunnerRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: GetRunnerRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRunnerRequest>, I>>(base?: I): GetRunnerRequest {
    return GetRunnerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRunnerRequest>, I>>(object: I): GetRunnerRequest {
    const message = createBaseGetRunnerRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBaseListRunnersRequest(): ListRunnersRequest {
  return {
    userAppId: undefined,
    nodepoolId: "",
    page: 0,
    perPage: 0,
    computeClusterId: "",
    minReplicas: 0,
    modelVersionIds: [],
  };
}

export const ListRunnersRequest: MessageFns<ListRunnersRequest> = {
  encode(message: ListRunnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(42).string(message.computeClusterId);
    }
    if (message.minReplicas !== 0) {
      writer.uint32(48).uint32(message.minReplicas);
    }
    for (const v of message.modelVersionIds) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.minReplicas = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modelVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunnersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      minReplicas: isSet(object.minReplicas) ? globalThis.Number(object.minReplicas) : 0,
      modelVersionIds: globalThis.Array.isArray(object?.modelVersionIds)
        ? object.modelVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRunnersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.minReplicas !== 0) {
      obj.minReplicas = Math.round(message.minReplicas);
    }
    if (message.modelVersionIds?.length) {
      obj.modelVersionIds = message.modelVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRunnersRequest>, I>>(base?: I): ListRunnersRequest {
    return ListRunnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRunnersRequest>, I>>(object: I): ListRunnersRequest {
    const message = createBaseListRunnersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.computeClusterId = object.computeClusterId ?? "";
    message.minReplicas = object.minReplicas ?? 0;
    message.modelVersionIds = object.modelVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBasePostRunnersRequest(): PostRunnersRequest {
  return { userAppId: undefined, nodepoolId: "", runners: [], computeClusterId: "" };
}

export const PostRunnersRequest: MessageFns<PostRunnersRequest> = {
  encode(message: PostRunnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    for (const v of message.runners) {
      Runner.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(34).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostRunnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostRunnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runners.push(Runner.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostRunnersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runners: globalThis.Array.isArray(object?.runners) ? object.runners.map((e: any) => Runner.fromJSON(e)) : [],
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: PostRunnersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runners?.length) {
      obj.runners = message.runners.map((e) => Runner.toJSON(e));
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostRunnersRequest>, I>>(base?: I): PostRunnersRequest {
    return PostRunnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostRunnersRequest>, I>>(object: I): PostRunnersRequest {
    const message = createBasePostRunnersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.runners = object.runners?.map((e) => Runner.fromPartial(e)) || [];
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBasePatchRunnersRequest(): PatchRunnersRequest {
  return { userAppId: undefined, nodepoolId: "", runners: [], computeClusterId: "", action: "" };
}

export const PatchRunnersRequest: MessageFns<PatchRunnersRequest> = {
  encode(message: PatchRunnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    for (const v of message.runners) {
      Runner.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(34).string(message.computeClusterId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchRunnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchRunnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runners.push(Runner.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchRunnersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runners: globalThis.Array.isArray(object?.runners) ? object.runners.map((e: any) => Runner.fromJSON(e)) : [],
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchRunnersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runners?.length) {
      obj.runners = message.runners.map((e) => Runner.toJSON(e));
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchRunnersRequest>, I>>(base?: I): PatchRunnersRequest {
    return PatchRunnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchRunnersRequest>, I>>(object: I): PatchRunnersRequest {
    const message = createBasePatchRunnersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.runners = object.runners?.map((e) => Runner.fromPartial(e)) || [];
    message.computeClusterId = object.computeClusterId ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteRunnersRequest(): DeleteRunnersRequest {
  return { userAppId: undefined, nodepoolId: "", ids: [], computeClusterId: "" };
}

export const DeleteRunnersRequest: MessageFns<DeleteRunnersRequest> = {
  encode(message: DeleteRunnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    for (const v of message.ids) {
      writer.uint32(26).string(v!);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(34).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRunnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRunnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRunnersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: DeleteRunnersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRunnersRequest>, I>>(base?: I): DeleteRunnersRequest {
    return DeleteRunnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRunnersRequest>, I>>(object: I): DeleteRunnersRequest {
    const message = createBaseDeleteRunnersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBaseSingleRunnerResponse(): SingleRunnerResponse {
  return { status: undefined, runner: undefined };
}

export const SingleRunnerResponse: MessageFns<SingleRunnerResponse> = {
  encode(message: SingleRunnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.runner !== undefined) {
      Runner.encode(message.runner, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleRunnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleRunnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runner = Runner.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleRunnerResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      runner: isSet(object.runner) ? Runner.fromJSON(object.runner) : undefined,
    };
  },

  toJSON(message: SingleRunnerResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.runner !== undefined) {
      obj.runner = Runner.toJSON(message.runner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleRunnerResponse>, I>>(base?: I): SingleRunnerResponse {
    return SingleRunnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleRunnerResponse>, I>>(object: I): SingleRunnerResponse {
    const message = createBaseSingleRunnerResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.runner = (object.runner !== undefined && object.runner !== null)
      ? Runner.fromPartial(object.runner)
      : undefined;
    return message;
  },
};

function createBaseMultiRunnerResponse(): MultiRunnerResponse {
  return { status: undefined, runners: [] };
}

export const MultiRunnerResponse: MessageFns<MultiRunnerResponse> = {
  encode(message: MultiRunnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.runners) {
      Runner.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiRunnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiRunnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runners.push(Runner.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiRunnerResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      runners: globalThis.Array.isArray(object?.runners) ? object.runners.map((e: any) => Runner.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiRunnerResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.runners?.length) {
      obj.runners = message.runners.map((e) => Runner.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiRunnerResponse>, I>>(base?: I): MultiRunnerResponse {
    return MultiRunnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiRunnerResponse>, I>>(object: I): MultiRunnerResponse {
    const message = createBaseMultiRunnerResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.runners = object.runners?.map((e) => Runner.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRunnerItemsRequest(): ListRunnerItemsRequest {
  return { userAppId: undefined, nodepoolId: "", runnerId: "", computeClusterId: "" };
}

export const ListRunnerItemsRequest: MessageFns<ListRunnerItemsRequest> = {
  encode(message: ListRunnerItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(26).string(message.runnerId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(34).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunnerItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunnerItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunnerItemsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: ListRunnerItemsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRunnerItemsRequest>, I>>(base?: I): ListRunnerItemsRequest {
    return ListRunnerItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRunnerItemsRequest>, I>>(object: I): ListRunnerItemsRequest {
    const message = createBaseListRunnerItemsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBasePostRunnerItemOutputsRequest(): PostRunnerItemOutputsRequest {
  return {
    userAppId: undefined,
    nodepoolId: "",
    runnerId: "",
    runnerItemId: "",
    runnerItemOutputs: [],
    status: undefined,
    runnerReplicaId: "",
    computeClusterId: "",
    cloudProviderId: "",
    region: "",
  };
}

export const PostRunnerItemOutputsRequest: MessageFns<PostRunnerItemOutputsRequest> = {
  encode(message: PostRunnerItemOutputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(26).string(message.runnerId);
    }
    if (message.runnerItemId !== "") {
      writer.uint32(34).string(message.runnerItemId);
    }
    for (const v of message.runnerItemOutputs) {
      RunnerItemOutput.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(50).fork()).join();
    }
    if (message.runnerReplicaId !== "") {
      writer.uint32(58).string(message.runnerReplicaId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(66).string(message.computeClusterId);
    }
    if (message.cloudProviderId !== "") {
      writer.uint32(74).string(message.cloudProviderId);
    }
    if (message.region !== "") {
      writer.uint32(82).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostRunnerItemOutputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostRunnerItemOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runnerItemId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runnerItemOutputs.push(RunnerItemOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runnerReplicaId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cloudProviderId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostRunnerItemOutputsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      runnerItemId: isSet(object.runnerItemId) ? globalThis.String(object.runnerItemId) : "",
      runnerItemOutputs: globalThis.Array.isArray(object?.runnerItemOutputs)
        ? object.runnerItemOutputs.map((e: any) => RunnerItemOutput.fromJSON(e))
        : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      runnerReplicaId: isSet(object.runnerReplicaId) ? globalThis.String(object.runnerReplicaId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      cloudProviderId: isSet(object.cloudProviderId) ? globalThis.String(object.cloudProviderId) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: PostRunnerItemOutputsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.runnerItemId !== "") {
      obj.runnerItemId = message.runnerItemId;
    }
    if (message.runnerItemOutputs?.length) {
      obj.runnerItemOutputs = message.runnerItemOutputs.map((e) => RunnerItemOutput.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.runnerReplicaId !== "") {
      obj.runnerReplicaId = message.runnerReplicaId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.cloudProviderId !== "") {
      obj.cloudProviderId = message.cloudProviderId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostRunnerItemOutputsRequest>, I>>(base?: I): PostRunnerItemOutputsRequest {
    return PostRunnerItemOutputsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostRunnerItemOutputsRequest>, I>>(object: I): PostRunnerItemOutputsRequest {
    const message = createBasePostRunnerItemOutputsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.runnerItemId = object.runnerItemId ?? "";
    message.runnerItemOutputs = object.runnerItemOutputs?.map((e) => RunnerItemOutput.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.runnerReplicaId = object.runnerReplicaId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    message.cloudProviderId = object.cloudProviderId ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseSyncStateRequest(): SyncStateRequest {
  return { operationType: "", computeClusters: [], nodepools: [], runners: [], pipelineVersionRuns: [], secrets: [] };
}

export const SyncStateRequest: MessageFns<SyncStateRequest> = {
  encode(message: SyncStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationType !== "") {
      writer.uint32(10).string(message.operationType);
    }
    for (const v of message.computeClusters) {
      ComputeCluster.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.runners) {
      Runner.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.pipelineVersionRuns) {
      PipelineVersionRun.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusters.push(ComputeCluster.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runners.push(Runner.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pipelineVersionRuns.push(PipelineVersionRun.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStateRequest {
    return {
      operationType: isSet(object.operationType) ? globalThis.String(object.operationType) : "",
      computeClusters: globalThis.Array.isArray(object?.computeClusters)
        ? object.computeClusters.map((e: any) => ComputeCluster.fromJSON(e))
        : [],
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
      runners: globalThis.Array.isArray(object?.runners) ? object.runners.map((e: any) => Runner.fromJSON(e)) : [],
      pipelineVersionRuns: globalThis.Array.isArray(object?.pipelineVersionRuns)
        ? object.pipelineVersionRuns.map((e: any) => PipelineVersionRun.fromJSON(e))
        : [],
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
    };
  },

  toJSON(message: SyncStateRequest): unknown {
    const obj: any = {};
    if (message.operationType !== "") {
      obj.operationType = message.operationType;
    }
    if (message.computeClusters?.length) {
      obj.computeClusters = message.computeClusters.map((e) => ComputeCluster.toJSON(e));
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    if (message.runners?.length) {
      obj.runners = message.runners.map((e) => Runner.toJSON(e));
    }
    if (message.pipelineVersionRuns?.length) {
      obj.pipelineVersionRuns = message.pipelineVersionRuns.map((e) => PipelineVersionRun.toJSON(e));
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncStateRequest>, I>>(base?: I): SyncStateRequest {
    return SyncStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncStateRequest>, I>>(object: I): SyncStateRequest {
    const message = createBaseSyncStateRequest();
    message.operationType = object.operationType ?? "";
    message.computeClusters = object.computeClusters?.map((e) => ComputeCluster.fromPartial(e)) || [];
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    message.runners = object.runners?.map((e) => Runner.fromPartial(e)) || [];
    message.pipelineVersionRuns = object.pipelineVersionRuns?.map((e) => PipelineVersionRun.fromPartial(e)) || [];
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiRunnerItemResponse(): MultiRunnerItemResponse {
  return { status: undefined, runnerItems: [] };
}

export const MultiRunnerItemResponse: MessageFns<MultiRunnerItemResponse> = {
  encode(message: MultiRunnerItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.runnerItems) {
      RunnerItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiRunnerItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiRunnerItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runnerItems.push(RunnerItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiRunnerItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      runnerItems: globalThis.Array.isArray(object?.runnerItems)
        ? object.runnerItems.map((e: any) => RunnerItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiRunnerItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.runnerItems?.length) {
      obj.runnerItems = message.runnerItems.map((e) => RunnerItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiRunnerItemResponse>, I>>(base?: I): MultiRunnerItemResponse {
    return MultiRunnerItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiRunnerItemResponse>, I>>(object: I): MultiRunnerItemResponse {
    const message = createBaseMultiRunnerItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.runnerItems = object.runnerItems?.map((e) => RunnerItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunnerItem(): RunnerItem {
  return {
    id: "",
    description: "",
    processingInfo: undefined,
    postModelOutputsRequest: undefined,
    syncStateRequest: undefined,
  };
}

export const RunnerItem: MessageFns<RunnerItem> = {
  encode(message: RunnerItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.processingInfo !== undefined) {
      ProcessingInfo.encode(message.processingInfo, writer.uint32(26).fork()).join();
    }
    if (message.postModelOutputsRequest !== undefined) {
      PostModelOutputsRequest.encode(message.postModelOutputsRequest, writer.uint32(34).fork()).join();
    }
    if (message.syncStateRequest !== undefined) {
      SyncStateRequest.encode(message.syncStateRequest, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processingInfo = ProcessingInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.postModelOutputsRequest = PostModelOutputsRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.syncStateRequest = SyncStateRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunnerItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      processingInfo: isSet(object.processingInfo) ? ProcessingInfo.fromJSON(object.processingInfo) : undefined,
      postModelOutputsRequest: isSet(object.postModelOutputsRequest)
        ? PostModelOutputsRequest.fromJSON(object.postModelOutputsRequest)
        : undefined,
      syncStateRequest: isSet(object.syncStateRequest) ? SyncStateRequest.fromJSON(object.syncStateRequest) : undefined,
    };
  },

  toJSON(message: RunnerItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.processingInfo !== undefined) {
      obj.processingInfo = ProcessingInfo.toJSON(message.processingInfo);
    }
    if (message.postModelOutputsRequest !== undefined) {
      obj.postModelOutputsRequest = PostModelOutputsRequest.toJSON(message.postModelOutputsRequest);
    }
    if (message.syncStateRequest !== undefined) {
      obj.syncStateRequest = SyncStateRequest.toJSON(message.syncStateRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunnerItem>, I>>(base?: I): RunnerItem {
    return RunnerItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunnerItem>, I>>(object: I): RunnerItem {
    const message = createBaseRunnerItem();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.processingInfo = (object.processingInfo !== undefined && object.processingInfo !== null)
      ? ProcessingInfo.fromPartial(object.processingInfo)
      : undefined;
    message.postModelOutputsRequest =
      (object.postModelOutputsRequest !== undefined && object.postModelOutputsRequest !== null)
        ? PostModelOutputsRequest.fromPartial(object.postModelOutputsRequest)
        : undefined;
    message.syncStateRequest = (object.syncStateRequest !== undefined && object.syncStateRequest !== null)
      ? SyncStateRequest.fromPartial(object.syncStateRequest)
      : undefined;
    return message;
  },
};

function createBaseRunnerItemOutput(): RunnerItemOutput {
  return { multiOutputResponse: undefined };
}

export const RunnerItemOutput: MessageFns<RunnerItemOutput> = {
  encode(message: RunnerItemOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiOutputResponse !== undefined) {
      MultiOutputResponse.encode(message.multiOutputResponse, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerItemOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerItemOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.multiOutputResponse = MultiOutputResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunnerItemOutput {
    return {
      multiOutputResponse: isSet(object.multiOutputResponse)
        ? MultiOutputResponse.fromJSON(object.multiOutputResponse)
        : undefined,
    };
  },

  toJSON(message: RunnerItemOutput): unknown {
    const obj: any = {};
    if (message.multiOutputResponse !== undefined) {
      obj.multiOutputResponse = MultiOutputResponse.toJSON(message.multiOutputResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunnerItemOutput>, I>>(base?: I): RunnerItemOutput {
    return RunnerItemOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunnerItemOutput>, I>>(object: I): RunnerItemOutput {
    const message = createBaseRunnerItemOutput();
    message.multiOutputResponse = (object.multiOutputResponse !== undefined && object.multiOutputResponse !== null)
      ? MultiOutputResponse.fromPartial(object.multiOutputResponse)
      : undefined;
    return message;
  },
};

function createBaseMultiRunnerItemOutputResponse(): MultiRunnerItemOutputResponse {
  return { status: undefined, runnerItemOutputs: [] };
}

export const MultiRunnerItemOutputResponse: MessageFns<MultiRunnerItemOutputResponse> = {
  encode(message: MultiRunnerItemOutputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.runnerItemOutputs) {
      RunnerItemOutput.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiRunnerItemOutputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiRunnerItemOutputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runnerItemOutputs.push(RunnerItemOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiRunnerItemOutputResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      runnerItemOutputs: globalThis.Array.isArray(object?.runnerItemOutputs)
        ? object.runnerItemOutputs.map((e: any) => RunnerItemOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiRunnerItemOutputResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.runnerItemOutputs?.length) {
      obj.runnerItemOutputs = message.runnerItemOutputs.map((e) => RunnerItemOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiRunnerItemOutputResponse>, I>>(base?: I): MultiRunnerItemOutputResponse {
    return MultiRunnerItemOutputResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiRunnerItemOutputResponse>, I>>(
    object: I,
  ): MultiRunnerItemOutputResponse {
    const message = createBaseMultiRunnerItemOutputResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.runnerItemOutputs = object.runnerItemOutputs?.map((e) => RunnerItemOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostModelVersionsTrainingTimeEstimateRequest(): PostModelVersionsTrainingTimeEstimateRequest {
  return { userAppId: undefined, modelId: "", modelVersions: [], estimatedInputCount: 0 };
}

export const PostModelVersionsTrainingTimeEstimateRequest: MessageFns<PostModelVersionsTrainingTimeEstimateRequest> = {
  encode(
    message: PostModelVersionsTrainingTimeEstimateRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.modelVersions) {
      ModelVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.estimatedInputCount !== 0) {
      writer.uint32(32).uint64(message.estimatedInputCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelVersionsTrainingTimeEstimateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelVersionsTrainingTimeEstimateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersions.push(ModelVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.estimatedInputCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelVersionsTrainingTimeEstimateRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersions: globalThis.Array.isArray(object?.modelVersions)
        ? object.modelVersions.map((e: any) => ModelVersion.fromJSON(e))
        : [],
      estimatedInputCount: isSet(object.estimatedInputCount) ? globalThis.Number(object.estimatedInputCount) : 0,
    };
  },

  toJSON(message: PostModelVersionsTrainingTimeEstimateRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersions?.length) {
      obj.modelVersions = message.modelVersions.map((e) => ModelVersion.toJSON(e));
    }
    if (message.estimatedInputCount !== 0) {
      obj.estimatedInputCount = Math.round(message.estimatedInputCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelVersionsTrainingTimeEstimateRequest>, I>>(
    base?: I,
  ): PostModelVersionsTrainingTimeEstimateRequest {
    return PostModelVersionsTrainingTimeEstimateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelVersionsTrainingTimeEstimateRequest>, I>>(
    object: I,
  ): PostModelVersionsTrainingTimeEstimateRequest {
    const message = createBasePostModelVersionsTrainingTimeEstimateRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersions = object.modelVersions?.map((e) => ModelVersion.fromPartial(e)) || [];
    message.estimatedInputCount = object.estimatedInputCount ?? 0;
    return message;
  },
};

function createBaseMultiTrainingTimeEstimateResponse(): MultiTrainingTimeEstimateResponse {
  return { status: undefined, trainingTimeEstimates: [] };
}

export const MultiTrainingTimeEstimateResponse: MessageFns<MultiTrainingTimeEstimateResponse> = {
  encode(message: MultiTrainingTimeEstimateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.trainingTimeEstimates) {
      Duration.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiTrainingTimeEstimateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiTrainingTimeEstimateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trainingTimeEstimates.push(Duration.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiTrainingTimeEstimateResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      trainingTimeEstimates: globalThis.Array.isArray(object?.trainingTimeEstimates)
        ? object.trainingTimeEstimates.map((e: any) => Duration.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiTrainingTimeEstimateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.trainingTimeEstimates?.length) {
      obj.trainingTimeEstimates = message.trainingTimeEstimates.map((e) => Duration.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiTrainingTimeEstimateResponse>, I>>(
    base?: I,
  ): MultiTrainingTimeEstimateResponse {
    return MultiTrainingTimeEstimateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiTrainingTimeEstimateResponse>, I>>(
    object: I,
  ): MultiTrainingTimeEstimateResponse {
    const message = createBaseMultiTrainingTimeEstimateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.trainingTimeEstimates = object.trainingTimeEstimates?.map((e) => Duration.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListCloudProvidersRequest(): ListCloudProvidersRequest {
  return {};
}

export const ListCloudProvidersRequest: MessageFns<ListCloudProvidersRequest> = {
  encode(_: ListCloudProvidersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudProvidersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudProvidersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListCloudProvidersRequest {
    return {};
  },

  toJSON(_: ListCloudProvidersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCloudProvidersRequest>, I>>(base?: I): ListCloudProvidersRequest {
    return ListCloudProvidersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCloudProvidersRequest>, I>>(_: I): ListCloudProvidersRequest {
    const message = createBaseListCloudProvidersRequest();
    return message;
  },
};

function createBaseMultiCloudProviderResponse(): MultiCloudProviderResponse {
  return { status: undefined, cloudProviders: [] };
}

export const MultiCloudProviderResponse: MessageFns<MultiCloudProviderResponse> = {
  encode(message: MultiCloudProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.cloudProviders) {
      CloudProvider.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCloudProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCloudProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cloudProviders.push(CloudProvider.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCloudProviderResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      cloudProviders: globalThis.Array.isArray(object?.cloudProviders)
        ? object.cloudProviders.map((e: any) => CloudProvider.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiCloudProviderResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.cloudProviders?.length) {
      obj.cloudProviders = message.cloudProviders.map((e) => CloudProvider.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCloudProviderResponse>, I>>(base?: I): MultiCloudProviderResponse {
    return MultiCloudProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCloudProviderResponse>, I>>(object: I): MultiCloudProviderResponse {
    const message = createBaseMultiCloudProviderResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.cloudProviders = object.cloudProviders?.map((e) => CloudProvider.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListCloudRegionsRequest(): ListCloudRegionsRequest {
  return { cloudProvider: undefined };
}

export const ListCloudRegionsRequest: MessageFns<ListCloudRegionsRequest> = {
  encode(message: ListCloudRegionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudProvider !== undefined) {
      CloudProvider.encode(message.cloudProvider, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloudRegionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloudRegionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cloudProvider = CloudProvider.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloudRegionsRequest {
    return { cloudProvider: isSet(object.cloudProvider) ? CloudProvider.fromJSON(object.cloudProvider) : undefined };
  },

  toJSON(message: ListCloudRegionsRequest): unknown {
    const obj: any = {};
    if (message.cloudProvider !== undefined) {
      obj.cloudProvider = CloudProvider.toJSON(message.cloudProvider);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCloudRegionsRequest>, I>>(base?: I): ListCloudRegionsRequest {
    return ListCloudRegionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCloudRegionsRequest>, I>>(object: I): ListCloudRegionsRequest {
    const message = createBaseListCloudRegionsRequest();
    message.cloudProvider = (object.cloudProvider !== undefined && object.cloudProvider !== null)
      ? CloudProvider.fromPartial(object.cloudProvider)
      : undefined;
    return message;
  },
};

function createBaseMultiCloudRegionResponse(): MultiCloudRegionResponse {
  return { status: undefined, regions: [] };
}

export const MultiCloudRegionResponse: MessageFns<MultiCloudRegionResponse> = {
  encode(message: MultiCloudRegionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.regions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCloudRegionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCloudRegionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCloudRegionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MultiCloudRegionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.regions?.length) {
      obj.regions = message.regions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCloudRegionResponse>, I>>(base?: I): MultiCloudRegionResponse {
    return MultiCloudRegionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCloudRegionResponse>, I>>(object: I): MultiCloudRegionResponse {
    const message = createBaseMultiCloudRegionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.regions = object.regions?.map((e) => e) || [];
    return message;
  },
};

function createBaseListInstanceTypesRequest(): ListInstanceTypesRequest {
  return { cloudProvider: undefined, region: "" };
}

export const ListInstanceTypesRequest: MessageFns<ListInstanceTypesRequest> = {
  encode(message: ListInstanceTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudProvider !== undefined) {
      CloudProvider.encode(message.cloudProvider, writer.uint32(10).fork()).join();
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cloudProvider = CloudProvider.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceTypesRequest {
    return {
      cloudProvider: isSet(object.cloudProvider) ? CloudProvider.fromJSON(object.cloudProvider) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: ListInstanceTypesRequest): unknown {
    const obj: any = {};
    if (message.cloudProvider !== undefined) {
      obj.cloudProvider = CloudProvider.toJSON(message.cloudProvider);
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInstanceTypesRequest>, I>>(base?: I): ListInstanceTypesRequest {
    return ListInstanceTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInstanceTypesRequest>, I>>(object: I): ListInstanceTypesRequest {
    const message = createBaseListInstanceTypesRequest();
    message.cloudProvider = (object.cloudProvider !== undefined && object.cloudProvider !== null)
      ? CloudProvider.fromPartial(object.cloudProvider)
      : undefined;
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseMultiInstanceTypeResponse(): MultiInstanceTypeResponse {
  return { status: undefined, instanceTypes: [] };
}

export const MultiInstanceTypeResponse: MessageFns<MultiInstanceTypeResponse> = {
  encode(message: MultiInstanceTypeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.instanceTypes) {
      InstanceType.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiInstanceTypeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiInstanceTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceTypes.push(InstanceType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiInstanceTypeResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      instanceTypes: globalThis.Array.isArray(object?.instanceTypes)
        ? object.instanceTypes.map((e: any) => InstanceType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiInstanceTypeResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.instanceTypes?.length) {
      obj.instanceTypes = message.instanceTypes.map((e) => InstanceType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiInstanceTypeResponse>, I>>(base?: I): MultiInstanceTypeResponse {
    return MultiInstanceTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiInstanceTypeResponse>, I>>(object: I): MultiInstanceTypeResponse {
    const message = createBaseMultiInstanceTypeResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.instanceTypes = object.instanceTypes?.map((e) => InstanceType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetComputeClusterRequest(): GetComputeClusterRequest {
  return { userAppId: undefined, computeClusterId: "" };
}

export const GetComputeClusterRequest: MessageFns<GetComputeClusterRequest> = {
  encode(message: GetComputeClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComputeClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComputeClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetComputeClusterRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: GetComputeClusterRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetComputeClusterRequest>, I>>(base?: I): GetComputeClusterRequest {
    return GetComputeClusterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetComputeClusterRequest>, I>>(object: I): GetComputeClusterRequest {
    const message = createBaseGetComputeClusterRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBaseListComputeClustersRequest(): ListComputeClustersRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListComputeClustersRequest: MessageFns<ListComputeClustersRequest> = {
  encode(message: ListComputeClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListComputeClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComputeClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListComputeClustersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListComputeClustersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListComputeClustersRequest>, I>>(base?: I): ListComputeClustersRequest {
    return ListComputeClustersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListComputeClustersRequest>, I>>(object: I): ListComputeClustersRequest {
    const message = createBaseListComputeClustersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostComputeClustersRequest(): PostComputeClustersRequest {
  return { userAppId: undefined, computeClusters: [] };
}

export const PostComputeClustersRequest: MessageFns<PostComputeClustersRequest> = {
  encode(message: PostComputeClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.computeClusters) {
      ComputeCluster.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostComputeClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostComputeClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusters.push(ComputeCluster.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostComputeClustersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusters: globalThis.Array.isArray(object?.computeClusters)
        ? object.computeClusters.map((e: any) => ComputeCluster.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostComputeClustersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusters?.length) {
      obj.computeClusters = message.computeClusters.map((e) => ComputeCluster.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostComputeClustersRequest>, I>>(base?: I): PostComputeClustersRequest {
    return PostComputeClustersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostComputeClustersRequest>, I>>(object: I): PostComputeClustersRequest {
    const message = createBasePostComputeClustersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusters = object.computeClusters?.map((e) => ComputeCluster.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteComputeClustersRequest(): DeleteComputeClustersRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteComputeClustersRequest: MessageFns<DeleteComputeClustersRequest> = {
  encode(message: DeleteComputeClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteComputeClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteComputeClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteComputeClustersRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteComputeClustersRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteComputeClustersRequest>, I>>(base?: I): DeleteComputeClustersRequest {
    return DeleteComputeClustersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteComputeClustersRequest>, I>>(object: I): DeleteComputeClustersRequest {
    const message = createBaseDeleteComputeClustersRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleComputeClusterResponse(): SingleComputeClusterResponse {
  return { status: undefined, computeCluster: undefined };
}

export const SingleComputeClusterResponse: MessageFns<SingleComputeClusterResponse> = {
  encode(message: SingleComputeClusterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.computeCluster !== undefined) {
      ComputeCluster.encode(message.computeCluster, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleComputeClusterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleComputeClusterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeCluster = ComputeCluster.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleComputeClusterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      computeCluster: isSet(object.computeCluster) ? ComputeCluster.fromJSON(object.computeCluster) : undefined,
    };
  },

  toJSON(message: SingleComputeClusterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.computeCluster !== undefined) {
      obj.computeCluster = ComputeCluster.toJSON(message.computeCluster);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleComputeClusterResponse>, I>>(base?: I): SingleComputeClusterResponse {
    return SingleComputeClusterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleComputeClusterResponse>, I>>(object: I): SingleComputeClusterResponse {
    const message = createBaseSingleComputeClusterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.computeCluster = (object.computeCluster !== undefined && object.computeCluster !== null)
      ? ComputeCluster.fromPartial(object.computeCluster)
      : undefined;
    return message;
  },
};

function createBaseMultiComputeClusterResponse(): MultiComputeClusterResponse {
  return { status: undefined, computeClusters: [] };
}

export const MultiComputeClusterResponse: MessageFns<MultiComputeClusterResponse> = {
  encode(message: MultiComputeClusterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.computeClusters) {
      ComputeCluster.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiComputeClusterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiComputeClusterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusters.push(ComputeCluster.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiComputeClusterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      computeClusters: globalThis.Array.isArray(object?.computeClusters)
        ? object.computeClusters.map((e: any) => ComputeCluster.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiComputeClusterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.computeClusters?.length) {
      obj.computeClusters = message.computeClusters.map((e) => ComputeCluster.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiComputeClusterResponse>, I>>(base?: I): MultiComputeClusterResponse {
    return MultiComputeClusterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiComputeClusterResponse>, I>>(object: I): MultiComputeClusterResponse {
    const message = createBaseMultiComputeClusterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.computeClusters = object.computeClusters?.map((e) => ComputeCluster.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNodepoolRequest(): GetNodepoolRequest {
  return { userAppId: undefined, computeClusterId: "", nodepoolId: "" };
}

export const GetNodepoolRequest: MessageFns<GetNodepoolRequest> = {
  encode(message: GetNodepoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    if (message.nodepoolId !== "") {
      writer.uint32(26).string(message.nodepoolId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodepoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodepoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodepoolRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
    };
  },

  toJSON(message: GetNodepoolRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodepoolRequest>, I>>(base?: I): GetNodepoolRequest {
    return GetNodepoolRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodepoolRequest>, I>>(object: I): GetNodepoolRequest {
    const message = createBaseGetNodepoolRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepoolId = object.nodepoolId ?? "";
    return message;
  },
};

function createBaseListNodepoolsRequest(): ListNodepoolsRequest {
  return { userAppId: undefined, computeClusterId: "", page: 0, perPage: 0, activeUsage: false };
}

export const ListNodepoolsRequest: MessageFns<ListNodepoolsRequest> = {
  encode(message: ListNodepoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    if (message.activeUsage !== false) {
      writer.uint32(40).bool(message.activeUsage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodepoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodepoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activeUsage = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodepoolsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      activeUsage: isSet(object.activeUsage) ? globalThis.Boolean(object.activeUsage) : false,
    };
  },

  toJSON(message: ListNodepoolsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.activeUsage !== false) {
      obj.activeUsage = message.activeUsage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNodepoolsRequest>, I>>(base?: I): ListNodepoolsRequest {
    return ListNodepoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNodepoolsRequest>, I>>(object: I): ListNodepoolsRequest {
    const message = createBaseListNodepoolsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.activeUsage = object.activeUsage ?? false;
    return message;
  },
};

function createBasePostNodepoolsRequest(): PostNodepoolsRequest {
  return { userAppId: undefined, computeClusterId: "", nodepools: [] };
}

export const PostNodepoolsRequest: MessageFns<PostNodepoolsRequest> = {
  encode(message: PostNodepoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostNodepoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostNodepoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostNodepoolsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostNodepoolsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostNodepoolsRequest>, I>>(base?: I): PostNodepoolsRequest {
    return PostNodepoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostNodepoolsRequest>, I>>(object: I): PostNodepoolsRequest {
    const message = createBasePostNodepoolsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchNodepoolsRequest(): PatchNodepoolsRequest {
  return { userAppId: undefined, computeClusterId: "", nodepools: [], action: "" };
}

export const PatchNodepoolsRequest: MessageFns<PatchNodepoolsRequest> = {
  encode(message: PatchNodepoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchNodepoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchNodepoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchNodepoolsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchNodepoolsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchNodepoolsRequest>, I>>(base?: I): PatchNodepoolsRequest {
    return PatchNodepoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchNodepoolsRequest>, I>>(object: I): PatchNodepoolsRequest {
    const message = createBasePatchNodepoolsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteNodepoolsRequest(): DeleteNodepoolsRequest {
  return { userAppId: undefined, computeClusterId: "", ids: [] };
}

export const DeleteNodepoolsRequest: MessageFns<DeleteNodepoolsRequest> = {
  encode(message: DeleteNodepoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.computeClusterId !== "") {
      writer.uint32(18).string(message.computeClusterId);
    }
    for (const v of message.ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodepoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodepoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodepoolsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteNodepoolsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNodepoolsRequest>, I>>(base?: I): DeleteNodepoolsRequest {
    return DeleteNodepoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNodepoolsRequest>, I>>(object: I): DeleteNodepoolsRequest {
    const message = createBaseDeleteNodepoolsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.computeClusterId = object.computeClusterId ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleNodepoolResponse(): SingleNodepoolResponse {
  return { status: undefined, nodepool: undefined };
}

export const SingleNodepoolResponse: MessageFns<SingleNodepoolResponse> = {
  encode(message: SingleNodepoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.nodepool !== undefined) {
      Nodepool.encode(message.nodepool, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleNodepoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleNodepoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepool = Nodepool.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleNodepoolResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      nodepool: isSet(object.nodepool) ? Nodepool.fromJSON(object.nodepool) : undefined,
    };
  },

  toJSON(message: SingleNodepoolResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.nodepool !== undefined) {
      obj.nodepool = Nodepool.toJSON(message.nodepool);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleNodepoolResponse>, I>>(base?: I): SingleNodepoolResponse {
    return SingleNodepoolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleNodepoolResponse>, I>>(object: I): SingleNodepoolResponse {
    const message = createBaseSingleNodepoolResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.nodepool = (object.nodepool !== undefined && object.nodepool !== null)
      ? Nodepool.fromPartial(object.nodepool)
      : undefined;
    return message;
  },
};

function createBaseMultiNodepoolResponse(): MultiNodepoolResponse {
  return { status: undefined, nodepools: [] };
}

export const MultiNodepoolResponse: MessageFns<MultiNodepoolResponse> = {
  encode(message: MultiNodepoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodepoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodepoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodepoolResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiNodepoolResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodepoolResponse>, I>>(base?: I): MultiNodepoolResponse {
    return MultiNodepoolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodepoolResponse>, I>>(object: I): MultiNodepoolResponse {
    const message = createBaseMultiNodepoolResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDeploymentRequest(): GetDeploymentRequest {
  return { userAppId: undefined, deploymentId: "" };
}

export const GetDeploymentRequest: MessageFns<GetDeploymentRequest> = {
  encode(message: GetDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.deploymentId !== "") {
      writer.uint32(18).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
    };
  },

  toJSON(message: GetDeploymentRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeploymentRequest>, I>>(base?: I): GetDeploymentRequest {
    return GetDeploymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeploymentRequest>, I>>(object: I): GetDeploymentRequest {
    const message = createBaseGetDeploymentRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.deploymentId = object.deploymentId ?? "";
    return message;
  },
};

function createBaseListDeploymentsRequest(): ListDeploymentsRequest {
  return {
    userAppId: undefined,
    nodepoolId: "",
    page: 0,
    perPage: 0,
    modelVersionIds: [],
    workflowVersionIds: [],
    computeClusterId: "",
  };
}

export const ListDeploymentsRequest: MessageFns<ListDeploymentsRequest> = {
  encode(message: ListDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.nodepoolId !== "") {
      writer.uint32(18).string(message.nodepoolId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    for (const v of message.modelVersionIds) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.workflowVersionIds) {
      writer.uint32(50).string(v!);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(58).string(message.computeClusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modelVersionIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workflowVersionIds.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      modelVersionIds: globalThis.Array.isArray(object?.modelVersionIds)
        ? object.modelVersionIds.map((e: any) => globalThis.String(e))
        : [],
      workflowVersionIds: globalThis.Array.isArray(object?.workflowVersionIds)
        ? object.workflowVersionIds.map((e: any) => globalThis.String(e))
        : [],
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
    };
  },

  toJSON(message: ListDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.modelVersionIds?.length) {
      obj.modelVersionIds = message.modelVersionIds;
    }
    if (message.workflowVersionIds?.length) {
      obj.workflowVersionIds = message.workflowVersionIds;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDeploymentsRequest>, I>>(base?: I): ListDeploymentsRequest {
    return ListDeploymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDeploymentsRequest>, I>>(object: I): ListDeploymentsRequest {
    const message = createBaseListDeploymentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.nodepoolId = object.nodepoolId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.modelVersionIds = object.modelVersionIds?.map((e) => e) || [];
    message.workflowVersionIds = object.workflowVersionIds?.map((e) => e) || [];
    message.computeClusterId = object.computeClusterId ?? "";
    return message;
  },
};

function createBasePostDeploymentsRequest(): PostDeploymentsRequest {
  return { userAppId: undefined, deployments: [] };
}

export const PostDeploymentsRequest: MessageFns<PostDeploymentsRequest> = {
  encode(message: PostDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostDeploymentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostDeploymentsRequest>, I>>(base?: I): PostDeploymentsRequest {
    return PostDeploymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostDeploymentsRequest>, I>>(object: I): PostDeploymentsRequest {
    const message = createBasePostDeploymentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteDeploymentsRequest(): DeleteDeploymentsRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteDeploymentsRequest: MessageFns<DeleteDeploymentsRequest> = {
  encode(message: DeleteDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDeploymentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDeploymentsRequest>, I>>(base?: I): DeleteDeploymentsRequest {
    return DeleteDeploymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDeploymentsRequest>, I>>(object: I): DeleteDeploymentsRequest {
    const message = createBaseDeleteDeploymentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBasePostAuditLogSearchesRequest(): PostAuditLogSearchesRequest {
  return { userAppId: undefined, query: undefined, sortAscending: false, pagination: undefined };
}

export const PostAuditLogSearchesRequest: MessageFns<PostAuditLogSearchesRequest> = {
  encode(message: PostAuditLogSearchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      AuditLogQuery.encode(message.query, writer.uint32(18).fork()).join();
    }
    if (message.sortAscending !== false) {
      writer.uint32(24).bool(message.sortAscending);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostAuditLogSearchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostAuditLogSearchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = AuditLogQuery.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sortAscending = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostAuditLogSearchesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      query: isSet(object.query) ? AuditLogQuery.fromJSON(object.query) : undefined,
      sortAscending: isSet(object.sortAscending) ? globalThis.Boolean(object.sortAscending) : false,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: PostAuditLogSearchesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.query !== undefined) {
      obj.query = AuditLogQuery.toJSON(message.query);
    }
    if (message.sortAscending !== false) {
      obj.sortAscending = message.sortAscending;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostAuditLogSearchesRequest>, I>>(base?: I): PostAuditLogSearchesRequest {
    return PostAuditLogSearchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostAuditLogSearchesRequest>, I>>(object: I): PostAuditLogSearchesRequest {
    const message = createBasePostAuditLogSearchesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null)
      ? AuditLogQuery.fromPartial(object.query)
      : undefined;
    message.sortAscending = object.sortAscending ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseMultiAuditLogEntryResponse(): MultiAuditLogEntryResponse {
  return { status: undefined, entries: [] };
}

export const MultiAuditLogEntryResponse: MessageFns<MultiAuditLogEntryResponse> = {
  encode(message: MultiAuditLogEntryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiAuditLogEntryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiAuditLogEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiAuditLogEntryResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => AuditLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiAuditLogEntryResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => AuditLogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiAuditLogEntryResponse>, I>>(base?: I): MultiAuditLogEntryResponse {
    return MultiAuditLogEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiAuditLogEntryResponse>, I>>(object: I): MultiAuditLogEntryResponse {
    const message = createBaseMultiAuditLogEntryResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.entries = object.entries?.map((e) => AuditLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchDeploymentsRequest(): PatchDeploymentsRequest {
  return { userAppId: undefined, deployments: [], action: "" };
}

export const PatchDeploymentsRequest: MessageFns<PatchDeploymentsRequest> = {
  encode(message: PatchDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchDeploymentsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchDeploymentsRequest>, I>>(base?: I): PatchDeploymentsRequest {
    return PatchDeploymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchDeploymentsRequest>, I>>(object: I): PatchDeploymentsRequest {
    const message = createBasePatchDeploymentsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseSingleDeploymentResponse(): SingleDeploymentResponse {
  return { status: undefined, deployment: undefined };
}

export const SingleDeploymentResponse: MessageFns<SingleDeploymentResponse> = {
  encode(message: SingleDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleDeploymentResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
    };
  },

  toJSON(message: SingleDeploymentResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleDeploymentResponse>, I>>(base?: I): SingleDeploymentResponse {
    return SingleDeploymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleDeploymentResponse>, I>>(object: I): SingleDeploymentResponse {
    const message = createBaseSingleDeploymentResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    return message;
  },
};

function createBaseMultiDeploymentResponse(): MultiDeploymentResponse {
  return { status: undefined, deployments: [] };
}

export const MultiDeploymentResponse: MessageFns<MultiDeploymentResponse> = {
  encode(message: MultiDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiDeploymentResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiDeploymentResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiDeploymentResponse>, I>>(base?: I): MultiDeploymentResponse {
    return MultiDeploymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiDeploymentResponse>, I>>(object: I): MultiDeploymentResponse {
    const message = createBaseMultiDeploymentResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListWorkflowEvaluationTemplatesRequest(): ListWorkflowEvaluationTemplatesRequest {
  return {};
}

export const ListWorkflowEvaluationTemplatesRequest: MessageFns<ListWorkflowEvaluationTemplatesRequest> = {
  encode(_: ListWorkflowEvaluationTemplatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowEvaluationTemplatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowEvaluationTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListWorkflowEvaluationTemplatesRequest {
    return {};
  },

  toJSON(_: ListWorkflowEvaluationTemplatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkflowEvaluationTemplatesRequest>, I>>(
    base?: I,
  ): ListWorkflowEvaluationTemplatesRequest {
    return ListWorkflowEvaluationTemplatesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkflowEvaluationTemplatesRequest>, I>>(
    _: I,
  ): ListWorkflowEvaluationTemplatesRequest {
    const message = createBaseListWorkflowEvaluationTemplatesRequest();
    return message;
  },
};

function createBaseMultiWorkflowEvaluationTemplateResponse(): MultiWorkflowEvaluationTemplateResponse {
  return { status: undefined, workflowVersionEvaluationTemplates: [] };
}

export const MultiWorkflowEvaluationTemplateResponse: MessageFns<MultiWorkflowEvaluationTemplateResponse> = {
  encode(message: MultiWorkflowEvaluationTemplateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflowVersionEvaluationTemplates) {
      WorkflowVersionEvaluationTemplate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiWorkflowEvaluationTemplateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiWorkflowEvaluationTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersionEvaluationTemplates.push(
            WorkflowVersionEvaluationTemplate.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiWorkflowEvaluationTemplateResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersionEvaluationTemplates: globalThis.Array.isArray(object?.workflowVersionEvaluationTemplates)
        ? object.workflowVersionEvaluationTemplates.map((e: any) => WorkflowVersionEvaluationTemplate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiWorkflowEvaluationTemplateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersionEvaluationTemplates?.length) {
      obj.workflowVersionEvaluationTemplates = message.workflowVersionEvaluationTemplates.map((e) =>
        WorkflowVersionEvaluationTemplate.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiWorkflowEvaluationTemplateResponse>, I>>(
    base?: I,
  ): MultiWorkflowEvaluationTemplateResponse {
    return MultiWorkflowEvaluationTemplateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiWorkflowEvaluationTemplateResponse>, I>>(
    object: I,
  ): MultiWorkflowEvaluationTemplateResponse {
    const message = createBaseMultiWorkflowEvaluationTemplateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersionEvaluationTemplates =
      object.workflowVersionEvaluationTemplates?.map((e) => WorkflowVersionEvaluationTemplate.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostWorkflowVersionEvaluationsRequest(): PostWorkflowVersionEvaluationsRequest {
  return {
    userAppId: undefined,
    workflowId: "",
    workflowVersionId: "",
    workflowVersionEvaluations: [],
    runnerSelectors: [],
  };
}

export const PostWorkflowVersionEvaluationsRequest: MessageFns<PostWorkflowVersionEvaluationsRequest> = {
  encode(message: PostWorkflowVersionEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    for (const v of message.workflowVersionEvaluations) {
      WorkflowVersionEvaluation.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.runnerSelectors) {
      RunnerSelector.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowVersionEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowVersionEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluations.push(WorkflowVersionEvaluation.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runnerSelectors.push(RunnerSelector.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowVersionEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      workflowVersionEvaluations: globalThis.Array.isArray(object?.workflowVersionEvaluations)
        ? object.workflowVersionEvaluations.map((e: any) => WorkflowVersionEvaluation.fromJSON(e))
        : [],
      runnerSelectors: globalThis.Array.isArray(object?.runnerSelectors)
        ? object.runnerSelectors.map((e: any) => RunnerSelector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostWorkflowVersionEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.workflowVersionEvaluations?.length) {
      obj.workflowVersionEvaluations = message.workflowVersionEvaluations.map((e) =>
        WorkflowVersionEvaluation.toJSON(e)
      );
    }
    if (message.runnerSelectors?.length) {
      obj.runnerSelectors = message.runnerSelectors.map((e) => RunnerSelector.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowVersionEvaluationsRequest>, I>>(
    base?: I,
  ): PostWorkflowVersionEvaluationsRequest {
    return PostWorkflowVersionEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowVersionEvaluationsRequest>, I>>(
    object: I,
  ): PostWorkflowVersionEvaluationsRequest {
    const message = createBasePostWorkflowVersionEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.workflowVersionEvaluations =
      object.workflowVersionEvaluations?.map((e) => WorkflowVersionEvaluation.fromPartial(e)) || [];
    message.runnerSelectors = object.runnerSelectors?.map((e) => RunnerSelector.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchWorkflowVersionEvaluationsRequest(): PatchWorkflowVersionEvaluationsRequest {
  return { userAppId: undefined, workflowId: "", workflowVersionId: "", workflowVersionEvaluations: [], action: "" };
}

export const PatchWorkflowVersionEvaluationsRequest: MessageFns<PatchWorkflowVersionEvaluationsRequest> = {
  encode(message: PatchWorkflowVersionEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    for (const v of message.workflowVersionEvaluations) {
      WorkflowVersionEvaluation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchWorkflowVersionEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchWorkflowVersionEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluations.push(WorkflowVersionEvaluation.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchWorkflowVersionEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      workflowVersionEvaluations: globalThis.Array.isArray(object?.workflowVersionEvaluations)
        ? object.workflowVersionEvaluations.map((e: any) => WorkflowVersionEvaluation.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchWorkflowVersionEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.workflowVersionEvaluations?.length) {
      obj.workflowVersionEvaluations = message.workflowVersionEvaluations.map((e) =>
        WorkflowVersionEvaluation.toJSON(e)
      );
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchWorkflowVersionEvaluationsRequest>, I>>(
    base?: I,
  ): PatchWorkflowVersionEvaluationsRequest {
    return PatchWorkflowVersionEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchWorkflowVersionEvaluationsRequest>, I>>(
    object: I,
  ): PatchWorkflowVersionEvaluationsRequest {
    const message = createBasePatchWorkflowVersionEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.workflowVersionEvaluations =
      object.workflowVersionEvaluations?.map((e) => WorkflowVersionEvaluation.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseMultiWorkflowVersionEvaluationResponse(): MultiWorkflowVersionEvaluationResponse {
  return { status: undefined, workflowVersionEvaluations: [] };
}

export const MultiWorkflowVersionEvaluationResponse: MessageFns<MultiWorkflowVersionEvaluationResponse> = {
  encode(message: MultiWorkflowVersionEvaluationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflowVersionEvaluations) {
      WorkflowVersionEvaluation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiWorkflowVersionEvaluationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiWorkflowVersionEvaluationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersionEvaluations.push(WorkflowVersionEvaluation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiWorkflowVersionEvaluationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersionEvaluations: globalThis.Array.isArray(object?.workflowVersionEvaluations)
        ? object.workflowVersionEvaluations.map((e: any) => WorkflowVersionEvaluation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiWorkflowVersionEvaluationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersionEvaluations?.length) {
      obj.workflowVersionEvaluations = message.workflowVersionEvaluations.map((e) =>
        WorkflowVersionEvaluation.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiWorkflowVersionEvaluationResponse>, I>>(
    base?: I,
  ): MultiWorkflowVersionEvaluationResponse {
    return MultiWorkflowVersionEvaluationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiWorkflowVersionEvaluationResponse>, I>>(
    object: I,
  ): MultiWorkflowVersionEvaluationResponse {
    const message = createBaseMultiWorkflowVersionEvaluationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersionEvaluations =
      object.workflowVersionEvaluations?.map((e) => WorkflowVersionEvaluation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleWorkflowVersionEvaluationResponse(): SingleWorkflowVersionEvaluationResponse {
  return { status: undefined, workflowVersionEvaluation: undefined };
}

export const SingleWorkflowVersionEvaluationResponse: MessageFns<SingleWorkflowVersionEvaluationResponse> = {
  encode(message: SingleWorkflowVersionEvaluationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.workflowVersionEvaluation !== undefined) {
      WorkflowVersionEvaluation.encode(message.workflowVersionEvaluation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleWorkflowVersionEvaluationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleWorkflowVersionEvaluationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersionEvaluation = WorkflowVersionEvaluation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleWorkflowVersionEvaluationResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersionEvaluation: isSet(object.workflowVersionEvaluation)
        ? WorkflowVersionEvaluation.fromJSON(object.workflowVersionEvaluation)
        : undefined,
    };
  },

  toJSON(message: SingleWorkflowVersionEvaluationResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersionEvaluation !== undefined) {
      obj.workflowVersionEvaluation = WorkflowVersionEvaluation.toJSON(message.workflowVersionEvaluation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleWorkflowVersionEvaluationResponse>, I>>(
    base?: I,
  ): SingleWorkflowVersionEvaluationResponse {
    return SingleWorkflowVersionEvaluationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleWorkflowVersionEvaluationResponse>, I>>(
    object: I,
  ): SingleWorkflowVersionEvaluationResponse {
    const message = createBaseSingleWorkflowVersionEvaluationResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersionEvaluation =
      (object.workflowVersionEvaluation !== undefined && object.workflowVersionEvaluation !== null)
        ? WorkflowVersionEvaluation.fromPartial(object.workflowVersionEvaluation)
        : undefined;
    return message;
  },
};

function createBaseGetWorkflowVersionEvaluationRequest(): GetWorkflowVersionEvaluationRequest {
  return { userAppId: undefined, workflowId: "", workflowVersionId: "", workflowVersionEvaluationId: "" };
}

export const GetWorkflowVersionEvaluationRequest: MessageFns<GetWorkflowVersionEvaluationRequest> = {
  encode(message: GetWorkflowVersionEvaluationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    if (message.workflowVersionEvaluationId !== "") {
      writer.uint32(34).string(message.workflowVersionEvaluationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkflowVersionEvaluationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowVersionEvaluationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowVersionEvaluationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      workflowVersionEvaluationId: isSet(object.workflowVersionEvaluationId)
        ? globalThis.String(object.workflowVersionEvaluationId)
        : "",
    };
  },

  toJSON(message: GetWorkflowVersionEvaluationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.workflowVersionEvaluationId !== "") {
      obj.workflowVersionEvaluationId = message.workflowVersionEvaluationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWorkflowVersionEvaluationRequest>, I>>(
    base?: I,
  ): GetWorkflowVersionEvaluationRequest {
    return GetWorkflowVersionEvaluationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWorkflowVersionEvaluationRequest>, I>>(
    object: I,
  ): GetWorkflowVersionEvaluationRequest {
    const message = createBaseGetWorkflowVersionEvaluationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.workflowVersionEvaluationId = object.workflowVersionEvaluationId ?? "";
    return message;
  },
};

function createBaseListWorkflowVersionEvaluationsRequest(): ListWorkflowVersionEvaluationsRequest {
  return { userAppId: undefined, workflowId: "", workflowVersionId: "", page: 0, perPage: 0 };
}

export const ListWorkflowVersionEvaluationsRequest: MessageFns<ListWorkflowVersionEvaluationsRequest> = {
  encode(message: ListWorkflowVersionEvaluationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowVersionEvaluationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowVersionEvaluationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkflowVersionEvaluationsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListWorkflowVersionEvaluationsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkflowVersionEvaluationsRequest>, I>>(
    base?: I,
  ): ListWorkflowVersionEvaluationsRequest {
    return ListWorkflowVersionEvaluationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkflowVersionEvaluationsRequest>, I>>(
    object: I,
  ): ListWorkflowVersionEvaluationsRequest {
    const message = createBaseListWorkflowVersionEvaluationsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostModelMigrationRequest(): PostModelMigrationRequest {
  return { userAppId: undefined, modelId: "" };
}

export const PostModelMigrationRequest: MessageFns<PostModelMigrationRequest> = {
  encode(message: PostModelMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostModelMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostModelMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostModelMigrationRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
    };
  },

  toJSON(message: PostModelMigrationRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostModelMigrationRequest>, I>>(base?: I): PostModelMigrationRequest {
    return PostModelMigrationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostModelMigrationRequest>, I>>(object: I): PostModelMigrationRequest {
    const message = createBasePostModelMigrationRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    return message;
  },
};

function createBaseListWorkflowVersionEvaluationDataRequest(): ListWorkflowVersionEvaluationDataRequest {
  return {
    userAppId: undefined,
    workflowId: "",
    workflowVersionId: "",
    workflowVersionEvaluationId: "",
    page: 0,
    perPage: 0,
  };
}

export const ListWorkflowVersionEvaluationDataRequest: MessageFns<ListWorkflowVersionEvaluationDataRequest> = {
  encode(message: ListWorkflowVersionEvaluationDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    if (message.workflowVersionEvaluationId !== "") {
      writer.uint32(34).string(message.workflowVersionEvaluationId);
    }
    if (message.page !== 0) {
      writer.uint32(40).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(48).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowVersionEvaluationDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowVersionEvaluationDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkflowVersionEvaluationDataRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      workflowVersionEvaluationId: isSet(object.workflowVersionEvaluationId)
        ? globalThis.String(object.workflowVersionEvaluationId)
        : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListWorkflowVersionEvaluationDataRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.workflowVersionEvaluationId !== "") {
      obj.workflowVersionEvaluationId = message.workflowVersionEvaluationId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkflowVersionEvaluationDataRequest>, I>>(
    base?: I,
  ): ListWorkflowVersionEvaluationDataRequest {
    return ListWorkflowVersionEvaluationDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkflowVersionEvaluationDataRequest>, I>>(
    object: I,
  ): ListWorkflowVersionEvaluationDataRequest {
    const message = createBaseListWorkflowVersionEvaluationDataRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.workflowVersionEvaluationId = object.workflowVersionEvaluationId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostWorkflowVersionEvaluationDataRequest(): PostWorkflowVersionEvaluationDataRequest {
  return {
    userAppId: undefined,
    workflowId: "",
    workflowVersionId: "",
    workflowVersionEvaluationId: "",
    workflowVersionEvaluationData: [],
  };
}

export const PostWorkflowVersionEvaluationDataRequest: MessageFns<PostWorkflowVersionEvaluationDataRequest> = {
  encode(message: PostWorkflowVersionEvaluationDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.workflowVersionId !== "") {
      writer.uint32(26).string(message.workflowVersionId);
    }
    if (message.workflowVersionEvaluationId !== "") {
      writer.uint32(34).string(message.workflowVersionEvaluationId);
    }
    for (const v of message.workflowVersionEvaluationData) {
      WorkflowVersionEvaluationData.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostWorkflowVersionEvaluationDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostWorkflowVersionEvaluationDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowVersionEvaluationData.push(WorkflowVersionEvaluationData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostWorkflowVersionEvaluationDataRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowVersionId: isSet(object.workflowVersionId) ? globalThis.String(object.workflowVersionId) : "",
      workflowVersionEvaluationId: isSet(object.workflowVersionEvaluationId)
        ? globalThis.String(object.workflowVersionEvaluationId)
        : "",
      workflowVersionEvaluationData: globalThis.Array.isArray(object?.workflowVersionEvaluationData)
        ? object.workflowVersionEvaluationData.map((e: any) => WorkflowVersionEvaluationData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostWorkflowVersionEvaluationDataRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== "") {
      obj.workflowVersionId = message.workflowVersionId;
    }
    if (message.workflowVersionEvaluationId !== "") {
      obj.workflowVersionEvaluationId = message.workflowVersionEvaluationId;
    }
    if (message.workflowVersionEvaluationData?.length) {
      obj.workflowVersionEvaluationData = message.workflowVersionEvaluationData.map((e) =>
        WorkflowVersionEvaluationData.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostWorkflowVersionEvaluationDataRequest>, I>>(
    base?: I,
  ): PostWorkflowVersionEvaluationDataRequest {
    return PostWorkflowVersionEvaluationDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostWorkflowVersionEvaluationDataRequest>, I>>(
    object: I,
  ): PostWorkflowVersionEvaluationDataRequest {
    const message = createBasePostWorkflowVersionEvaluationDataRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.workflowId = object.workflowId ?? "";
    message.workflowVersionId = object.workflowVersionId ?? "";
    message.workflowVersionEvaluationId = object.workflowVersionEvaluationId ?? "";
    message.workflowVersionEvaluationData =
      object.workflowVersionEvaluationData?.map((e) => WorkflowVersionEvaluationData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiListWorkflowVersionEvaluationDataResponse(): MultiListWorkflowVersionEvaluationDataResponse {
  return { status: undefined, workflowVersionEvaluationData: [] };
}

export const MultiListWorkflowVersionEvaluationDataResponse: MessageFns<
  MultiListWorkflowVersionEvaluationDataResponse
> = {
  encode(
    message: MultiListWorkflowVersionEvaluationDataResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.workflowVersionEvaluationData) {
      WorkflowVersionEvaluationData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiListWorkflowVersionEvaluationDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiListWorkflowVersionEvaluationDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersionEvaluationData.push(WorkflowVersionEvaluationData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiListWorkflowVersionEvaluationDataResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      workflowVersionEvaluationData: globalThis.Array.isArray(object?.workflowVersionEvaluationData)
        ? object.workflowVersionEvaluationData.map((e: any) => WorkflowVersionEvaluationData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiListWorkflowVersionEvaluationDataResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.workflowVersionEvaluationData?.length) {
      obj.workflowVersionEvaluationData = message.workflowVersionEvaluationData.map((e) =>
        WorkflowVersionEvaluationData.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiListWorkflowVersionEvaluationDataResponse>, I>>(
    base?: I,
  ): MultiListWorkflowVersionEvaluationDataResponse {
    return MultiListWorkflowVersionEvaluationDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiListWorkflowVersionEvaluationDataResponse>, I>>(
    object: I,
  ): MultiListWorkflowVersionEvaluationDataResponse {
    const message = createBaseMultiListWorkflowVersionEvaluationDataResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.workflowVersionEvaluationData =
      object.workflowVersionEvaluationData?.map((e) => WorkflowVersionEvaluationData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPipelineRequest(): GetPipelineRequest {
  return { userAppId: undefined, pipelineId: "" };
}

export const GetPipelineRequest: MessageFns<GetPipelineRequest> = {
  encode(message: GetPipelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPipelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
    };
  },

  toJSON(message: GetPipelineRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineRequest>, I>>(base?: I): GetPipelineRequest {
    return GetPipelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineRequest>, I>>(object: I): GetPipelineRequest {
    const message = createBaseGetPipelineRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    return message;
  },
};

function createBaseListPipelinesRequest(): ListPipelinesRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListPipelinesRequest: MessageFns<ListPipelinesRequest> = {
  encode(message: ListPipelinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPipelinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelinesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListPipelinesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelinesRequest>, I>>(base?: I): ListPipelinesRequest {
    return ListPipelinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelinesRequest>, I>>(object: I): ListPipelinesRequest {
    const message = createBaseListPipelinesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostPipelinesRequest(): PostPipelinesRequest {
  return { userAppId: undefined, pipelines: [] };
}

export const PostPipelinesRequest: MessageFns<PostPipelinesRequest> = {
  encode(message: PostPipelinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelines) {
      Pipeline.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelines.push(Pipeline.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelinesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelines: globalThis.Array.isArray(object?.pipelines)
        ? object.pipelines.map((e: any) => Pipeline.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostPipelinesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelines?.length) {
      obj.pipelines = message.pipelines.map((e) => Pipeline.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelinesRequest>, I>>(base?: I): PostPipelinesRequest {
    return PostPipelinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelinesRequest>, I>>(object: I): PostPipelinesRequest {
    const message = createBasePostPipelinesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelines = object.pipelines?.map((e) => Pipeline.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchPipelinesRequest(): PatchPipelinesRequest {
  return { userAppId: undefined, pipelines: [], action: "" };
}

export const PatchPipelinesRequest: MessageFns<PatchPipelinesRequest> = {
  encode(message: PatchPipelinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelines) {
      Pipeline.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchPipelinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchPipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelines.push(Pipeline.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchPipelinesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelines: globalThis.Array.isArray(object?.pipelines)
        ? object.pipelines.map((e: any) => Pipeline.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchPipelinesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelines?.length) {
      obj.pipelines = message.pipelines.map((e) => Pipeline.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchPipelinesRequest>, I>>(base?: I): PatchPipelinesRequest {
    return PatchPipelinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchPipelinesRequest>, I>>(object: I): PatchPipelinesRequest {
    const message = createBasePatchPipelinesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelines = object.pipelines?.map((e) => Pipeline.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeletePipelinesRequest(): DeletePipelinesRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeletePipelinesRequest: MessageFns<DeletePipelinesRequest> = {
  encode(message: DeletePipelinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePipelinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePipelinesRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeletePipelinesRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePipelinesRequest>, I>>(base?: I): DeletePipelinesRequest {
    return DeletePipelinesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePipelinesRequest>, I>>(object: I): DeletePipelinesRequest {
    const message = createBaseDeletePipelinesRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSinglePipelineResponse(): SinglePipelineResponse {
  return { status: undefined, pipeline: undefined };
}

export const SinglePipelineResponse: MessageFns<SinglePipelineResponse> = {
  encode(message: SinglePipelineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pipeline !== undefined) {
      Pipeline.encode(message.pipeline, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePipelineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePipelineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipeline = Pipeline.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePipelineResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipeline: isSet(object.pipeline) ? Pipeline.fromJSON(object.pipeline) : undefined,
    };
  },

  toJSON(message: SinglePipelineResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipeline !== undefined) {
      obj.pipeline = Pipeline.toJSON(message.pipeline);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePipelineResponse>, I>>(base?: I): SinglePipelineResponse {
    return SinglePipelineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePipelineResponse>, I>>(object: I): SinglePipelineResponse {
    const message = createBaseSinglePipelineResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipeline = (object.pipeline !== undefined && object.pipeline !== null)
      ? Pipeline.fromPartial(object.pipeline)
      : undefined;
    return message;
  },
};

function createBaseMultiPipelineResponse(): MultiPipelineResponse {
  return { status: undefined, pipelines: [] };
}

export const MultiPipelineResponse: MessageFns<MultiPipelineResponse> = {
  encode(message: MultiPipelineResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelines) {
      Pipeline.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPipelineResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPipelineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelines.push(Pipeline.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPipelineResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelines: globalThis.Array.isArray(object?.pipelines)
        ? object.pipelines.map((e: any) => Pipeline.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiPipelineResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelines?.length) {
      obj.pipelines = message.pipelines.map((e) => Pipeline.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPipelineResponse>, I>>(base?: I): MultiPipelineResponse {
    return MultiPipelineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPipelineResponse>, I>>(object: I): MultiPipelineResponse {
    const message = createBaseMultiPipelineResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelines = object.pipelines?.map((e) => Pipeline.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPipelineVersionRequest(): GetPipelineVersionRequest {
  return { userAppId: undefined, pipelineId: "", pipelineVersionId: "" };
}

export const GetPipelineVersionRequest: MessageFns<GetPipelineVersionRequest> = {
  encode(message: GetPipelineVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(26).string(message.pipelineVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPipelineVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
    };
  },

  toJSON(message: GetPipelineVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineVersionRequest>, I>>(base?: I): GetPipelineVersionRequest {
    return GetPipelineVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineVersionRequest>, I>>(object: I): GetPipelineVersionRequest {
    const message = createBaseGetPipelineVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    return message;
  },
};

function createBaseListPipelineVersionsRequest(): ListPipelineVersionsRequest {
  return { userAppId: undefined, pipelineId: "", page: 0, perPage: 0 };
}

export const ListPipelineVersionsRequest: MessageFns<ListPipelineVersionsRequest> = {
  encode(message: ListPipelineVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPipelineVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelineVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelineVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListPipelineVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelineVersionsRequest>, I>>(base?: I): ListPipelineVersionsRequest {
    return ListPipelineVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelineVersionsRequest>, I>>(object: I): ListPipelineVersionsRequest {
    const message = createBaseListPipelineVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePatchPipelineVersionsRequest(): PatchPipelineVersionsRequest {
  return { userAppId: undefined, pipelineId: "", pipelineVersions: [], action: "" };
}

export const PatchPipelineVersionsRequest: MessageFns<PatchPipelineVersionsRequest> = {
  encode(message: PatchPipelineVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    for (const v of message.pipelineVersions) {
      PipelineVersion.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchPipelineVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchPipelineVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersions.push(PipelineVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchPipelineVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersions: globalThis.Array.isArray(object?.pipelineVersions)
        ? object.pipelineVersions.map((e: any) => PipelineVersion.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchPipelineVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersions?.length) {
      obj.pipelineVersions = message.pipelineVersions.map((e) => PipelineVersion.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchPipelineVersionsRequest>, I>>(base?: I): PatchPipelineVersionsRequest {
    return PatchPipelineVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchPipelineVersionsRequest>, I>>(object: I): PatchPipelineVersionsRequest {
    const message = createBasePatchPipelineVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersions = object.pipelineVersions?.map((e) => PipelineVersion.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeletePipelineVersionsRequest(): DeletePipelineVersionsRequest {
  return { userAppId: undefined, pipelineId: "", pipelineVersionIds: [] };
}

export const DeletePipelineVersionsRequest: MessageFns<DeletePipelineVersionsRequest> = {
  encode(message: DeletePipelineVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    for (const v of message.pipelineVersionIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePipelineVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePipelineVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePipelineVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionIds: globalThis.Array.isArray(object?.pipelineVersionIds)
        ? object.pipelineVersionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeletePipelineVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionIds?.length) {
      obj.pipelineVersionIds = message.pipelineVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePipelineVersionsRequest>, I>>(base?: I): DeletePipelineVersionsRequest {
    return DeletePipelineVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePipelineVersionsRequest>, I>>(
    object: I,
  ): DeletePipelineVersionsRequest {
    const message = createBaseDeletePipelineVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionIds = object.pipelineVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseSinglePipelineVersionResponse(): SinglePipelineVersionResponse {
  return { status: undefined, pipelineVersion: undefined };
}

export const SinglePipelineVersionResponse: MessageFns<SinglePipelineVersionResponse> = {
  encode(message: SinglePipelineVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pipelineVersion !== undefined) {
      PipelineVersion.encode(message.pipelineVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePipelineVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePipelineVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineVersion = PipelineVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePipelineVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineVersion: isSet(object.pipelineVersion) ? PipelineVersion.fromJSON(object.pipelineVersion) : undefined,
    };
  },

  toJSON(message: SinglePipelineVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineVersion !== undefined) {
      obj.pipelineVersion = PipelineVersion.toJSON(message.pipelineVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePipelineVersionResponse>, I>>(base?: I): SinglePipelineVersionResponse {
    return SinglePipelineVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePipelineVersionResponse>, I>>(
    object: I,
  ): SinglePipelineVersionResponse {
    const message = createBaseSinglePipelineVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineVersion = (object.pipelineVersion !== undefined && object.pipelineVersion !== null)
      ? PipelineVersion.fromPartial(object.pipelineVersion)
      : undefined;
    return message;
  },
};

function createBaseMultiPipelineVersionResponse(): MultiPipelineVersionResponse {
  return { status: undefined, pipelineVersions: [] };
}

export const MultiPipelineVersionResponse: MessageFns<MultiPipelineVersionResponse> = {
  encode(message: MultiPipelineVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelineVersions) {
      PipelineVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPipelineVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPipelineVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineVersions.push(PipelineVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPipelineVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineVersions: globalThis.Array.isArray(object?.pipelineVersions)
        ? object.pipelineVersions.map((e: any) => PipelineVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiPipelineVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineVersions?.length) {
      obj.pipelineVersions = message.pipelineVersions.map((e) => PipelineVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPipelineVersionResponse>, I>>(base?: I): MultiPipelineVersionResponse {
    return MultiPipelineVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPipelineVersionResponse>, I>>(object: I): MultiPipelineVersionResponse {
    const message = createBaseMultiPipelineVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineVersions = object.pipelineVersions?.map((e) => PipelineVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPipelineVersionRunRequest(): GetPipelineVersionRunRequest {
  return { userAppId: undefined, pipelineId: "", pipelineVersionId: "", pipelineVersionRunId: "" };
}

export const GetPipelineVersionRunRequest: MessageFns<GetPipelineVersionRunRequest> = {
  encode(message: GetPipelineVersionRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(26).string(message.pipelineVersionId);
    }
    if (message.pipelineVersionRunId !== "") {
      writer.uint32(34).string(message.pipelineVersionRunId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPipelineVersionRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineVersionRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pipelineVersionRunId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineVersionRunRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRunId: isSet(object.pipelineVersionRunId) ? globalThis.String(object.pipelineVersionRunId) : "",
    };
  },

  toJSON(message: GetPipelineVersionRunRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRunId !== "") {
      obj.pipelineVersionRunId = message.pipelineVersionRunId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineVersionRunRequest>, I>>(base?: I): GetPipelineVersionRunRequest {
    return GetPipelineVersionRunRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineVersionRunRequest>, I>>(object: I): GetPipelineVersionRunRequest {
    const message = createBaseGetPipelineVersionRunRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRunId = object.pipelineVersionRunId ?? "";
    return message;
  },
};

function createBaseListPipelineVersionRunsRequest(): ListPipelineVersionRunsRequest {
  return {
    userAppId: undefined,
    pipelineId: "",
    pipelineVersionId: "",
    page: 0,
    perPage: 0,
    statusCodes: [],
    computeClusterId: "",
    nodepoolId: "",
  };
}

export const ListPipelineVersionRunsRequest: MessageFns<ListPipelineVersionRunsRequest> = {
  encode(message: ListPipelineVersionRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(26).string(message.pipelineVersionId);
    }
    if (message.page !== 0) {
      writer.uint32(32).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(40).uint32(message.perPage);
    }
    writer.uint32(50).fork();
    for (const v of message.statusCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.computeClusterId !== "") {
      writer.uint32(58).string(message.computeClusterId);
    }
    if (message.nodepoolId !== "") {
      writer.uint32(66).string(message.nodepoolId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPipelineVersionRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelineVersionRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.statusCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statusCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelineVersionRunsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      statusCodes: globalThis.Array.isArray(object?.statusCodes)
        ? object.statusCodes.map((e: any) => statusCodeFromJSON(e))
        : [],
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
    };
  },

  toJSON(message: ListPipelineVersionRunsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.statusCodes?.length) {
      obj.statusCodes = message.statusCodes.map((e) => statusCodeToJSON(e));
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelineVersionRunsRequest>, I>>(base?: I): ListPipelineVersionRunsRequest {
    return ListPipelineVersionRunsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelineVersionRunsRequest>, I>>(
    object: I,
  ): ListPipelineVersionRunsRequest {
    const message = createBaseListPipelineVersionRunsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.statusCodes = object.statusCodes?.map((e) => e) || [];
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepoolId = object.nodepoolId ?? "";
    return message;
  },
};

function createBasePostPipelineVersionRunsRequest(): PostPipelineVersionRunsRequest {
  return {
    userAppId: undefined,
    pipelineId: "",
    pipelineVersionId: "",
    pipelineVersionRuns: [],
    runnerSelector: undefined,
  };
}

export const PostPipelineVersionRunsRequest: MessageFns<PostPipelineVersionRunsRequest> = {
  encode(message: PostPipelineVersionRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(26).string(message.pipelineVersionId);
    }
    for (const v of message.pipelineVersionRuns) {
      PipelineVersionRun.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.runnerSelector !== undefined) {
      RunnerSelector.encode(message.runnerSelector, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelineVersionRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelineVersionRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pipelineVersionRuns.push(PipelineVersionRun.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runnerSelector = RunnerSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelineVersionRunsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRuns: globalThis.Array.isArray(object?.pipelineVersionRuns)
        ? object.pipelineVersionRuns.map((e: any) => PipelineVersionRun.fromJSON(e))
        : [],
      runnerSelector: isSet(object.runnerSelector) ? RunnerSelector.fromJSON(object.runnerSelector) : undefined,
    };
  },

  toJSON(message: PostPipelineVersionRunsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRuns?.length) {
      obj.pipelineVersionRuns = message.pipelineVersionRuns.map((e) => PipelineVersionRun.toJSON(e));
    }
    if (message.runnerSelector !== undefined) {
      obj.runnerSelector = RunnerSelector.toJSON(message.runnerSelector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelineVersionRunsRequest>, I>>(base?: I): PostPipelineVersionRunsRequest {
    return PostPipelineVersionRunsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelineVersionRunsRequest>, I>>(
    object: I,
  ): PostPipelineVersionRunsRequest {
    const message = createBasePostPipelineVersionRunsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRuns = object.pipelineVersionRuns?.map((e) => PipelineVersionRun.fromPartial(e)) || [];
    message.runnerSelector = (object.runnerSelector !== undefined && object.runnerSelector !== null)
      ? RunnerSelector.fromPartial(object.runnerSelector)
      : undefined;
    return message;
  },
};

function createBasePatchPipelineVersionRunsRequest(): PatchPipelineVersionRunsRequest {
  return { userAppId: undefined, pipelineId: "", pipelineVersionId: "", pipelineVersionRuns: [], action: "" };
}

export const PatchPipelineVersionRunsRequest: MessageFns<PatchPipelineVersionRunsRequest> = {
  encode(message: PatchPipelineVersionRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(18).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(26).string(message.pipelineVersionId);
    }
    for (const v of message.pipelineVersionRuns) {
      PipelineVersionRun.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchPipelineVersionRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchPipelineVersionRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pipelineVersionRuns.push(PipelineVersionRun.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchPipelineVersionRunsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRuns: globalThis.Array.isArray(object?.pipelineVersionRuns)
        ? object.pipelineVersionRuns.map((e: any) => PipelineVersionRun.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchPipelineVersionRunsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRuns?.length) {
      obj.pipelineVersionRuns = message.pipelineVersionRuns.map((e) => PipelineVersionRun.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchPipelineVersionRunsRequest>, I>>(base?: I): PatchPipelineVersionRunsRequest {
    return PatchPipelineVersionRunsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchPipelineVersionRunsRequest>, I>>(
    object: I,
  ): PatchPipelineVersionRunsRequest {
    const message = createBasePatchPipelineVersionRunsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRuns = object.pipelineVersionRuns?.map((e) => PipelineVersionRun.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseSinglePipelineVersionRunResponse(): SinglePipelineVersionRunResponse {
  return { status: undefined, pipelineVersionRun: undefined };
}

export const SinglePipelineVersionRunResponse: MessageFns<SinglePipelineVersionRunResponse> = {
  encode(message: SinglePipelineVersionRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pipelineVersionRun !== undefined) {
      PipelineVersionRun.encode(message.pipelineVersionRun, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePipelineVersionRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePipelineVersionRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineVersionRun = PipelineVersionRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePipelineVersionRunResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineVersionRun: isSet(object.pipelineVersionRun)
        ? PipelineVersionRun.fromJSON(object.pipelineVersionRun)
        : undefined,
    };
  },

  toJSON(message: SinglePipelineVersionRunResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineVersionRun !== undefined) {
      obj.pipelineVersionRun = PipelineVersionRun.toJSON(message.pipelineVersionRun);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePipelineVersionRunResponse>, I>>(
    base?: I,
  ): SinglePipelineVersionRunResponse {
    return SinglePipelineVersionRunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePipelineVersionRunResponse>, I>>(
    object: I,
  ): SinglePipelineVersionRunResponse {
    const message = createBaseSinglePipelineVersionRunResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineVersionRun = (object.pipelineVersionRun !== undefined && object.pipelineVersionRun !== null)
      ? PipelineVersionRun.fromPartial(object.pipelineVersionRun)
      : undefined;
    return message;
  },
};

function createBaseMultiPipelineVersionRunResponse(): MultiPipelineVersionRunResponse {
  return { status: undefined, pipelineVersionRuns: [] };
}

export const MultiPipelineVersionRunResponse: MessageFns<MultiPipelineVersionRunResponse> = {
  encode(message: MultiPipelineVersionRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelineVersionRuns) {
      PipelineVersionRun.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPipelineVersionRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPipelineVersionRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineVersionRuns.push(PipelineVersionRun.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPipelineVersionRunResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineVersionRuns: globalThis.Array.isArray(object?.pipelineVersionRuns)
        ? object.pipelineVersionRuns.map((e: any) => PipelineVersionRun.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiPipelineVersionRunResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineVersionRuns?.length) {
      obj.pipelineVersionRuns = message.pipelineVersionRuns.map((e) => PipelineVersionRun.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPipelineVersionRunResponse>, I>>(base?: I): MultiPipelineVersionRunResponse {
    return MultiPipelineVersionRunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPipelineVersionRunResponse>, I>>(
    object: I,
  ): MultiPipelineVersionRunResponse {
    const message = createBaseMultiPipelineVersionRunResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineVersionRuns = object.pipelineVersionRuns?.map((e) => PipelineVersionRun.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostPipelineStepsRequest(): PostPipelineStepsRequest {
  return { userAppId: undefined, pipelineSteps: [] };
}

export const PostPipelineStepsRequest: MessageFns<PostPipelineStepsRequest> = {
  encode(message: PostPipelineStepsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelineSteps) {
      PipelineStep.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelineStepsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelineStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineSteps.push(PipelineStep.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelineStepsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineSteps: globalThis.Array.isArray(object?.pipelineSteps)
        ? object.pipelineSteps.map((e: any) => PipelineStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PostPipelineStepsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineSteps?.length) {
      obj.pipelineSteps = message.pipelineSteps.map((e) => PipelineStep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelineStepsRequest>, I>>(base?: I): PostPipelineStepsRequest {
    return PostPipelineStepsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelineStepsRequest>, I>>(object: I): PostPipelineStepsRequest {
    const message = createBasePostPipelineStepsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineSteps = object.pipelineSteps?.map((e) => PipelineStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiPipelineStepResponse(): MultiPipelineStepResponse {
  return { status: undefined, pipelineSteps: [] };
}

export const MultiPipelineStepResponse: MessageFns<MultiPipelineStepResponse> = {
  encode(message: MultiPipelineStepResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelineSteps) {
      PipelineStep.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPipelineStepResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPipelineStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineSteps.push(PipelineStep.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPipelineStepResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineSteps: globalThis.Array.isArray(object?.pipelineSteps)
        ? object.pipelineSteps.map((e: any) => PipelineStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiPipelineStepResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineSteps?.length) {
      obj.pipelineSteps = message.pipelineSteps.map((e) => PipelineStep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPipelineStepResponse>, I>>(base?: I): MultiPipelineStepResponse {
    return MultiPipelineStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPipelineStepResponse>, I>>(object: I): MultiPipelineStepResponse {
    const message = createBaseMultiPipelineStepResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineSteps = object.pipelineSteps?.map((e) => PipelineStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListPipelineStepsRequest(): ListPipelineStepsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListPipelineStepsRequest: MessageFns<ListPipelineStepsRequest> = {
  encode(message: ListPipelineStepsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPipelineStepsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelineStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelineStepsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListPipelineStepsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelineStepsRequest>, I>>(base?: I): ListPipelineStepsRequest {
    return ListPipelineStepsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelineStepsRequest>, I>>(object: I): ListPipelineStepsRequest {
    const message = createBaseListPipelineStepsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBaseListPipelineStepVersionsRequest(): ListPipelineStepVersionsRequest {
  return { userAppId: undefined, pipelineStepId: "", page: 0, perPage: 0, statusCodes: [] };
}

export const ListPipelineStepVersionsRequest: MessageFns<ListPipelineStepVersionsRequest> = {
  encode(message: ListPipelineStepVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(18).string(message.pipelineStepId);
    }
    if (message.page !== 0) {
      writer.uint32(24).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(32).uint32(message.perPage);
    }
    writer.uint32(50).fork();
    for (const v of message.statusCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPipelineStepVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPipelineStepVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.statusCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statusCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPipelineStepVersionsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      statusCodes: globalThis.Array.isArray(object?.statusCodes)
        ? object.statusCodes.map((e: any) => statusCodeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPipelineStepVersionsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    if (message.statusCodes?.length) {
      obj.statusCodes = message.statusCodes.map((e) => statusCodeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPipelineStepVersionsRequest>, I>>(base?: I): ListPipelineStepVersionsRequest {
    return ListPipelineStepVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPipelineStepVersionsRequest>, I>>(
    object: I,
  ): ListPipelineStepVersionsRequest {
    const message = createBaseListPipelineStepVersionsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    message.statusCodes = object.statusCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiPipelineStepVersionResponse(): MultiPipelineStepVersionResponse {
  return { status: undefined, pipelineStepVersions: [] };
}

export const MultiPipelineStepVersionResponse: MessageFns<MultiPipelineStepVersionResponse> = {
  encode(message: MultiPipelineStepVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.pipelineStepVersions) {
      PipelineStepVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiPipelineStepVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiPipelineStepVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepVersions.push(PipelineStepVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiPipelineStepVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineStepVersions: globalThis.Array.isArray(object?.pipelineStepVersions)
        ? object.pipelineStepVersions.map((e: any) => PipelineStepVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiPipelineStepVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineStepVersions?.length) {
      obj.pipelineStepVersions = message.pipelineStepVersions.map((e) => PipelineStepVersion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiPipelineStepVersionResponse>, I>>(
    base?: I,
  ): MultiPipelineStepVersionResponse {
    return MultiPipelineStepVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiPipelineStepVersionResponse>, I>>(
    object: I,
  ): MultiPipelineStepVersionResponse {
    const message = createBaseMultiPipelineStepVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineStepVersions = object.pipelineStepVersions?.map((e) => PipelineStepVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePostPipelineStepVersionsUploadRequest(): PostPipelineStepVersionsUploadRequest {
  return { uploadConfig: undefined, contentPart: undefined };
}

export const PostPipelineStepVersionsUploadRequest: MessageFns<PostPipelineStepVersionsUploadRequest> = {
  encode(message: PostPipelineStepVersionsUploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadConfig !== undefined) {
      PostPipelineStepVersionsUploadConfig.encode(message.uploadConfig, writer.uint32(18).fork()).join();
    }
    if (message.contentPart !== undefined) {
      UploadContentPart.encode(message.contentPart, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelineStepVersionsUploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelineStepVersionsUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uploadConfig = PostPipelineStepVersionsUploadConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentPart = UploadContentPart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelineStepVersionsUploadRequest {
    return {
      uploadConfig: isSet(object.uploadConfig)
        ? PostPipelineStepVersionsUploadConfig.fromJSON(object.uploadConfig)
        : undefined,
      contentPart: isSet(object.contentPart) ? UploadContentPart.fromJSON(object.contentPart) : undefined,
    };
  },

  toJSON(message: PostPipelineStepVersionsUploadRequest): unknown {
    const obj: any = {};
    if (message.uploadConfig !== undefined) {
      obj.uploadConfig = PostPipelineStepVersionsUploadConfig.toJSON(message.uploadConfig);
    }
    if (message.contentPart !== undefined) {
      obj.contentPart = UploadContentPart.toJSON(message.contentPart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadRequest>, I>>(
    base?: I,
  ): PostPipelineStepVersionsUploadRequest {
    return PostPipelineStepVersionsUploadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadRequest>, I>>(
    object: I,
  ): PostPipelineStepVersionsUploadRequest {
    const message = createBasePostPipelineStepVersionsUploadRequest();
    message.uploadConfig = (object.uploadConfig !== undefined && object.uploadConfig !== null)
      ? PostPipelineStepVersionsUploadConfig.fromPartial(object.uploadConfig)
      : undefined;
    message.contentPart = (object.contentPart !== undefined && object.contentPart !== null)
      ? UploadContentPart.fromPartial(object.contentPart)
      : undefined;
    return message;
  },
};

function createBasePostPipelineStepVersionsUploadResponse(): PostPipelineStepVersionsUploadResponse {
  return { status: undefined, bytesRemaining: 0, pipelineStepVersionId: "" };
}

export const PostPipelineStepVersionsUploadResponse: MessageFns<PostPipelineStepVersionsUploadResponse> = {
  encode(message: PostPipelineStepVersionsUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.bytesRemaining !== 0) {
      writer.uint32(16).uint64(message.bytesRemaining);
    }
    if (message.pipelineStepVersionId !== "") {
      writer.uint32(26).string(message.pipelineStepVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelineStepVersionsUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelineStepVersionsUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesRemaining = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineStepVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelineStepVersionsUploadResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      bytesRemaining: isSet(object.bytesRemaining) ? globalThis.Number(object.bytesRemaining) : 0,
      pipelineStepVersionId: isSet(object.pipelineStepVersionId) ? globalThis.String(object.pipelineStepVersionId) : "",
    };
  },

  toJSON(message: PostPipelineStepVersionsUploadResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.bytesRemaining !== 0) {
      obj.bytesRemaining = Math.round(message.bytesRemaining);
    }
    if (message.pipelineStepVersionId !== "") {
      obj.pipelineStepVersionId = message.pipelineStepVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadResponse>, I>>(
    base?: I,
  ): PostPipelineStepVersionsUploadResponse {
    return PostPipelineStepVersionsUploadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadResponse>, I>>(
    object: I,
  ): PostPipelineStepVersionsUploadResponse {
    const message = createBasePostPipelineStepVersionsUploadResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.bytesRemaining = object.bytesRemaining ?? 0;
    message.pipelineStepVersionId = object.pipelineStepVersionId ?? "";
    return message;
  },
};

function createBasePostPipelineStepVersionsUploadConfig(): PostPipelineStepVersionsUploadConfig {
  return {
    userAppId: undefined,
    pipelineStepId: "",
    pipelineStepVersion: undefined,
    totalSize: 0,
    storageRequestSize: 0,
  };
}

export const PostPipelineStepVersionsUploadConfig: MessageFns<PostPipelineStepVersionsUploadConfig> = {
  encode(message: PostPipelineStepVersionsUploadConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(18).string(message.pipelineStepId);
    }
    if (message.pipelineStepVersion !== undefined) {
      PipelineStepVersion.encode(message.pipelineStepVersion, writer.uint32(26).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).uint64(message.totalSize);
    }
    if (message.storageRequestSize !== 0) {
      writer.uint32(40).uint64(message.storageRequestSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPipelineStepVersionsUploadConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPipelineStepVersionsUploadConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineStepVersion = PipelineStepVersion.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalSize = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageRequestSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPipelineStepVersionsUploadConfig {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      pipelineStepVersion: isSet(object.pipelineStepVersion)
        ? PipelineStepVersion.fromJSON(object.pipelineStepVersion)
        : undefined,
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      storageRequestSize: isSet(object.storageRequestSize) ? globalThis.Number(object.storageRequestSize) : 0,
    };
  },

  toJSON(message: PostPipelineStepVersionsUploadConfig): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.pipelineStepVersion !== undefined) {
      obj.pipelineStepVersion = PipelineStepVersion.toJSON(message.pipelineStepVersion);
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.storageRequestSize !== 0) {
      obj.storageRequestSize = Math.round(message.storageRequestSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadConfig>, I>>(
    base?: I,
  ): PostPipelineStepVersionsUploadConfig {
    return PostPipelineStepVersionsUploadConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPipelineStepVersionsUploadConfig>, I>>(
    object: I,
  ): PostPipelineStepVersionsUploadConfig {
    const message = createBasePostPipelineStepVersionsUploadConfig();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.pipelineStepVersion = (object.pipelineStepVersion !== undefined && object.pipelineStepVersion !== null)
      ? PipelineStepVersion.fromPartial(object.pipelineStepVersion)
      : undefined;
    message.totalSize = object.totalSize ?? 0;
    message.storageRequestSize = object.storageRequestSize ?? 0;
    return message;
  },
};

function createBaseGetPipelineStepRequest(): GetPipelineStepRequest {
  return { userAppId: undefined, pipelineStepId: "" };
}

export const GetPipelineStepRequest: MessageFns<GetPipelineStepRequest> = {
  encode(message: GetPipelineStepRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(18).string(message.pipelineStepId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPipelineStepRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineStepRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
    };
  },

  toJSON(message: GetPipelineStepRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineStepRequest>, I>>(base?: I): GetPipelineStepRequest {
    return GetPipelineStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineStepRequest>, I>>(object: I): GetPipelineStepRequest {
    const message = createBaseGetPipelineStepRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineStepId = object.pipelineStepId ?? "";
    return message;
  },
};

function createBaseSinglePipelineStepResponse(): SinglePipelineStepResponse {
  return { status: undefined, pipelineStep: undefined };
}

export const SinglePipelineStepResponse: MessageFns<SinglePipelineStepResponse> = {
  encode(message: SinglePipelineStepResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStep !== undefined) {
      PipelineStep.encode(message.pipelineStep, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePipelineStepResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePipelineStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStep = PipelineStep.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePipelineStepResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineStep: isSet(object.pipelineStep) ? PipelineStep.fromJSON(object.pipelineStep) : undefined,
    };
  },

  toJSON(message: SinglePipelineStepResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineStep !== undefined) {
      obj.pipelineStep = PipelineStep.toJSON(message.pipelineStep);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePipelineStepResponse>, I>>(base?: I): SinglePipelineStepResponse {
    return SinglePipelineStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePipelineStepResponse>, I>>(object: I): SinglePipelineStepResponse {
    const message = createBaseSinglePipelineStepResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineStep = (object.pipelineStep !== undefined && object.pipelineStep !== null)
      ? PipelineStep.fromPartial(object.pipelineStep)
      : undefined;
    return message;
  },
};

function createBaseGetPipelineStepVersionRequest(): GetPipelineStepVersionRequest {
  return { userAppId: undefined, pipelineStepId: "", pipelineStepVersionId: "" };
}

export const GetPipelineStepVersionRequest: MessageFns<GetPipelineStepVersionRequest> = {
  encode(message: GetPipelineStepVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(18).string(message.pipelineStepId);
    }
    if (message.pipelineStepVersionId !== "") {
      writer.uint32(26).string(message.pipelineStepVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPipelineStepVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPipelineStepVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pipelineStepVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPipelineStepVersionRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      pipelineStepVersionId: isSet(object.pipelineStepVersionId) ? globalThis.String(object.pipelineStepVersionId) : "",
    };
  },

  toJSON(message: GetPipelineStepVersionRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.pipelineStepVersionId !== "") {
      obj.pipelineStepVersionId = message.pipelineStepVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPipelineStepVersionRequest>, I>>(base?: I): GetPipelineStepVersionRequest {
    return GetPipelineStepVersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPipelineStepVersionRequest>, I>>(
    object: I,
  ): GetPipelineStepVersionRequest {
    const message = createBaseGetPipelineStepVersionRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.pipelineStepVersionId = object.pipelineStepVersionId ?? "";
    return message;
  },
};

function createBaseSinglePipelineStepVersionResponse(): SinglePipelineStepVersionResponse {
  return { status: undefined, pipelineStepVersion: undefined };
}

export const SinglePipelineStepVersionResponse: MessageFns<SinglePipelineStepVersionResponse> = {
  encode(message: SinglePipelineStepVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pipelineStepVersion !== undefined) {
      PipelineStepVersion.encode(message.pipelineStepVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePipelineStepVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePipelineStepVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineStepVersion = PipelineStepVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePipelineStepVersionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineStepVersion: isSet(object.pipelineStepVersion)
        ? PipelineStepVersion.fromJSON(object.pipelineStepVersion)
        : undefined,
    };
  },

  toJSON(message: SinglePipelineStepVersionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineStepVersion !== undefined) {
      obj.pipelineStepVersion = PipelineStepVersion.toJSON(message.pipelineStepVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinglePipelineStepVersionResponse>, I>>(
    base?: I,
  ): SinglePipelineStepVersionResponse {
    return SinglePipelineStepVersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinglePipelineStepVersionResponse>, I>>(
    object: I,
  ): SinglePipelineStepVersionResponse {
    const message = createBaseSinglePipelineStepVersionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineStepVersion = (object.pipelineStepVersion !== undefined && object.pipelineStepVersion !== null)
      ? PipelineStepVersion.fromPartial(object.pipelineStepVersion)
      : undefined;
    return message;
  },
};

function createBaseGetSecretRequest(): GetSecretRequest {
  return { userAppId: undefined, id: "" };
}

export const GetSecretRequest: MessageFns<GetSecretRequest> = {
  encode(message: GetSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecretRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetSecretRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecretRequest>, I>>(base?: I): GetSecretRequest {
    return GetSecretRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecretRequest>, I>>(object: I): GetSecretRequest {
    const message = createBaseGetSecretRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListSecretsRequest(): ListSecretsRequest {
  return { userAppId: undefined, page: 0, perPage: 0 };
}

export const ListSecretsRequest: MessageFns<ListSecretsRequest> = {
  encode(message: ListSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(16).uint32(message.page);
    }
    if (message.perPage !== 0) {
      writer.uint32(24).uint32(message.perPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.perPage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSecretsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      perPage: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
    };
  },

  toJSON(message: ListSecretsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.perPage !== 0) {
      obj.perPage = Math.round(message.perPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSecretsRequest>, I>>(base?: I): ListSecretsRequest {
    return ListSecretsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSecretsRequest>, I>>(object: I): ListSecretsRequest {
    const message = createBaseListSecretsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.page = object.page ?? 0;
    message.perPage = object.perPage ?? 0;
    return message;
  },
};

function createBasePostSecretsRequest(): PostSecretsRequest {
  return { userAppId: undefined, secrets: [] };
}

export const PostSecretsRequest: MessageFns<PostSecretsRequest> = {
  encode(message: PostSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostSecretsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
    };
  },

  toJSON(message: PostSecretsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostSecretsRequest>, I>>(base?: I): PostSecretsRequest {
    return PostSecretsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostSecretsRequest>, I>>(object: I): PostSecretsRequest {
    const message = createBasePostSecretsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatchSecretsRequest(): PatchSecretsRequest {
  return { userAppId: undefined, secret: [], action: "" };
}

export const PatchSecretsRequest: MessageFns<PatchSecretsRequest> = {
  encode(message: PatchSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.secret) {
      Secret.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(66).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secret.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchSecretsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      secret: globalThis.Array.isArray(object?.secret) ? object.secret.map((e: any) => Secret.fromJSON(e)) : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: PatchSecretsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.secret?.length) {
      obj.secret = message.secret.map((e) => Secret.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchSecretsRequest>, I>>(base?: I): PatchSecretsRequest {
    return PatchSecretsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchSecretsRequest>, I>>(object: I): PatchSecretsRequest {
    const message = createBasePatchSecretsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.secret = object.secret?.map((e) => Secret.fromPartial(e)) || [];
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseDeleteSecretsRequest(): DeleteSecretsRequest {
  return { userAppId: undefined, ids: [] };
}

export const DeleteSecretsRequest: MessageFns<DeleteSecretsRequest> = {
  encode(message: DeleteSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSecretsRequest {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteSecretsRequest): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSecretsRequest>, I>>(base?: I): DeleteSecretsRequest {
    return DeleteSecretsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSecretsRequest>, I>>(object: I): DeleteSecretsRequest {
    const message = createBaseDeleteSecretsRequest();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSingleSecretResponse(): SingleSecretResponse {
  return { status: undefined, secret: undefined };
}

export const SingleSecretResponse: MessageFns<SingleSecretResponse> = {
  encode(message: SingleSecretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.secret !== undefined) {
      Secret.encode(message.secret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleSecretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = Secret.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleSecretResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      secret: isSet(object.secret) ? Secret.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: SingleSecretResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.secret !== undefined) {
      obj.secret = Secret.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleSecretResponse>, I>>(base?: I): SingleSecretResponse {
    return SingleSecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleSecretResponse>, I>>(object: I): SingleSecretResponse {
    const message = createBaseSingleSecretResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Secret.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

function createBaseMultiSecretResponse(): MultiSecretResponse {
  return { status: undefined, secrets: [] };
}

export const MultiSecretResponse: MessageFns<MultiSecretResponse> = {
  encode(message: MultiSecretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiSecretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiSecretResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiSecretResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiSecretResponse>, I>>(base?: I): MultiSecretResponse {
    return MultiSecretResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiSecretResponse>, I>>(object: I): MultiSecretResponse {
    const message = createBaseMultiSecretResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    return message;
  },
};

export type V2Service = typeof V2Service;
export const V2Service = {
  /**
   * List concept relations between concepts in the platform.
   * MUST be above ListConcepts so that if concept_id is empty this will still match
   * /concepts/relations to list all the concept relations in the app.
   */
  listConceptRelations: {
    path: "/clarifai.api.V2/ListConceptRelations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConceptRelationsRequest): Buffer =>
      Buffer.from(ListConceptRelationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConceptRelationsRequest => ListConceptRelationsRequest.decode(value),
    responseSerialize: (value: MultiConceptRelationResponse): Buffer =>
      Buffer.from(MultiConceptRelationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptRelationResponse => MultiConceptRelationResponse.decode(value),
  },
  /** Post concept relations to create relations between concepts in the platform. */
  postConceptRelations: {
    path: "/clarifai.api.V2/PostConceptRelations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostConceptRelationsRequest): Buffer =>
      Buffer.from(PostConceptRelationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostConceptRelationsRequest => PostConceptRelationsRequest.decode(value),
    responseSerialize: (value: MultiConceptRelationResponse): Buffer =>
      Buffer.from(MultiConceptRelationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptRelationResponse => MultiConceptRelationResponse.decode(value),
  },
  /** Post concept relations to create relations between concepts in the platform. */
  deleteConceptRelations: {
    path: "/clarifai.api.V2/DeleteConceptRelations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConceptRelationsRequest): Buffer =>
      Buffer.from(DeleteConceptRelationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteConceptRelationsRequest => DeleteConceptRelationsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all the concepts with their positive and negative counts */
  getConceptCounts: {
    path: "/clarifai.api.V2/GetConceptCounts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConceptCountsRequest): Buffer =>
      Buffer.from(GetConceptCountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConceptCountsRequest => GetConceptCountsRequest.decode(value),
    responseSerialize: (value: MultiConceptCountResponse): Buffer =>
      Buffer.from(MultiConceptCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptCountResponse => MultiConceptCountResponse.decode(value),
  },
  /** Get a specific concept from an app. */
  getConcept: {
    path: "/clarifai.api.V2/GetConcept",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConceptRequest): Buffer => Buffer.from(GetConceptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConceptRequest => GetConceptRequest.decode(value),
    responseSerialize: (value: SingleConceptResponse): Buffer =>
      Buffer.from(SingleConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleConceptResponse => SingleConceptResponse.decode(value),
  },
  /** List all the concepts. */
  listConcepts: {
    path: "/clarifai.api.V2/ListConcepts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConceptsRequest): Buffer => Buffer.from(ListConceptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConceptsRequest => ListConceptsRequest.decode(value),
    responseSerialize: (value: MultiConceptResponse): Buffer =>
      Buffer.from(MultiConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptResponse => MultiConceptResponse.decode(value),
  },
  /** List models concepts. */
  listModelConcepts: {
    path: "/clarifai.api.V2/ListModelConcepts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelConceptsRequest): Buffer =>
      Buffer.from(ListModelConceptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelConceptsRequest => ListModelConceptsRequest.decode(value),
    responseSerialize: (value: MultiConceptResponse): Buffer =>
      Buffer.from(MultiConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptResponse => MultiConceptResponse.decode(value),
  },
  /**
   * Search over the concepts to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postConceptsSearches: {
    path: "/clarifai.api.V2/PostConceptsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostConceptsSearchesRequest): Buffer =>
      Buffer.from(PostConceptsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostConceptsSearchesRequest => PostConceptsSearchesRequest.decode(value),
    responseSerialize: (value: MultiConceptResponse): Buffer =>
      Buffer.from(MultiConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptResponse => MultiConceptResponse.decode(value),
  },
  /** Add a concept to an app. */
  postConcepts: {
    path: "/clarifai.api.V2/PostConcepts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostConceptsRequest): Buffer => Buffer.from(PostConceptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostConceptsRequest => PostConceptsRequest.decode(value),
    responseSerialize: (value: MultiConceptResponse): Buffer =>
      Buffer.from(MultiConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptResponse => MultiConceptResponse.decode(value),
  },
  /** Patch one or more concepts. */
  patchConcepts: {
    path: "/clarifai.api.V2/PatchConcepts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchConceptsRequest): Buffer => Buffer.from(PatchConceptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchConceptsRequest => PatchConceptsRequest.decode(value),
    responseSerialize: (value: MultiConceptResponse): Buffer =>
      Buffer.from(MultiConceptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptResponse => MultiConceptResponse.decode(value),
  },
  /** Get a specific concept from an app. */
  getConceptLanguage: {
    path: "/clarifai.api.V2/GetConceptLanguage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConceptLanguageRequest): Buffer =>
      Buffer.from(GetConceptLanguageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConceptLanguageRequest => GetConceptLanguageRequest.decode(value),
    responseSerialize: (value: SingleConceptLanguageResponse): Buffer =>
      Buffer.from(SingleConceptLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleConceptLanguageResponse => SingleConceptLanguageResponse.decode(value),
  },
  /** List the concept in all the translated languages. */
  listConceptLanguages: {
    path: "/clarifai.api.V2/ListConceptLanguages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConceptLanguagesRequest): Buffer =>
      Buffer.from(ListConceptLanguagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConceptLanguagesRequest => ListConceptLanguagesRequest.decode(value),
    responseSerialize: (value: MultiConceptLanguageResponse): Buffer =>
      Buffer.from(MultiConceptLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptLanguageResponse => MultiConceptLanguageResponse.decode(value),
  },
  /** Add a new translation for this concept. */
  postConceptLanguages: {
    path: "/clarifai.api.V2/PostConceptLanguages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostConceptLanguagesRequest): Buffer =>
      Buffer.from(PostConceptLanguagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostConceptLanguagesRequest => PostConceptLanguagesRequest.decode(value),
    responseSerialize: (value: MultiConceptLanguageResponse): Buffer =>
      Buffer.from(MultiConceptLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptLanguageResponse => MultiConceptLanguageResponse.decode(value),
  },
  /**
   * Patch the name for a given language names by passing in a list of concepts with the new names
   * for the languages.
   */
  patchConceptLanguages: {
    path: "/clarifai.api.V2/PatchConceptLanguages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchConceptLanguagesRequest): Buffer =>
      Buffer.from(PatchConceptLanguagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchConceptLanguagesRequest => PatchConceptLanguagesRequest.decode(value),
    responseSerialize: (value: MultiConceptLanguageResponse): Buffer =>
      Buffer.from(MultiConceptLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiConceptLanguageResponse => MultiConceptLanguageResponse.decode(value),
  },
  /** List all domain graphs. */
  listKnowledgeGraphs: {
    path: "/clarifai.api.V2/ListKnowledgeGraphs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListKnowledgeGraphsRequest): Buffer =>
      Buffer.from(ListKnowledgeGraphsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListKnowledgeGraphsRequest => ListKnowledgeGraphsRequest.decode(value),
    responseSerialize: (value: MultiKnowledgeGraphResponse): Buffer =>
      Buffer.from(MultiKnowledgeGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKnowledgeGraphResponse => MultiKnowledgeGraphResponse.decode(value),
  },
  /** Post domain graphs. */
  postKnowledgeGraphs: {
    path: "/clarifai.api.V2/PostKnowledgeGraphs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostKnowledgeGraphsRequest): Buffer =>
      Buffer.from(PostKnowledgeGraphsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostKnowledgeGraphsRequest => PostKnowledgeGraphsRequest.decode(value),
    responseSerialize: (value: MultiKnowledgeGraphResponse): Buffer =>
      Buffer.from(MultiKnowledgeGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKnowledgeGraphResponse => MultiKnowledgeGraphResponse.decode(value),
  },
  /** Get a specific annotation from an app. */
  getAnnotation: {
    path: "/clarifai.api.V2/GetAnnotation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAnnotationRequest): Buffer => Buffer.from(GetAnnotationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAnnotationRequest => GetAnnotationRequest.decode(value),
    responseSerialize: (value: SingleAnnotationResponse): Buffer =>
      Buffer.from(SingleAnnotationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleAnnotationResponse => SingleAnnotationResponse.decode(value),
  },
  /** List all the annotation. */
  listAnnotations: {
    path: "/clarifai.api.V2/ListAnnotations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAnnotationsRequest): Buffer =>
      Buffer.from(ListAnnotationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAnnotationsRequest => ListAnnotationsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationResponse): Buffer =>
      Buffer.from(MultiAnnotationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationResponse => MultiAnnotationResponse.decode(value),
  },
  /** Post annotations. */
  postAnnotations: {
    path: "/clarifai.api.V2/PostAnnotations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAnnotationsRequest): Buffer =>
      Buffer.from(PostAnnotationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAnnotationsRequest => PostAnnotationsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationResponse): Buffer =>
      Buffer.from(MultiAnnotationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationResponse => MultiAnnotationResponse.decode(value),
  },
  /** Patch one or more annotations. */
  patchAnnotations: {
    path: "/clarifai.api.V2/PatchAnnotations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAnnotationsRequest): Buffer =>
      Buffer.from(PatchAnnotationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAnnotationsRequest => PatchAnnotationsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationResponse): Buffer =>
      Buffer.from(MultiAnnotationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationResponse => MultiAnnotationResponse.decode(value),
  },
  /**
   * Patch annotations status by worker id and task id.
   * Deprecated: Use PutTaskAssignments to update task annotations.
   *   For example, you can use PutTaskAssignments with action REVIEW_APPROVE
   *   to approve task assignments and associated annotations in bulk.
   */
  patchAnnotationsStatus: {
    path: "/clarifai.api.V2/PatchAnnotationsStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAnnotationsStatusRequest): Buffer =>
      Buffer.from(PatchAnnotationsStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAnnotationsStatusRequest => PatchAnnotationsStatusRequest.decode(value),
    responseSerialize: (value: PatchAnnotationsStatusResponse): Buffer =>
      Buffer.from(PatchAnnotationsStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PatchAnnotationsStatusResponse =>
      PatchAnnotationsStatusResponse.decode(value),
  },
  /** Delete a single annotation. */
  deleteAnnotation: {
    path: "/clarifai.api.V2/DeleteAnnotation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAnnotationRequest): Buffer =>
      Buffer.from(DeleteAnnotationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAnnotationRequest => DeleteAnnotationRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Delete multiple annotations in one request. */
  deleteAnnotations: {
    path: "/clarifai.api.V2/DeleteAnnotations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAnnotationsRequest): Buffer =>
      Buffer.from(DeleteAnnotationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAnnotationsRequest => DeleteAnnotationsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all the annotation tracks. */
  listAnnotationTracks: {
    path: "/clarifai.api.V2/ListAnnotationTracks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAnnotationTracksRequest): Buffer =>
      Buffer.from(ListAnnotationTracksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAnnotationTracksRequest => ListAnnotationTracksRequest.decode(value),
    responseSerialize: (value: MultiAnnotationTrackResponse): Buffer =>
      Buffer.from(MultiAnnotationTrackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationTrackResponse => MultiAnnotationTrackResponse.decode(value),
  },
  /** Post annotation tracks. */
  postAnnotationTracks: {
    path: "/clarifai.api.V2/PostAnnotationTracks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAnnotationTracksRequest): Buffer =>
      Buffer.from(PostAnnotationTracksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAnnotationTracksRequest => PostAnnotationTracksRequest.decode(value),
    responseSerialize: (value: MultiAnnotationTrackResponse): Buffer =>
      Buffer.from(MultiAnnotationTrackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationTrackResponse => MultiAnnotationTrackResponse.decode(value),
  },
  /** Patch one or more annotation tracks. */
  patchAnnotationTracks: {
    path: "/clarifai.api.V2/PatchAnnotationTracks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAnnotationTracksRequest): Buffer =>
      Buffer.from(PatchAnnotationTracksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAnnotationTracksRequest => PatchAnnotationTracksRequest.decode(value),
    responseSerialize: (value: MultiAnnotationTrackResponse): Buffer =>
      Buffer.from(MultiAnnotationTrackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationTrackResponse => MultiAnnotationTrackResponse.decode(value),
  },
  /** Delete multiple annotation tracks in one request. */
  deleteAnnotationTracks: {
    path: "/clarifai.api.V2/DeleteAnnotationTracks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAnnotationTracksRequest): Buffer =>
      Buffer.from(DeleteAnnotationTracksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAnnotationTracksRequest => DeleteAnnotationTracksRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Patch saved annotations searches by ids. */
  patchAnnotationsSearches: {
    path: "/clarifai.api.V2/PatchAnnotationsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAnnotationsSearchesRequest): Buffer =>
      Buffer.from(PatchAnnotationsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAnnotationsSearchesRequest =>
      PatchAnnotationsSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Execute a search over annotations */
  postAnnotationsSearches: {
    path: "/clarifai.api.V2/PostAnnotationsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAnnotationsSearchesRequest): Buffer =>
      Buffer.from(PostAnnotationsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAnnotationsSearchesRequest => PostAnnotationsSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /**
   * ListAnnotationWorkers lists users, models, and workflows (collectively
   * known as "workers") that have added annotations to the application.
   */
  listAnnotationWorkers: {
    path: "/clarifai.api.V2/ListAnnotationWorkers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAnnotationWorkersRequest): Buffer =>
      Buffer.from(ListAnnotationWorkersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAnnotationWorkersRequest => ListAnnotationWorkersRequest.decode(value),
    responseSerialize: (value: MultiWorkerResponse): Buffer => Buffer.from(MultiWorkerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkerResponse => MultiWorkerResponse.decode(value),
  },
  /** Get input count per status. */
  getInputCount: {
    path: "/clarifai.api.V2/GetInputCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInputCountRequest): Buffer => Buffer.from(GetInputCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInputCountRequest => GetInputCountRequest.decode(value),
    responseSerialize: (value: SingleInputCountResponse): Buffer =>
      Buffer.from(SingleInputCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInputCountResponse => SingleInputCountResponse.decode(value),
  },
  /** Streams all the inputs starting from oldest assets. */
  streamInputs: {
    path: "/clarifai.api.V2/StreamInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StreamInputsRequest): Buffer => Buffer.from(StreamInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StreamInputsRequest => StreamInputsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  getInputSamples: {
    path: "/clarifai.api.V2/GetInputSamples",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInputSamplesRequest): Buffer =>
      Buffer.from(GetInputSamplesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInputSamplesRequest => GetInputSamplesRequest.decode(value),
    responseSerialize: (value: MultiInputAnnotationResponse): Buffer =>
      Buffer.from(MultiInputAnnotationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputAnnotationResponse => MultiInputAnnotationResponse.decode(value),
  },
  /** Get a specific input from an app. */
  getInput: {
    path: "/clarifai.api.V2/GetInput",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInputRequest): Buffer => Buffer.from(GetInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInputRequest => GetInputRequest.decode(value),
    responseSerialize: (value: SingleInputResponse): Buffer => Buffer.from(SingleInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInputResponse => SingleInputResponse.decode(value),
  },
  /**
   * Get a MPEG-DASH manifest for video-type inputs that were added via PostInputs and successfully processed
   * Experimental. Manifest is used by browser and desktop clients that implement an efficient streaming playback
   * This means client can switch between low-resolution and high-resolution video streams
   * Depending on network bandwidth or user's preference
   * This also means that reencoded video streams are reencoded in a uniform way, not relying on original format
   * Alternative to MPEG-dash is to stream original file with byte-range header
   */
  getInputVideoManifest: {
    path: "/clarifai.api.V2/GetInputVideoManifest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVideoManifestRequest): Buffer =>
      Buffer.from(GetVideoManifestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVideoManifestRequest => GetVideoManifestRequest.decode(value),
    responseSerialize: (value: GetVideoManifestResponse): Buffer =>
      Buffer.from(GetVideoManifestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetVideoManifestResponse => GetVideoManifestResponse.decode(value),
  },
  /** List all the inputs. */
  listInputs: {
    path: "/clarifai.api.V2/ListInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListInputsRequest): Buffer => Buffer.from(ListInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListInputsRequest => ListInputsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  /**
   * PostInputs adds one or more inputs to the app.
   * Takes a list of image/video/audio/text URLs, image/video/audio bytes or raw text
   * Optionally, include concepts or dataset ids to link them
   * Optionally, include metadata for search
   * Note that inputs processing is asynchronous process
   * See ListInputs, StreamInputs or PostInputSearches to list results
   */
  postInputs: {
    path: "/clarifai.api.V2/PostInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInputsRequest): Buffer => Buffer.from(PostInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInputsRequest => PostInputsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  /** Patch one or more inputs. */
  patchInputs: {
    path: "/clarifai.api.V2/PatchInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchInputsRequest): Buffer => Buffer.from(PatchInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchInputsRequest => PatchInputsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  /** Delete a single input asynchronously. */
  deleteInput: {
    path: "/clarifai.api.V2/DeleteInput",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteInputRequest): Buffer => Buffer.from(DeleteInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteInputRequest => DeleteInputRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Delete multiple inputs in one request.
   * This call is asynchronous.
   */
  deleteInputs: {
    path: "/clarifai.api.V2/DeleteInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteInputsRequest): Buffer => Buffer.from(DeleteInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteInputsRequest => DeleteInputsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Patch saved inputs searches by ids. */
  patchInputsSearches: {
    path: "/clarifai.api.V2/PatchInputsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchInputsSearchesRequest): Buffer =>
      Buffer.from(PatchInputsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchInputsSearchesRequest => PatchInputsSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Execute a search over inputs */
  postInputsSearches: {
    path: "/clarifai.api.V2/PostInputsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInputsSearchesRequest): Buffer =>
      Buffer.from(PostInputsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInputsSearchesRequest => PostInputsSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Get predicted outputs from the model. */
  postModelOutputs: {
    path: "/clarifai.api.V2/PostModelOutputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelOutputsRequest): Buffer =>
      Buffer.from(PostModelOutputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelOutputsRequest => PostModelOutputsRequest.decode(value),
    responseSerialize: (value: MultiOutputResponse): Buffer => Buffer.from(MultiOutputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiOutputResponse => MultiOutputResponse.decode(value),
  },
  /**
   * TODO(zeiler): will need to
   * Single request but streaming responses.
   */
  generateModelOutputs: {
    path: "/clarifai.api.V2/GenerateModelOutputs",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: PostModelOutputsRequest): Buffer =>
      Buffer.from(PostModelOutputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelOutputsRequest => PostModelOutputsRequest.decode(value),
    responseSerialize: (value: MultiOutputResponse): Buffer => Buffer.from(MultiOutputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiOutputResponse => MultiOutputResponse.decode(value),
  },
  /** Stream of requests and stream of responses */
  streamModelOutputs: {
    path: "/clarifai.api.V2/StreamModelOutputs",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: PostModelOutputsRequest): Buffer =>
      Buffer.from(PostModelOutputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelOutputsRequest => PostModelOutputsRequest.decode(value),
    responseSerialize: (value: MultiOutputResponse): Buffer => Buffer.from(MultiOutputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiOutputResponse => MultiOutputResponse.decode(value),
  },
  /** List all the datasets. */
  listDatasets: {
    path: "/clarifai.api.V2/ListDatasets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDatasetsRequest): Buffer => Buffer.from(ListDatasetsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDatasetsRequest => ListDatasetsRequest.decode(value),
    responseSerialize: (value: MultiDatasetResponse): Buffer =>
      Buffer.from(MultiDatasetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetResponse => MultiDatasetResponse.decode(value),
  },
  /** Get a specific dataset. */
  getDataset: {
    path: "/clarifai.api.V2/GetDataset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDatasetRequest): Buffer => Buffer.from(GetDatasetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDatasetRequest => GetDatasetRequest.decode(value),
    responseSerialize: (value: SingleDatasetResponse): Buffer =>
      Buffer.from(SingleDatasetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleDatasetResponse => SingleDatasetResponse.decode(value),
  },
  /**
   * Add datasets to an app.
   * The process is atomic, i.e. either all or no datasets are added.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  postDatasets: {
    path: "/clarifai.api.V2/PostDatasets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostDatasetsRequest): Buffer => Buffer.from(PostDatasetsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostDatasetsRequest => PostDatasetsRequest.decode(value),
    responseSerialize: (value: MultiDatasetResponse): Buffer =>
      Buffer.from(MultiDatasetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetResponse => MultiDatasetResponse.decode(value),
  },
  /**
   * Patch one or more datasets.
   * The process is atomic, i.e. either all or no datasets are patched.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  patchDatasets: {
    path: "/clarifai.api.V2/PatchDatasets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchDatasetsRequest): Buffer => Buffer.from(PatchDatasetsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchDatasetsRequest => PatchDatasetsRequest.decode(value),
    responseSerialize: (value: MultiDatasetResponse): Buffer =>
      Buffer.from(MultiDatasetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetResponse => MultiDatasetResponse.decode(value),
  },
  /** Delete one or more datasets in a single request. */
  deleteDatasets: {
    path: "/clarifai.api.V2/DeleteDatasets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDatasetsRequest): Buffer =>
      Buffer.from(DeleteDatasetsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteDatasetsRequest => DeleteDatasetsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all the dataset inputs in a dataset. */
  listDatasetInputs: {
    path: "/clarifai.api.V2/ListDatasetInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDatasetInputsRequest): Buffer =>
      Buffer.from(ListDatasetInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDatasetInputsRequest => ListDatasetInputsRequest.decode(value),
    responseSerialize: (value: MultiDatasetInputResponse): Buffer =>
      Buffer.from(MultiDatasetInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetInputResponse => MultiDatasetInputResponse.decode(value),
  },
  /** Get a specific dataset input. */
  getDatasetInput: {
    path: "/clarifai.api.V2/GetDatasetInput",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDatasetInputRequest): Buffer =>
      Buffer.from(GetDatasetInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDatasetInputRequest => GetDatasetInputRequest.decode(value),
    responseSerialize: (value: SingleDatasetInputResponse): Buffer =>
      Buffer.from(SingleDatasetInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleDatasetInputResponse => SingleDatasetInputResponse.decode(value),
  },
  /**
   * Add dataset inputs to a dataset.
   * The process is not atomic, i.e. if there are errors with some dataset
   * inputs, others might still be added. The response reports
   *   - SUCCESS if all dataset inputs were added,
   *   - MIXED_STATUS if only some dataset inputs were added, and
   *   - FAILURE if no dataset inputs were added.
   * Each individual dataset input in the response has the status set to
   * indicate if it was successful or if there was an error.
   */
  postDatasetInputs: {
    path: "/clarifai.api.V2/PostDatasetInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostDatasetInputsRequest): Buffer =>
      Buffer.from(PostDatasetInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostDatasetInputsRequest => PostDatasetInputsRequest.decode(value),
    responseSerialize: (value: MultiDatasetInputResponse): Buffer =>
      Buffer.from(MultiDatasetInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetInputResponse => MultiDatasetInputResponse.decode(value),
  },
  /** Delete one or more dataset inputs in a single request. */
  deleteDatasetInputs: {
    path: "/clarifai.api.V2/DeleteDatasetInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDatasetInputsRequest): Buffer =>
      Buffer.from(DeleteDatasetInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteDatasetInputsRequest => DeleteDatasetInputsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all the dataset versions. */
  listDatasetVersions: {
    path: "/clarifai.api.V2/ListDatasetVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDatasetVersionsRequest): Buffer =>
      Buffer.from(ListDatasetVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDatasetVersionsRequest => ListDatasetVersionsRequest.decode(value),
    responseSerialize: (value: MultiDatasetVersionResponse): Buffer =>
      Buffer.from(MultiDatasetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetVersionResponse => MultiDatasetVersionResponse.decode(value),
  },
  /** Get a specific dataset version. */
  getDatasetVersion: {
    path: "/clarifai.api.V2/GetDatasetVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDatasetVersionRequest): Buffer =>
      Buffer.from(GetDatasetVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDatasetVersionRequest => GetDatasetVersionRequest.decode(value),
    responseSerialize: (value: SingleDatasetVersionResponse): Buffer =>
      Buffer.from(SingleDatasetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleDatasetVersionResponse => SingleDatasetVersionResponse.decode(value),
  },
  listDatasetVersionMetricsGroups: {
    path: "/clarifai.api.V2/ListDatasetVersionMetricsGroups",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDatasetVersionMetricsGroupsRequest): Buffer =>
      Buffer.from(ListDatasetVersionMetricsGroupsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDatasetVersionMetricsGroupsRequest =>
      ListDatasetVersionMetricsGroupsRequest.decode(value),
    responseSerialize: (value: MultiDatasetVersionMetricsGroupResponse): Buffer =>
      Buffer.from(MultiDatasetVersionMetricsGroupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetVersionMetricsGroupResponse =>
      MultiDatasetVersionMetricsGroupResponse.decode(value),
  },
  /** Add dataset versions to a dataset. */
  postDatasetVersions: {
    path: "/clarifai.api.V2/PostDatasetVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostDatasetVersionsRequest): Buffer =>
      Buffer.from(PostDatasetVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostDatasetVersionsRequest => PostDatasetVersionsRequest.decode(value),
    responseSerialize: (value: MultiDatasetVersionResponse): Buffer =>
      Buffer.from(MultiDatasetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetVersionResponse => MultiDatasetVersionResponse.decode(value),
  },
  /** Patch one or more dataset versions. */
  patchDatasetVersions: {
    path: "/clarifai.api.V2/PatchDatasetVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchDatasetVersionsRequest): Buffer =>
      Buffer.from(PatchDatasetVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchDatasetVersionsRequest => PatchDatasetVersionsRequest.decode(value),
    responseSerialize: (value: MultiDatasetVersionResponse): Buffer =>
      Buffer.from(MultiDatasetVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetVersionResponse => MultiDatasetVersionResponse.decode(value),
  },
  /** Delete one or more dataset versions in a single request. */
  deleteDatasetVersions: {
    path: "/clarifai.api.V2/DeleteDatasetVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDatasetVersionsRequest): Buffer =>
      Buffer.from(DeleteDatasetVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteDatasetVersionsRequest => DeleteDatasetVersionsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Create export of a dataset version. */
  putDatasetVersionExports: {
    path: "/clarifai.api.V2/PutDatasetVersionExports",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutDatasetVersionExportsRequest): Buffer =>
      Buffer.from(PutDatasetVersionExportsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PutDatasetVersionExportsRequest =>
      PutDatasetVersionExportsRequest.decode(value),
    responseSerialize: (value: MultiDatasetVersionExportResponse): Buffer =>
      Buffer.from(MultiDatasetVersionExportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDatasetVersionExportResponse =>
      MultiDatasetVersionExportResponse.decode(value),
  },
  /** Get a specific model type. */
  getModelType: {
    path: "/clarifai.api.V2/GetModelType",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelTypeRequest): Buffer => Buffer.from(GetModelTypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelTypeRequest => GetModelTypeRequest.decode(value),
    responseSerialize: (value: SingleModelTypeResponse): Buffer =>
      Buffer.from(SingleModelTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelTypeResponse => SingleModelTypeResponse.decode(value),
  },
  /** List all the supported open source licenses in the platform. */
  listOpenSourceLicenses: {
    path: "/clarifai.api.V2/ListOpenSourceLicenses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOpenSourceLicensesRequest): Buffer =>
      Buffer.from(ListOpenSourceLicensesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListOpenSourceLicensesRequest => ListOpenSourceLicensesRequest.decode(value),
    responseSerialize: (value: ListOpenSourceLicensesResponse): Buffer =>
      Buffer.from(ListOpenSourceLicensesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListOpenSourceLicensesResponse =>
      ListOpenSourceLicensesResponse.decode(value),
  },
  /**
   * List all the model types available in the platform.
   * This MUST be above ListModels so that the /models/types endpoint takes precedence.
   */
  listModelTypes: {
    path: "/clarifai.api.V2/ListModelTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelTypesRequest): Buffer =>
      Buffer.from(ListModelTypesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelTypesRequest => ListModelTypesRequest.decode(value),
    responseSerialize: (value: MultiModelTypeResponse): Buffer =>
      Buffer.from(MultiModelTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelTypeResponse => MultiModelTypeResponse.decode(value),
  },
  /** Get a specific model from an app. */
  getModel: {
    path: "/clarifai.api.V2/GetModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelRequest): Buffer => Buffer.from(GetModelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelRequest => GetModelRequest.decode(value),
    responseSerialize: (value: SingleModelResponse): Buffer => Buffer.from(SingleModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelResponse => SingleModelResponse.decode(value),
  },
  /**
   * Get a the output info for a given model_id or model_id/version_id
   * combo.
   */
  getModelOutputInfo: {
    path: "/clarifai.api.V2/GetModelOutputInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelRequest): Buffer => Buffer.from(GetModelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelRequest => GetModelRequest.decode(value),
    responseSerialize: (value: SingleModelResponse): Buffer => Buffer.from(SingleModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelResponse => SingleModelResponse.decode(value),
  },
  /** List all the models. */
  listModels: {
    path: "/clarifai.api.V2/ListModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelsRequest): Buffer => Buffer.from(ListModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelsRequest => ListModelsRequest.decode(value),
    responseSerialize: (value: MultiModelResponse): Buffer => Buffer.from(MultiModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelResponse => MultiModelResponse.decode(value),
  },
  /** List the resource counts for the app. */
  getResourceCounts: {
    path: "/clarifai.api.V2/GetResourceCounts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetResourceCountsRequest): Buffer =>
      Buffer.from(GetResourceCountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetResourceCountsRequest => GetResourceCountsRequest.decode(value),
    responseSerialize: (value: GetResourceCountsResponse): Buffer =>
      Buffer.from(GetResourceCountsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResourceCountsResponse => GetResourceCountsResponse.decode(value),
  },
  /**
   * Search over the models to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postModelsSearches: {
    path: "/clarifai.api.V2/PostModelsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelsSearchesRequest): Buffer =>
      Buffer.from(PostModelsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelsSearchesRequest => PostModelsSearchesRequest.decode(value),
    responseSerialize: (value: MultiModelResponse): Buffer => Buffer.from(MultiModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelResponse => MultiModelResponse.decode(value),
  },
  /** Add a models to an app. */
  postModels: {
    path: "/clarifai.api.V2/PostModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelsRequest): Buffer => Buffer.from(PostModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelsRequest => PostModelsRequest.decode(value),
    responseSerialize: (value: SingleModelResponse): Buffer => Buffer.from(SingleModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelResponse => SingleModelResponse.decode(value),
  },
  /** Patch one or more models. */
  patchModels: {
    path: "/clarifai.api.V2/PatchModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelsRequest): Buffer => Buffer.from(PatchModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelsRequest => PatchModelsRequest.decode(value),
    responseSerialize: (value: MultiModelResponse): Buffer => Buffer.from(MultiModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelResponse => MultiModelResponse.decode(value),
  },
  /** Patch one or more models ids. */
  patchModelIds: {
    path: "/clarifai.api.V2/PatchModelIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelIdsRequest): Buffer => Buffer.from(PatchModelIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelIdsRequest => PatchModelIdsRequest.decode(value),
    responseSerialize: (value: MultiModelResponse): Buffer => Buffer.from(MultiModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelResponse => MultiModelResponse.decode(value),
  },
  /** Delete a single model. */
  deleteModel: {
    path: "/clarifai.api.V2/DeleteModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteModelRequest): Buffer => Buffer.from(DeleteModelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteModelRequest => DeleteModelRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Delete multiple models in one request. */
  deleteModels: {
    path: "/clarifai.api.V2/DeleteModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteModelsRequest): Buffer => Buffer.from(DeleteModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteModelsRequest => DeleteModelsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Update model check consents */
  patchModelCheckConsents: {
    path: "/clarifai.api.V2/PatchModelCheckConsents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelCheckConsentsRequest): Buffer =>
      Buffer.from(PatchModelCheckConsentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelCheckConsentsRequest => PatchModelCheckConsentsRequest.decode(value),
    responseSerialize: (value: MultiModelCheckConsentResponse): Buffer =>
      Buffer.from(MultiModelCheckConsentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelCheckConsentResponse =>
      MultiModelCheckConsentResponse.decode(value),
  },
  /** Update model toolkits tags */
  patchModelToolkits: {
    path: "/clarifai.api.V2/PatchModelToolkits",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelToolkitsRequest): Buffer =>
      Buffer.from(PatchModelToolkitsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelToolkitsRequest => PatchModelToolkitsRequest.decode(value),
    responseSerialize: (value: MultiModelToolkitResponse): Buffer =>
      Buffer.from(MultiModelToolkitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelToolkitResponse => MultiModelToolkitResponse.decode(value),
  },
  /** Update model use_cases tags */
  patchModelUseCases: {
    path: "/clarifai.api.V2/PatchModelUseCases",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelUseCasesRequest): Buffer =>
      Buffer.from(PatchModelUseCasesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelUseCasesRequest => PatchModelUseCasesRequest.decode(value),
    responseSerialize: (value: MultiModelUseCaseResponse): Buffer =>
      Buffer.from(MultiModelUseCaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelUseCaseResponse => MultiModelUseCaseResponse.decode(value),
  },
  /** Update model languages tags */
  patchModelLanguages: {
    path: "/clarifai.api.V2/PatchModelLanguages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelLanguagesRequest): Buffer =>
      Buffer.from(PatchModelLanguagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelLanguagesRequest => PatchModelLanguagesRequest.decode(value),
    responseSerialize: (value: MultiModelLanguageResponse): Buffer =>
      Buffer.from(MultiModelLanguageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelLanguageResponse => MultiModelLanguageResponse.decode(value),
  },
  /**
   * Deprecated: Unmaintained and ideally replaced with usage of datasets
   *   The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  listModelInputs: {
    path: "/clarifai.api.V2/ListModelInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelInputsRequest): Buffer =>
      Buffer.from(ListModelInputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelInputsRequest => ListModelInputsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  /** Get a specific model from an app. */
  getModelVersion: {
    path: "/clarifai.api.V2/GetModelVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelVersionRequest): Buffer =>
      Buffer.from(GetModelVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelVersionRequest => GetModelVersionRequest.decode(value),
    responseSerialize: (value: SingleModelVersionResponse): Buffer =>
      Buffer.from(SingleModelVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionResponse => SingleModelVersionResponse.decode(value),
  },
  /** List all the models. */
  listModelVersions: {
    path: "/clarifai.api.V2/ListModelVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelVersionsRequest): Buffer =>
      Buffer.from(ListModelVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelVersionsRequest => ListModelVersionsRequest.decode(value),
    responseSerialize: (value: MultiModelVersionResponse): Buffer =>
      Buffer.from(MultiModelVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelVersionResponse => MultiModelVersionResponse.decode(value),
  },
  postWorkflowVersionsUnPublish: {
    path: "/clarifai.api.V2/PostWorkflowVersionsUnPublish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowVersionsUnPublishRequest): Buffer =>
      Buffer.from(PostWorkflowVersionsUnPublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowVersionsUnPublishRequest =>
      PostWorkflowVersionsUnPublishRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  postWorkflowVersionsPublish: {
    path: "/clarifai.api.V2/PostWorkflowVersionsPublish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowVersionsPublishRequest): Buffer =>
      Buffer.from(PostWorkflowVersionsPublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowVersionsPublishRequest =>
      PostWorkflowVersionsPublishRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** PostModelVersionsPublish */
  postModelVersionsPublish: {
    path: "/clarifai.api.V2/PostModelVersionsPublish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionsPublishRequest): Buffer =>
      Buffer.from(PostModelVersionsPublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionsPublishRequest =>
      PostModelVersionsPublishRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** PostModelVersionsUnPublish */
  postModelVersionsUnPublish: {
    path: "/clarifai.api.V2/PostModelVersionsUnPublish",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionsUnPublishRequest): Buffer =>
      Buffer.from(PostModelVersionsUnPublishRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionsUnPublishRequest =>
      PostModelVersionsUnPublishRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Create a new model version to trigger training of the model. */
  postModelVersions: {
    path: "/clarifai.api.V2/PostModelVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionsRequest): Buffer =>
      Buffer.from(PostModelVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionsRequest => PostModelVersionsRequest.decode(value),
    responseSerialize: (value: SingleModelResponse): Buffer => Buffer.from(SingleModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelResponse => SingleModelResponse.decode(value),
  },
  /** PatchModelVersions */
  patchModelVersions: {
    path: "/clarifai.api.V2/PatchModelVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModelVersionsRequest): Buffer =>
      Buffer.from(PatchModelVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModelVersionsRequest => PatchModelVersionsRequest.decode(value),
    responseSerialize: (value: MultiModelVersionResponse): Buffer =>
      Buffer.from(MultiModelVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelVersionResponse => MultiModelVersionResponse.decode(value),
  },
  /** Delete a single model. */
  deleteModelVersion: {
    path: "/clarifai.api.V2/DeleteModelVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteModelVersionRequest): Buffer =>
      Buffer.from(DeleteModelVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteModelVersionRequest => DeleteModelVersionRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the model_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the model_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the model_version_id specified for your model_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the model_bytes.
   */
  postModelVersionsUpload: {
    path: "/clarifai.api.V2/PostModelVersionsUpload",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: PostModelVersionsUploadRequest): Buffer =>
      Buffer.from(PostModelVersionsUploadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionsUploadRequest => PostModelVersionsUploadRequest.decode(value),
    responseSerialize: (value: PostModelVersionsUploadResponse): Buffer =>
      Buffer.from(PostModelVersionsUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PostModelVersionsUploadResponse =>
      PostModelVersionsUploadResponse.decode(value),
  },
  /** Kicks off conversion from the old Triton model format to the new Docker model format. */
  postModelMigration: {
    path: "/clarifai.api.V2/PostModelMigration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelMigrationRequest): Buffer =>
      Buffer.from(PostModelMigrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelMigrationRequest => PostModelMigrationRequest.decode(value),
    responseSerialize: (value: SingleModelResponse): Buffer => Buffer.from(SingleModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelResponse => SingleModelResponse.decode(value),
  },
  /** Export a model */
  putModelVersionExports: {
    path: "/clarifai.api.V2/PutModelVersionExports",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutModelVersionExportsRequest): Buffer =>
      Buffer.from(PutModelVersionExportsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PutModelVersionExportsRequest => PutModelVersionExportsRequest.decode(value),
    responseSerialize: (value: SingleModelVersionExportResponse): Buffer =>
      Buffer.from(SingleModelVersionExportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionExportResponse =>
      SingleModelVersionExportResponse.decode(value),
  },
  /** GetModelVersionExport */
  getModelVersionExport: {
    path: "/clarifai.api.V2/GetModelVersionExport",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelVersionExportRequest): Buffer =>
      Buffer.from(GetModelVersionExportRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelVersionExportRequest => GetModelVersionExportRequest.decode(value),
    responseSerialize: (value: SingleModelVersionExportResponse): Buffer =>
      Buffer.from(SingleModelVersionExportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionExportResponse =>
      SingleModelVersionExportResponse.decode(value),
  },
  /**
   * Get the evaluation metrics for a model version.
   * Deprecated: Use GetEvaluation instead
   *   The server may refuse to accept requests to this endpoint.
   */
  getModelVersionMetrics: {
    path: "/clarifai.api.V2/GetModelVersionMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelVersionMetricsRequest): Buffer =>
      Buffer.from(GetModelVersionMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelVersionMetricsRequest => GetModelVersionMetricsRequest.decode(value),
    responseSerialize: (value: SingleModelVersionResponse): Buffer =>
      Buffer.from(SingleModelVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionResponse => SingleModelVersionResponse.decode(value),
  },
  /**
   * Deprecated, use PostEvaluations instead
   * Run the evaluation metrics for a model version.
   */
  postModelVersionMetrics: {
    path: "/clarifai.api.V2/PostModelVersionMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionMetricsRequest): Buffer =>
      Buffer.from(PostModelVersionMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionMetricsRequest => PostModelVersionMetricsRequest.decode(value),
    responseSerialize: (value: SingleModelVersionResponse): Buffer =>
      Buffer.from(SingleModelVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionResponse => SingleModelVersionResponse.decode(value),
  },
  /** Deprecated, use PostEvaluations instead */
  postModelVersionEvaluations: {
    path: "/clarifai.api.V2/PostModelVersionEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionEvaluationsRequest): Buffer =>
      Buffer.from(PostModelVersionEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionEvaluationsRequest =>
      PostModelVersionEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiEvalMetricsResponse): Buffer =>
      Buffer.from(MultiEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiEvalMetricsResponse => MultiEvalMetricsResponse.decode(value),
  },
  /**
   * Deprecated, use GetEvaluation instead
   * List the evaluation metrics for a model version.
   */
  listModelVersionEvaluations: {
    path: "/clarifai.api.V2/ListModelVersionEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelVersionEvaluationsRequest): Buffer =>
      Buffer.from(ListModelVersionEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelVersionEvaluationsRequest =>
      ListModelVersionEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiEvalMetricsResponse): Buffer =>
      Buffer.from(MultiEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiEvalMetricsResponse => MultiEvalMetricsResponse.decode(value),
  },
  /**
   * Deprecated, use GetEvaluation instead
   * Get an evaluation metrics for a model version.
   */
  getModelVersionEvaluation: {
    path: "/clarifai.api.V2/GetModelVersionEvaluation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelVersionEvaluationRequest): Buffer =>
      Buffer.from(GetModelVersionEvaluationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelVersionEvaluationRequest =>
      GetModelVersionEvaluationRequest.decode(value),
    responseSerialize: (value: SingleEvalMetricsResponse): Buffer =>
      Buffer.from(SingleEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleEvalMetricsResponse => SingleEvalMetricsResponse.decode(value),
  },
  postEvaluations: {
    path: "/clarifai.api.V2/PostEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostEvaluationsRequest): Buffer =>
      Buffer.from(PostEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostEvaluationsRequest => PostEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiEvalMetricsResponse): Buffer =>
      Buffer.from(MultiEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiEvalMetricsResponse => MultiEvalMetricsResponse.decode(value),
  },
  listEvaluations: {
    path: "/clarifai.api.V2/ListEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListEvaluationsRequest): Buffer =>
      Buffer.from(ListEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListEvaluationsRequest => ListEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiEvalMetricsResponse): Buffer =>
      Buffer.from(MultiEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiEvalMetricsResponse => MultiEvalMetricsResponse.decode(value),
  },
  getEvaluation: {
    path: "/clarifai.api.V2/GetEvaluation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEvaluationRequest): Buffer => Buffer.from(GetEvaluationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEvaluationRequest => GetEvaluationRequest.decode(value),
    responseSerialize: (value: SingleEvalMetricsResponse): Buffer =>
      Buffer.from(SingleEvalMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleEvalMetricsResponse => SingleEvalMetricsResponse.decode(value),
  },
  /** Lists model references tied to a particular model id. */
  listModelReferences: {
    path: "/clarifai.api.V2/ListModelReferences",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelReferencesRequest): Buffer =>
      Buffer.from(ListModelReferencesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelReferencesRequest => ListModelReferencesRequest.decode(value),
    responseSerialize: (value: MultiModelReferenceResponse): Buffer =>
      Buffer.from(MultiModelReferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelReferenceResponse => MultiModelReferenceResponse.decode(value),
  },
  /** GetModelVersionInputExample */
  getModelVersionInputExample: {
    path: "/clarifai.api.V2/GetModelVersionInputExample",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelVersionInputExampleRequest): Buffer =>
      Buffer.from(GetModelVersionInputExampleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModelVersionInputExampleRequest =>
      GetModelVersionInputExampleRequest.decode(value),
    responseSerialize: (value: SingleModelVersionInputExampleResponse): Buffer =>
      Buffer.from(SingleModelVersionInputExampleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModelVersionInputExampleResponse =>
      SingleModelVersionInputExampleResponse.decode(value),
  },
  /** ListModelVersionInputExamples */
  listModelVersionInputExamples: {
    path: "/clarifai.api.V2/ListModelVersionInputExamples",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelVersionInputExamplesRequest): Buffer =>
      Buffer.from(ListModelVersionInputExamplesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModelVersionInputExamplesRequest =>
      ListModelVersionInputExamplesRequest.decode(value),
    responseSerialize: (value: MultiModelVersionInputExampleResponse): Buffer =>
      Buffer.from(MultiModelVersionInputExampleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModelVersionInputExampleResponse =>
      MultiModelVersionInputExampleResponse.decode(value),
  },
  /** Get a specific workflow from an app. */
  getWorkflow: {
    path: "/clarifai.api.V2/GetWorkflow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWorkflowRequest): Buffer => Buffer.from(GetWorkflowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetWorkflowRequest => GetWorkflowRequest.decode(value),
    responseSerialize: (value: SingleWorkflowResponse): Buffer =>
      Buffer.from(SingleWorkflowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleWorkflowResponse => SingleWorkflowResponse.decode(value),
  },
  /** List all the workflows. */
  listWorkflows: {
    path: "/clarifai.api.V2/ListWorkflows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkflowsRequest): Buffer => Buffer.from(ListWorkflowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkflowsRequest => ListWorkflowsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowResponse): Buffer =>
      Buffer.from(MultiWorkflowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowResponse => MultiWorkflowResponse.decode(value),
  },
  /**
   * Add a workflow to an app.
   * Note(zeiler): the order of the workflows that are returned from this endpoint
   * may be different than the order in which the user provides them. This is because
   * we reorder by a sort that optimizes for performance of the graph and its dependencies.
   * When using the workflow in any future call the order returned by this endpoint
   * will be used.
   */
  postWorkflows: {
    path: "/clarifai.api.V2/PostWorkflows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowsRequest): Buffer => Buffer.from(PostWorkflowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowsRequest => PostWorkflowsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowResponse): Buffer =>
      Buffer.from(MultiWorkflowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowResponse => MultiWorkflowResponse.decode(value),
  },
  /** Patch one or more workflows. */
  patchWorkflows: {
    path: "/clarifai.api.V2/PatchWorkflows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchWorkflowsRequest): Buffer =>
      Buffer.from(PatchWorkflowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchWorkflowsRequest => PatchWorkflowsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowResponse): Buffer =>
      Buffer.from(MultiWorkflowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowResponse => MultiWorkflowResponse.decode(value),
  },
  /** Patch one or more workflows ids. */
  patchWorkflowIds: {
    path: "/clarifai.api.V2/PatchWorkflowIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchWorkflowIdsRequest): Buffer =>
      Buffer.from(PatchWorkflowIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchWorkflowIdsRequest => PatchWorkflowIdsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowResponse): Buffer =>
      Buffer.from(MultiWorkflowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowResponse => MultiWorkflowResponse.decode(value),
  },
  /** Delete a single workflow. */
  deleteWorkflow: {
    path: "/clarifai.api.V2/DeleteWorkflow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteWorkflowRequest): Buffer =>
      Buffer.from(DeleteWorkflowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteWorkflowRequest => DeleteWorkflowRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Delete multiple workflows in one request. */
  deleteWorkflows: {
    path: "/clarifai.api.V2/DeleteWorkflows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteWorkflowsRequest): Buffer =>
      Buffer.from(DeleteWorkflowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteWorkflowsRequest => DeleteWorkflowsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Predict using a workflow. */
  postWorkflowResults: {
    path: "/clarifai.api.V2/PostWorkflowResults",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowResultsRequest): Buffer =>
      Buffer.from(PostWorkflowResultsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowResultsRequest => PostWorkflowResultsRequest.decode(value),
    responseSerialize: (value: PostWorkflowResultsResponse): Buffer =>
      Buffer.from(PostWorkflowResultsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PostWorkflowResultsResponse => PostWorkflowResultsResponse.decode(value),
  },
  /** List workflow versions. */
  listWorkflowVersions: {
    path: "/clarifai.api.V2/ListWorkflowVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkflowVersionsRequest): Buffer =>
      Buffer.from(ListWorkflowVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkflowVersionsRequest => ListWorkflowVersionsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowVersionResponse): Buffer =>
      Buffer.from(MultiWorkflowVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowVersionResponse => MultiWorkflowVersionResponse.decode(value),
  },
  /** Get single workflow version. */
  getWorkflowVersion: {
    path: "/clarifai.api.V2/GetWorkflowVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWorkflowVersionRequest): Buffer =>
      Buffer.from(GetWorkflowVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetWorkflowVersionRequest => GetWorkflowVersionRequest.decode(value),
    responseSerialize: (value: SingleWorkflowVersionResponse): Buffer =>
      Buffer.from(SingleWorkflowVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleWorkflowVersionResponse => SingleWorkflowVersionResponse.decode(value),
  },
  /** Delete workflow versions. */
  deleteWorkflowVersions: {
    path: "/clarifai.api.V2/DeleteWorkflowVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteWorkflowVersionsRequest): Buffer =>
      Buffer.from(DeleteWorkflowVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteWorkflowVersionsRequest => DeleteWorkflowVersionsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Patch workflow versions. */
  patchWorkflowVersions: {
    path: "/clarifai.api.V2/PatchWorkflowVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchWorkflowVersionsRequest): Buffer =>
      Buffer.from(PatchWorkflowVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchWorkflowVersionsRequest => PatchWorkflowVersionsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowVersionResponse): Buffer =>
      Buffer.from(MultiWorkflowVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowVersionResponse => MultiWorkflowVersionResponse.decode(value),
  },
  /** Get a specific key from an app. */
  getKey: {
    path: "/clarifai.api.V2/GetKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetKeyRequest): Buffer => Buffer.from(GetKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetKeyRequest => GetKeyRequest.decode(value),
    responseSerialize: (value: SingleKeyResponse): Buffer => Buffer.from(SingleKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleKeyResponse => SingleKeyResponse.decode(value),
  },
  /** List all the keys. */
  listKeys: {
    path: "/clarifai.api.V2/ListKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListKeysRequest): Buffer => Buffer.from(ListKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListKeysRequest => ListKeysRequest.decode(value),
    responseSerialize: (value: MultiKeyResponse): Buffer => Buffer.from(MultiKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKeyResponse => MultiKeyResponse.decode(value),
  },
  /** List keys by app_id */
  listAppKeys: {
    path: "/clarifai.api.V2/ListAppKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAppKeysRequest): Buffer => Buffer.from(ListAppKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAppKeysRequest => ListAppKeysRequest.decode(value),
    responseSerialize: (value: MultiKeyResponse): Buffer => Buffer.from(MultiKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKeyResponse => MultiKeyResponse.decode(value),
  },
  /**
   * Search over the keys to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteKey: {
    path: "/clarifai.api.V2/DeleteKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteKeyRequest): Buffer => Buffer.from(DeleteKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteKeyRequest => DeleteKeyRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Add a key to an app. */
  postKeys: {
    path: "/clarifai.api.V2/PostKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostKeysRequest): Buffer => Buffer.from(PostKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostKeysRequest => PostKeysRequest.decode(value),
    responseSerialize: (value: MultiKeyResponse): Buffer => Buffer.from(MultiKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKeyResponse => MultiKeyResponse.decode(value),
  },
  /** Patch one or more keys. */
  patchKeys: {
    path: "/clarifai.api.V2/PatchKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchKeysRequest): Buffer => Buffer.from(PatchKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchKeysRequest => PatchKeysRequest.decode(value),
    responseSerialize: (value: MultiKeyResponse): Buffer => Buffer.from(MultiKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiKeyResponse => MultiKeyResponse.decode(value),
  },
  /**
   * API Keys in the public API -- request is itself Key authorized, and will tell
   * the user the scopes/access of the key/credential they're providing, as computed by
   * our authorizer:
   */
  myScopes: {
    path: "/clarifai.api.V2/MyScopes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MyScopesRequest): Buffer => Buffer.from(MyScopesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MyScopesRequest => MyScopesRequest.decode(value),
    responseSerialize: (value: MultiScopeResponse): Buffer => Buffer.from(MultiScopeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiScopeResponse => MultiScopeResponse.decode(value),
  },
  myScopesUser: {
    path: "/clarifai.api.V2/MyScopesUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MyScopesUserRequest): Buffer => Buffer.from(MyScopesUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MyScopesUserRequest => MyScopesUserRequest.decode(value),
    responseSerialize: (value: MultiScopeUserResponse): Buffer =>
      Buffer.from(MultiScopeUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiScopeUserResponse => MultiScopeUserResponse.decode(value),
  },
  myScopesRoot: {
    path: "/clarifai.api.V2/MyScopesRoot",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MyScopesRootRequest): Buffer => Buffer.from(MyScopesRootRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MyScopesRootRequest => MyScopesRootRequest.decode(value),
    responseSerialize: (value: MultiScopeRootResponse): Buffer =>
      Buffer.from(MultiScopeRootResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiScopeRootResponse => MultiScopeRootResponse.decode(value),
  },
  /** List all auth scopes available to me as a user. */
  listScopes: {
    path: "/clarifai.api.V2/ListScopes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListScopesRequest): Buffer => Buffer.from(ListScopesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListScopesRequest => ListScopesRequest.decode(value),
    responseSerialize: (value: MultiScopeDepsResponse): Buffer =>
      Buffer.from(MultiScopeDepsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiScopeDepsResponse => MultiScopeDepsResponse.decode(value),
  },
  /** Get a specific app from an app. */
  getApp: {
    path: "/clarifai.api.V2/GetApp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAppRequest): Buffer => Buffer.from(GetAppRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAppRequest => GetAppRequest.decode(value),
    responseSerialize: (value: SingleAppResponse): Buffer => Buffer.from(SingleAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleAppResponse => SingleAppResponse.decode(value),
  },
  /** List all the apps. */
  listApps: {
    path: "/clarifai.api.V2/ListApps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAppsRequest): Buffer => Buffer.from(ListAppsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAppsRequest => ListAppsRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /**
   * Search over the apps to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteApp: {
    path: "/clarifai.api.V2/DeleteApp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAppRequest): Buffer => Buffer.from(DeleteAppRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAppRequest => DeleteAppRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Add a app to an app.
   * This needs to load the default workflow to make a copy, validating all the models in it, and
   * then writing the new workflow back to this new app.
   */
  postApps: {
    path: "/clarifai.api.V2/PostApps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAppsRequest): Buffer => Buffer.from(PostAppsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAppsRequest => PostAppsRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /** Patch one or more apps. */
  patchApps: {
    path: "/clarifai.api.V2/PatchApps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAppsRequest): Buffer => Buffer.from(PatchAppsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAppsRequest => PatchAppsRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /**
   * Allows to Patch only the below fields in one or more apps.
   * Allowed fields are notes, description and image
   */
  patchAppsDetails: {
    path: "/clarifai.api.V2/PatchAppsDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAppsDetailsRequest): Buffer =>
      Buffer.from(PatchAppsDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAppsDetailsRequest => PatchAppsDetailsRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /** Patch apps ids. */
  patchAppsIds: {
    path: "/clarifai.api.V2/PatchAppsIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAppsIdsRequest): Buffer => Buffer.from(PatchAppsIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAppsIdsRequest => PatchAppsIdsRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /** Patch one app. */
  patchApp: {
    path: "/clarifai.api.V2/PatchApp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAppRequest): Buffer => Buffer.from(PatchAppRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAppRequest => PatchAppRequest.decode(value),
    responseSerialize: (value: SingleAppResponse): Buffer => Buffer.from(SingleAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleAppResponse => SingleAppResponse.decode(value),
  },
  /** Search over the applications to find one or more you're looking for. */
  postAppsSearches: {
    path: "/clarifai.api.V2/PostAppsSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAppsSearchesRequest): Buffer =>
      Buffer.from(PostAppsSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAppsSearchesRequest => PostAppsSearchesRequest.decode(value),
    responseSerialize: (value: MultiAppResponse): Buffer => Buffer.from(MultiAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppResponse => MultiAppResponse.decode(value),
  },
  /** Get user information */
  getUser: {
    path: "/clarifai.api.V2/GetUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRequest): Buffer => Buffer.from(GetUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserRequest => GetUserRequest.decode(value),
    responseSerialize: (value: SingleUserResponse): Buffer => Buffer.from(SingleUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleUserResponse => SingleUserResponse.decode(value),
  },
  /** Validate new password in real-time for a user */
  postValidatePassword: {
    path: "/clarifai.api.V2/PostValidatePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostValidatePasswordRequest): Buffer =>
      Buffer.from(PostValidatePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostValidatePasswordRequest => PostValidatePasswordRequest.decode(value),
    responseSerialize: (value: SinglePasswordValidationResponse): Buffer =>
      Buffer.from(SinglePasswordValidationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePasswordValidationResponse =>
      SinglePasswordValidationResponse.decode(value),
  },
  /** Get a saved legacy search. */
  getSearch: {
    path: "/clarifai.api.V2/GetSearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSearchRequest): Buffer => Buffer.from(GetSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSearchRequest => GetSearchRequest.decode(value),
    responseSerialize: (value: SingleSearchResponse): Buffer =>
      Buffer.from(SingleSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleSearchResponse => SingleSearchResponse.decode(value),
  },
  /** List all saved legacy searches. */
  listSearches: {
    path: "/clarifai.api.V2/ListSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSearchesRequest): Buffer => Buffer.from(ListSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSearchesRequest => ListSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Patch saved legacy searches by ids. */
  patchSearches: {
    path: "/clarifai.api.V2/PatchSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchSearchesRequest): Buffer => Buffer.from(PatchSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchSearchesRequest => PatchSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /**
   * Execute a new search and optionally save it.
   *
   * Deprecated: Use PostInputsSearches or PostAnnotationsSearches instead.
   *  The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  postSearches: {
    path: "/clarifai.api.V2/PostSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostSearchesRequest): Buffer => Buffer.from(PostSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostSearchesRequest => PostSearchesRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Execute a previously saved legacy search. */
  postSearchesById: {
    path: "/clarifai.api.V2/PostSearchesByID",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostSearchesByIDRequest): Buffer =>
      Buffer.from(PostSearchesByIDRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostSearchesByIDRequest => PostSearchesByIDRequest.decode(value),
    responseSerialize: (value: MultiSearchResponse): Buffer => Buffer.from(MultiSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSearchResponse => MultiSearchResponse.decode(value),
  },
  /** Evaluate the results of two search requests */
  postAnnotationSearchMetrics: {
    path: "/clarifai.api.V2/PostAnnotationSearchMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAnnotationSearchMetricsRequest): Buffer =>
      Buffer.from(PostAnnotationSearchMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAnnotationSearchMetricsRequest =>
      PostAnnotationSearchMetricsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationSearchMetricsResponse): Buffer =>
      Buffer.from(MultiAnnotationSearchMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationSearchMetricsResponse =>
      MultiAnnotationSearchMetricsResponse.decode(value),
  },
  /** Get the evaluation results between two search requests */
  getAnnotationSearchMetrics: {
    path: "/clarifai.api.V2/GetAnnotationSearchMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAnnotationSearchMetricsRequest): Buffer =>
      Buffer.from(GetAnnotationSearchMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAnnotationSearchMetricsRequest =>
      GetAnnotationSearchMetricsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationSearchMetricsResponse): Buffer =>
      Buffer.from(MultiAnnotationSearchMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationSearchMetricsResponse =>
      MultiAnnotationSearchMetricsResponse.decode(value),
  },
  /** List the evaluation results between two search requests */
  listAnnotationSearchMetrics: {
    path: "/clarifai.api.V2/ListAnnotationSearchMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAnnotationSearchMetricsRequest): Buffer =>
      Buffer.from(ListAnnotationSearchMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAnnotationSearchMetricsRequest =>
      ListAnnotationSearchMetricsRequest.decode(value),
    responseSerialize: (value: MultiAnnotationSearchMetricsResponse): Buffer =>
      Buffer.from(MultiAnnotationSearchMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationSearchMetricsResponse =>
      MultiAnnotationSearchMetricsResponse.decode(value),
  },
  /** DeleteAnnotationSearchMetrics */
  deleteAnnotationSearchMetrics: {
    path: "/clarifai.api.V2/DeleteAnnotationSearchMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAnnotationSearchMetricsRequest): Buffer =>
      Buffer.from(DeleteAnnotationSearchMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAnnotationSearchMetricsRequest =>
      DeleteAnnotationSearchMetricsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Delete a saved search. */
  deleteSearch: {
    path: "/clarifai.api.V2/DeleteSearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteSearchRequest): Buffer => Buffer.from(DeleteSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteSearchRequest => DeleteSearchRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all the annotation filters. */
  listAnnotationFilters: {
    path: "/clarifai.api.V2/ListAnnotationFilters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAnnotationFiltersRequest): Buffer =>
      Buffer.from(ListAnnotationFiltersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAnnotationFiltersRequest => ListAnnotationFiltersRequest.decode(value),
    responseSerialize: (value: MultiAnnotationFilterResponse): Buffer =>
      Buffer.from(MultiAnnotationFilterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationFilterResponse => MultiAnnotationFilterResponse.decode(value),
  },
  /** Get a specific annotation filter. */
  getAnnotationFilter: {
    path: "/clarifai.api.V2/GetAnnotationFilter",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAnnotationFilterRequest): Buffer =>
      Buffer.from(GetAnnotationFilterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAnnotationFilterRequest => GetAnnotationFilterRequest.decode(value),
    responseSerialize: (value: SingleAnnotationFilterResponse): Buffer =>
      Buffer.from(SingleAnnotationFilterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleAnnotationFilterResponse =>
      SingleAnnotationFilterResponse.decode(value),
  },
  /** Add annotation filters. */
  postAnnotationFilters: {
    path: "/clarifai.api.V2/PostAnnotationFilters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAnnotationFiltersRequest): Buffer =>
      Buffer.from(PostAnnotationFiltersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAnnotationFiltersRequest => PostAnnotationFiltersRequest.decode(value),
    responseSerialize: (value: MultiAnnotationFilterResponse): Buffer =>
      Buffer.from(MultiAnnotationFilterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationFilterResponse => MultiAnnotationFilterResponse.decode(value),
  },
  /** Patch one or more annotation filters. */
  patchAnnotationFilters: {
    path: "/clarifai.api.V2/PatchAnnotationFilters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchAnnotationFiltersRequest): Buffer =>
      Buffer.from(PatchAnnotationFiltersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchAnnotationFiltersRequest => PatchAnnotationFiltersRequest.decode(value),
    responseSerialize: (value: MultiAnnotationFilterResponse): Buffer =>
      Buffer.from(MultiAnnotationFilterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAnnotationFilterResponse => MultiAnnotationFilterResponse.decode(value),
  },
  /** Delete one or more annotation filters in a single request. */
  deleteAnnotationFilters: {
    path: "/clarifai.api.V2/DeleteAnnotationFilters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAnnotationFiltersRequest): Buffer =>
      Buffer.from(DeleteAnnotationFiltersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAnnotationFiltersRequest => DeleteAnnotationFiltersRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** List all status codes. */
  listStatusCodes: {
    path: "/clarifai.api.V2/ListStatusCodes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListStatusCodesRequest): Buffer =>
      Buffer.from(ListStatusCodesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListStatusCodesRequest => ListStatusCodesRequest.decode(value),
    responseSerialize: (value: MultiStatusCodeResponse): Buffer =>
      Buffer.from(MultiStatusCodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiStatusCodeResponse => MultiStatusCodeResponse.decode(value),
  },
  /** Get more details for a status code. */
  getStatusCode: {
    path: "/clarifai.api.V2/GetStatusCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatusCodeRequest): Buffer => Buffer.from(GetStatusCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatusCodeRequest => GetStatusCodeRequest.decode(value),
    responseSerialize: (value: SingleStatusCodeResponse): Buffer =>
      Buffer.from(SingleStatusCodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleStatusCodeResponse => SingleStatusCodeResponse.decode(value),
  },
  /** owner list users who the app is shared with */
  listCollaborators: {
    path: "/clarifai.api.V2/ListCollaborators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollaboratorsRequest): Buffer =>
      Buffer.from(ListCollaboratorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollaboratorsRequest => ListCollaboratorsRequest.decode(value),
    responseSerialize: (value: MultiCollaboratorsResponse): Buffer =>
      Buffer.from(MultiCollaboratorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollaboratorsResponse => MultiCollaboratorsResponse.decode(value),
  },
  /** add collaborators to an app. */
  postCollaborators: {
    path: "/clarifai.api.V2/PostCollaborators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostCollaboratorsRequest): Buffer =>
      Buffer.from(PostCollaboratorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostCollaboratorsRequest => PostCollaboratorsRequest.decode(value),
    responseSerialize: (value: MultiCollaboratorsResponse): Buffer =>
      Buffer.from(MultiCollaboratorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollaboratorsResponse => MultiCollaboratorsResponse.decode(value),
  },
  /** Patch existing collaborators. */
  patchCollaborators: {
    path: "/clarifai.api.V2/PatchCollaborators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchCollaboratorsRequest): Buffer =>
      Buffer.from(PatchCollaboratorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchCollaboratorsRequest => PatchCollaboratorsRequest.decode(value),
    responseSerialize: (value: MultiCollaboratorsResponse): Buffer =>
      Buffer.from(MultiCollaboratorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollaboratorsResponse => MultiCollaboratorsResponse.decode(value),
  },
  /** Delete existing collaborators. */
  deleteCollaborators: {
    path: "/clarifai.api.V2/DeleteCollaborators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCollaboratorsRequest): Buffer =>
      Buffer.from(DeleteCollaboratorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCollaboratorsRequest => DeleteCollaboratorsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Collaboration includes the app user are invitied to work on */
  listCollaborations: {
    path: "/clarifai.api.V2/ListCollaborations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollaborationsRequest): Buffer =>
      Buffer.from(ListCollaborationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollaborationsRequest => ListCollaborationsRequest.decode(value),
    responseSerialize: (value: MultiCollaborationsResponse): Buffer =>
      Buffer.from(MultiCollaborationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollaborationsResponse => MultiCollaborationsResponse.decode(value),
  },
  /**
   * PostAppDuplications starts async app duplication jobs which copy resources
   * (inputs, annotations, models etc) from one application to another. It can
   * also create the destination application if it does not exist, with fields
   * (description, metadata etc) copied from the source application.
   *
   * A duplication job can be started by any user that can read from the source
   * application (the target of this call) and can create and write to the
   * destination application. The duplication is associated with the user that
   * created it, so in order to read the status and progress of the job, that
   * user's ID has to be used in the call to GetAppDuplication, which might be
   * different to the source application owner ID in this call.
   */
  postAppDuplications: {
    path: "/clarifai.api.V2/PostAppDuplications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAppDuplicationsRequest): Buffer =>
      Buffer.from(PostAppDuplicationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAppDuplicationsRequest => PostAppDuplicationsRequest.decode(value),
    responseSerialize: (value: MultiAppDuplicationsResponse): Buffer =>
      Buffer.from(MultiAppDuplicationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppDuplicationsResponse => MultiAppDuplicationsResponse.decode(value),
  },
  /** ListAppDuplications lists all app duplication jobs created by the user. */
  listAppDuplications: {
    path: "/clarifai.api.V2/ListAppDuplications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAppDuplicationsRequest): Buffer =>
      Buffer.from(ListAppDuplicationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAppDuplicationsRequest => ListAppDuplicationsRequest.decode(value),
    responseSerialize: (value: MultiAppDuplicationsResponse): Buffer =>
      Buffer.from(MultiAppDuplicationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAppDuplicationsResponse => MultiAppDuplicationsResponse.decode(value),
  },
  /** GetAppDuplication returns an app duplication job created by the user. */
  getAppDuplication: {
    path: "/clarifai.api.V2/GetAppDuplication",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAppDuplicationRequest): Buffer =>
      Buffer.from(GetAppDuplicationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAppDuplicationRequest => GetAppDuplicationRequest.decode(value),
    responseSerialize: (value: SingleAppDuplicationResponse): Buffer =>
      Buffer.from(SingleAppDuplicationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleAppDuplicationResponse => SingleAppDuplicationResponse.decode(value),
  },
  /** Add tasks to an app. */
  postTasks: {
    path: "/clarifai.api.V2/PostTasks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostTasksRequest): Buffer => Buffer.from(PostTasksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostTasksRequest => PostTasksRequest.decode(value),
    responseSerialize: (value: MultiTaskResponse): Buffer => Buffer.from(MultiTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiTaskResponse => MultiTaskResponse.decode(value),
  },
  /** Task annotation count */
  getTaskAnnotationCount: {
    path: "/clarifai.api.V2/GetTaskAnnotationCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskCountRequest): Buffer => Buffer.from(GetTaskCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTaskCountRequest => GetTaskCountRequest.decode(value),
    responseSerialize: (value: SingleTaskCountResponse): Buffer =>
      Buffer.from(SingleTaskCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleTaskCountResponse => SingleTaskCountResponse.decode(value),
  },
  /** Task Input count */
  getTaskInputCount: {
    path: "/clarifai.api.V2/GetTaskInputCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskCountRequest): Buffer => Buffer.from(GetTaskCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTaskCountRequest => GetTaskCountRequest.decode(value),
    responseSerialize: (value: SingleTaskCountResponse): Buffer =>
      Buffer.from(SingleTaskCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleTaskCountResponse => SingleTaskCountResponse.decode(value),
  },
  /** Get a specific task from an app. */
  getTask: {
    path: "/clarifai.api.V2/GetTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskRequest): Buffer => Buffer.from(GetTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTaskRequest => GetTaskRequest.decode(value),
    responseSerialize: (value: SingleTaskResponse): Buffer => Buffer.from(SingleTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleTaskResponse => SingleTaskResponse.decode(value),
  },
  /** List tasks from an app. */
  listTasks: {
    path: "/clarifai.api.V2/ListTasks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTasksRequest): Buffer => Buffer.from(ListTasksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTasksRequest => ListTasksRequest.decode(value),
    responseSerialize: (value: MultiTaskResponse): Buffer => Buffer.from(MultiTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiTaskResponse => MultiTaskResponse.decode(value),
  },
  /** Patch one or more tasks. */
  patchTasks: {
    path: "/clarifai.api.V2/PatchTasks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchTasksRequest): Buffer => Buffer.from(PatchTasksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchTasksRequest => PatchTasksRequest.decode(value),
    responseSerialize: (value: MultiTaskResponse): Buffer => Buffer.from(MultiTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiTaskResponse => MultiTaskResponse.decode(value),
  },
  /** Delete multiple tasks in one request. */
  deleteTasks: {
    path: "/clarifai.api.V2/DeleteTasks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTasksRequest): Buffer => Buffer.from(DeleteTasksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteTasksRequest => DeleteTasksRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Add Label orders. */
  postLabelOrders: {
    path: "/clarifai.api.V2/PostLabelOrders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostLabelOrdersRequest): Buffer =>
      Buffer.from(PostLabelOrdersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostLabelOrdersRequest => PostLabelOrdersRequest.decode(value),
    responseSerialize: (value: MultiLabelOrderResponse): Buffer =>
      Buffer.from(MultiLabelOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiLabelOrderResponse => MultiLabelOrderResponse.decode(value),
  },
  /** Get a label order. */
  getLabelOrder: {
    path: "/clarifai.api.V2/GetLabelOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLabelOrderRequest): Buffer => Buffer.from(GetLabelOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLabelOrderRequest => GetLabelOrderRequest.decode(value),
    responseSerialize: (value: SingleLabelOrderResponse): Buffer =>
      Buffer.from(SingleLabelOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleLabelOrderResponse => SingleLabelOrderResponse.decode(value),
  },
  /** List label orders. */
  listLabelOrders: {
    path: "/clarifai.api.V2/ListLabelOrders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListLabelOrdersRequest): Buffer =>
      Buffer.from(ListLabelOrdersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListLabelOrdersRequest => ListLabelOrdersRequest.decode(value),
    responseSerialize: (value: MultiLabelOrderResponse): Buffer =>
      Buffer.from(MultiLabelOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiLabelOrderResponse => MultiLabelOrderResponse.decode(value),
  },
  /** Patch one or more label orders. */
  patchLabelOrders: {
    path: "/clarifai.api.V2/PatchLabelOrders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchLabelOrdersRequest): Buffer =>
      Buffer.from(PatchLabelOrdersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchLabelOrdersRequest => PatchLabelOrdersRequest.decode(value),
    responseSerialize: (value: MultiLabelOrderResponse): Buffer =>
      Buffer.from(MultiLabelOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiLabelOrderResponse => MultiLabelOrderResponse.decode(value),
  },
  /**
   * Delete multiple label orders in one request.
   * this do not change task status
   */
  deleteLabelOrders: {
    path: "/clarifai.api.V2/DeleteLabelOrders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteLabelOrdersRequest): Buffer =>
      Buffer.from(DeleteLabelOrdersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteLabelOrdersRequest => DeleteLabelOrdersRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Add a list of Collectors to an app.
   * In the handler of this endpoint we also check for all the scopes of the  POST /inputs
   * endpoint.
   * Those current scopes are listed here as a hard requirement.
   * They are needed when adding the collectors just so we now that you have permission with
   * that key at least to do the writing to this app with POST /inputs.
   */
  postCollectors: {
    path: "/clarifai.api.V2/PostCollectors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostCollectorsRequest): Buffer =>
      Buffer.from(PostCollectorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostCollectorsRequest => PostCollectorsRequest.decode(value),
    responseSerialize: (value: MultiCollectorResponse): Buffer =>
      Buffer.from(MultiCollectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollectorResponse => MultiCollectorResponse.decode(value),
  },
  /** Get a specific collector from an app. */
  getCollector: {
    path: "/clarifai.api.V2/GetCollector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCollectorRequest): Buffer => Buffer.from(GetCollectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCollectorRequest => GetCollectorRequest.decode(value),
    responseSerialize: (value: SingleCollectorResponse): Buffer =>
      Buffer.from(SingleCollectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleCollectorResponse => SingleCollectorResponse.decode(value),
  },
  /** List all the collectors. */
  listCollectors: {
    path: "/clarifai.api.V2/ListCollectors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollectorsRequest): Buffer =>
      Buffer.from(ListCollectorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollectorsRequest => ListCollectorsRequest.decode(value),
    responseSerialize: (value: MultiCollectorResponse): Buffer =>
      Buffer.from(MultiCollectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollectorResponse => MultiCollectorResponse.decode(value),
  },
  /** Patch one or more collectors. */
  patchCollectors: {
    path: "/clarifai.api.V2/PatchCollectors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchCollectorsRequest): Buffer =>
      Buffer.from(PatchCollectorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchCollectorsRequest => PatchCollectorsRequest.decode(value),
    responseSerialize: (value: MultiCollectorResponse): Buffer =>
      Buffer.from(MultiCollectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCollectorResponse => MultiCollectorResponse.decode(value),
  },
  /**
   * Delete multiple collectors in one request.
   * This call is asynchronous. Use DeleteCollector if you want a synchronous version.
   */
  deleteCollectors: {
    path: "/clarifai.api.V2/DeleteCollectors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCollectorsRequest): Buffer =>
      Buffer.from(DeleteCollectorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCollectorsRequest => DeleteCollectorsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** PostStatValues */
  postStatValues: {
    path: "/clarifai.api.V2/PostStatValues",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostStatValuesRequest): Buffer =>
      Buffer.from(PostStatValuesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostStatValuesRequest => PostStatValuesRequest.decode(value),
    responseSerialize: (value: MultiStatValueResponse): Buffer =>
      Buffer.from(MultiStatValueResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiStatValueResponse => MultiStatValueResponse.decode(value),
  },
  /** PostStatValuesAggregate */
  postStatValuesAggregate: {
    path: "/clarifai.api.V2/PostStatValuesAggregate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostStatValuesAggregateRequest): Buffer =>
      Buffer.from(PostStatValuesAggregateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostStatValuesAggregateRequest => PostStatValuesAggregateRequest.decode(value),
    responseSerialize: (value: MultiStatValueAggregateResponse): Buffer =>
      Buffer.from(MultiStatValueAggregateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiStatValueAggregateResponse =>
      MultiStatValueAggregateResponse.decode(value),
  },
  /** Get a specific module from an app. */
  getModule: {
    path: "/clarifai.api.V2/GetModule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModuleRequest): Buffer => Buffer.from(GetModuleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModuleRequest => GetModuleRequest.decode(value),
    responseSerialize: (value: SingleModuleResponse): Buffer =>
      Buffer.from(SingleModuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModuleResponse => SingleModuleResponse.decode(value),
  },
  /** List all the modules in community, by user or by app. */
  listModules: {
    path: "/clarifai.api.V2/ListModules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModulesRequest): Buffer => Buffer.from(ListModulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModulesRequest => ListModulesRequest.decode(value),
    responseSerialize: (value: MultiModuleResponse): Buffer => Buffer.from(MultiModuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleResponse => MultiModuleResponse.decode(value),
  },
  /** Add a modules to an app. */
  postModules: {
    path: "/clarifai.api.V2/PostModules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModulesRequest): Buffer => Buffer.from(PostModulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModulesRequest => PostModulesRequest.decode(value),
    responseSerialize: (value: MultiModuleResponse): Buffer => Buffer.from(MultiModuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleResponse => MultiModuleResponse.decode(value),
  },
  /** Patch one or more modules. */
  patchModules: {
    path: "/clarifai.api.V2/PatchModules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModulesRequest): Buffer => Buffer.from(PatchModulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModulesRequest => PatchModulesRequest.decode(value),
    responseSerialize: (value: MultiModuleResponse): Buffer => Buffer.from(MultiModuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleResponse => MultiModuleResponse.decode(value),
  },
  /** Delete multiple modules in one request. */
  deleteModules: {
    path: "/clarifai.api.V2/DeleteModules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteModulesRequest): Buffer => Buffer.from(DeleteModulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteModulesRequest => DeleteModulesRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Get a specific module version for a module. */
  getModuleVersion: {
    path: "/clarifai.api.V2/GetModuleVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModuleVersionRequest): Buffer =>
      Buffer.from(GetModuleVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModuleVersionRequest => GetModuleVersionRequest.decode(value),
    responseSerialize: (value: SingleModuleVersionResponse): Buffer =>
      Buffer.from(SingleModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModuleVersionResponse => SingleModuleVersionResponse.decode(value),
  },
  /** List all the modules versions for a given module. */
  listModuleVersions: {
    path: "/clarifai.api.V2/ListModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModuleVersionsRequest): Buffer =>
      Buffer.from(ListModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListModuleVersionsRequest => ListModuleVersionsRequest.decode(value),
    responseSerialize: (value: MultiModuleVersionResponse): Buffer =>
      Buffer.from(MultiModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleVersionResponse => MultiModuleVersionResponse.decode(value),
  },
  /** Create a new module version to trigger training of the module. */
  postModuleVersions: {
    path: "/clarifai.api.V2/PostModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModuleVersionsRequest): Buffer =>
      Buffer.from(PostModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModuleVersionsRequest => PostModuleVersionsRequest.decode(value),
    responseSerialize: (value: MultiModuleVersionResponse): Buffer =>
      Buffer.from(MultiModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleVersionResponse => MultiModuleVersionResponse.decode(value),
  },
  /** Modify details of an existing module version. */
  patchModuleVersions: {
    path: "/clarifai.api.V2/PatchModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchModuleVersionsRequest): Buffer =>
      Buffer.from(PatchModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchModuleVersionsRequest => PatchModuleVersionsRequest.decode(value),
    responseSerialize: (value: MultiModuleVersionResponse): Buffer =>
      Buffer.from(MultiModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiModuleVersionResponse => MultiModuleVersionResponse.decode(value),
  },
  /** Delete a multiple module version. */
  deleteModuleVersions: {
    path: "/clarifai.api.V2/DeleteModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteModuleVersionsRequest): Buffer =>
      Buffer.from(DeleteModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteModuleVersionsRequest => DeleteModuleVersionsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Get usage count for specific module version. */
  getModuleVersionUsageCount: {
    path: "/clarifai.api.V2/GetModuleVersionUsageCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModuleVersionUsageCountRequest): Buffer =>
      Buffer.from(GetModuleVersionUsageCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetModuleVersionUsageCountRequest =>
      GetModuleVersionUsageCountRequest.decode(value),
    responseSerialize: (value: SingleModuleVersionUsageCountResponse): Buffer =>
      Buffer.from(SingleModuleVersionUsageCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleModuleVersionUsageCountResponse =>
      SingleModuleVersionUsageCountResponse.decode(value),
  },
  /** Get installed modules vesrions for an app. */
  getInstalledModuleVersion: {
    path: "/clarifai.api.V2/GetInstalledModuleVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInstalledModuleVersionRequest): Buffer =>
      Buffer.from(GetInstalledModuleVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInstalledModuleVersionRequest =>
      GetInstalledModuleVersionRequest.decode(value),
    responseSerialize: (value: SingleInstalledModuleVersionResponse): Buffer =>
      Buffer.from(SingleInstalledModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInstalledModuleVersionResponse =>
      SingleInstalledModuleVersionResponse.decode(value),
  },
  /** List installed modules vesrions for an app. */
  listInstalledModuleVersions: {
    path: "/clarifai.api.V2/ListInstalledModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListInstalledModuleVersionsRequest): Buffer =>
      Buffer.from(ListInstalledModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListInstalledModuleVersionsRequest =>
      ListInstalledModuleVersionsRequest.decode(value),
    responseSerialize: (value: MultiInstalledModuleVersionResponse): Buffer =>
      Buffer.from(MultiInstalledModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInstalledModuleVersionResponse =>
      MultiInstalledModuleVersionResponse.decode(value),
  },
  /** Install a new module version which will deploy the specific ModuleVersion to the app in the url. */
  postInstalledModuleVersions: {
    path: "/clarifai.api.V2/PostInstalledModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInstalledModuleVersionsRequest): Buffer =>
      Buffer.from(PostInstalledModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInstalledModuleVersionsRequest =>
      PostInstalledModuleVersionsRequest.decode(value),
    responseSerialize: (value: MultiInstalledModuleVersionResponse): Buffer =>
      Buffer.from(MultiInstalledModuleVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInstalledModuleVersionResponse =>
      MultiInstalledModuleVersionResponse.decode(value),
  },
  /**
   * Uninstall an installed module version which will deploy the specific ModuleVersion to the app
   * in the url.
   * This cleaned up any associated caller keys so needs the Keys_Delete scope.
   */
  deleteInstalledModuleVersions: {
    path: "/clarifai.api.V2/DeleteInstalledModuleVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteInstalledModuleVersionsRequest): Buffer =>
      Buffer.from(DeleteInstalledModuleVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteInstalledModuleVersionsRequest =>
      DeleteInstalledModuleVersionsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Assign a key that the caller owns to be used when accessing this installed module version
   * If this endpoint is called with a different key then it overwrites what is there.
   */
  postInstalledModuleVersionsKey: {
    path: "/clarifai.api.V2/PostInstalledModuleVersionsKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInstalledModuleVersionsKeyRequest): Buffer =>
      Buffer.from(PostInstalledModuleVersionsKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInstalledModuleVersionsKeyRequest =>
      PostInstalledModuleVersionsKeyRequest.decode(value),
    responseSerialize: (value: SingleKeyResponse): Buffer => Buffer.from(SingleKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleKeyResponse => SingleKeyResponse.decode(value),
  },
  /**
   * Perform bulk operations on a list of inputs based on input source.
   * Operation include add, update, delete of concepts, metadata and geo data.
   * This is an Asynchronous process. Use ListBulkOperations or GetBulkOperation to check the status.
   */
  postBulkOperations: {
    path: "/clarifai.api.V2/PostBulkOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostBulkOperationsRequest): Buffer =>
      Buffer.from(PostBulkOperationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostBulkOperationsRequest => PostBulkOperationsRequest.decode(value),
    responseSerialize: (value: MultiBulkOperationsResponse): Buffer =>
      Buffer.from(MultiBulkOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiBulkOperationsResponse => MultiBulkOperationsResponse.decode(value),
  },
  /** List all the bulk operations */
  listBulkOperations: {
    path: "/clarifai.api.V2/ListBulkOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBulkOperationsRequest): Buffer =>
      Buffer.from(ListBulkOperationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListBulkOperationsRequest => ListBulkOperationsRequest.decode(value),
    responseSerialize: (value: MultiBulkOperationsResponse): Buffer =>
      Buffer.from(MultiBulkOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiBulkOperationsResponse => MultiBulkOperationsResponse.decode(value),
  },
  /** Get the bulk operation details by ID */
  getBulkOperation: {
    path: "/clarifai.api.V2/GetBulkOperation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBulkOperationRequest): Buffer =>
      Buffer.from(GetBulkOperationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBulkOperationRequest => GetBulkOperationRequest.decode(value),
    responseSerialize: (value: SingleBulkOperationsResponse): Buffer =>
      Buffer.from(SingleBulkOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleBulkOperationsResponse => SingleBulkOperationsResponse.decode(value),
  },
  /** Cancel one or more bulk operations */
  cancelBulkOperations: {
    path: "/clarifai.api.V2/CancelBulkOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelBulkOperationRequest): Buffer =>
      Buffer.from(CancelBulkOperationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelBulkOperationRequest => CancelBulkOperationRequest.decode(value),
    responseSerialize: (value: MultiBulkOperationsResponse): Buffer =>
      Buffer.from(MultiBulkOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiBulkOperationsResponse => MultiBulkOperationsResponse.decode(value),
  },
  /** delete one or more terminated bulk operations */
  deleteBulkOperations: {
    path: "/clarifai.api.V2/DeleteBulkOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteBulkOperationRequest): Buffer =>
      Buffer.from(DeleteBulkOperationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteBulkOperationRequest => DeleteBulkOperationRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Deprecated: Use PutTaskAssignments with action=LABEL_START.
   *   This endpoint has initially been designed as a GET request,
   *   but has been re-designed to serve a PUT logic.
   *   In order to clearly highlight that this endpoint serves a PUT request,
   *   this endpoint has been deprecated and replaced by PutTaskAssignments with action=LABEL_START.
   */
  listNextTaskAssignments: {
    path: "/clarifai.api.V2/ListNextTaskAssignments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListNextTaskAssignmentsRequest): Buffer =>
      Buffer.from(ListNextTaskAssignmentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListNextTaskAssignmentsRequest => ListNextTaskAssignmentsRequest.decode(value),
    responseSerialize: (value: MultiInputResponse): Buffer => Buffer.from(MultiInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputResponse => MultiInputResponse.decode(value),
  },
  /**
   * PutTaskAssignments performs an idempotent action for the task assignments in given task.
   * See PutTaskAssignmentsRequestAction for more details about possible actions.
   */
  putTaskAssignments: {
    path: "/clarifai.api.V2/PutTaskAssignments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutTaskAssignmentsRequest): Buffer =>
      Buffer.from(PutTaskAssignmentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PutTaskAssignmentsRequest => PutTaskAssignmentsRequest.decode(value),
    responseSerialize: (value: MultiTaskAssignmentResponse): Buffer =>
      Buffer.from(MultiTaskAssignmentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiTaskAssignmentResponse => MultiTaskAssignmentResponse.decode(value),
  },
  /** List all the inputs add jobs */
  listInputsAddJobs: {
    path: "/clarifai.api.V2/ListInputsAddJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListInputsAddJobsRequest): Buffer =>
      Buffer.from(ListInputsAddJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListInputsAddJobsRequest => ListInputsAddJobsRequest.decode(value),
    responseSerialize: (value: MultiInputsAddJobResponse): Buffer =>
      Buffer.from(MultiInputsAddJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputsAddJobResponse => MultiInputsAddJobResponse.decode(value),
  },
  /** Get the input add job details by ID */
  getInputsAddJob: {
    path: "/clarifai.api.V2/GetInputsAddJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInputsAddJobRequest): Buffer =>
      Buffer.from(GetInputsAddJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInputsAddJobRequest => GetInputsAddJobRequest.decode(value),
    responseSerialize: (value: SingleInputsAddJobResponse): Buffer =>
      Buffer.from(SingleInputsAddJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInputsAddJobResponse => SingleInputsAddJobResponse.decode(value),
  },
  /** cancel the input add job by ID */
  cancelInputsAddJob: {
    path: "/clarifai.api.V2/CancelInputsAddJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelInputsAddJobRequest): Buffer =>
      Buffer.from(CancelInputsAddJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelInputsAddJobRequest => CancelInputsAddJobRequest.decode(value),
    responseSerialize: (value: SingleInputsAddJobResponse): Buffer =>
      Buffer.from(SingleInputsAddJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInputsAddJobResponse => SingleInputsAddJobResponse.decode(value),
  },
  /**
   * PostUploads is used to upload files. Note that this does not create inputs.
   * returns job with uploadID, job has UPLOAD_IN_PROGRESS status
   * Actual upload content can be done in multiple calls with PutUploadContentParts
   * You can get status of upload with GetUpload or ListUploads endpoints
   * See also PostInputsUploads
   */
  postUploads: {
    path: "/clarifai.api.V2/PostUploads",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostUploadsRequest): Buffer => Buffer.from(PostUploadsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostUploadsRequest => PostUploadsRequest.decode(value),
    responseSerialize: (value: MultiUploadResponse): Buffer => Buffer.from(MultiUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiUploadResponse => MultiUploadResponse.decode(value),
  },
  /**
   * Upload a part of a multipart upload.
   * Behaviour on completion depends on the endpoint that was used to initiate the upload.
   */
  putUploadContentParts: {
    path: "/clarifai.api.V2/PutUploadContentParts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutUploadContentPartsRequest): Buffer =>
      Buffer.from(PutUploadContentPartsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PutUploadContentPartsRequest => PutUploadContentPartsRequest.decode(value),
    responseSerialize: (value: SingleUploadResponse): Buffer =>
      Buffer.from(SingleUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleUploadResponse => SingleUploadResponse.decode(value),
  },
  getUpload: {
    path: "/clarifai.api.V2/GetUpload",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUploadRequest): Buffer => Buffer.from(GetUploadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUploadRequest => GetUploadRequest.decode(value),
    responseSerialize: (value: SingleUploadResponse): Buffer =>
      Buffer.from(SingleUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleUploadResponse => SingleUploadResponse.decode(value),
  },
  listUploads: {
    path: "/clarifai.api.V2/ListUploads",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUploadsRequest): Buffer => Buffer.from(ListUploadsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListUploadsRequest => ListUploadsRequest.decode(value),
    responseSerialize: (value: MultiUploadResponse): Buffer => Buffer.from(MultiUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiUploadResponse => MultiUploadResponse.decode(value),
  },
  deleteUploads: {
    path: "/clarifai.api.V2/DeleteUploads",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteUploadsRequest): Buffer => Buffer.from(DeleteUploadsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteUploadsRequest => DeleteUploadsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * Initiates retrieval of inputs from cloud storage from a user provided data source.
   * Will create and return an inputs-add-job for tracking progress.
   * Archives will be extracted and their contents will be processed as inputs.
   *
   * The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
   * files in the images_folder beginning with abc or in a subfolder beginning with abc.
   * For example:
   * bucket/images_folder/abcImage.png
   * bucket/images_folder/abc-1/Data.zip
   *
   * If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
   * Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
   * in which case it only requires rights to access that particular file.
   */
  postInputsDataSources: {
    path: "/clarifai.api.V2/PostInputsDataSources",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInputsDataSourcesRequest): Buffer =>
      Buffer.from(PostInputsDataSourcesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInputsDataSourcesRequest => PostInputsDataSourcesRequest.decode(value),
    responseSerialize: (value: MultiInputsAddJobResponse): Buffer =>
      Buffer.from(MultiInputsAddJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputsAddJobResponse => MultiInputsAddJobResponse.decode(value),
  },
  /** Get the input extraction job details by ID */
  getInputsExtractionJob: {
    path: "/clarifai.api.V2/GetInputsExtractionJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetInputsExtractionJobRequest): Buffer =>
      Buffer.from(GetInputsExtractionJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetInputsExtractionJobRequest => GetInputsExtractionJobRequest.decode(value),
    responseSerialize: (value: SingleInputsExtractionJobResponse): Buffer =>
      Buffer.from(SingleInputsExtractionJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleInputsExtractionJobResponse =>
      SingleInputsExtractionJobResponse.decode(value),
  },
  /** List all the input extraction jobs */
  listInputsExtractionJobs: {
    path: "/clarifai.api.V2/ListInputsExtractionJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListInputsExtractionJobsRequest): Buffer =>
      Buffer.from(ListInputsExtractionJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListInputsExtractionJobsRequest =>
      ListInputsExtractionJobsRequest.decode(value),
    responseSerialize: (value: MultiInputsExtractionJobResponse): Buffer =>
      Buffer.from(MultiInputsExtractionJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputsExtractionJobResponse =>
      MultiInputsExtractionJobResponse.decode(value),
  },
  cancelInputsExtractionJobs: {
    path: "/clarifai.api.V2/CancelInputsExtractionJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelInputsExtractionJobsRequest): Buffer =>
      Buffer.from(CancelInputsExtractionJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelInputsExtractionJobsRequest =>
      CancelInputsExtractionJobsRequest.decode(value),
    responseSerialize: (value: MultiInputsExtractionJobResponse): Buffer =>
      Buffer.from(MultiInputsExtractionJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputsExtractionJobResponse =>
      MultiInputsExtractionJobResponse.decode(value),
  },
  /**
   * Create new upload job with a file archive containing inputs (images, videos, text, audio)
   * Actual file upload happens in next steps by calling `PutUploadContentParts` endpoint
   * and providing the file content in the request body.
   * This endpoint creates and return an inputs-add-job which contains an upload id needed for upload and further status tracking
   * Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
   * See also GetInputsAddJob and then GetInputsExtractionJob
   */
  postInputsUploads: {
    path: "/clarifai.api.V2/PostInputsUploads",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostInputsUploadsRequest): Buffer =>
      Buffer.from(PostInputsUploadsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostInputsUploadsRequest => PostInputsUploadsRequest.decode(value),
    responseSerialize: (value: MultiInputsAddJobResponse): Buffer =>
      Buffer.from(MultiInputsAddJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInputsAddJobResponse => MultiInputsAddJobResponse.decode(value),
  },
  /** putting above the Get Nodepool endpoint to make it appear above the other one */
  listPipelineVersionRuns: {
    path: "/clarifai.api.V2/ListPipelineVersionRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelineVersionRunsRequest): Buffer =>
      Buffer.from(ListPipelineVersionRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPipelineVersionRunsRequest => ListPipelineVersionRunsRequest.decode(value),
    responseSerialize: (value: MultiPipelineVersionRunResponse): Buffer =>
      Buffer.from(MultiPipelineVersionRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineVersionRunResponse =>
      MultiPipelineVersionRunResponse.decode(value),
  },
  /**
   * Get a specific runner.
   * TODO(zeiler): runner_id is a UUID so can list globally as well.
   */
  getRunner: {
    path: "/clarifai.api.V2/GetRunner",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRunnerRequest): Buffer => Buffer.from(GetRunnerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRunnerRequest => GetRunnerRequest.decode(value),
    responseSerialize: (value: SingleRunnerResponse): Buffer =>
      Buffer.from(SingleRunnerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleRunnerResponse => SingleRunnerResponse.decode(value),
  },
  /** List all the runners for the user. */
  listRunners: {
    path: "/clarifai.api.V2/ListRunners",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunnersRequest): Buffer => Buffer.from(ListRunnersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunnersRequest => ListRunnersRequest.decode(value),
    responseSerialize: (value: MultiRunnerResponse): Buffer => Buffer.from(MultiRunnerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerResponse => MultiRunnerResponse.decode(value),
  },
  /** Add a runners to a user. */
  postRunners: {
    path: "/clarifai.api.V2/PostRunners",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostRunnersRequest): Buffer => Buffer.from(PostRunnersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostRunnersRequest => PostRunnersRequest.decode(value),
    responseSerialize: (value: MultiRunnerResponse): Buffer => Buffer.from(MultiRunnerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerResponse => MultiRunnerResponse.decode(value),
  },
  /** Patch runners of a user. */
  patchRunners: {
    path: "/clarifai.api.V2/PatchRunners",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchRunnersRequest): Buffer => Buffer.from(PatchRunnersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchRunnersRequest => PatchRunnersRequest.decode(value),
    responseSerialize: (value: MultiRunnerResponse): Buffer => Buffer.from(MultiRunnerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerResponse => MultiRunnerResponse.decode(value),
  },
  /** Delete multiple runners in one request. */
  deleteRunners: {
    path: "/clarifai.api.V2/DeleteRunners",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRunnersRequest): Buffer => Buffer.from(DeleteRunnersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRunnersRequest => DeleteRunnersRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /**
   * List items for the remote runner to work on.
   * since the runner_id is a UUID we can access it directly too.
   */
  listRunnerItems: {
    path: "/clarifai.api.V2/ListRunnerItems",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunnerItemsRequest): Buffer =>
      Buffer.from(ListRunnerItemsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunnerItemsRequest => ListRunnerItemsRequest.decode(value),
    responseSerialize: (value: MultiRunnerItemResponse): Buffer =>
      Buffer.from(MultiRunnerItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerItemResponse => MultiRunnerItemResponse.decode(value),
  },
  /**
   * Post back outputs from remote runners
   * since the runner_id is a UUID we can access it directly too.
   */
  postRunnerItemOutputs: {
    path: "/clarifai.api.V2/PostRunnerItemOutputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostRunnerItemOutputsRequest): Buffer =>
      Buffer.from(PostRunnerItemOutputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostRunnerItemOutputsRequest => PostRunnerItemOutputsRequest.decode(value),
    responseSerialize: (value: MultiRunnerItemOutputResponse): Buffer =>
      Buffer.from(MultiRunnerItemOutputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerItemOutputResponse => MultiRunnerItemOutputResponse.decode(value),
  },
  /**
   * This maintains a single request for asking the API if there is any work to be done, processing
   * it and streaming back results.
   * To do that first handshake the MultiRunnerItemOutputResponse will have RUNNER_STREAM_START
   * status filled in so that the API knows to respond with a MultiRunnerItemResponse.
   * For now there will only be one of those if the model prediction only has one request.
   * NOTE(zeiler): downside of this is you can't use HTTP REST requests to do runner work.
   */
  processRunnerItems: {
    path: "/clarifai.api.V2/ProcessRunnerItems",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: PostRunnerItemOutputsRequest): Buffer =>
      Buffer.from(PostRunnerItemOutputsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostRunnerItemOutputsRequest => PostRunnerItemOutputsRequest.decode(value),
    responseSerialize: (value: MultiRunnerItemResponse): Buffer =>
      Buffer.from(MultiRunnerItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiRunnerItemResponse => MultiRunnerItemResponse.decode(value),
  },
  /** Get the training time estimate based off train request and estimated input count. */
  postModelVersionsTrainingTimeEstimate: {
    path: "/clarifai.api.V2/PostModelVersionsTrainingTimeEstimate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostModelVersionsTrainingTimeEstimateRequest): Buffer =>
      Buffer.from(PostModelVersionsTrainingTimeEstimateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostModelVersionsTrainingTimeEstimateRequest =>
      PostModelVersionsTrainingTimeEstimateRequest.decode(value),
    responseSerialize: (value: MultiTrainingTimeEstimateResponse): Buffer =>
      Buffer.from(MultiTrainingTimeEstimateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiTrainingTimeEstimateResponse =>
      MultiTrainingTimeEstimateResponse.decode(value),
  },
  /** List Available Cloud Providers */
  listCloudProviders: {
    path: "/clarifai.api.V2/ListCloudProviders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCloudProvidersRequest): Buffer =>
      Buffer.from(ListCloudProvidersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCloudProvidersRequest => ListCloudProvidersRequest.decode(value),
    responseSerialize: (value: MultiCloudProviderResponse): Buffer =>
      Buffer.from(MultiCloudProviderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCloudProviderResponse => MultiCloudProviderResponse.decode(value),
  },
  /** List Regions for given Cloud Provider */
  listCloudRegions: {
    path: "/clarifai.api.V2/ListCloudRegions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCloudRegionsRequest): Buffer =>
      Buffer.from(ListCloudRegionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCloudRegionsRequest => ListCloudRegionsRequest.decode(value),
    responseSerialize: (value: MultiCloudRegionResponse): Buffer =>
      Buffer.from(MultiCloudRegionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiCloudRegionResponse => MultiCloudRegionResponse.decode(value),
  },
  /** Get InstanceTypes given Cloud Provider and Region */
  listInstanceTypes: {
    path: "/clarifai.api.V2/ListInstanceTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListInstanceTypesRequest): Buffer =>
      Buffer.from(ListInstanceTypesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListInstanceTypesRequest => ListInstanceTypesRequest.decode(value),
    responseSerialize: (value: MultiInstanceTypeResponse): Buffer =>
      Buffer.from(MultiInstanceTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiInstanceTypeResponse => MultiInstanceTypeResponse.decode(value),
  },
  /** ComputeCluster CRUD */
  getComputeCluster: {
    path: "/clarifai.api.V2/GetComputeCluster",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetComputeClusterRequest): Buffer =>
      Buffer.from(GetComputeClusterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetComputeClusterRequest => GetComputeClusterRequest.decode(value),
    responseSerialize: (value: SingleComputeClusterResponse): Buffer =>
      Buffer.from(SingleComputeClusterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleComputeClusterResponse => SingleComputeClusterResponse.decode(value),
  },
  listComputeClusters: {
    path: "/clarifai.api.V2/ListComputeClusters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListComputeClustersRequest): Buffer =>
      Buffer.from(ListComputeClustersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListComputeClustersRequest => ListComputeClustersRequest.decode(value),
    responseSerialize: (value: MultiComputeClusterResponse): Buffer =>
      Buffer.from(MultiComputeClusterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiComputeClusterResponse => MultiComputeClusterResponse.decode(value),
  },
  postComputeClusters: {
    path: "/clarifai.api.V2/PostComputeClusters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostComputeClustersRequest): Buffer =>
      Buffer.from(PostComputeClustersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostComputeClustersRequest => PostComputeClustersRequest.decode(value),
    responseSerialize: (value: MultiComputeClusterResponse): Buffer =>
      Buffer.from(MultiComputeClusterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiComputeClusterResponse => MultiComputeClusterResponse.decode(value),
  },
  /** Delete multiple compute_clusters in one request. */
  deleteComputeClusters: {
    path: "/clarifai.api.V2/DeleteComputeClusters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteComputeClustersRequest): Buffer =>
      Buffer.from(DeleteComputeClustersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteComputeClustersRequest => DeleteComputeClustersRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Nodepools CRUD */
  getNodepool: {
    path: "/clarifai.api.V2/GetNodepool",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNodepoolRequest): Buffer => Buffer.from(GetNodepoolRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNodepoolRequest => GetNodepoolRequest.decode(value),
    responseSerialize: (value: SingleNodepoolResponse): Buffer =>
      Buffer.from(SingleNodepoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleNodepoolResponse => SingleNodepoolResponse.decode(value),
  },
  listNodepools: {
    path: "/clarifai.api.V2/ListNodepools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListNodepoolsRequest): Buffer => Buffer.from(ListNodepoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListNodepoolsRequest => ListNodepoolsRequest.decode(value),
    responseSerialize: (value: MultiNodepoolResponse): Buffer =>
      Buffer.from(MultiNodepoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiNodepoolResponse => MultiNodepoolResponse.decode(value),
  },
  postNodepools: {
    path: "/clarifai.api.V2/PostNodepools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostNodepoolsRequest): Buffer => Buffer.from(PostNodepoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostNodepoolsRequest => PostNodepoolsRequest.decode(value),
    responseSerialize: (value: MultiNodepoolResponse): Buffer =>
      Buffer.from(MultiNodepoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiNodepoolResponse => MultiNodepoolResponse.decode(value),
  },
  patchNodepools: {
    path: "/clarifai.api.V2/PatchNodepools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchNodepoolsRequest): Buffer =>
      Buffer.from(PatchNodepoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchNodepoolsRequest => PatchNodepoolsRequest.decode(value),
    responseSerialize: (value: MultiNodepoolResponse): Buffer =>
      Buffer.from(MultiNodepoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiNodepoolResponse => MultiNodepoolResponse.decode(value),
  },
  /** Delete multiple nodepools in one request. */
  deleteNodepools: {
    path: "/clarifai.api.V2/DeleteNodepools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteNodepoolsRequest): Buffer =>
      Buffer.from(DeleteNodepoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteNodepoolsRequest => DeleteNodepoolsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  /** Deployments CRUD */
  getDeployment: {
    path: "/clarifai.api.V2/GetDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDeploymentRequest): Buffer => Buffer.from(GetDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDeploymentRequest => GetDeploymentRequest.decode(value),
    responseSerialize: (value: SingleDeploymentResponse): Buffer =>
      Buffer.from(SingleDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleDeploymentResponse => SingleDeploymentResponse.decode(value),
  },
  listDeployments: {
    path: "/clarifai.api.V2/ListDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDeploymentsRequest): Buffer =>
      Buffer.from(ListDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListDeploymentsRequest => ListDeploymentsRequest.decode(value),
    responseSerialize: (value: MultiDeploymentResponse): Buffer =>
      Buffer.from(MultiDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDeploymentResponse => MultiDeploymentResponse.decode(value),
  },
  postDeployments: {
    path: "/clarifai.api.V2/PostDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostDeploymentsRequest): Buffer =>
      Buffer.from(PostDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostDeploymentsRequest => PostDeploymentsRequest.decode(value),
    responseSerialize: (value: MultiDeploymentResponse): Buffer =>
      Buffer.from(MultiDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDeploymentResponse => MultiDeploymentResponse.decode(value),
  },
  patchDeployments: {
    path: "/clarifai.api.V2/PatchDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchDeploymentsRequest): Buffer =>
      Buffer.from(PatchDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchDeploymentsRequest => PatchDeploymentsRequest.decode(value),
    responseSerialize: (value: MultiDeploymentResponse): Buffer =>
      Buffer.from(MultiDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiDeploymentResponse => MultiDeploymentResponse.decode(value),
  },
  /** Delete multiple deployments in one request. */
  deleteDeployments: {
    path: "/clarifai.api.V2/DeleteDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDeploymentsRequest): Buffer =>
      Buffer.from(DeleteDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteDeploymentsRequest => DeleteDeploymentsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  postAuditLogSearches: {
    path: "/clarifai.api.V2/PostAuditLogSearches",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostAuditLogSearchesRequest): Buffer =>
      Buffer.from(PostAuditLogSearchesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostAuditLogSearchesRequest => PostAuditLogSearchesRequest.decode(value),
    responseSerialize: (value: MultiAuditLogEntryResponse): Buffer =>
      Buffer.from(MultiAuditLogEntryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiAuditLogEntryResponse => MultiAuditLogEntryResponse.decode(value),
  },
  listWorkflowEvaluationTemplates: {
    path: "/clarifai.api.V2/ListWorkflowEvaluationTemplates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkflowEvaluationTemplatesRequest): Buffer =>
      Buffer.from(ListWorkflowEvaluationTemplatesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkflowEvaluationTemplatesRequest =>
      ListWorkflowEvaluationTemplatesRequest.decode(value),
    responseSerialize: (value: MultiWorkflowEvaluationTemplateResponse): Buffer =>
      Buffer.from(MultiWorkflowEvaluationTemplateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowEvaluationTemplateResponse =>
      MultiWorkflowEvaluationTemplateResponse.decode(value),
  },
  postLogEntries: {
    path: "/clarifai.api.V2/PostLogEntries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostLogEntriesRequest): Buffer =>
      Buffer.from(PostLogEntriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostLogEntriesRequest => PostLogEntriesRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  listLogEntries: {
    path: "/clarifai.api.V2/ListLogEntries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListLogEntriesRequest): Buffer =>
      Buffer.from(ListLogEntriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListLogEntriesRequest => ListLogEntriesRequest.decode(value),
    responseSerialize: (value: MultiLogEntryResponse): Buffer =>
      Buffer.from(MultiLogEntryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiLogEntryResponse => MultiLogEntryResponse.decode(value),
  },
  streamLogEntries: {
    path: "/clarifai.api.V2/StreamLogEntries",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: StreamLogEntriesRequest): Buffer =>
      Buffer.from(StreamLogEntriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StreamLogEntriesRequest => StreamLogEntriesRequest.decode(value),
    responseSerialize: (value: MultiLogEntryResponse): Buffer =>
      Buffer.from(MultiLogEntryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiLogEntryResponse => MultiLogEntryResponse.decode(value),
  },
  postComputePlaneMetrics: {
    path: "/clarifai.api.V2/PostComputePlaneMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostComputePlaneMetricsRequest): Buffer =>
      Buffer.from(PostComputePlaneMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostComputePlaneMetricsRequest => PostComputePlaneMetricsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  postWorkflowVersionEvaluations: {
    path: "/clarifai.api.V2/PostWorkflowVersionEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowVersionEvaluationsRequest): Buffer =>
      Buffer.from(PostWorkflowVersionEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowVersionEvaluationsRequest =>
      PostWorkflowVersionEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowVersionEvaluationResponse): Buffer =>
      Buffer.from(MultiWorkflowVersionEvaluationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowVersionEvaluationResponse =>
      MultiWorkflowVersionEvaluationResponse.decode(value),
  },
  getWorkflowVersionEvaluation: {
    path: "/clarifai.api.V2/GetWorkflowVersionEvaluation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWorkflowVersionEvaluationRequest): Buffer =>
      Buffer.from(GetWorkflowVersionEvaluationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetWorkflowVersionEvaluationRequest =>
      GetWorkflowVersionEvaluationRequest.decode(value),
    responseSerialize: (value: SingleWorkflowVersionEvaluationResponse): Buffer =>
      Buffer.from(SingleWorkflowVersionEvaluationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleWorkflowVersionEvaluationResponse =>
      SingleWorkflowVersionEvaluationResponse.decode(value),
  },
  listWorkflowVersionEvaluations: {
    path: "/clarifai.api.V2/ListWorkflowVersionEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkflowVersionEvaluationsRequest): Buffer =>
      Buffer.from(ListWorkflowVersionEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkflowVersionEvaluationsRequest =>
      ListWorkflowVersionEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowVersionEvaluationResponse): Buffer =>
      Buffer.from(MultiWorkflowVersionEvaluationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowVersionEvaluationResponse =>
      MultiWorkflowVersionEvaluationResponse.decode(value),
  },
  patchWorkflowVersionEvaluations: {
    path: "/clarifai.api.V2/PatchWorkflowVersionEvaluations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchWorkflowVersionEvaluationsRequest): Buffer =>
      Buffer.from(PatchWorkflowVersionEvaluationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchWorkflowVersionEvaluationsRequest =>
      PatchWorkflowVersionEvaluationsRequest.decode(value),
    responseSerialize: (value: MultiWorkflowVersionEvaluationResponse): Buffer =>
      Buffer.from(MultiWorkflowVersionEvaluationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiWorkflowVersionEvaluationResponse =>
      MultiWorkflowVersionEvaluationResponse.decode(value),
  },
  listWorkflowVersionEvaluationData: {
    path: "/clarifai.api.V2/ListWorkflowVersionEvaluationData",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkflowVersionEvaluationDataRequest): Buffer =>
      Buffer.from(ListWorkflowVersionEvaluationDataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkflowVersionEvaluationDataRequest =>
      ListWorkflowVersionEvaluationDataRequest.decode(value),
    responseSerialize: (value: MultiListWorkflowVersionEvaluationDataResponse): Buffer =>
      Buffer.from(MultiListWorkflowVersionEvaluationDataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiListWorkflowVersionEvaluationDataResponse =>
      MultiListWorkflowVersionEvaluationDataResponse.decode(value),
  },
  postWorkflowVersionEvaluationData: {
    path: "/clarifai.api.V2/PostWorkflowVersionEvaluationData",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostWorkflowVersionEvaluationDataRequest): Buffer =>
      Buffer.from(PostWorkflowVersionEvaluationDataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostWorkflowVersionEvaluationDataRequest =>
      PostWorkflowVersionEvaluationDataRequest.decode(value),
    responseSerialize: (value: MultiListWorkflowVersionEvaluationDataResponse): Buffer =>
      Buffer.from(MultiListWorkflowVersionEvaluationDataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiListWorkflowVersionEvaluationDataResponse =>
      MultiListWorkflowVersionEvaluationDataResponse.decode(value),
  },
  postPipelines: {
    path: "/clarifai.api.V2/PostPipelines",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostPipelinesRequest): Buffer => Buffer.from(PostPipelinesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostPipelinesRequest => PostPipelinesRequest.decode(value),
    responseSerialize: (value: MultiPipelineResponse): Buffer =>
      Buffer.from(MultiPipelineResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineResponse => MultiPipelineResponse.decode(value),
  },
  getPipeline: {
    path: "/clarifai.api.V2/GetPipeline",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineRequest): Buffer => Buffer.from(GetPipelineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPipelineRequest => GetPipelineRequest.decode(value),
    responseSerialize: (value: SinglePipelineResponse): Buffer =>
      Buffer.from(SinglePipelineResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePipelineResponse => SinglePipelineResponse.decode(value),
  },
  listPipelines: {
    path: "/clarifai.api.V2/ListPipelines",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelinesRequest): Buffer => Buffer.from(ListPipelinesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPipelinesRequest => ListPipelinesRequest.decode(value),
    responseSerialize: (value: MultiPipelineResponse): Buffer =>
      Buffer.from(MultiPipelineResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineResponse => MultiPipelineResponse.decode(value),
  },
  patchPipelines: {
    path: "/clarifai.api.V2/PatchPipelines",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchPipelinesRequest): Buffer =>
      Buffer.from(PatchPipelinesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchPipelinesRequest => PatchPipelinesRequest.decode(value),
    responseSerialize: (value: MultiPipelineResponse): Buffer =>
      Buffer.from(MultiPipelineResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineResponse => MultiPipelineResponse.decode(value),
  },
  deletePipelines: {
    path: "/clarifai.api.V2/DeletePipelines",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePipelinesRequest): Buffer =>
      Buffer.from(DeletePipelinesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePipelinesRequest => DeletePipelinesRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  getPipelineVersion: {
    path: "/clarifai.api.V2/GetPipelineVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineVersionRequest): Buffer =>
      Buffer.from(GetPipelineVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPipelineVersionRequest => GetPipelineVersionRequest.decode(value),
    responseSerialize: (value: SinglePipelineVersionResponse): Buffer =>
      Buffer.from(SinglePipelineVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePipelineVersionResponse => SinglePipelineVersionResponse.decode(value),
  },
  listPipelineVersions: {
    path: "/clarifai.api.V2/ListPipelineVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelineVersionsRequest): Buffer =>
      Buffer.from(ListPipelineVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPipelineVersionsRequest => ListPipelineVersionsRequest.decode(value),
    responseSerialize: (value: MultiPipelineVersionResponse): Buffer =>
      Buffer.from(MultiPipelineVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineVersionResponse => MultiPipelineVersionResponse.decode(value),
  },
  patchPipelineVersions: {
    path: "/clarifai.api.V2/PatchPipelineVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchPipelineVersionsRequest): Buffer =>
      Buffer.from(PatchPipelineVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchPipelineVersionsRequest => PatchPipelineVersionsRequest.decode(value),
    responseSerialize: (value: MultiPipelineVersionResponse): Buffer =>
      Buffer.from(MultiPipelineVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineVersionResponse => MultiPipelineVersionResponse.decode(value),
  },
  deletePipelineVersions: {
    path: "/clarifai.api.V2/DeletePipelineVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePipelineVersionsRequest): Buffer =>
      Buffer.from(DeletePipelineVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePipelineVersionsRequest => DeletePipelineVersionsRequest.decode(value),
    responseSerialize: (value: BaseResponse): Buffer => Buffer.from(BaseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaseResponse => BaseResponse.decode(value),
  },
  getPipelineVersionRun: {
    path: "/clarifai.api.V2/GetPipelineVersionRun",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineVersionRunRequest): Buffer =>
      Buffer.from(GetPipelineVersionRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPipelineVersionRunRequest => GetPipelineVersionRunRequest.decode(value),
    responseSerialize: (value: SinglePipelineVersionRunResponse): Buffer =>
      Buffer.from(SinglePipelineVersionRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePipelineVersionRunResponse =>
      SinglePipelineVersionRunResponse.decode(value),
  },
  postPipelineVersionRuns: {
    path: "/clarifai.api.V2/PostPipelineVersionRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostPipelineVersionRunsRequest): Buffer =>
      Buffer.from(PostPipelineVersionRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostPipelineVersionRunsRequest => PostPipelineVersionRunsRequest.decode(value),
    responseSerialize: (value: MultiPipelineVersionRunResponse): Buffer =>
      Buffer.from(MultiPipelineVersionRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineVersionRunResponse =>
      MultiPipelineVersionRunResponse.decode(value),
  },
  patchPipelineVersionRuns: {
    path: "/clarifai.api.V2/PatchPipelineVersionRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchPipelineVersionRunsRequest): Buffer =>
      Buffer.from(PatchPipelineVersionRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchPipelineVersionRunsRequest =>
      PatchPipelineVersionRunsRequest.decode(value),
    responseSerialize: (value: MultiPipelineVersionRunResponse): Buffer =>
      Buffer.from(MultiPipelineVersionRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineVersionRunResponse =>
      MultiPipelineVersionRunResponse.decode(value),
  },
  postPipelineSteps: {
    path: "/clarifai.api.V2/PostPipelineSteps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostPipelineStepsRequest): Buffer =>
      Buffer.from(PostPipelineStepsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostPipelineStepsRequest => PostPipelineStepsRequest.decode(value),
    responseSerialize: (value: MultiPipelineStepResponse): Buffer =>
      Buffer.from(MultiPipelineStepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineStepResponse => MultiPipelineStepResponse.decode(value),
  },
  getPipelineStep: {
    path: "/clarifai.api.V2/GetPipelineStep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineStepRequest): Buffer =>
      Buffer.from(GetPipelineStepRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPipelineStepRequest => GetPipelineStepRequest.decode(value),
    responseSerialize: (value: SinglePipelineStepResponse): Buffer =>
      Buffer.from(SinglePipelineStepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePipelineStepResponse => SinglePipelineStepResponse.decode(value),
  },
  listPipelineSteps: {
    path: "/clarifai.api.V2/ListPipelineSteps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelineStepsRequest): Buffer =>
      Buffer.from(ListPipelineStepsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPipelineStepsRequest => ListPipelineStepsRequest.decode(value),
    responseSerialize: (value: MultiPipelineStepResponse): Buffer =>
      Buffer.from(MultiPipelineStepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineStepResponse => MultiPipelineStepResponse.decode(value),
  },
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the pipeline_step_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the pipeline_step_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the pipeline_step_version_id specified for your pipeline_step_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the pipeline_step_bytes.
   */
  postPipelineStepVersionsUpload: {
    path: "/clarifai.api.V2/PostPipelineStepVersionsUpload",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: PostPipelineStepVersionsUploadRequest): Buffer =>
      Buffer.from(PostPipelineStepVersionsUploadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostPipelineStepVersionsUploadRequest =>
      PostPipelineStepVersionsUploadRequest.decode(value),
    responseSerialize: (value: PostPipelineStepVersionsUploadResponse): Buffer =>
      Buffer.from(PostPipelineStepVersionsUploadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PostPipelineStepVersionsUploadResponse =>
      PostPipelineStepVersionsUploadResponse.decode(value),
  },
  listPipelineStepVersions: {
    path: "/clarifai.api.V2/ListPipelineStepVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPipelineStepVersionsRequest): Buffer =>
      Buffer.from(ListPipelineStepVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPipelineStepVersionsRequest =>
      ListPipelineStepVersionsRequest.decode(value),
    responseSerialize: (value: MultiPipelineStepVersionResponse): Buffer =>
      Buffer.from(MultiPipelineStepVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiPipelineStepVersionResponse =>
      MultiPipelineStepVersionResponse.decode(value),
  },
  getPipelineStepVersion: {
    path: "/clarifai.api.V2/GetPipelineStepVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPipelineStepVersionRequest): Buffer =>
      Buffer.from(GetPipelineStepVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPipelineStepVersionRequest => GetPipelineStepVersionRequest.decode(value),
    responseSerialize: (value: SinglePipelineStepVersionResponse): Buffer =>
      Buffer.from(SinglePipelineStepVersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SinglePipelineStepVersionResponse =>
      SinglePipelineStepVersionResponse.decode(value),
  },
  getSecret: {
    path: "/clarifai.api.V2/GetSecret",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSecretRequest): Buffer => Buffer.from(GetSecretRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSecretRequest => GetSecretRequest.decode(value),
    responseSerialize: (value: SingleSecretResponse): Buffer =>
      Buffer.from(SingleSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SingleSecretResponse => SingleSecretResponse.decode(value),
  },
  listSecrets: {
    path: "/clarifai.api.V2/ListSecrets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSecretsRequest): Buffer => Buffer.from(ListSecretsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSecretsRequest => ListSecretsRequest.decode(value),
    responseSerialize: (value: MultiSecretResponse): Buffer => Buffer.from(MultiSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSecretResponse => MultiSecretResponse.decode(value),
  },
  postSecrets: {
    path: "/clarifai.api.V2/PostSecrets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PostSecretsRequest): Buffer => Buffer.from(PostSecretsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PostSecretsRequest => PostSecretsRequest.decode(value),
    responseSerialize: (value: MultiSecretResponse): Buffer => Buffer.from(MultiSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSecretResponse => MultiSecretResponse.decode(value),
  },
  patchSecrets: {
    path: "/clarifai.api.V2/PatchSecrets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PatchSecretsRequest): Buffer => Buffer.from(PatchSecretsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PatchSecretsRequest => PatchSecretsRequest.decode(value),
    responseSerialize: (value: MultiSecretResponse): Buffer => Buffer.from(MultiSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSecretResponse => MultiSecretResponse.decode(value),
  },
  deleteSecrets: {
    path: "/clarifai.api.V2/DeleteSecrets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteSecretsRequest): Buffer => Buffer.from(DeleteSecretsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteSecretsRequest => DeleteSecretsRequest.decode(value),
    responseSerialize: (value: MultiSecretResponse): Buffer => Buffer.from(MultiSecretResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSecretResponse => MultiSecretResponse.decode(value),
  },
} as const;

export interface V2Server extends UntypedServiceImplementation {
  /**
   * List concept relations between concepts in the platform.
   * MUST be above ListConcepts so that if concept_id is empty this will still match
   * /concepts/relations to list all the concept relations in the app.
   */
  listConceptRelations: handleUnaryCall<ListConceptRelationsRequest, MultiConceptRelationResponse>;
  /** Post concept relations to create relations between concepts in the platform. */
  postConceptRelations: handleUnaryCall<PostConceptRelationsRequest, MultiConceptRelationResponse>;
  /** Post concept relations to create relations between concepts in the platform. */
  deleteConceptRelations: handleUnaryCall<DeleteConceptRelationsRequest, BaseResponse>;
  /** List all the concepts with their positive and negative counts */
  getConceptCounts: handleUnaryCall<GetConceptCountsRequest, MultiConceptCountResponse>;
  /** Get a specific concept from an app. */
  getConcept: handleUnaryCall<GetConceptRequest, SingleConceptResponse>;
  /** List all the concepts. */
  listConcepts: handleUnaryCall<ListConceptsRequest, MultiConceptResponse>;
  /** List models concepts. */
  listModelConcepts: handleUnaryCall<ListModelConceptsRequest, MultiConceptResponse>;
  /**
   * Search over the concepts to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postConceptsSearches: handleUnaryCall<PostConceptsSearchesRequest, MultiConceptResponse>;
  /** Add a concept to an app. */
  postConcepts: handleUnaryCall<PostConceptsRequest, MultiConceptResponse>;
  /** Patch one or more concepts. */
  patchConcepts: handleUnaryCall<PatchConceptsRequest, MultiConceptResponse>;
  /** Get a specific concept from an app. */
  getConceptLanguage: handleUnaryCall<GetConceptLanguageRequest, SingleConceptLanguageResponse>;
  /** List the concept in all the translated languages. */
  listConceptLanguages: handleUnaryCall<ListConceptLanguagesRequest, MultiConceptLanguageResponse>;
  /** Add a new translation for this concept. */
  postConceptLanguages: handleUnaryCall<PostConceptLanguagesRequest, MultiConceptLanguageResponse>;
  /**
   * Patch the name for a given language names by passing in a list of concepts with the new names
   * for the languages.
   */
  patchConceptLanguages: handleUnaryCall<PatchConceptLanguagesRequest, MultiConceptLanguageResponse>;
  /** List all domain graphs. */
  listKnowledgeGraphs: handleUnaryCall<ListKnowledgeGraphsRequest, MultiKnowledgeGraphResponse>;
  /** Post domain graphs. */
  postKnowledgeGraphs: handleUnaryCall<PostKnowledgeGraphsRequest, MultiKnowledgeGraphResponse>;
  /** Get a specific annotation from an app. */
  getAnnotation: handleUnaryCall<GetAnnotationRequest, SingleAnnotationResponse>;
  /** List all the annotation. */
  listAnnotations: handleUnaryCall<ListAnnotationsRequest, MultiAnnotationResponse>;
  /** Post annotations. */
  postAnnotations: handleUnaryCall<PostAnnotationsRequest, MultiAnnotationResponse>;
  /** Patch one or more annotations. */
  patchAnnotations: handleUnaryCall<PatchAnnotationsRequest, MultiAnnotationResponse>;
  /**
   * Patch annotations status by worker id and task id.
   * Deprecated: Use PutTaskAssignments to update task annotations.
   *   For example, you can use PutTaskAssignments with action REVIEW_APPROVE
   *   to approve task assignments and associated annotations in bulk.
   */
  patchAnnotationsStatus: handleUnaryCall<PatchAnnotationsStatusRequest, PatchAnnotationsStatusResponse>;
  /** Delete a single annotation. */
  deleteAnnotation: handleUnaryCall<DeleteAnnotationRequest, BaseResponse>;
  /** Delete multiple annotations in one request. */
  deleteAnnotations: handleUnaryCall<DeleteAnnotationsRequest, BaseResponse>;
  /** List all the annotation tracks. */
  listAnnotationTracks: handleUnaryCall<ListAnnotationTracksRequest, MultiAnnotationTrackResponse>;
  /** Post annotation tracks. */
  postAnnotationTracks: handleUnaryCall<PostAnnotationTracksRequest, MultiAnnotationTrackResponse>;
  /** Patch one or more annotation tracks. */
  patchAnnotationTracks: handleUnaryCall<PatchAnnotationTracksRequest, MultiAnnotationTrackResponse>;
  /** Delete multiple annotation tracks in one request. */
  deleteAnnotationTracks: handleUnaryCall<DeleteAnnotationTracksRequest, BaseResponse>;
  /** Patch saved annotations searches by ids. */
  patchAnnotationsSearches: handleUnaryCall<PatchAnnotationsSearchesRequest, MultiSearchResponse>;
  /** Execute a search over annotations */
  postAnnotationsSearches: handleUnaryCall<PostAnnotationsSearchesRequest, MultiSearchResponse>;
  /**
   * ListAnnotationWorkers lists users, models, and workflows (collectively
   * known as "workers") that have added annotations to the application.
   */
  listAnnotationWorkers: handleUnaryCall<ListAnnotationWorkersRequest, MultiWorkerResponse>;
  /** Get input count per status. */
  getInputCount: handleUnaryCall<GetInputCountRequest, SingleInputCountResponse>;
  /** Streams all the inputs starting from oldest assets. */
  streamInputs: handleUnaryCall<StreamInputsRequest, MultiInputResponse>;
  getInputSamples: handleUnaryCall<GetInputSamplesRequest, MultiInputAnnotationResponse>;
  /** Get a specific input from an app. */
  getInput: handleUnaryCall<GetInputRequest, SingleInputResponse>;
  /**
   * Get a MPEG-DASH manifest for video-type inputs that were added via PostInputs and successfully processed
   * Experimental. Manifest is used by browser and desktop clients that implement an efficient streaming playback
   * This means client can switch between low-resolution and high-resolution video streams
   * Depending on network bandwidth or user's preference
   * This also means that reencoded video streams are reencoded in a uniform way, not relying on original format
   * Alternative to MPEG-dash is to stream original file with byte-range header
   */
  getInputVideoManifest: handleUnaryCall<GetVideoManifestRequest, GetVideoManifestResponse>;
  /** List all the inputs. */
  listInputs: handleUnaryCall<ListInputsRequest, MultiInputResponse>;
  /**
   * PostInputs adds one or more inputs to the app.
   * Takes a list of image/video/audio/text URLs, image/video/audio bytes or raw text
   * Optionally, include concepts or dataset ids to link them
   * Optionally, include metadata for search
   * Note that inputs processing is asynchronous process
   * See ListInputs, StreamInputs or PostInputSearches to list results
   */
  postInputs: handleUnaryCall<PostInputsRequest, MultiInputResponse>;
  /** Patch one or more inputs. */
  patchInputs: handleUnaryCall<PatchInputsRequest, MultiInputResponse>;
  /** Delete a single input asynchronously. */
  deleteInput: handleUnaryCall<DeleteInputRequest, BaseResponse>;
  /**
   * Delete multiple inputs in one request.
   * This call is asynchronous.
   */
  deleteInputs: handleUnaryCall<DeleteInputsRequest, BaseResponse>;
  /** Patch saved inputs searches by ids. */
  patchInputsSearches: handleUnaryCall<PatchInputsSearchesRequest, MultiSearchResponse>;
  /** Execute a search over inputs */
  postInputsSearches: handleUnaryCall<PostInputsSearchesRequest, MultiSearchResponse>;
  /** Get predicted outputs from the model. */
  postModelOutputs: handleUnaryCall<PostModelOutputsRequest, MultiOutputResponse>;
  /**
   * TODO(zeiler): will need to
   * Single request but streaming responses.
   */
  generateModelOutputs: handleServerStreamingCall<PostModelOutputsRequest, MultiOutputResponse>;
  /** Stream of requests and stream of responses */
  streamModelOutputs: handleBidiStreamingCall<PostModelOutputsRequest, MultiOutputResponse>;
  /** List all the datasets. */
  listDatasets: handleUnaryCall<ListDatasetsRequest, MultiDatasetResponse>;
  /** Get a specific dataset. */
  getDataset: handleUnaryCall<GetDatasetRequest, SingleDatasetResponse>;
  /**
   * Add datasets to an app.
   * The process is atomic, i.e. either all or no datasets are added.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  postDatasets: handleUnaryCall<PostDatasetsRequest, MultiDatasetResponse>;
  /**
   * Patch one or more datasets.
   * The process is atomic, i.e. either all or no datasets are patched.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  patchDatasets: handleUnaryCall<PatchDatasetsRequest, MultiDatasetResponse>;
  /** Delete one or more datasets in a single request. */
  deleteDatasets: handleUnaryCall<DeleteDatasetsRequest, BaseResponse>;
  /** List all the dataset inputs in a dataset. */
  listDatasetInputs: handleUnaryCall<ListDatasetInputsRequest, MultiDatasetInputResponse>;
  /** Get a specific dataset input. */
  getDatasetInput: handleUnaryCall<GetDatasetInputRequest, SingleDatasetInputResponse>;
  /**
   * Add dataset inputs to a dataset.
   * The process is not atomic, i.e. if there are errors with some dataset
   * inputs, others might still be added. The response reports
   *   - SUCCESS if all dataset inputs were added,
   *   - MIXED_STATUS if only some dataset inputs were added, and
   *   - FAILURE if no dataset inputs were added.
   * Each individual dataset input in the response has the status set to
   * indicate if it was successful or if there was an error.
   */
  postDatasetInputs: handleUnaryCall<PostDatasetInputsRequest, MultiDatasetInputResponse>;
  /** Delete one or more dataset inputs in a single request. */
  deleteDatasetInputs: handleUnaryCall<DeleteDatasetInputsRequest, BaseResponse>;
  /** List all the dataset versions. */
  listDatasetVersions: handleUnaryCall<ListDatasetVersionsRequest, MultiDatasetVersionResponse>;
  /** Get a specific dataset version. */
  getDatasetVersion: handleUnaryCall<GetDatasetVersionRequest, SingleDatasetVersionResponse>;
  listDatasetVersionMetricsGroups: handleUnaryCall<
    ListDatasetVersionMetricsGroupsRequest,
    MultiDatasetVersionMetricsGroupResponse
  >;
  /** Add dataset versions to a dataset. */
  postDatasetVersions: handleUnaryCall<PostDatasetVersionsRequest, MultiDatasetVersionResponse>;
  /** Patch one or more dataset versions. */
  patchDatasetVersions: handleUnaryCall<PatchDatasetVersionsRequest, MultiDatasetVersionResponse>;
  /** Delete one or more dataset versions in a single request. */
  deleteDatasetVersions: handleUnaryCall<DeleteDatasetVersionsRequest, BaseResponse>;
  /** Create export of a dataset version. */
  putDatasetVersionExports: handleUnaryCall<PutDatasetVersionExportsRequest, MultiDatasetVersionExportResponse>;
  /** Get a specific model type. */
  getModelType: handleUnaryCall<GetModelTypeRequest, SingleModelTypeResponse>;
  /** List all the supported open source licenses in the platform. */
  listOpenSourceLicenses: handleUnaryCall<ListOpenSourceLicensesRequest, ListOpenSourceLicensesResponse>;
  /**
   * List all the model types available in the platform.
   * This MUST be above ListModels so that the /models/types endpoint takes precedence.
   */
  listModelTypes: handleUnaryCall<ListModelTypesRequest, MultiModelTypeResponse>;
  /** Get a specific model from an app. */
  getModel: handleUnaryCall<GetModelRequest, SingleModelResponse>;
  /**
   * Get a the output info for a given model_id or model_id/version_id
   * combo.
   */
  getModelOutputInfo: handleUnaryCall<GetModelRequest, SingleModelResponse>;
  /** List all the models. */
  listModels: handleUnaryCall<ListModelsRequest, MultiModelResponse>;
  /** List the resource counts for the app. */
  getResourceCounts: handleUnaryCall<GetResourceCountsRequest, GetResourceCountsResponse>;
  /**
   * Search over the models to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postModelsSearches: handleUnaryCall<PostModelsSearchesRequest, MultiModelResponse>;
  /** Add a models to an app. */
  postModels: handleUnaryCall<PostModelsRequest, SingleModelResponse>;
  /** Patch one or more models. */
  patchModels: handleUnaryCall<PatchModelsRequest, MultiModelResponse>;
  /** Patch one or more models ids. */
  patchModelIds: handleUnaryCall<PatchModelIdsRequest, MultiModelResponse>;
  /** Delete a single model. */
  deleteModel: handleUnaryCall<DeleteModelRequest, BaseResponse>;
  /** Delete multiple models in one request. */
  deleteModels: handleUnaryCall<DeleteModelsRequest, BaseResponse>;
  /** Update model check consents */
  patchModelCheckConsents: handleUnaryCall<PatchModelCheckConsentsRequest, MultiModelCheckConsentResponse>;
  /** Update model toolkits tags */
  patchModelToolkits: handleUnaryCall<PatchModelToolkitsRequest, MultiModelToolkitResponse>;
  /** Update model use_cases tags */
  patchModelUseCases: handleUnaryCall<PatchModelUseCasesRequest, MultiModelUseCaseResponse>;
  /** Update model languages tags */
  patchModelLanguages: handleUnaryCall<PatchModelLanguagesRequest, MultiModelLanguageResponse>;
  /**
   * Deprecated: Unmaintained and ideally replaced with usage of datasets
   *   The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  listModelInputs: handleUnaryCall<ListModelInputsRequest, MultiInputResponse>;
  /** Get a specific model from an app. */
  getModelVersion: handleUnaryCall<GetModelVersionRequest, SingleModelVersionResponse>;
  /** List all the models. */
  listModelVersions: handleUnaryCall<ListModelVersionsRequest, MultiModelVersionResponse>;
  postWorkflowVersionsUnPublish: handleUnaryCall<PostWorkflowVersionsUnPublishRequest, BaseResponse>;
  postWorkflowVersionsPublish: handleUnaryCall<PostWorkflowVersionsPublishRequest, BaseResponse>;
  /** PostModelVersionsPublish */
  postModelVersionsPublish: handleUnaryCall<PostModelVersionsPublishRequest, BaseResponse>;
  /** PostModelVersionsUnPublish */
  postModelVersionsUnPublish: handleUnaryCall<PostModelVersionsUnPublishRequest, BaseResponse>;
  /** Create a new model version to trigger training of the model. */
  postModelVersions: handleUnaryCall<PostModelVersionsRequest, SingleModelResponse>;
  /** PatchModelVersions */
  patchModelVersions: handleUnaryCall<PatchModelVersionsRequest, MultiModelVersionResponse>;
  /** Delete a single model. */
  deleteModelVersion: handleUnaryCall<DeleteModelVersionRequest, BaseResponse>;
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the model_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the model_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the model_version_id specified for your model_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the model_bytes.
   */
  postModelVersionsUpload: handleBidiStreamingCall<PostModelVersionsUploadRequest, PostModelVersionsUploadResponse>;
  /** Kicks off conversion from the old Triton model format to the new Docker model format. */
  postModelMigration: handleUnaryCall<PostModelMigrationRequest, SingleModelResponse>;
  /** Export a model */
  putModelVersionExports: handleUnaryCall<PutModelVersionExportsRequest, SingleModelVersionExportResponse>;
  /** GetModelVersionExport */
  getModelVersionExport: handleUnaryCall<GetModelVersionExportRequest, SingleModelVersionExportResponse>;
  /**
   * Get the evaluation metrics for a model version.
   * Deprecated: Use GetEvaluation instead
   *   The server may refuse to accept requests to this endpoint.
   */
  getModelVersionMetrics: handleUnaryCall<GetModelVersionMetricsRequest, SingleModelVersionResponse>;
  /**
   * Deprecated, use PostEvaluations instead
   * Run the evaluation metrics for a model version.
   */
  postModelVersionMetrics: handleUnaryCall<PostModelVersionMetricsRequest, SingleModelVersionResponse>;
  /** Deprecated, use PostEvaluations instead */
  postModelVersionEvaluations: handleUnaryCall<PostModelVersionEvaluationsRequest, MultiEvalMetricsResponse>;
  /**
   * Deprecated, use GetEvaluation instead
   * List the evaluation metrics for a model version.
   */
  listModelVersionEvaluations: handleUnaryCall<ListModelVersionEvaluationsRequest, MultiEvalMetricsResponse>;
  /**
   * Deprecated, use GetEvaluation instead
   * Get an evaluation metrics for a model version.
   */
  getModelVersionEvaluation: handleUnaryCall<GetModelVersionEvaluationRequest, SingleEvalMetricsResponse>;
  postEvaluations: handleUnaryCall<PostEvaluationsRequest, MultiEvalMetricsResponse>;
  listEvaluations: handleUnaryCall<ListEvaluationsRequest, MultiEvalMetricsResponse>;
  getEvaluation: handleUnaryCall<GetEvaluationRequest, SingleEvalMetricsResponse>;
  /** Lists model references tied to a particular model id. */
  listModelReferences: handleUnaryCall<ListModelReferencesRequest, MultiModelReferenceResponse>;
  /** GetModelVersionInputExample */
  getModelVersionInputExample: handleUnaryCall<
    GetModelVersionInputExampleRequest,
    SingleModelVersionInputExampleResponse
  >;
  /** ListModelVersionInputExamples */
  listModelVersionInputExamples: handleUnaryCall<
    ListModelVersionInputExamplesRequest,
    MultiModelVersionInputExampleResponse
  >;
  /** Get a specific workflow from an app. */
  getWorkflow: handleUnaryCall<GetWorkflowRequest, SingleWorkflowResponse>;
  /** List all the workflows. */
  listWorkflows: handleUnaryCall<ListWorkflowsRequest, MultiWorkflowResponse>;
  /**
   * Add a workflow to an app.
   * Note(zeiler): the order of the workflows that are returned from this endpoint
   * may be different than the order in which the user provides them. This is because
   * we reorder by a sort that optimizes for performance of the graph and its dependencies.
   * When using the workflow in any future call the order returned by this endpoint
   * will be used.
   */
  postWorkflows: handleUnaryCall<PostWorkflowsRequest, MultiWorkflowResponse>;
  /** Patch one or more workflows. */
  patchWorkflows: handleUnaryCall<PatchWorkflowsRequest, MultiWorkflowResponse>;
  /** Patch one or more workflows ids. */
  patchWorkflowIds: handleUnaryCall<PatchWorkflowIdsRequest, MultiWorkflowResponse>;
  /** Delete a single workflow. */
  deleteWorkflow: handleUnaryCall<DeleteWorkflowRequest, BaseResponse>;
  /** Delete multiple workflows in one request. */
  deleteWorkflows: handleUnaryCall<DeleteWorkflowsRequest, BaseResponse>;
  /** Predict using a workflow. */
  postWorkflowResults: handleUnaryCall<PostWorkflowResultsRequest, PostWorkflowResultsResponse>;
  /** List workflow versions. */
  listWorkflowVersions: handleUnaryCall<ListWorkflowVersionsRequest, MultiWorkflowVersionResponse>;
  /** Get single workflow version. */
  getWorkflowVersion: handleUnaryCall<GetWorkflowVersionRequest, SingleWorkflowVersionResponse>;
  /** Delete workflow versions. */
  deleteWorkflowVersions: handleUnaryCall<DeleteWorkflowVersionsRequest, BaseResponse>;
  /** Patch workflow versions. */
  patchWorkflowVersions: handleUnaryCall<PatchWorkflowVersionsRequest, MultiWorkflowVersionResponse>;
  /** Get a specific key from an app. */
  getKey: handleUnaryCall<GetKeyRequest, SingleKeyResponse>;
  /** List all the keys. */
  listKeys: handleUnaryCall<ListKeysRequest, MultiKeyResponse>;
  /** List keys by app_id */
  listAppKeys: handleUnaryCall<ListAppKeysRequest, MultiKeyResponse>;
  /**
   * Search over the keys to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteKey: handleUnaryCall<DeleteKeyRequest, BaseResponse>;
  /** Add a key to an app. */
  postKeys: handleUnaryCall<PostKeysRequest, MultiKeyResponse>;
  /** Patch one or more keys. */
  patchKeys: handleUnaryCall<PatchKeysRequest, MultiKeyResponse>;
  /**
   * API Keys in the public API -- request is itself Key authorized, and will tell
   * the user the scopes/access of the key/credential they're providing, as computed by
   * our authorizer:
   */
  myScopes: handleUnaryCall<MyScopesRequest, MultiScopeResponse>;
  myScopesUser: handleUnaryCall<MyScopesUserRequest, MultiScopeUserResponse>;
  myScopesRoot: handleUnaryCall<MyScopesRootRequest, MultiScopeRootResponse>;
  /** List all auth scopes available to me as a user. */
  listScopes: handleUnaryCall<ListScopesRequest, MultiScopeDepsResponse>;
  /** Get a specific app from an app. */
  getApp: handleUnaryCall<GetAppRequest, SingleAppResponse>;
  /** List all the apps. */
  listApps: handleUnaryCall<ListAppsRequest, MultiAppResponse>;
  /**
   * Search over the apps to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteApp: handleUnaryCall<DeleteAppRequest, BaseResponse>;
  /**
   * Add a app to an app.
   * This needs to load the default workflow to make a copy, validating all the models in it, and
   * then writing the new workflow back to this new app.
   */
  postApps: handleUnaryCall<PostAppsRequest, MultiAppResponse>;
  /** Patch one or more apps. */
  patchApps: handleUnaryCall<PatchAppsRequest, MultiAppResponse>;
  /**
   * Allows to Patch only the below fields in one or more apps.
   * Allowed fields are notes, description and image
   */
  patchAppsDetails: handleUnaryCall<PatchAppsDetailsRequest, MultiAppResponse>;
  /** Patch apps ids. */
  patchAppsIds: handleUnaryCall<PatchAppsIdsRequest, MultiAppResponse>;
  /** Patch one app. */
  patchApp: handleUnaryCall<PatchAppRequest, SingleAppResponse>;
  /** Search over the applications to find one or more you're looking for. */
  postAppsSearches: handleUnaryCall<PostAppsSearchesRequest, MultiAppResponse>;
  /** Get user information */
  getUser: handleUnaryCall<GetUserRequest, SingleUserResponse>;
  /** Validate new password in real-time for a user */
  postValidatePassword: handleUnaryCall<PostValidatePasswordRequest, SinglePasswordValidationResponse>;
  /** Get a saved legacy search. */
  getSearch: handleUnaryCall<GetSearchRequest, SingleSearchResponse>;
  /** List all saved legacy searches. */
  listSearches: handleUnaryCall<ListSearchesRequest, MultiSearchResponse>;
  /** Patch saved legacy searches by ids. */
  patchSearches: handleUnaryCall<PatchSearchesRequest, MultiSearchResponse>;
  /**
   * Execute a new search and optionally save it.
   *
   * Deprecated: Use PostInputsSearches or PostAnnotationsSearches instead.
   *  The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  postSearches: handleUnaryCall<PostSearchesRequest, MultiSearchResponse>;
  /** Execute a previously saved legacy search. */
  postSearchesById: handleUnaryCall<PostSearchesByIDRequest, MultiSearchResponse>;
  /** Evaluate the results of two search requests */
  postAnnotationSearchMetrics: handleUnaryCall<
    PostAnnotationSearchMetricsRequest,
    MultiAnnotationSearchMetricsResponse
  >;
  /** Get the evaluation results between two search requests */
  getAnnotationSearchMetrics: handleUnaryCall<GetAnnotationSearchMetricsRequest, MultiAnnotationSearchMetricsResponse>;
  /** List the evaluation results between two search requests */
  listAnnotationSearchMetrics: handleUnaryCall<
    ListAnnotationSearchMetricsRequest,
    MultiAnnotationSearchMetricsResponse
  >;
  /** DeleteAnnotationSearchMetrics */
  deleteAnnotationSearchMetrics: handleUnaryCall<DeleteAnnotationSearchMetricsRequest, BaseResponse>;
  /** Delete a saved search. */
  deleteSearch: handleUnaryCall<DeleteSearchRequest, BaseResponse>;
  /** List all the annotation filters. */
  listAnnotationFilters: handleUnaryCall<ListAnnotationFiltersRequest, MultiAnnotationFilterResponse>;
  /** Get a specific annotation filter. */
  getAnnotationFilter: handleUnaryCall<GetAnnotationFilterRequest, SingleAnnotationFilterResponse>;
  /** Add annotation filters. */
  postAnnotationFilters: handleUnaryCall<PostAnnotationFiltersRequest, MultiAnnotationFilterResponse>;
  /** Patch one or more annotation filters. */
  patchAnnotationFilters: handleUnaryCall<PatchAnnotationFiltersRequest, MultiAnnotationFilterResponse>;
  /** Delete one or more annotation filters in a single request. */
  deleteAnnotationFilters: handleUnaryCall<DeleteAnnotationFiltersRequest, BaseResponse>;
  /** List all status codes. */
  listStatusCodes: handleUnaryCall<ListStatusCodesRequest, MultiStatusCodeResponse>;
  /** Get more details for a status code. */
  getStatusCode: handleUnaryCall<GetStatusCodeRequest, SingleStatusCodeResponse>;
  /** owner list users who the app is shared with */
  listCollaborators: handleUnaryCall<ListCollaboratorsRequest, MultiCollaboratorsResponse>;
  /** add collaborators to an app. */
  postCollaborators: handleUnaryCall<PostCollaboratorsRequest, MultiCollaboratorsResponse>;
  /** Patch existing collaborators. */
  patchCollaborators: handleUnaryCall<PatchCollaboratorsRequest, MultiCollaboratorsResponse>;
  /** Delete existing collaborators. */
  deleteCollaborators: handleUnaryCall<DeleteCollaboratorsRequest, BaseResponse>;
  /** Collaboration includes the app user are invitied to work on */
  listCollaborations: handleUnaryCall<ListCollaborationsRequest, MultiCollaborationsResponse>;
  /**
   * PostAppDuplications starts async app duplication jobs which copy resources
   * (inputs, annotations, models etc) from one application to another. It can
   * also create the destination application if it does not exist, with fields
   * (description, metadata etc) copied from the source application.
   *
   * A duplication job can be started by any user that can read from the source
   * application (the target of this call) and can create and write to the
   * destination application. The duplication is associated with the user that
   * created it, so in order to read the status and progress of the job, that
   * user's ID has to be used in the call to GetAppDuplication, which might be
   * different to the source application owner ID in this call.
   */
  postAppDuplications: handleUnaryCall<PostAppDuplicationsRequest, MultiAppDuplicationsResponse>;
  /** ListAppDuplications lists all app duplication jobs created by the user. */
  listAppDuplications: handleUnaryCall<ListAppDuplicationsRequest, MultiAppDuplicationsResponse>;
  /** GetAppDuplication returns an app duplication job created by the user. */
  getAppDuplication: handleUnaryCall<GetAppDuplicationRequest, SingleAppDuplicationResponse>;
  /** Add tasks to an app. */
  postTasks: handleUnaryCall<PostTasksRequest, MultiTaskResponse>;
  /** Task annotation count */
  getTaskAnnotationCount: handleUnaryCall<GetTaskCountRequest, SingleTaskCountResponse>;
  /** Task Input count */
  getTaskInputCount: handleUnaryCall<GetTaskCountRequest, SingleTaskCountResponse>;
  /** Get a specific task from an app. */
  getTask: handleUnaryCall<GetTaskRequest, SingleTaskResponse>;
  /** List tasks from an app. */
  listTasks: handleUnaryCall<ListTasksRequest, MultiTaskResponse>;
  /** Patch one or more tasks. */
  patchTasks: handleUnaryCall<PatchTasksRequest, MultiTaskResponse>;
  /** Delete multiple tasks in one request. */
  deleteTasks: handleUnaryCall<DeleteTasksRequest, BaseResponse>;
  /** Add Label orders. */
  postLabelOrders: handleUnaryCall<PostLabelOrdersRequest, MultiLabelOrderResponse>;
  /** Get a label order. */
  getLabelOrder: handleUnaryCall<GetLabelOrderRequest, SingleLabelOrderResponse>;
  /** List label orders. */
  listLabelOrders: handleUnaryCall<ListLabelOrdersRequest, MultiLabelOrderResponse>;
  /** Patch one or more label orders. */
  patchLabelOrders: handleUnaryCall<PatchLabelOrdersRequest, MultiLabelOrderResponse>;
  /**
   * Delete multiple label orders in one request.
   * this do not change task status
   */
  deleteLabelOrders: handleUnaryCall<DeleteLabelOrdersRequest, BaseResponse>;
  /**
   * Add a list of Collectors to an app.
   * In the handler of this endpoint we also check for all the scopes of the  POST /inputs
   * endpoint.
   * Those current scopes are listed here as a hard requirement.
   * They are needed when adding the collectors just so we now that you have permission with
   * that key at least to do the writing to this app with POST /inputs.
   */
  postCollectors: handleUnaryCall<PostCollectorsRequest, MultiCollectorResponse>;
  /** Get a specific collector from an app. */
  getCollector: handleUnaryCall<GetCollectorRequest, SingleCollectorResponse>;
  /** List all the collectors. */
  listCollectors: handleUnaryCall<ListCollectorsRequest, MultiCollectorResponse>;
  /** Patch one or more collectors. */
  patchCollectors: handleUnaryCall<PatchCollectorsRequest, MultiCollectorResponse>;
  /**
   * Delete multiple collectors in one request.
   * This call is asynchronous. Use DeleteCollector if you want a synchronous version.
   */
  deleteCollectors: handleUnaryCall<DeleteCollectorsRequest, BaseResponse>;
  /** PostStatValues */
  postStatValues: handleUnaryCall<PostStatValuesRequest, MultiStatValueResponse>;
  /** PostStatValuesAggregate */
  postStatValuesAggregate: handleUnaryCall<PostStatValuesAggregateRequest, MultiStatValueAggregateResponse>;
  /** Get a specific module from an app. */
  getModule: handleUnaryCall<GetModuleRequest, SingleModuleResponse>;
  /** List all the modules in community, by user or by app. */
  listModules: handleUnaryCall<ListModulesRequest, MultiModuleResponse>;
  /** Add a modules to an app. */
  postModules: handleUnaryCall<PostModulesRequest, MultiModuleResponse>;
  /** Patch one or more modules. */
  patchModules: handleUnaryCall<PatchModulesRequest, MultiModuleResponse>;
  /** Delete multiple modules in one request. */
  deleteModules: handleUnaryCall<DeleteModulesRequest, BaseResponse>;
  /** Get a specific module version for a module. */
  getModuleVersion: handleUnaryCall<GetModuleVersionRequest, SingleModuleVersionResponse>;
  /** List all the modules versions for a given module. */
  listModuleVersions: handleUnaryCall<ListModuleVersionsRequest, MultiModuleVersionResponse>;
  /** Create a new module version to trigger training of the module. */
  postModuleVersions: handleUnaryCall<PostModuleVersionsRequest, MultiModuleVersionResponse>;
  /** Modify details of an existing module version. */
  patchModuleVersions: handleUnaryCall<PatchModuleVersionsRequest, MultiModuleVersionResponse>;
  /** Delete a multiple module version. */
  deleteModuleVersions: handleUnaryCall<DeleteModuleVersionsRequest, BaseResponse>;
  /** Get usage count for specific module version. */
  getModuleVersionUsageCount: handleUnaryCall<GetModuleVersionUsageCountRequest, SingleModuleVersionUsageCountResponse>;
  /** Get installed modules vesrions for an app. */
  getInstalledModuleVersion: handleUnaryCall<GetInstalledModuleVersionRequest, SingleInstalledModuleVersionResponse>;
  /** List installed modules vesrions for an app. */
  listInstalledModuleVersions: handleUnaryCall<ListInstalledModuleVersionsRequest, MultiInstalledModuleVersionResponse>;
  /** Install a new module version which will deploy the specific ModuleVersion to the app in the url. */
  postInstalledModuleVersions: handleUnaryCall<PostInstalledModuleVersionsRequest, MultiInstalledModuleVersionResponse>;
  /**
   * Uninstall an installed module version which will deploy the specific ModuleVersion to the app
   * in the url.
   * This cleaned up any associated caller keys so needs the Keys_Delete scope.
   */
  deleteInstalledModuleVersions: handleUnaryCall<DeleteInstalledModuleVersionsRequest, BaseResponse>;
  /**
   * Assign a key that the caller owns to be used when accessing this installed module version
   * If this endpoint is called with a different key then it overwrites what is there.
   */
  postInstalledModuleVersionsKey: handleUnaryCall<PostInstalledModuleVersionsKeyRequest, SingleKeyResponse>;
  /**
   * Perform bulk operations on a list of inputs based on input source.
   * Operation include add, update, delete of concepts, metadata and geo data.
   * This is an Asynchronous process. Use ListBulkOperations or GetBulkOperation to check the status.
   */
  postBulkOperations: handleUnaryCall<PostBulkOperationsRequest, MultiBulkOperationsResponse>;
  /** List all the bulk operations */
  listBulkOperations: handleUnaryCall<ListBulkOperationsRequest, MultiBulkOperationsResponse>;
  /** Get the bulk operation details by ID */
  getBulkOperation: handleUnaryCall<GetBulkOperationRequest, SingleBulkOperationsResponse>;
  /** Cancel one or more bulk operations */
  cancelBulkOperations: handleUnaryCall<CancelBulkOperationRequest, MultiBulkOperationsResponse>;
  /** delete one or more terminated bulk operations */
  deleteBulkOperations: handleUnaryCall<DeleteBulkOperationRequest, BaseResponse>;
  /**
   * Deprecated: Use PutTaskAssignments with action=LABEL_START.
   *   This endpoint has initially been designed as a GET request,
   *   but has been re-designed to serve a PUT logic.
   *   In order to clearly highlight that this endpoint serves a PUT request,
   *   this endpoint has been deprecated and replaced by PutTaskAssignments with action=LABEL_START.
   */
  listNextTaskAssignments: handleUnaryCall<ListNextTaskAssignmentsRequest, MultiInputResponse>;
  /**
   * PutTaskAssignments performs an idempotent action for the task assignments in given task.
   * See PutTaskAssignmentsRequestAction for more details about possible actions.
   */
  putTaskAssignments: handleUnaryCall<PutTaskAssignmentsRequest, MultiTaskAssignmentResponse>;
  /** List all the inputs add jobs */
  listInputsAddJobs: handleUnaryCall<ListInputsAddJobsRequest, MultiInputsAddJobResponse>;
  /** Get the input add job details by ID */
  getInputsAddJob: handleUnaryCall<GetInputsAddJobRequest, SingleInputsAddJobResponse>;
  /** cancel the input add job by ID */
  cancelInputsAddJob: handleUnaryCall<CancelInputsAddJobRequest, SingleInputsAddJobResponse>;
  /**
   * PostUploads is used to upload files. Note that this does not create inputs.
   * returns job with uploadID, job has UPLOAD_IN_PROGRESS status
   * Actual upload content can be done in multiple calls with PutUploadContentParts
   * You can get status of upload with GetUpload or ListUploads endpoints
   * See also PostInputsUploads
   */
  postUploads: handleUnaryCall<PostUploadsRequest, MultiUploadResponse>;
  /**
   * Upload a part of a multipart upload.
   * Behaviour on completion depends on the endpoint that was used to initiate the upload.
   */
  putUploadContentParts: handleUnaryCall<PutUploadContentPartsRequest, SingleUploadResponse>;
  getUpload: handleUnaryCall<GetUploadRequest, SingleUploadResponse>;
  listUploads: handleUnaryCall<ListUploadsRequest, MultiUploadResponse>;
  deleteUploads: handleUnaryCall<DeleteUploadsRequest, BaseResponse>;
  /**
   * Initiates retrieval of inputs from cloud storage from a user provided data source.
   * Will create and return an inputs-add-job for tracking progress.
   * Archives will be extracted and their contents will be processed as inputs.
   *
   * The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
   * files in the images_folder beginning with abc or in a subfolder beginning with abc.
   * For example:
   * bucket/images_folder/abcImage.png
   * bucket/images_folder/abc-1/Data.zip
   *
   * If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
   * Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
   * in which case it only requires rights to access that particular file.
   */
  postInputsDataSources: handleUnaryCall<PostInputsDataSourcesRequest, MultiInputsAddJobResponse>;
  /** Get the input extraction job details by ID */
  getInputsExtractionJob: handleUnaryCall<GetInputsExtractionJobRequest, SingleInputsExtractionJobResponse>;
  /** List all the input extraction jobs */
  listInputsExtractionJobs: handleUnaryCall<ListInputsExtractionJobsRequest, MultiInputsExtractionJobResponse>;
  cancelInputsExtractionJobs: handleUnaryCall<CancelInputsExtractionJobsRequest, MultiInputsExtractionJobResponse>;
  /**
   * Create new upload job with a file archive containing inputs (images, videos, text, audio)
   * Actual file upload happens in next steps by calling `PutUploadContentParts` endpoint
   * and providing the file content in the request body.
   * This endpoint creates and return an inputs-add-job which contains an upload id needed for upload and further status tracking
   * Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
   * See also GetInputsAddJob and then GetInputsExtractionJob
   */
  postInputsUploads: handleUnaryCall<PostInputsUploadsRequest, MultiInputsAddJobResponse>;
  /** putting above the Get Nodepool endpoint to make it appear above the other one */
  listPipelineVersionRuns: handleUnaryCall<ListPipelineVersionRunsRequest, MultiPipelineVersionRunResponse>;
  /**
   * Get a specific runner.
   * TODO(zeiler): runner_id is a UUID so can list globally as well.
   */
  getRunner: handleUnaryCall<GetRunnerRequest, SingleRunnerResponse>;
  /** List all the runners for the user. */
  listRunners: handleUnaryCall<ListRunnersRequest, MultiRunnerResponse>;
  /** Add a runners to a user. */
  postRunners: handleUnaryCall<PostRunnersRequest, MultiRunnerResponse>;
  /** Patch runners of a user. */
  patchRunners: handleUnaryCall<PatchRunnersRequest, MultiRunnerResponse>;
  /** Delete multiple runners in one request. */
  deleteRunners: handleUnaryCall<DeleteRunnersRequest, BaseResponse>;
  /**
   * List items for the remote runner to work on.
   * since the runner_id is a UUID we can access it directly too.
   */
  listRunnerItems: handleUnaryCall<ListRunnerItemsRequest, MultiRunnerItemResponse>;
  /**
   * Post back outputs from remote runners
   * since the runner_id is a UUID we can access it directly too.
   */
  postRunnerItemOutputs: handleUnaryCall<PostRunnerItemOutputsRequest, MultiRunnerItemOutputResponse>;
  /**
   * This maintains a single request for asking the API if there is any work to be done, processing
   * it and streaming back results.
   * To do that first handshake the MultiRunnerItemOutputResponse will have RUNNER_STREAM_START
   * status filled in so that the API knows to respond with a MultiRunnerItemResponse.
   * For now there will only be one of those if the model prediction only has one request.
   * NOTE(zeiler): downside of this is you can't use HTTP REST requests to do runner work.
   */
  processRunnerItems: handleBidiStreamingCall<PostRunnerItemOutputsRequest, MultiRunnerItemResponse>;
  /** Get the training time estimate based off train request and estimated input count. */
  postModelVersionsTrainingTimeEstimate: handleUnaryCall<
    PostModelVersionsTrainingTimeEstimateRequest,
    MultiTrainingTimeEstimateResponse
  >;
  /** List Available Cloud Providers */
  listCloudProviders: handleUnaryCall<ListCloudProvidersRequest, MultiCloudProviderResponse>;
  /** List Regions for given Cloud Provider */
  listCloudRegions: handleUnaryCall<ListCloudRegionsRequest, MultiCloudRegionResponse>;
  /** Get InstanceTypes given Cloud Provider and Region */
  listInstanceTypes: handleUnaryCall<ListInstanceTypesRequest, MultiInstanceTypeResponse>;
  /** ComputeCluster CRUD */
  getComputeCluster: handleUnaryCall<GetComputeClusterRequest, SingleComputeClusterResponse>;
  listComputeClusters: handleUnaryCall<ListComputeClustersRequest, MultiComputeClusterResponse>;
  postComputeClusters: handleUnaryCall<PostComputeClustersRequest, MultiComputeClusterResponse>;
  /** Delete multiple compute_clusters in one request. */
  deleteComputeClusters: handleUnaryCall<DeleteComputeClustersRequest, BaseResponse>;
  /** Nodepools CRUD */
  getNodepool: handleUnaryCall<GetNodepoolRequest, SingleNodepoolResponse>;
  listNodepools: handleUnaryCall<ListNodepoolsRequest, MultiNodepoolResponse>;
  postNodepools: handleUnaryCall<PostNodepoolsRequest, MultiNodepoolResponse>;
  patchNodepools: handleUnaryCall<PatchNodepoolsRequest, MultiNodepoolResponse>;
  /** Delete multiple nodepools in one request. */
  deleteNodepools: handleUnaryCall<DeleteNodepoolsRequest, BaseResponse>;
  /** Deployments CRUD */
  getDeployment: handleUnaryCall<GetDeploymentRequest, SingleDeploymentResponse>;
  listDeployments: handleUnaryCall<ListDeploymentsRequest, MultiDeploymentResponse>;
  postDeployments: handleUnaryCall<PostDeploymentsRequest, MultiDeploymentResponse>;
  patchDeployments: handleUnaryCall<PatchDeploymentsRequest, MultiDeploymentResponse>;
  /** Delete multiple deployments in one request. */
  deleteDeployments: handleUnaryCall<DeleteDeploymentsRequest, BaseResponse>;
  postAuditLogSearches: handleUnaryCall<PostAuditLogSearchesRequest, MultiAuditLogEntryResponse>;
  listWorkflowEvaluationTemplates: handleUnaryCall<
    ListWorkflowEvaluationTemplatesRequest,
    MultiWorkflowEvaluationTemplateResponse
  >;
  postLogEntries: handleUnaryCall<PostLogEntriesRequest, BaseResponse>;
  listLogEntries: handleUnaryCall<ListLogEntriesRequest, MultiLogEntryResponse>;
  streamLogEntries: handleServerStreamingCall<StreamLogEntriesRequest, MultiLogEntryResponse>;
  postComputePlaneMetrics: handleUnaryCall<PostComputePlaneMetricsRequest, BaseResponse>;
  postWorkflowVersionEvaluations: handleUnaryCall<
    PostWorkflowVersionEvaluationsRequest,
    MultiWorkflowVersionEvaluationResponse
  >;
  getWorkflowVersionEvaluation: handleUnaryCall<
    GetWorkflowVersionEvaluationRequest,
    SingleWorkflowVersionEvaluationResponse
  >;
  listWorkflowVersionEvaluations: handleUnaryCall<
    ListWorkflowVersionEvaluationsRequest,
    MultiWorkflowVersionEvaluationResponse
  >;
  patchWorkflowVersionEvaluations: handleUnaryCall<
    PatchWorkflowVersionEvaluationsRequest,
    MultiWorkflowVersionEvaluationResponse
  >;
  listWorkflowVersionEvaluationData: handleUnaryCall<
    ListWorkflowVersionEvaluationDataRequest,
    MultiListWorkflowVersionEvaluationDataResponse
  >;
  postWorkflowVersionEvaluationData: handleUnaryCall<
    PostWorkflowVersionEvaluationDataRequest,
    MultiListWorkflowVersionEvaluationDataResponse
  >;
  postPipelines: handleUnaryCall<PostPipelinesRequest, MultiPipelineResponse>;
  getPipeline: handleUnaryCall<GetPipelineRequest, SinglePipelineResponse>;
  listPipelines: handleUnaryCall<ListPipelinesRequest, MultiPipelineResponse>;
  patchPipelines: handleUnaryCall<PatchPipelinesRequest, MultiPipelineResponse>;
  deletePipelines: handleUnaryCall<DeletePipelinesRequest, BaseResponse>;
  getPipelineVersion: handleUnaryCall<GetPipelineVersionRequest, SinglePipelineVersionResponse>;
  listPipelineVersions: handleUnaryCall<ListPipelineVersionsRequest, MultiPipelineVersionResponse>;
  patchPipelineVersions: handleUnaryCall<PatchPipelineVersionsRequest, MultiPipelineVersionResponse>;
  deletePipelineVersions: handleUnaryCall<DeletePipelineVersionsRequest, BaseResponse>;
  getPipelineVersionRun: handleUnaryCall<GetPipelineVersionRunRequest, SinglePipelineVersionRunResponse>;
  postPipelineVersionRuns: handleUnaryCall<PostPipelineVersionRunsRequest, MultiPipelineVersionRunResponse>;
  patchPipelineVersionRuns: handleUnaryCall<PatchPipelineVersionRunsRequest, MultiPipelineVersionRunResponse>;
  postPipelineSteps: handleUnaryCall<PostPipelineStepsRequest, MultiPipelineStepResponse>;
  getPipelineStep: handleUnaryCall<GetPipelineStepRequest, SinglePipelineStepResponse>;
  listPipelineSteps: handleUnaryCall<ListPipelineStepsRequest, MultiPipelineStepResponse>;
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the pipeline_step_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the pipeline_step_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the pipeline_step_version_id specified for your pipeline_step_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the pipeline_step_bytes.
   */
  postPipelineStepVersionsUpload: handleBidiStreamingCall<
    PostPipelineStepVersionsUploadRequest,
    PostPipelineStepVersionsUploadResponse
  >;
  listPipelineStepVersions: handleUnaryCall<ListPipelineStepVersionsRequest, MultiPipelineStepVersionResponse>;
  getPipelineStepVersion: handleUnaryCall<GetPipelineStepVersionRequest, SinglePipelineStepVersionResponse>;
  getSecret: handleUnaryCall<GetSecretRequest, SingleSecretResponse>;
  listSecrets: handleUnaryCall<ListSecretsRequest, MultiSecretResponse>;
  postSecrets: handleUnaryCall<PostSecretsRequest, MultiSecretResponse>;
  patchSecrets: handleUnaryCall<PatchSecretsRequest, MultiSecretResponse>;
  deleteSecrets: handleUnaryCall<DeleteSecretsRequest, MultiSecretResponse>;
}

export interface V2Client extends Client {
  /**
   * List concept relations between concepts in the platform.
   * MUST be above ListConcepts so that if concept_id is empty this will still match
   * /concepts/relations to list all the concept relations in the app.
   */
  listConceptRelations(
    request: ListConceptRelationsRequest,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  listConceptRelations(
    request: ListConceptRelationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  listConceptRelations(
    request: ListConceptRelationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  /** Post concept relations to create relations between concepts in the platform. */
  postConceptRelations(
    request: PostConceptRelationsRequest,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  postConceptRelations(
    request: PostConceptRelationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  postConceptRelations(
    request: PostConceptRelationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptRelationResponse) => void,
  ): ClientUnaryCall;
  /** Post concept relations to create relations between concepts in the platform. */
  deleteConceptRelations(
    request: DeleteConceptRelationsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteConceptRelations(
    request: DeleteConceptRelationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteConceptRelations(
    request: DeleteConceptRelationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all the concepts with their positive and negative counts */
  getConceptCounts(
    request: GetConceptCountsRequest,
    callback: (error: ServiceError | null, response: MultiConceptCountResponse) => void,
  ): ClientUnaryCall;
  getConceptCounts(
    request: GetConceptCountsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptCountResponse) => void,
  ): ClientUnaryCall;
  getConceptCounts(
    request: GetConceptCountsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptCountResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific concept from an app. */
  getConcept(
    request: GetConceptRequest,
    callback: (error: ServiceError | null, response: SingleConceptResponse) => void,
  ): ClientUnaryCall;
  getConcept(
    request: GetConceptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleConceptResponse) => void,
  ): ClientUnaryCall;
  getConcept(
    request: GetConceptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleConceptResponse) => void,
  ): ClientUnaryCall;
  /** List all the concepts. */
  listConcepts(
    request: ListConceptsRequest,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  listConcepts(
    request: ListConceptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  listConcepts(
    request: ListConceptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  /** List models concepts. */
  listModelConcepts(
    request: ListModelConceptsRequest,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  listModelConcepts(
    request: ListModelConceptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  listModelConcepts(
    request: ListModelConceptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  /**
   * Search over the concepts to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postConceptsSearches(
    request: PostConceptsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  postConceptsSearches(
    request: PostConceptsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  postConceptsSearches(
    request: PostConceptsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  /** Add a concept to an app. */
  postConcepts(
    request: PostConceptsRequest,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  postConcepts(
    request: PostConceptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  postConcepts(
    request: PostConceptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more concepts. */
  patchConcepts(
    request: PatchConceptsRequest,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  patchConcepts(
    request: PatchConceptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  patchConcepts(
    request: PatchConceptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific concept from an app. */
  getConceptLanguage(
    request: GetConceptLanguageRequest,
    callback: (error: ServiceError | null, response: SingleConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  getConceptLanguage(
    request: GetConceptLanguageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  getConceptLanguage(
    request: GetConceptLanguageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  /** List the concept in all the translated languages. */
  listConceptLanguages(
    request: ListConceptLanguagesRequest,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  listConceptLanguages(
    request: ListConceptLanguagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  listConceptLanguages(
    request: ListConceptLanguagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  /** Add a new translation for this concept. */
  postConceptLanguages(
    request: PostConceptLanguagesRequest,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  postConceptLanguages(
    request: PostConceptLanguagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  postConceptLanguages(
    request: PostConceptLanguagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  /**
   * Patch the name for a given language names by passing in a list of concepts with the new names
   * for the languages.
   */
  patchConceptLanguages(
    request: PatchConceptLanguagesRequest,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  patchConceptLanguages(
    request: PatchConceptLanguagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  patchConceptLanguages(
    request: PatchConceptLanguagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiConceptLanguageResponse) => void,
  ): ClientUnaryCall;
  /** List all domain graphs. */
  listKnowledgeGraphs(
    request: ListKnowledgeGraphsRequest,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  listKnowledgeGraphs(
    request: ListKnowledgeGraphsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  listKnowledgeGraphs(
    request: ListKnowledgeGraphsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  /** Post domain graphs. */
  postKnowledgeGraphs(
    request: PostKnowledgeGraphsRequest,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  postKnowledgeGraphs(
    request: PostKnowledgeGraphsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  postKnowledgeGraphs(
    request: PostKnowledgeGraphsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKnowledgeGraphResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific annotation from an app. */
  getAnnotation(
    request: GetAnnotationRequest,
    callback: (error: ServiceError | null, response: SingleAnnotationResponse) => void,
  ): ClientUnaryCall;
  getAnnotation(
    request: GetAnnotationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleAnnotationResponse) => void,
  ): ClientUnaryCall;
  getAnnotation(
    request: GetAnnotationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleAnnotationResponse) => void,
  ): ClientUnaryCall;
  /** List all the annotation. */
  listAnnotations(
    request: ListAnnotationsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  listAnnotations(
    request: ListAnnotationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  listAnnotations(
    request: ListAnnotationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  /** Post annotations. */
  postAnnotations(
    request: PostAnnotationsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  postAnnotations(
    request: PostAnnotationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  postAnnotations(
    request: PostAnnotationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more annotations. */
  patchAnnotations(
    request: PatchAnnotationsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  patchAnnotations(
    request: PatchAnnotationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  patchAnnotations(
    request: PatchAnnotationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationResponse) => void,
  ): ClientUnaryCall;
  /**
   * Patch annotations status by worker id and task id.
   * Deprecated: Use PutTaskAssignments to update task annotations.
   *   For example, you can use PutTaskAssignments with action REVIEW_APPROVE
   *   to approve task assignments and associated annotations in bulk.
   */
  patchAnnotationsStatus(
    request: PatchAnnotationsStatusRequest,
    callback: (error: ServiceError | null, response: PatchAnnotationsStatusResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationsStatus(
    request: PatchAnnotationsStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PatchAnnotationsStatusResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationsStatus(
    request: PatchAnnotationsStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PatchAnnotationsStatusResponse) => void,
  ): ClientUnaryCall;
  /** Delete a single annotation. */
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple annotations in one request. */
  deleteAnnotations(
    request: DeleteAnnotationsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotations(
    request: DeleteAnnotationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotations(
    request: DeleteAnnotationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all the annotation tracks. */
  listAnnotationTracks(
    request: ListAnnotationTracksRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  listAnnotationTracks(
    request: ListAnnotationTracksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  listAnnotationTracks(
    request: ListAnnotationTracksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  /** Post annotation tracks. */
  postAnnotationTracks(
    request: PostAnnotationTracksRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  postAnnotationTracks(
    request: PostAnnotationTracksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  postAnnotationTracks(
    request: PostAnnotationTracksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more annotation tracks. */
  patchAnnotationTracks(
    request: PatchAnnotationTracksRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationTracks(
    request: PatchAnnotationTracksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationTracks(
    request: PatchAnnotationTracksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationTrackResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple annotation tracks in one request. */
  deleteAnnotationTracks(
    request: DeleteAnnotationTracksRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationTracks(
    request: DeleteAnnotationTracksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationTracks(
    request: DeleteAnnotationTracksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Patch saved annotations searches by ids. */
  patchAnnotationsSearches(
    request: PatchAnnotationsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationsSearches(
    request: PatchAnnotationsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationsSearches(
    request: PatchAnnotationsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Execute a search over annotations */
  postAnnotationsSearches(
    request: PostAnnotationsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postAnnotationsSearches(
    request: PostAnnotationsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postAnnotationsSearches(
    request: PostAnnotationsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /**
   * ListAnnotationWorkers lists users, models, and workflows (collectively
   * known as "workers") that have added annotations to the application.
   */
  listAnnotationWorkers(
    request: ListAnnotationWorkersRequest,
    callback: (error: ServiceError | null, response: MultiWorkerResponse) => void,
  ): ClientUnaryCall;
  listAnnotationWorkers(
    request: ListAnnotationWorkersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkerResponse) => void,
  ): ClientUnaryCall;
  listAnnotationWorkers(
    request: ListAnnotationWorkersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkerResponse) => void,
  ): ClientUnaryCall;
  /** Get input count per status. */
  getInputCount(
    request: GetInputCountRequest,
    callback: (error: ServiceError | null, response: SingleInputCountResponse) => void,
  ): ClientUnaryCall;
  getInputCount(
    request: GetInputCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInputCountResponse) => void,
  ): ClientUnaryCall;
  getInputCount(
    request: GetInputCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInputCountResponse) => void,
  ): ClientUnaryCall;
  /** Streams all the inputs starting from oldest assets. */
  streamInputs(
    request: StreamInputsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  streamInputs(
    request: StreamInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  streamInputs(
    request: StreamInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  getInputSamples(
    request: GetInputSamplesRequest,
    callback: (error: ServiceError | null, response: MultiInputAnnotationResponse) => void,
  ): ClientUnaryCall;
  getInputSamples(
    request: GetInputSamplesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputAnnotationResponse) => void,
  ): ClientUnaryCall;
  getInputSamples(
    request: GetInputSamplesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputAnnotationResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific input from an app. */
  getInput(
    request: GetInputRequest,
    callback: (error: ServiceError | null, response: SingleInputResponse) => void,
  ): ClientUnaryCall;
  getInput(
    request: GetInputRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInputResponse) => void,
  ): ClientUnaryCall;
  getInput(
    request: GetInputRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInputResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get a MPEG-DASH manifest for video-type inputs that were added via PostInputs and successfully processed
   * Experimental. Manifest is used by browser and desktop clients that implement an efficient streaming playback
   * This means client can switch between low-resolution and high-resolution video streams
   * Depending on network bandwidth or user's preference
   * This also means that reencoded video streams are reencoded in a uniform way, not relying on original format
   * Alternative to MPEG-dash is to stream original file with byte-range header
   */
  getInputVideoManifest(
    request: GetVideoManifestRequest,
    callback: (error: ServiceError | null, response: GetVideoManifestResponse) => void,
  ): ClientUnaryCall;
  getInputVideoManifest(
    request: GetVideoManifestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetVideoManifestResponse) => void,
  ): ClientUnaryCall;
  getInputVideoManifest(
    request: GetVideoManifestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetVideoManifestResponse) => void,
  ): ClientUnaryCall;
  /** List all the inputs. */
  listInputs(
    request: ListInputsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listInputs(
    request: ListInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listInputs(
    request: ListInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  /**
   * PostInputs adds one or more inputs to the app.
   * Takes a list of image/video/audio/text URLs, image/video/audio bytes or raw text
   * Optionally, include concepts or dataset ids to link them
   * Optionally, include metadata for search
   * Note that inputs processing is asynchronous process
   * See ListInputs, StreamInputs or PostInputSearches to list results
   */
  postInputs(
    request: PostInputsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  postInputs(
    request: PostInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  postInputs(
    request: PostInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more inputs. */
  patchInputs(
    request: PatchInputsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  patchInputs(
    request: PatchInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  patchInputs(
    request: PatchInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  /** Delete a single input asynchronously. */
  deleteInput(
    request: DeleteInputRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInput(
    request: DeleteInputRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInput(
    request: DeleteInputRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Delete multiple inputs in one request.
   * This call is asynchronous.
   */
  deleteInputs(
    request: DeleteInputsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInputs(
    request: DeleteInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInputs(
    request: DeleteInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Patch saved inputs searches by ids. */
  patchInputsSearches(
    request: PatchInputsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchInputsSearches(
    request: PatchInputsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchInputsSearches(
    request: PatchInputsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Execute a search over inputs */
  postInputsSearches(
    request: PostInputsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postInputsSearches(
    request: PostInputsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postInputsSearches(
    request: PostInputsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Get predicted outputs from the model. */
  postModelOutputs(
    request: PostModelOutputsRequest,
    callback: (error: ServiceError | null, response: MultiOutputResponse) => void,
  ): ClientUnaryCall;
  postModelOutputs(
    request: PostModelOutputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiOutputResponse) => void,
  ): ClientUnaryCall;
  postModelOutputs(
    request: PostModelOutputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiOutputResponse) => void,
  ): ClientUnaryCall;
  /**
   * TODO(zeiler): will need to
   * Single request but streaming responses.
   */
  generateModelOutputs(
    request: PostModelOutputsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MultiOutputResponse>;
  generateModelOutputs(
    request: PostModelOutputsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MultiOutputResponse>;
  /** Stream of requests and stream of responses */
  streamModelOutputs(): ClientDuplexStream<PostModelOutputsRequest, MultiOutputResponse>;
  streamModelOutputs(options: Partial<CallOptions>): ClientDuplexStream<PostModelOutputsRequest, MultiOutputResponse>;
  streamModelOutputs(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<PostModelOutputsRequest, MultiOutputResponse>;
  /** List all the datasets. */
  listDatasets(
    request: ListDatasetsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  listDatasets(
    request: ListDatasetsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  listDatasets(
    request: ListDatasetsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific dataset. */
  getDataset(
    request: GetDatasetRequest,
    callback: (error: ServiceError | null, response: SingleDatasetResponse) => void,
  ): ClientUnaryCall;
  getDataset(
    request: GetDatasetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleDatasetResponse) => void,
  ): ClientUnaryCall;
  getDataset(
    request: GetDatasetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleDatasetResponse) => void,
  ): ClientUnaryCall;
  /**
   * Add datasets to an app.
   * The process is atomic, i.e. either all or no datasets are added.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  postDatasets(
    request: PostDatasetsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  postDatasets(
    request: PostDatasetsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  postDatasets(
    request: PostDatasetsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  /**
   * Patch one or more datasets.
   * The process is atomic, i.e. either all or no datasets are patched.
   * If there is an error for one dataset,
   * the process will stop, revert the transaction and return the error.
   */
  patchDatasets(
    request: PatchDatasetsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  patchDatasets(
    request: PatchDatasetsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  patchDatasets(
    request: PatchDatasetsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetResponse) => void,
  ): ClientUnaryCall;
  /** Delete one or more datasets in a single request. */
  deleteDatasets(
    request: DeleteDatasetsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasets(
    request: DeleteDatasetsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasets(
    request: DeleteDatasetsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all the dataset inputs in a dataset. */
  listDatasetInputs(
    request: ListDatasetInputsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  listDatasetInputs(
    request: ListDatasetInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  listDatasetInputs(
    request: ListDatasetInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific dataset input. */
  getDatasetInput(
    request: GetDatasetInputRequest,
    callback: (error: ServiceError | null, response: SingleDatasetInputResponse) => void,
  ): ClientUnaryCall;
  getDatasetInput(
    request: GetDatasetInputRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleDatasetInputResponse) => void,
  ): ClientUnaryCall;
  getDatasetInput(
    request: GetDatasetInputRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleDatasetInputResponse) => void,
  ): ClientUnaryCall;
  /**
   * Add dataset inputs to a dataset.
   * The process is not atomic, i.e. if there are errors with some dataset
   * inputs, others might still be added. The response reports
   *   - SUCCESS if all dataset inputs were added,
   *   - MIXED_STATUS if only some dataset inputs were added, and
   *   - FAILURE if no dataset inputs were added.
   * Each individual dataset input in the response has the status set to
   * indicate if it was successful or if there was an error.
   */
  postDatasetInputs(
    request: PostDatasetInputsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  postDatasetInputs(
    request: PostDatasetInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  postDatasetInputs(
    request: PostDatasetInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetInputResponse) => void,
  ): ClientUnaryCall;
  /** Delete one or more dataset inputs in a single request. */
  deleteDatasetInputs(
    request: DeleteDatasetInputsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasetInputs(
    request: DeleteDatasetInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasetInputs(
    request: DeleteDatasetInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all the dataset versions. */
  listDatasetVersions(
    request: ListDatasetVersionsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  listDatasetVersions(
    request: ListDatasetVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  listDatasetVersions(
    request: ListDatasetVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific dataset version. */
  getDatasetVersion(
    request: GetDatasetVersionRequest,
    callback: (error: ServiceError | null, response: SingleDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  getDatasetVersion(
    request: GetDatasetVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  getDatasetVersion(
    request: GetDatasetVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  listDatasetVersionMetricsGroups(
    request: ListDatasetVersionMetricsGroupsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetVersionMetricsGroupResponse) => void,
  ): ClientUnaryCall;
  listDatasetVersionMetricsGroups(
    request: ListDatasetVersionMetricsGroupsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetVersionMetricsGroupResponse) => void,
  ): ClientUnaryCall;
  listDatasetVersionMetricsGroups(
    request: ListDatasetVersionMetricsGroupsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetVersionMetricsGroupResponse) => void,
  ): ClientUnaryCall;
  /** Add dataset versions to a dataset. */
  postDatasetVersions(
    request: PostDatasetVersionsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  postDatasetVersions(
    request: PostDatasetVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  postDatasetVersions(
    request: PostDatasetVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more dataset versions. */
  patchDatasetVersions(
    request: PatchDatasetVersionsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  patchDatasetVersions(
    request: PatchDatasetVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  patchDatasetVersions(
    request: PatchDatasetVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetVersionResponse) => void,
  ): ClientUnaryCall;
  /** Delete one or more dataset versions in a single request. */
  deleteDatasetVersions(
    request: DeleteDatasetVersionsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasetVersions(
    request: DeleteDatasetVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDatasetVersions(
    request: DeleteDatasetVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Create export of a dataset version. */
  putDatasetVersionExports(
    request: PutDatasetVersionExportsRequest,
    callback: (error: ServiceError | null, response: MultiDatasetVersionExportResponse) => void,
  ): ClientUnaryCall;
  putDatasetVersionExports(
    request: PutDatasetVersionExportsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDatasetVersionExportResponse) => void,
  ): ClientUnaryCall;
  putDatasetVersionExports(
    request: PutDatasetVersionExportsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDatasetVersionExportResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific model type. */
  getModelType(
    request: GetModelTypeRequest,
    callback: (error: ServiceError | null, response: SingleModelTypeResponse) => void,
  ): ClientUnaryCall;
  getModelType(
    request: GetModelTypeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelTypeResponse) => void,
  ): ClientUnaryCall;
  getModelType(
    request: GetModelTypeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelTypeResponse) => void,
  ): ClientUnaryCall;
  /** List all the supported open source licenses in the platform. */
  listOpenSourceLicenses(
    request: ListOpenSourceLicensesRequest,
    callback: (error: ServiceError | null, response: ListOpenSourceLicensesResponse) => void,
  ): ClientUnaryCall;
  listOpenSourceLicenses(
    request: ListOpenSourceLicensesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListOpenSourceLicensesResponse) => void,
  ): ClientUnaryCall;
  listOpenSourceLicenses(
    request: ListOpenSourceLicensesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListOpenSourceLicensesResponse) => void,
  ): ClientUnaryCall;
  /**
   * List all the model types available in the platform.
   * This MUST be above ListModels so that the /models/types endpoint takes precedence.
   */
  listModelTypes(
    request: ListModelTypesRequest,
    callback: (error: ServiceError | null, response: MultiModelTypeResponse) => void,
  ): ClientUnaryCall;
  listModelTypes(
    request: ListModelTypesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelTypeResponse) => void,
  ): ClientUnaryCall;
  listModelTypes(
    request: ListModelTypesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelTypeResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific model from an app. */
  getModel(
    request: GetModelRequest,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  getModel(
    request: GetModelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  getModel(
    request: GetModelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get a the output info for a given model_id or model_id/version_id
   * combo.
   */
  getModelOutputInfo(
    request: GetModelRequest,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  getModelOutputInfo(
    request: GetModelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  getModelOutputInfo(
    request: GetModelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  /** List all the models. */
  listModels(
    request: ListModelsRequest,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  listModels(
    request: ListModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  listModels(
    request: ListModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  /** List the resource counts for the app. */
  getResourceCounts(
    request: GetResourceCountsRequest,
    callback: (error: ServiceError | null, response: GetResourceCountsResponse) => void,
  ): ClientUnaryCall;
  getResourceCounts(
    request: GetResourceCountsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResourceCountsResponse) => void,
  ): ClientUnaryCall;
  getResourceCounts(
    request: GetResourceCountsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResourceCountsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Search over the models to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  postModelsSearches(
    request: PostModelsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  postModelsSearches(
    request: PostModelsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  postModelsSearches(
    request: PostModelsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  /** Add a models to an app. */
  postModels(
    request: PostModelsRequest,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModels(
    request: PostModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModels(
    request: PostModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more models. */
  patchModels(
    request: PatchModelsRequest,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  patchModels(
    request: PatchModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  patchModels(
    request: PatchModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more models ids. */
  patchModelIds(
    request: PatchModelIdsRequest,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  patchModelIds(
    request: PatchModelIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  patchModelIds(
    request: PatchModelIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelResponse) => void,
  ): ClientUnaryCall;
  /** Delete a single model. */
  deleteModel(
    request: DeleteModelRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModel(
    request: DeleteModelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModel(
    request: DeleteModelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple models in one request. */
  deleteModels(
    request: DeleteModelsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModels(
    request: DeleteModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModels(
    request: DeleteModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Update model check consents */
  patchModelCheckConsents(
    request: PatchModelCheckConsentsRequest,
    callback: (error: ServiceError | null, response: MultiModelCheckConsentResponse) => void,
  ): ClientUnaryCall;
  patchModelCheckConsents(
    request: PatchModelCheckConsentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelCheckConsentResponse) => void,
  ): ClientUnaryCall;
  patchModelCheckConsents(
    request: PatchModelCheckConsentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelCheckConsentResponse) => void,
  ): ClientUnaryCall;
  /** Update model toolkits tags */
  patchModelToolkits(
    request: PatchModelToolkitsRequest,
    callback: (error: ServiceError | null, response: MultiModelToolkitResponse) => void,
  ): ClientUnaryCall;
  patchModelToolkits(
    request: PatchModelToolkitsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelToolkitResponse) => void,
  ): ClientUnaryCall;
  patchModelToolkits(
    request: PatchModelToolkitsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelToolkitResponse) => void,
  ): ClientUnaryCall;
  /** Update model use_cases tags */
  patchModelUseCases(
    request: PatchModelUseCasesRequest,
    callback: (error: ServiceError | null, response: MultiModelUseCaseResponse) => void,
  ): ClientUnaryCall;
  patchModelUseCases(
    request: PatchModelUseCasesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelUseCaseResponse) => void,
  ): ClientUnaryCall;
  patchModelUseCases(
    request: PatchModelUseCasesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelUseCaseResponse) => void,
  ): ClientUnaryCall;
  /** Update model languages tags */
  patchModelLanguages(
    request: PatchModelLanguagesRequest,
    callback: (error: ServiceError | null, response: MultiModelLanguageResponse) => void,
  ): ClientUnaryCall;
  patchModelLanguages(
    request: PatchModelLanguagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelLanguageResponse) => void,
  ): ClientUnaryCall;
  patchModelLanguages(
    request: PatchModelLanguagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelLanguageResponse) => void,
  ): ClientUnaryCall;
  /**
   * Deprecated: Unmaintained and ideally replaced with usage of datasets
   *   The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  listModelInputs(
    request: ListModelInputsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listModelInputs(
    request: ListModelInputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listModelInputs(
    request: ListModelInputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific model from an app. */
  getModelVersion(
    request: GetModelVersionRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  getModelVersion(
    request: GetModelVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  getModelVersion(
    request: GetModelVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  /** List all the models. */
  listModelVersions(
    request: ListModelVersionsRequest,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  listModelVersions(
    request: ListModelVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  listModelVersions(
    request: ListModelVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsUnPublish(
    request: PostWorkflowVersionsUnPublishRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsUnPublish(
    request: PostWorkflowVersionsUnPublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsUnPublish(
    request: PostWorkflowVersionsUnPublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsPublish(
    request: PostWorkflowVersionsPublishRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsPublish(
    request: PostWorkflowVersionsPublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionsPublish(
    request: PostWorkflowVersionsPublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** PostModelVersionsPublish */
  postModelVersionsPublish(
    request: PostModelVersionsPublishRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsPublish(
    request: PostModelVersionsPublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsPublish(
    request: PostModelVersionsPublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** PostModelVersionsUnPublish */
  postModelVersionsUnPublish(
    request: PostModelVersionsUnPublishRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsUnPublish(
    request: PostModelVersionsUnPublishRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsUnPublish(
    request: PostModelVersionsUnPublishRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Create a new model version to trigger training of the model. */
  postModelVersions(
    request: PostModelVersionsRequest,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModelVersions(
    request: PostModelVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModelVersions(
    request: PostModelVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  /** PatchModelVersions */
  patchModelVersions(
    request: PatchModelVersionsRequest,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  patchModelVersions(
    request: PatchModelVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  patchModelVersions(
    request: PatchModelVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelVersionResponse) => void,
  ): ClientUnaryCall;
  /** Delete a single model. */
  deleteModelVersion(
    request: DeleteModelVersionRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModelVersion(
    request: DeleteModelVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModelVersion(
    request: DeleteModelVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the model_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the model_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the model_version_id specified for your model_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the model_bytes.
   */
  postModelVersionsUpload(): ClientDuplexStream<PostModelVersionsUploadRequest, PostModelVersionsUploadResponse>;
  postModelVersionsUpload(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<PostModelVersionsUploadRequest, PostModelVersionsUploadResponse>;
  postModelVersionsUpload(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<PostModelVersionsUploadRequest, PostModelVersionsUploadResponse>;
  /** Kicks off conversion from the old Triton model format to the new Docker model format. */
  postModelMigration(
    request: PostModelMigrationRequest,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModelMigration(
    request: PostModelMigrationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  postModelMigration(
    request: PostModelMigrationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelResponse) => void,
  ): ClientUnaryCall;
  /** Export a model */
  putModelVersionExports(
    request: PutModelVersionExportsRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  putModelVersionExports(
    request: PutModelVersionExportsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  putModelVersionExports(
    request: PutModelVersionExportsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  /** GetModelVersionExport */
  getModelVersionExport(
    request: GetModelVersionExportRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  getModelVersionExport(
    request: GetModelVersionExportRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  getModelVersionExport(
    request: GetModelVersionExportRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionExportResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get the evaluation metrics for a model version.
   * Deprecated: Use GetEvaluation instead
   *   The server may refuse to accept requests to this endpoint.
   */
  getModelVersionMetrics(
    request: GetModelVersionMetricsRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  getModelVersionMetrics(
    request: GetModelVersionMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  getModelVersionMetrics(
    request: GetModelVersionMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  /**
   * Deprecated, use PostEvaluations instead
   * Run the evaluation metrics for a model version.
   */
  postModelVersionMetrics(
    request: PostModelVersionMetricsRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  postModelVersionMetrics(
    request: PostModelVersionMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  postModelVersionMetrics(
    request: PostModelVersionMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionResponse) => void,
  ): ClientUnaryCall;
  /** Deprecated, use PostEvaluations instead */
  postModelVersionEvaluations(
    request: PostModelVersionEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  postModelVersionEvaluations(
    request: PostModelVersionEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  postModelVersionEvaluations(
    request: PostModelVersionEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Deprecated, use GetEvaluation instead
   * List the evaluation metrics for a model version.
   */
  listModelVersionEvaluations(
    request: ListModelVersionEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  listModelVersionEvaluations(
    request: ListModelVersionEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  listModelVersionEvaluations(
    request: ListModelVersionEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  /**
   * Deprecated, use GetEvaluation instead
   * Get an evaluation metrics for a model version.
   */
  getModelVersionEvaluation(
    request: GetModelVersionEvaluationRequest,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  getModelVersionEvaluation(
    request: GetModelVersionEvaluationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  getModelVersionEvaluation(
    request: GetModelVersionEvaluationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  postEvaluations(
    request: PostEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  postEvaluations(
    request: PostEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  postEvaluations(
    request: PostEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  listEvaluations(
    request: ListEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  listEvaluations(
    request: ListEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  listEvaluations(
    request: ListEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  getEvaluation(
    request: GetEvaluationRequest,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  getEvaluation(
    request: GetEvaluationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  getEvaluation(
    request: GetEvaluationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleEvalMetricsResponse) => void,
  ): ClientUnaryCall;
  /** Lists model references tied to a particular model id. */
  listModelReferences(
    request: ListModelReferencesRequest,
    callback: (error: ServiceError | null, response: MultiModelReferenceResponse) => void,
  ): ClientUnaryCall;
  listModelReferences(
    request: ListModelReferencesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelReferenceResponse) => void,
  ): ClientUnaryCall;
  listModelReferences(
    request: ListModelReferencesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelReferenceResponse) => void,
  ): ClientUnaryCall;
  /** GetModelVersionInputExample */
  getModelVersionInputExample(
    request: GetModelVersionInputExampleRequest,
    callback: (error: ServiceError | null, response: SingleModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  getModelVersionInputExample(
    request: GetModelVersionInputExampleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  getModelVersionInputExample(
    request: GetModelVersionInputExampleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  /** ListModelVersionInputExamples */
  listModelVersionInputExamples(
    request: ListModelVersionInputExamplesRequest,
    callback: (error: ServiceError | null, response: MultiModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  listModelVersionInputExamples(
    request: ListModelVersionInputExamplesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  listModelVersionInputExamples(
    request: ListModelVersionInputExamplesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModelVersionInputExampleResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific workflow from an app. */
  getWorkflow(
    request: GetWorkflowRequest,
    callback: (error: ServiceError | null, response: SingleWorkflowResponse) => void,
  ): ClientUnaryCall;
  getWorkflow(
    request: GetWorkflowRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleWorkflowResponse) => void,
  ): ClientUnaryCall;
  getWorkflow(
    request: GetWorkflowRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleWorkflowResponse) => void,
  ): ClientUnaryCall;
  /** List all the workflows. */
  listWorkflows(
    request: ListWorkflowsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  listWorkflows(
    request: ListWorkflowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  listWorkflows(
    request: ListWorkflowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  /**
   * Add a workflow to an app.
   * Note(zeiler): the order of the workflows that are returned from this endpoint
   * may be different than the order in which the user provides them. This is because
   * we reorder by a sort that optimizes for performance of the graph and its dependencies.
   * When using the workflow in any future call the order returned by this endpoint
   * will be used.
   */
  postWorkflows(
    request: PostWorkflowsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  postWorkflows(
    request: PostWorkflowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  postWorkflows(
    request: PostWorkflowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more workflows. */
  patchWorkflows(
    request: PatchWorkflowsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  patchWorkflows(
    request: PatchWorkflowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  patchWorkflows(
    request: PatchWorkflowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more workflows ids. */
  patchWorkflowIds(
    request: PatchWorkflowIdsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowIds(
    request: PatchWorkflowIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowIds(
    request: PatchWorkflowIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowResponse) => void,
  ): ClientUnaryCall;
  /** Delete a single workflow. */
  deleteWorkflow(
    request: DeleteWorkflowRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflow(
    request: DeleteWorkflowRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflow(
    request: DeleteWorkflowRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple workflows in one request. */
  deleteWorkflows(
    request: DeleteWorkflowsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflows(
    request: DeleteWorkflowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflows(
    request: DeleteWorkflowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Predict using a workflow. */
  postWorkflowResults(
    request: PostWorkflowResultsRequest,
    callback: (error: ServiceError | null, response: PostWorkflowResultsResponse) => void,
  ): ClientUnaryCall;
  postWorkflowResults(
    request: PostWorkflowResultsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PostWorkflowResultsResponse) => void,
  ): ClientUnaryCall;
  postWorkflowResults(
    request: PostWorkflowResultsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PostWorkflowResultsResponse) => void,
  ): ClientUnaryCall;
  /** List workflow versions. */
  listWorkflowVersions(
    request: ListWorkflowVersionsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersions(
    request: ListWorkflowVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersions(
    request: ListWorkflowVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  /** Get single workflow version. */
  getWorkflowVersion(
    request: GetWorkflowVersionRequest,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  getWorkflowVersion(
    request: GetWorkflowVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  getWorkflowVersion(
    request: GetWorkflowVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  /** Delete workflow versions. */
  deleteWorkflowVersions(
    request: DeleteWorkflowVersionsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflowVersions(
    request: DeleteWorkflowVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteWorkflowVersions(
    request: DeleteWorkflowVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Patch workflow versions. */
  patchWorkflowVersions(
    request: PatchWorkflowVersionsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowVersions(
    request: PatchWorkflowVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowVersions(
    request: PatchWorkflowVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific key from an app. */
  getKey(
    request: GetKeyRequest,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  getKey(
    request: GetKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  getKey(
    request: GetKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  /** List all the keys. */
  listKeys(
    request: ListKeysRequest,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  listKeys(
    request: ListKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  listKeys(
    request: ListKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  /** List keys by app_id */
  listAppKeys(
    request: ListAppKeysRequest,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  listAppKeys(
    request: ListAppKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  listAppKeys(
    request: ListAppKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  /**
   * Search over the keys to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteKey(
    request: DeleteKeyRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteKey(
    request: DeleteKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteKey(
    request: DeleteKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Add a key to an app. */
  postKeys(
    request: PostKeysRequest,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  postKeys(
    request: PostKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  postKeys(
    request: PostKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more keys. */
  patchKeys(
    request: PatchKeysRequest,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  patchKeys(
    request: PatchKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  patchKeys(
    request: PatchKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiKeyResponse) => void,
  ): ClientUnaryCall;
  /**
   * API Keys in the public API -- request is itself Key authorized, and will tell
   * the user the scopes/access of the key/credential they're providing, as computed by
   * our authorizer:
   */
  myScopes(
    request: MyScopesRequest,
    callback: (error: ServiceError | null, response: MultiScopeResponse) => void,
  ): ClientUnaryCall;
  myScopes(
    request: MyScopesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiScopeResponse) => void,
  ): ClientUnaryCall;
  myScopes(
    request: MyScopesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiScopeResponse) => void,
  ): ClientUnaryCall;
  myScopesUser(
    request: MyScopesUserRequest,
    callback: (error: ServiceError | null, response: MultiScopeUserResponse) => void,
  ): ClientUnaryCall;
  myScopesUser(
    request: MyScopesUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiScopeUserResponse) => void,
  ): ClientUnaryCall;
  myScopesUser(
    request: MyScopesUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiScopeUserResponse) => void,
  ): ClientUnaryCall;
  myScopesRoot(
    request: MyScopesRootRequest,
    callback: (error: ServiceError | null, response: MultiScopeRootResponse) => void,
  ): ClientUnaryCall;
  myScopesRoot(
    request: MyScopesRootRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiScopeRootResponse) => void,
  ): ClientUnaryCall;
  myScopesRoot(
    request: MyScopesRootRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiScopeRootResponse) => void,
  ): ClientUnaryCall;
  /** List all auth scopes available to me as a user. */
  listScopes(
    request: ListScopesRequest,
    callback: (error: ServiceError | null, response: MultiScopeDepsResponse) => void,
  ): ClientUnaryCall;
  listScopes(
    request: ListScopesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiScopeDepsResponse) => void,
  ): ClientUnaryCall;
  listScopes(
    request: ListScopesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiScopeDepsResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific app from an app. */
  getApp(
    request: GetAppRequest,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  getApp(
    request: GetAppRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  getApp(
    request: GetAppRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  /** List all the apps. */
  listApps(
    request: ListAppsRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  listApps(
    request: ListAppsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  listApps(
    request: ListAppsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /**
   * Search over the apps to find one or more you're looking for.
   * This leverage the "body" parameter because we also have page and
   * per_page as url query param variables in this request.
   */
  deleteApp(
    request: DeleteAppRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteApp(
    request: DeleteAppRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteApp(
    request: DeleteAppRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Add a app to an app.
   * This needs to load the default workflow to make a copy, validating all the models in it, and
   * then writing the new workflow back to this new app.
   */
  postApps(
    request: PostAppsRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  postApps(
    request: PostAppsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  postApps(
    request: PostAppsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more apps. */
  patchApps(
    request: PatchAppsRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchApps(
    request: PatchAppsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchApps(
    request: PatchAppsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /**
   * Allows to Patch only the below fields in one or more apps.
   * Allowed fields are notes, description and image
   */
  patchAppsDetails(
    request: PatchAppsDetailsRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchAppsDetails(
    request: PatchAppsDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchAppsDetails(
    request: PatchAppsDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /** Patch apps ids. */
  patchAppsIds(
    request: PatchAppsIdsRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchAppsIds(
    request: PatchAppsIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  patchAppsIds(
    request: PatchAppsIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /** Patch one app. */
  patchApp(
    request: PatchAppRequest,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  patchApp(
    request: PatchAppRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  patchApp(
    request: PatchAppRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleAppResponse) => void,
  ): ClientUnaryCall;
  /** Search over the applications to find one or more you're looking for. */
  postAppsSearches(
    request: PostAppsSearchesRequest,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  postAppsSearches(
    request: PostAppsSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  postAppsSearches(
    request: PostAppsSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppResponse) => void,
  ): ClientUnaryCall;
  /** Get user information */
  getUser(
    request: GetUserRequest,
    callback: (error: ServiceError | null, response: SingleUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleUserResponse) => void,
  ): ClientUnaryCall;
  /** Validate new password in real-time for a user */
  postValidatePassword(
    request: PostValidatePasswordRequest,
    callback: (error: ServiceError | null, response: SinglePasswordValidationResponse) => void,
  ): ClientUnaryCall;
  postValidatePassword(
    request: PostValidatePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePasswordValidationResponse) => void,
  ): ClientUnaryCall;
  postValidatePassword(
    request: PostValidatePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePasswordValidationResponse) => void,
  ): ClientUnaryCall;
  /** Get a saved legacy search. */
  getSearch(
    request: GetSearchRequest,
    callback: (error: ServiceError | null, response: SingleSearchResponse) => void,
  ): ClientUnaryCall;
  getSearch(
    request: GetSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleSearchResponse) => void,
  ): ClientUnaryCall;
  getSearch(
    request: GetSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleSearchResponse) => void,
  ): ClientUnaryCall;
  /** List all saved legacy searches. */
  listSearches(
    request: ListSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  listSearches(
    request: ListSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  listSearches(
    request: ListSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Patch saved legacy searches by ids. */
  patchSearches(
    request: PatchSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchSearches(
    request: PatchSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  patchSearches(
    request: PatchSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /**
   * Execute a new search and optionally save it.
   *
   * Deprecated: Use PostInputsSearches or PostAnnotationsSearches instead.
   *  The server may refuse to accept requests to this endpoint.
   *
   * @deprecated
   */
  postSearches(
    request: PostSearchesRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postSearches(
    request: PostSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postSearches(
    request: PostSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Execute a previously saved legacy search. */
  postSearchesById(
    request: PostSearchesByIDRequest,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postSearchesById(
    request: PostSearchesByIDRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  postSearchesById(
    request: PostSearchesByIDRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSearchResponse) => void,
  ): ClientUnaryCall;
  /** Evaluate the results of two search requests */
  postAnnotationSearchMetrics(
    request: PostAnnotationSearchMetricsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  postAnnotationSearchMetrics(
    request: PostAnnotationSearchMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  postAnnotationSearchMetrics(
    request: PostAnnotationSearchMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  /** Get the evaluation results between two search requests */
  getAnnotationSearchMetrics(
    request: GetAnnotationSearchMetricsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  getAnnotationSearchMetrics(
    request: GetAnnotationSearchMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  getAnnotationSearchMetrics(
    request: GetAnnotationSearchMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  /** List the evaluation results between two search requests */
  listAnnotationSearchMetrics(
    request: ListAnnotationSearchMetricsRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  listAnnotationSearchMetrics(
    request: ListAnnotationSearchMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  listAnnotationSearchMetrics(
    request: ListAnnotationSearchMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationSearchMetricsResponse) => void,
  ): ClientUnaryCall;
  /** DeleteAnnotationSearchMetrics */
  deleteAnnotationSearchMetrics(
    request: DeleteAnnotationSearchMetricsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationSearchMetrics(
    request: DeleteAnnotationSearchMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationSearchMetrics(
    request: DeleteAnnotationSearchMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Delete a saved search. */
  deleteSearch(
    request: DeleteSearchRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteSearch(
    request: DeleteSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteSearch(
    request: DeleteSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all the annotation filters. */
  listAnnotationFilters(
    request: ListAnnotationFiltersRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  listAnnotationFilters(
    request: ListAnnotationFiltersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  listAnnotationFilters(
    request: ListAnnotationFiltersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific annotation filter. */
  getAnnotationFilter(
    request: GetAnnotationFilterRequest,
    callback: (error: ServiceError | null, response: SingleAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  getAnnotationFilter(
    request: GetAnnotationFilterRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  getAnnotationFilter(
    request: GetAnnotationFilterRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  /** Add annotation filters. */
  postAnnotationFilters(
    request: PostAnnotationFiltersRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  postAnnotationFilters(
    request: PostAnnotationFiltersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  postAnnotationFilters(
    request: PostAnnotationFiltersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more annotation filters. */
  patchAnnotationFilters(
    request: PatchAnnotationFiltersRequest,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationFilters(
    request: PatchAnnotationFiltersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  patchAnnotationFilters(
    request: PatchAnnotationFiltersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAnnotationFilterResponse) => void,
  ): ClientUnaryCall;
  /** Delete one or more annotation filters in a single request. */
  deleteAnnotationFilters(
    request: DeleteAnnotationFiltersRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationFilters(
    request: DeleteAnnotationFiltersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteAnnotationFilters(
    request: DeleteAnnotationFiltersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** List all status codes. */
  listStatusCodes(
    request: ListStatusCodesRequest,
    callback: (error: ServiceError | null, response: MultiStatusCodeResponse) => void,
  ): ClientUnaryCall;
  listStatusCodes(
    request: ListStatusCodesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiStatusCodeResponse) => void,
  ): ClientUnaryCall;
  listStatusCodes(
    request: ListStatusCodesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiStatusCodeResponse) => void,
  ): ClientUnaryCall;
  /** Get more details for a status code. */
  getStatusCode(
    request: GetStatusCodeRequest,
    callback: (error: ServiceError | null, response: SingleStatusCodeResponse) => void,
  ): ClientUnaryCall;
  getStatusCode(
    request: GetStatusCodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleStatusCodeResponse) => void,
  ): ClientUnaryCall;
  getStatusCode(
    request: GetStatusCodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleStatusCodeResponse) => void,
  ): ClientUnaryCall;
  /** owner list users who the app is shared with */
  listCollaborators(
    request: ListCollaboratorsRequest,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  listCollaborators(
    request: ListCollaboratorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  listCollaborators(
    request: ListCollaboratorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  /** add collaborators to an app. */
  postCollaborators(
    request: PostCollaboratorsRequest,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  postCollaborators(
    request: PostCollaboratorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  postCollaborators(
    request: PostCollaboratorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  /** Patch existing collaborators. */
  patchCollaborators(
    request: PatchCollaboratorsRequest,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  patchCollaborators(
    request: PatchCollaboratorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  patchCollaborators(
    request: PatchCollaboratorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollaboratorsResponse) => void,
  ): ClientUnaryCall;
  /** Delete existing collaborators. */
  deleteCollaborators(
    request: DeleteCollaboratorsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteCollaborators(
    request: DeleteCollaboratorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteCollaborators(
    request: DeleteCollaboratorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Collaboration includes the app user are invitied to work on */
  listCollaborations(
    request: ListCollaborationsRequest,
    callback: (error: ServiceError | null, response: MultiCollaborationsResponse) => void,
  ): ClientUnaryCall;
  listCollaborations(
    request: ListCollaborationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollaborationsResponse) => void,
  ): ClientUnaryCall;
  listCollaborations(
    request: ListCollaborationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollaborationsResponse) => void,
  ): ClientUnaryCall;
  /**
   * PostAppDuplications starts async app duplication jobs which copy resources
   * (inputs, annotations, models etc) from one application to another. It can
   * also create the destination application if it does not exist, with fields
   * (description, metadata etc) copied from the source application.
   *
   * A duplication job can be started by any user that can read from the source
   * application (the target of this call) and can create and write to the
   * destination application. The duplication is associated with the user that
   * created it, so in order to read the status and progress of the job, that
   * user's ID has to be used in the call to GetAppDuplication, which might be
   * different to the source application owner ID in this call.
   */
  postAppDuplications(
    request: PostAppDuplicationsRequest,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  postAppDuplications(
    request: PostAppDuplicationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  postAppDuplications(
    request: PostAppDuplicationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  /** ListAppDuplications lists all app duplication jobs created by the user. */
  listAppDuplications(
    request: ListAppDuplicationsRequest,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  listAppDuplications(
    request: ListAppDuplicationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  listAppDuplications(
    request: ListAppDuplicationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAppDuplicationsResponse) => void,
  ): ClientUnaryCall;
  /** GetAppDuplication returns an app duplication job created by the user. */
  getAppDuplication(
    request: GetAppDuplicationRequest,
    callback: (error: ServiceError | null, response: SingleAppDuplicationResponse) => void,
  ): ClientUnaryCall;
  getAppDuplication(
    request: GetAppDuplicationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleAppDuplicationResponse) => void,
  ): ClientUnaryCall;
  getAppDuplication(
    request: GetAppDuplicationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleAppDuplicationResponse) => void,
  ): ClientUnaryCall;
  /** Add tasks to an app. */
  postTasks(
    request: PostTasksRequest,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  postTasks(
    request: PostTasksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  postTasks(
    request: PostTasksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  /** Task annotation count */
  getTaskAnnotationCount(
    request: GetTaskCountRequest,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  getTaskAnnotationCount(
    request: GetTaskCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  getTaskAnnotationCount(
    request: GetTaskCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  /** Task Input count */
  getTaskInputCount(
    request: GetTaskCountRequest,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  getTaskInputCount(
    request: GetTaskCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  getTaskInputCount(
    request: GetTaskCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleTaskCountResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific task from an app. */
  getTask(
    request: GetTaskRequest,
    callback: (error: ServiceError | null, response: SingleTaskResponse) => void,
  ): ClientUnaryCall;
  getTask(
    request: GetTaskRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleTaskResponse) => void,
  ): ClientUnaryCall;
  getTask(
    request: GetTaskRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleTaskResponse) => void,
  ): ClientUnaryCall;
  /** List tasks from an app. */
  listTasks(
    request: ListTasksRequest,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  listTasks(
    request: ListTasksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  listTasks(
    request: ListTasksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more tasks. */
  patchTasks(
    request: PatchTasksRequest,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  patchTasks(
    request: PatchTasksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  patchTasks(
    request: PatchTasksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiTaskResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple tasks in one request. */
  deleteTasks(
    request: DeleteTasksRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteTasks(
    request: DeleteTasksRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteTasks(
    request: DeleteTasksRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Add Label orders. */
  postLabelOrders(
    request: PostLabelOrdersRequest,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  postLabelOrders(
    request: PostLabelOrdersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  postLabelOrders(
    request: PostLabelOrdersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  /** Get a label order. */
  getLabelOrder(
    request: GetLabelOrderRequest,
    callback: (error: ServiceError | null, response: SingleLabelOrderResponse) => void,
  ): ClientUnaryCall;
  getLabelOrder(
    request: GetLabelOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleLabelOrderResponse) => void,
  ): ClientUnaryCall;
  getLabelOrder(
    request: GetLabelOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleLabelOrderResponse) => void,
  ): ClientUnaryCall;
  /** List label orders. */
  listLabelOrders(
    request: ListLabelOrdersRequest,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  listLabelOrders(
    request: ListLabelOrdersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  listLabelOrders(
    request: ListLabelOrdersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more label orders. */
  patchLabelOrders(
    request: PatchLabelOrdersRequest,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  patchLabelOrders(
    request: PatchLabelOrdersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  patchLabelOrders(
    request: PatchLabelOrdersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiLabelOrderResponse) => void,
  ): ClientUnaryCall;
  /**
   * Delete multiple label orders in one request.
   * this do not change task status
   */
  deleteLabelOrders(
    request: DeleteLabelOrdersRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteLabelOrders(
    request: DeleteLabelOrdersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteLabelOrders(
    request: DeleteLabelOrdersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Add a list of Collectors to an app.
   * In the handler of this endpoint we also check for all the scopes of the  POST /inputs
   * endpoint.
   * Those current scopes are listed here as a hard requirement.
   * They are needed when adding the collectors just so we now that you have permission with
   * that key at least to do the writing to this app with POST /inputs.
   */
  postCollectors(
    request: PostCollectorsRequest,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  postCollectors(
    request: PostCollectorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  postCollectors(
    request: PostCollectorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific collector from an app. */
  getCollector(
    request: GetCollectorRequest,
    callback: (error: ServiceError | null, response: SingleCollectorResponse) => void,
  ): ClientUnaryCall;
  getCollector(
    request: GetCollectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleCollectorResponse) => void,
  ): ClientUnaryCall;
  getCollector(
    request: GetCollectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleCollectorResponse) => void,
  ): ClientUnaryCall;
  /** List all the collectors. */
  listCollectors(
    request: ListCollectorsRequest,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  listCollectors(
    request: ListCollectorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  listCollectors(
    request: ListCollectorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more collectors. */
  patchCollectors(
    request: PatchCollectorsRequest,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  patchCollectors(
    request: PatchCollectorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  patchCollectors(
    request: PatchCollectorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCollectorResponse) => void,
  ): ClientUnaryCall;
  /**
   * Delete multiple collectors in one request.
   * This call is asynchronous. Use DeleteCollector if you want a synchronous version.
   */
  deleteCollectors(
    request: DeleteCollectorsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteCollectors(
    request: DeleteCollectorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteCollectors(
    request: DeleteCollectorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** PostStatValues */
  postStatValues(
    request: PostStatValuesRequest,
    callback: (error: ServiceError | null, response: MultiStatValueResponse) => void,
  ): ClientUnaryCall;
  postStatValues(
    request: PostStatValuesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiStatValueResponse) => void,
  ): ClientUnaryCall;
  postStatValues(
    request: PostStatValuesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiStatValueResponse) => void,
  ): ClientUnaryCall;
  /** PostStatValuesAggregate */
  postStatValuesAggregate(
    request: PostStatValuesAggregateRequest,
    callback: (error: ServiceError | null, response: MultiStatValueAggregateResponse) => void,
  ): ClientUnaryCall;
  postStatValuesAggregate(
    request: PostStatValuesAggregateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiStatValueAggregateResponse) => void,
  ): ClientUnaryCall;
  postStatValuesAggregate(
    request: PostStatValuesAggregateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiStatValueAggregateResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific module from an app. */
  getModule(
    request: GetModuleRequest,
    callback: (error: ServiceError | null, response: SingleModuleResponse) => void,
  ): ClientUnaryCall;
  getModule(
    request: GetModuleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModuleResponse) => void,
  ): ClientUnaryCall;
  getModule(
    request: GetModuleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModuleResponse) => void,
  ): ClientUnaryCall;
  /** List all the modules in community, by user or by app. */
  listModules(
    request: ListModulesRequest,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  listModules(
    request: ListModulesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  listModules(
    request: ListModulesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  /** Add a modules to an app. */
  postModules(
    request: PostModulesRequest,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  postModules(
    request: PostModulesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  postModules(
    request: PostModulesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  /** Patch one or more modules. */
  patchModules(
    request: PatchModulesRequest,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  patchModules(
    request: PatchModulesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  patchModules(
    request: PatchModulesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple modules in one request. */
  deleteModules(
    request: DeleteModulesRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModules(
    request: DeleteModulesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModules(
    request: DeleteModulesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Get a specific module version for a module. */
  getModuleVersion(
    request: GetModuleVersionRequest,
    callback: (error: ServiceError | null, response: SingleModuleVersionResponse) => void,
  ): ClientUnaryCall;
  getModuleVersion(
    request: GetModuleVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModuleVersionResponse) => void,
  ): ClientUnaryCall;
  getModuleVersion(
    request: GetModuleVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** List all the modules versions for a given module. */
  listModuleVersions(
    request: ListModuleVersionsRequest,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  listModuleVersions(
    request: ListModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  listModuleVersions(
    request: ListModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** Create a new module version to trigger training of the module. */
  postModuleVersions(
    request: PostModuleVersionsRequest,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  postModuleVersions(
    request: PostModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  postModuleVersions(
    request: PostModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** Modify details of an existing module version. */
  patchModuleVersions(
    request: PatchModuleVersionsRequest,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  patchModuleVersions(
    request: PatchModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  patchModuleVersions(
    request: PatchModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** Delete a multiple module version. */
  deleteModuleVersions(
    request: DeleteModuleVersionsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModuleVersions(
    request: DeleteModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteModuleVersions(
    request: DeleteModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Get usage count for specific module version. */
  getModuleVersionUsageCount(
    request: GetModuleVersionUsageCountRequest,
    callback: (error: ServiceError | null, response: SingleModuleVersionUsageCountResponse) => void,
  ): ClientUnaryCall;
  getModuleVersionUsageCount(
    request: GetModuleVersionUsageCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleModuleVersionUsageCountResponse) => void,
  ): ClientUnaryCall;
  getModuleVersionUsageCount(
    request: GetModuleVersionUsageCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleModuleVersionUsageCountResponse) => void,
  ): ClientUnaryCall;
  /** Get installed modules vesrions for an app. */
  getInstalledModuleVersion(
    request: GetInstalledModuleVersionRequest,
    callback: (error: ServiceError | null, response: SingleInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  getInstalledModuleVersion(
    request: GetInstalledModuleVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  getInstalledModuleVersion(
    request: GetInstalledModuleVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** List installed modules vesrions for an app. */
  listInstalledModuleVersions(
    request: ListInstalledModuleVersionsRequest,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  listInstalledModuleVersions(
    request: ListInstalledModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  listInstalledModuleVersions(
    request: ListInstalledModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /** Install a new module version which will deploy the specific ModuleVersion to the app in the url. */
  postInstalledModuleVersions(
    request: PostInstalledModuleVersionsRequest,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  postInstalledModuleVersions(
    request: PostInstalledModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  postInstalledModuleVersions(
    request: PostInstalledModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInstalledModuleVersionResponse) => void,
  ): ClientUnaryCall;
  /**
   * Uninstall an installed module version which will deploy the specific ModuleVersion to the app
   * in the url.
   * This cleaned up any associated caller keys so needs the Keys_Delete scope.
   */
  deleteInstalledModuleVersions(
    request: DeleteInstalledModuleVersionsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInstalledModuleVersions(
    request: DeleteInstalledModuleVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteInstalledModuleVersions(
    request: DeleteInstalledModuleVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Assign a key that the caller owns to be used when accessing this installed module version
   * If this endpoint is called with a different key then it overwrites what is there.
   */
  postInstalledModuleVersionsKey(
    request: PostInstalledModuleVersionsKeyRequest,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  postInstalledModuleVersionsKey(
    request: PostInstalledModuleVersionsKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  postInstalledModuleVersionsKey(
    request: PostInstalledModuleVersionsKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleKeyResponse) => void,
  ): ClientUnaryCall;
  /**
   * Perform bulk operations on a list of inputs based on input source.
   * Operation include add, update, delete of concepts, metadata and geo data.
   * This is an Asynchronous process. Use ListBulkOperations or GetBulkOperation to check the status.
   */
  postBulkOperations(
    request: PostBulkOperationsRequest,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  postBulkOperations(
    request: PostBulkOperationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  postBulkOperations(
    request: PostBulkOperationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  /** List all the bulk operations */
  listBulkOperations(
    request: ListBulkOperationsRequest,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  listBulkOperations(
    request: ListBulkOperationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  listBulkOperations(
    request: ListBulkOperationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  /** Get the bulk operation details by ID */
  getBulkOperation(
    request: GetBulkOperationRequest,
    callback: (error: ServiceError | null, response: SingleBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  getBulkOperation(
    request: GetBulkOperationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  getBulkOperation(
    request: GetBulkOperationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  /** Cancel one or more bulk operations */
  cancelBulkOperations(
    request: CancelBulkOperationRequest,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  cancelBulkOperations(
    request: CancelBulkOperationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  cancelBulkOperations(
    request: CancelBulkOperationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiBulkOperationsResponse) => void,
  ): ClientUnaryCall;
  /** delete one or more terminated bulk operations */
  deleteBulkOperations(
    request: DeleteBulkOperationRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteBulkOperations(
    request: DeleteBulkOperationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteBulkOperations(
    request: DeleteBulkOperationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Deprecated: Use PutTaskAssignments with action=LABEL_START.
   *   This endpoint has initially been designed as a GET request,
   *   but has been re-designed to serve a PUT logic.
   *   In order to clearly highlight that this endpoint serves a PUT request,
   *   this endpoint has been deprecated and replaced by PutTaskAssignments with action=LABEL_START.
   */
  listNextTaskAssignments(
    request: ListNextTaskAssignmentsRequest,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listNextTaskAssignments(
    request: ListNextTaskAssignmentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  listNextTaskAssignments(
    request: ListNextTaskAssignmentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputResponse) => void,
  ): ClientUnaryCall;
  /**
   * PutTaskAssignments performs an idempotent action for the task assignments in given task.
   * See PutTaskAssignmentsRequestAction for more details about possible actions.
   */
  putTaskAssignments(
    request: PutTaskAssignmentsRequest,
    callback: (error: ServiceError | null, response: MultiTaskAssignmentResponse) => void,
  ): ClientUnaryCall;
  putTaskAssignments(
    request: PutTaskAssignmentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiTaskAssignmentResponse) => void,
  ): ClientUnaryCall;
  putTaskAssignments(
    request: PutTaskAssignmentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiTaskAssignmentResponse) => void,
  ): ClientUnaryCall;
  /** List all the inputs add jobs */
  listInputsAddJobs(
    request: ListInputsAddJobsRequest,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  listInputsAddJobs(
    request: ListInputsAddJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  listInputsAddJobs(
    request: ListInputsAddJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  /** Get the input add job details by ID */
  getInputsAddJob(
    request: GetInputsAddJobRequest,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  getInputsAddJob(
    request: GetInputsAddJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  getInputsAddJob(
    request: GetInputsAddJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  /** cancel the input add job by ID */
  cancelInputsAddJob(
    request: CancelInputsAddJobRequest,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  cancelInputsAddJob(
    request: CancelInputsAddJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  cancelInputsAddJob(
    request: CancelInputsAddJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  /**
   * PostUploads is used to upload files. Note that this does not create inputs.
   * returns job with uploadID, job has UPLOAD_IN_PROGRESS status
   * Actual upload content can be done in multiple calls with PutUploadContentParts
   * You can get status of upload with GetUpload or ListUploads endpoints
   * See also PostInputsUploads
   */
  postUploads(
    request: PostUploadsRequest,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  postUploads(
    request: PostUploadsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  postUploads(
    request: PostUploadsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  /**
   * Upload a part of a multipart upload.
   * Behaviour on completion depends on the endpoint that was used to initiate the upload.
   */
  putUploadContentParts(
    request: PutUploadContentPartsRequest,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  putUploadContentParts(
    request: PutUploadContentPartsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  putUploadContentParts(
    request: PutUploadContentPartsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  getUpload(
    request: GetUploadRequest,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  getUpload(
    request: GetUploadRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  getUpload(
    request: GetUploadRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleUploadResponse) => void,
  ): ClientUnaryCall;
  listUploads(
    request: ListUploadsRequest,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  listUploads(
    request: ListUploadsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  listUploads(
    request: ListUploadsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiUploadResponse) => void,
  ): ClientUnaryCall;
  deleteUploads(
    request: DeleteUploadsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteUploads(
    request: DeleteUploadsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteUploads(
    request: DeleteUploadsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * Initiates retrieval of inputs from cloud storage from a user provided data source.
   * Will create and return an inputs-add-job for tracking progress.
   * Archives will be extracted and their contents will be processed as inputs.
   *
   * The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
   * files in the images_folder beginning with abc or in a subfolder beginning with abc.
   * For example:
   * bucket/images_folder/abcImage.png
   * bucket/images_folder/abc-1/Data.zip
   *
   * If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
   * Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
   * in which case it only requires rights to access that particular file.
   */
  postInputsDataSources(
    request: PostInputsDataSourcesRequest,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  postInputsDataSources(
    request: PostInputsDataSourcesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  postInputsDataSources(
    request: PostInputsDataSourcesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  /** Get the input extraction job details by ID */
  getInputsExtractionJob(
    request: GetInputsExtractionJobRequest,
    callback: (error: ServiceError | null, response: SingleInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  getInputsExtractionJob(
    request: GetInputsExtractionJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  getInputsExtractionJob(
    request: GetInputsExtractionJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  /** List all the input extraction jobs */
  listInputsExtractionJobs(
    request: ListInputsExtractionJobsRequest,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  listInputsExtractionJobs(
    request: ListInputsExtractionJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  listInputsExtractionJobs(
    request: ListInputsExtractionJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  cancelInputsExtractionJobs(
    request: CancelInputsExtractionJobsRequest,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  cancelInputsExtractionJobs(
    request: CancelInputsExtractionJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  cancelInputsExtractionJobs(
    request: CancelInputsExtractionJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputsExtractionJobResponse) => void,
  ): ClientUnaryCall;
  /**
   * Create new upload job with a file archive containing inputs (images, videos, text, audio)
   * Actual file upload happens in next steps by calling `PutUploadContentParts` endpoint
   * and providing the file content in the request body.
   * This endpoint creates and return an inputs-add-job which contains an upload id needed for upload and further status tracking
   * Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
   * See also GetInputsAddJob and then GetInputsExtractionJob
   */
  postInputsUploads(
    request: PostInputsUploadsRequest,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  postInputsUploads(
    request: PostInputsUploadsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  postInputsUploads(
    request: PostInputsUploadsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInputsAddJobResponse) => void,
  ): ClientUnaryCall;
  /** putting above the Get Nodepool endpoint to make it appear above the other one */
  listPipelineVersionRuns(
    request: ListPipelineVersionRunsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  listPipelineVersionRuns(
    request: ListPipelineVersionRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  listPipelineVersionRuns(
    request: ListPipelineVersionRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  /**
   * Get a specific runner.
   * TODO(zeiler): runner_id is a UUID so can list globally as well.
   */
  getRunner(
    request: GetRunnerRequest,
    callback: (error: ServiceError | null, response: SingleRunnerResponse) => void,
  ): ClientUnaryCall;
  getRunner(
    request: GetRunnerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleRunnerResponse) => void,
  ): ClientUnaryCall;
  getRunner(
    request: GetRunnerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleRunnerResponse) => void,
  ): ClientUnaryCall;
  /** List all the runners for the user. */
  listRunners(
    request: ListRunnersRequest,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  listRunners(
    request: ListRunnersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  listRunners(
    request: ListRunnersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  /** Add a runners to a user. */
  postRunners(
    request: PostRunnersRequest,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  postRunners(
    request: PostRunnersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  postRunners(
    request: PostRunnersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  /** Patch runners of a user. */
  patchRunners(
    request: PatchRunnersRequest,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  patchRunners(
    request: PatchRunnersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  patchRunners(
    request: PatchRunnersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiRunnerResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple runners in one request. */
  deleteRunners(
    request: DeleteRunnersRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteRunners(
    request: DeleteRunnersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteRunners(
    request: DeleteRunnersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /**
   * List items for the remote runner to work on.
   * since the runner_id is a UUID we can access it directly too.
   */
  listRunnerItems(
    request: ListRunnerItemsRequest,
    callback: (error: ServiceError | null, response: MultiRunnerItemResponse) => void,
  ): ClientUnaryCall;
  listRunnerItems(
    request: ListRunnerItemsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiRunnerItemResponse) => void,
  ): ClientUnaryCall;
  listRunnerItems(
    request: ListRunnerItemsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiRunnerItemResponse) => void,
  ): ClientUnaryCall;
  /**
   * Post back outputs from remote runners
   * since the runner_id is a UUID we can access it directly too.
   */
  postRunnerItemOutputs(
    request: PostRunnerItemOutputsRequest,
    callback: (error: ServiceError | null, response: MultiRunnerItemOutputResponse) => void,
  ): ClientUnaryCall;
  postRunnerItemOutputs(
    request: PostRunnerItemOutputsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiRunnerItemOutputResponse) => void,
  ): ClientUnaryCall;
  postRunnerItemOutputs(
    request: PostRunnerItemOutputsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiRunnerItemOutputResponse) => void,
  ): ClientUnaryCall;
  /**
   * This maintains a single request for asking the API if there is any work to be done, processing
   * it and streaming back results.
   * To do that first handshake the MultiRunnerItemOutputResponse will have RUNNER_STREAM_START
   * status filled in so that the API knows to respond with a MultiRunnerItemResponse.
   * For now there will only be one of those if the model prediction only has one request.
   * NOTE(zeiler): downside of this is you can't use HTTP REST requests to do runner work.
   */
  processRunnerItems(): ClientDuplexStream<PostRunnerItemOutputsRequest, MultiRunnerItemResponse>;
  processRunnerItems(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<PostRunnerItemOutputsRequest, MultiRunnerItemResponse>;
  processRunnerItems(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<PostRunnerItemOutputsRequest, MultiRunnerItemResponse>;
  /** Get the training time estimate based off train request and estimated input count. */
  postModelVersionsTrainingTimeEstimate(
    request: PostModelVersionsTrainingTimeEstimateRequest,
    callback: (error: ServiceError | null, response: MultiTrainingTimeEstimateResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsTrainingTimeEstimate(
    request: PostModelVersionsTrainingTimeEstimateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiTrainingTimeEstimateResponse) => void,
  ): ClientUnaryCall;
  postModelVersionsTrainingTimeEstimate(
    request: PostModelVersionsTrainingTimeEstimateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiTrainingTimeEstimateResponse) => void,
  ): ClientUnaryCall;
  /** List Available Cloud Providers */
  listCloudProviders(
    request: ListCloudProvidersRequest,
    callback: (error: ServiceError | null, response: MultiCloudProviderResponse) => void,
  ): ClientUnaryCall;
  listCloudProviders(
    request: ListCloudProvidersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCloudProviderResponse) => void,
  ): ClientUnaryCall;
  listCloudProviders(
    request: ListCloudProvidersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCloudProviderResponse) => void,
  ): ClientUnaryCall;
  /** List Regions for given Cloud Provider */
  listCloudRegions(
    request: ListCloudRegionsRequest,
    callback: (error: ServiceError | null, response: MultiCloudRegionResponse) => void,
  ): ClientUnaryCall;
  listCloudRegions(
    request: ListCloudRegionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiCloudRegionResponse) => void,
  ): ClientUnaryCall;
  listCloudRegions(
    request: ListCloudRegionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiCloudRegionResponse) => void,
  ): ClientUnaryCall;
  /** Get InstanceTypes given Cloud Provider and Region */
  listInstanceTypes(
    request: ListInstanceTypesRequest,
    callback: (error: ServiceError | null, response: MultiInstanceTypeResponse) => void,
  ): ClientUnaryCall;
  listInstanceTypes(
    request: ListInstanceTypesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiInstanceTypeResponse) => void,
  ): ClientUnaryCall;
  listInstanceTypes(
    request: ListInstanceTypesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiInstanceTypeResponse) => void,
  ): ClientUnaryCall;
  /** ComputeCluster CRUD */
  getComputeCluster(
    request: GetComputeClusterRequest,
    callback: (error: ServiceError | null, response: SingleComputeClusterResponse) => void,
  ): ClientUnaryCall;
  getComputeCluster(
    request: GetComputeClusterRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleComputeClusterResponse) => void,
  ): ClientUnaryCall;
  getComputeCluster(
    request: GetComputeClusterRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleComputeClusterResponse) => void,
  ): ClientUnaryCall;
  listComputeClusters(
    request: ListComputeClustersRequest,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  listComputeClusters(
    request: ListComputeClustersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  listComputeClusters(
    request: ListComputeClustersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  postComputeClusters(
    request: PostComputeClustersRequest,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  postComputeClusters(
    request: PostComputeClustersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  postComputeClusters(
    request: PostComputeClustersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiComputeClusterResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple compute_clusters in one request. */
  deleteComputeClusters(
    request: DeleteComputeClustersRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteComputeClusters(
    request: DeleteComputeClustersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteComputeClusters(
    request: DeleteComputeClustersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Nodepools CRUD */
  getNodepool(
    request: GetNodepoolRequest,
    callback: (error: ServiceError | null, response: SingleNodepoolResponse) => void,
  ): ClientUnaryCall;
  getNodepool(
    request: GetNodepoolRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleNodepoolResponse) => void,
  ): ClientUnaryCall;
  getNodepool(
    request: GetNodepoolRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleNodepoolResponse) => void,
  ): ClientUnaryCall;
  listNodepools(
    request: ListNodepoolsRequest,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  listNodepools(
    request: ListNodepoolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  listNodepools(
    request: ListNodepoolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  postNodepools(
    request: PostNodepoolsRequest,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  postNodepools(
    request: PostNodepoolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  postNodepools(
    request: PostNodepoolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  patchNodepools(
    request: PatchNodepoolsRequest,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  patchNodepools(
    request: PatchNodepoolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  patchNodepools(
    request: PatchNodepoolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiNodepoolResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple nodepools in one request. */
  deleteNodepools(
    request: DeleteNodepoolsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteNodepools(
    request: DeleteNodepoolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteNodepools(
    request: DeleteNodepoolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  /** Deployments CRUD */
  getDeployment(
    request: GetDeploymentRequest,
    callback: (error: ServiceError | null, response: SingleDeploymentResponse) => void,
  ): ClientUnaryCall;
  getDeployment(
    request: GetDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleDeploymentResponse) => void,
  ): ClientUnaryCall;
  getDeployment(
    request: GetDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleDeploymentResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  postDeployments(
    request: PostDeploymentsRequest,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  postDeployments(
    request: PostDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  postDeployments(
    request: PostDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  patchDeployments(
    request: PatchDeploymentsRequest,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  patchDeployments(
    request: PatchDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  patchDeployments(
    request: PatchDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiDeploymentResponse) => void,
  ): ClientUnaryCall;
  /** Delete multiple deployments in one request. */
  deleteDeployments(
    request: DeleteDeploymentsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDeployments(
    request: DeleteDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deleteDeployments(
    request: DeleteDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postAuditLogSearches(
    request: PostAuditLogSearchesRequest,
    callback: (error: ServiceError | null, response: MultiAuditLogEntryResponse) => void,
  ): ClientUnaryCall;
  postAuditLogSearches(
    request: PostAuditLogSearchesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiAuditLogEntryResponse) => void,
  ): ClientUnaryCall;
  postAuditLogSearches(
    request: PostAuditLogSearchesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiAuditLogEntryResponse) => void,
  ): ClientUnaryCall;
  listWorkflowEvaluationTemplates(
    request: ListWorkflowEvaluationTemplatesRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowEvaluationTemplateResponse) => void,
  ): ClientUnaryCall;
  listWorkflowEvaluationTemplates(
    request: ListWorkflowEvaluationTemplatesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowEvaluationTemplateResponse) => void,
  ): ClientUnaryCall;
  listWorkflowEvaluationTemplates(
    request: ListWorkflowEvaluationTemplatesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowEvaluationTemplateResponse) => void,
  ): ClientUnaryCall;
  postLogEntries(
    request: PostLogEntriesRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postLogEntries(
    request: PostLogEntriesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postLogEntries(
    request: PostLogEntriesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  listLogEntries(
    request: ListLogEntriesRequest,
    callback: (error: ServiceError | null, response: MultiLogEntryResponse) => void,
  ): ClientUnaryCall;
  listLogEntries(
    request: ListLogEntriesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiLogEntryResponse) => void,
  ): ClientUnaryCall;
  listLogEntries(
    request: ListLogEntriesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiLogEntryResponse) => void,
  ): ClientUnaryCall;
  streamLogEntries(
    request: StreamLogEntriesRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MultiLogEntryResponse>;
  streamLogEntries(
    request: StreamLogEntriesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MultiLogEntryResponse>;
  postComputePlaneMetrics(
    request: PostComputePlaneMetricsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postComputePlaneMetrics(
    request: PostComputePlaneMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postComputePlaneMetrics(
    request: PostComputePlaneMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluations(
    request: PostWorkflowVersionEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluations(
    request: PostWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluations(
    request: PostWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  getWorkflowVersionEvaluation(
    request: GetWorkflowVersionEvaluationRequest,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  getWorkflowVersionEvaluation(
    request: GetWorkflowVersionEvaluationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  getWorkflowVersionEvaluation(
    request: GetWorkflowVersionEvaluationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluations(
    request: ListWorkflowVersionEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluations(
    request: ListWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluations(
    request: ListWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowVersionEvaluations(
    request: PatchWorkflowVersionEvaluationsRequest,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowVersionEvaluations(
    request: PatchWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  patchWorkflowVersionEvaluations(
    request: PatchWorkflowVersionEvaluationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiWorkflowVersionEvaluationResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluationData(
    request: ListWorkflowVersionEvaluationDataRequest,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluationData(
    request: ListWorkflowVersionEvaluationDataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  listWorkflowVersionEvaluationData(
    request: ListWorkflowVersionEvaluationDataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluationData(
    request: PostWorkflowVersionEvaluationDataRequest,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluationData(
    request: PostWorkflowVersionEvaluationDataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  postWorkflowVersionEvaluationData(
    request: PostWorkflowVersionEvaluationDataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiListWorkflowVersionEvaluationDataResponse) => void,
  ): ClientUnaryCall;
  postPipelines(
    request: PostPipelinesRequest,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  postPipelines(
    request: PostPipelinesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  postPipelines(
    request: PostPipelinesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    callback: (error: ServiceError | null, response: SinglePipelineResponse) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePipelineResponse) => void,
  ): ClientUnaryCall;
  getPipeline(
    request: GetPipelineRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePipelineResponse) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  listPipelines(
    request: ListPipelinesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  patchPipelines(
    request: PatchPipelinesRequest,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  patchPipelines(
    request: PatchPipelinesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  patchPipelines(
    request: PatchPipelinesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineResponse) => void,
  ): ClientUnaryCall;
  deletePipelines(
    request: DeletePipelinesRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deletePipelines(
    request: DeletePipelinesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deletePipelines(
    request: DeletePipelinesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersion(
    request: GetPipelineVersionRequest,
    callback: (error: ServiceError | null, response: SinglePipelineVersionResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersion(
    request: GetPipelineVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePipelineVersionResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersion(
    request: GetPipelineVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePipelineVersionResponse) => void,
  ): ClientUnaryCall;
  listPipelineVersions(
    request: ListPipelineVersionsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  listPipelineVersions(
    request: ListPipelineVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  listPipelineVersions(
    request: ListPipelineVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersions(
    request: PatchPipelineVersionsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersions(
    request: PatchPipelineVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersions(
    request: PatchPipelineVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineVersionResponse) => void,
  ): ClientUnaryCall;
  deletePipelineVersions(
    request: DeletePipelineVersionsRequest,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deletePipelineVersions(
    request: DeletePipelineVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  deletePipelineVersions(
    request: DeletePipelineVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BaseResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersionRun(
    request: GetPipelineVersionRunRequest,
    callback: (error: ServiceError | null, response: SinglePipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersionRun(
    request: GetPipelineVersionRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  getPipelineVersionRun(
    request: GetPipelineVersionRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  postPipelineVersionRuns(
    request: PostPipelineVersionRunsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  postPipelineVersionRuns(
    request: PostPipelineVersionRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  postPipelineVersionRuns(
    request: PostPipelineVersionRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersionRuns(
    request: PatchPipelineVersionRunsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersionRuns(
    request: PatchPipelineVersionRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  patchPipelineVersionRuns(
    request: PatchPipelineVersionRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineVersionRunResponse) => void,
  ): ClientUnaryCall;
  postPipelineSteps(
    request: PostPipelineStepsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  postPipelineSteps(
    request: PostPipelineStepsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  postPipelineSteps(
    request: PostPipelineStepsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  getPipelineStep(
    request: GetPipelineStepRequest,
    callback: (error: ServiceError | null, response: SinglePipelineStepResponse) => void,
  ): ClientUnaryCall;
  getPipelineStep(
    request: GetPipelineStepRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePipelineStepResponse) => void,
  ): ClientUnaryCall;
  getPipelineStep(
    request: GetPipelineStepRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePipelineStepResponse) => void,
  ): ClientUnaryCall;
  listPipelineSteps(
    request: ListPipelineStepsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  listPipelineSteps(
    request: ListPipelineStepsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  listPipelineSteps(
    request: ListPipelineStepsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineStepResponse) => void,
  ): ClientUnaryCall;
  /**
   * This is a streaming endpoint, the request has a field, upload_data, which can either be the config for the upload or the actual data to upload.
   * The config must be sent first before the pipeline_step_bytes can be uploaded.
   * Once the config has been sent, the server will respond with a confirmation containing the pipeline_step_version_id.
   * This is so that if your upload is interrupted, you can resume the upload by sending the config again with the pipeline_step_version_id specified for your pipeline_step_version.
   * The actual upload will be done via a multipart upload, the latest successful part_id will be sent from the server in the response to the pipeline_step_bytes.
   */
  postPipelineStepVersionsUpload(): ClientDuplexStream<
    PostPipelineStepVersionsUploadRequest,
    PostPipelineStepVersionsUploadResponse
  >;
  postPipelineStepVersionsUpload(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<PostPipelineStepVersionsUploadRequest, PostPipelineStepVersionsUploadResponse>;
  postPipelineStepVersionsUpload(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<PostPipelineStepVersionsUploadRequest, PostPipelineStepVersionsUploadResponse>;
  listPipelineStepVersions(
    request: ListPipelineStepVersionsRequest,
    callback: (error: ServiceError | null, response: MultiPipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  listPipelineStepVersions(
    request: ListPipelineStepVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiPipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  listPipelineStepVersions(
    request: ListPipelineStepVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiPipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  getPipelineStepVersion(
    request: GetPipelineStepVersionRequest,
    callback: (error: ServiceError | null, response: SinglePipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  getPipelineStepVersion(
    request: GetPipelineStepVersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SinglePipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  getPipelineStepVersion(
    request: GetPipelineStepVersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SinglePipelineStepVersionResponse) => void,
  ): ClientUnaryCall;
  getSecret(
    request: GetSecretRequest,
    callback: (error: ServiceError | null, response: SingleSecretResponse) => void,
  ): ClientUnaryCall;
  getSecret(
    request: GetSecretRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SingleSecretResponse) => void,
  ): ClientUnaryCall;
  getSecret(
    request: GetSecretRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SingleSecretResponse) => void,
  ): ClientUnaryCall;
  listSecrets(
    request: ListSecretsRequest,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  listSecrets(
    request: ListSecretsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  listSecrets(
    request: ListSecretsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  postSecrets(
    request: PostSecretsRequest,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  postSecrets(
    request: PostSecretsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  postSecrets(
    request: PostSecretsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  patchSecrets(
    request: PatchSecretsRequest,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  patchSecrets(
    request: PatchSecretsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  patchSecrets(
    request: PatchSecretsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  deleteSecrets(
    request: DeleteSecretsRequest,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  deleteSecrets(
    request: DeleteSecretsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
  deleteSecrets(
    request: DeleteSecretsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MultiSecretResponse) => void,
  ): ClientUnaryCall;
}

export const V2Client = makeGenericClientConstructor(V2Service, "clarifai.api.V2") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): V2Client;
  service: typeof V2Service;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
