// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: proto/clarifai/api/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct, Value } from "../../../google/protobuf/struct";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { BoolValue, Int32Value, UInt64Value } from "../../../google/protobuf/wrappers";
import { Status } from "./status/status";
import { StatusCode, statusCodeFromJSON, statusCodeToJSON } from "./status/status_code";
import { MatrixUint64 } from "./utils/matrix";

export const protobufPackage = "clarifai.api";

export enum WorkflowModelUseCase {
  WORKFLOW_MODEL_USE_CASE_NOT_SET = 0,
  /**
   * CLASSIFICATION - Classifier models without a detector parent (recursive check) in a workflow
   * are used for classification.
   */
  CLASSIFICATION = 1,
  /**
   * DETECTION - Detector models in a workflow are used for detection.
   * Classifier models that run after a detector model are also used for detection.
   */
  DETECTION = 2,
  UNRECOGNIZED = -1,
}

export function workflowModelUseCaseFromJSON(object: any): WorkflowModelUseCase {
  switch (object) {
    case 0:
    case "WORKFLOW_MODEL_USE_CASE_NOT_SET":
      return WorkflowModelUseCase.WORKFLOW_MODEL_USE_CASE_NOT_SET;
    case 1:
    case "CLASSIFICATION":
      return WorkflowModelUseCase.CLASSIFICATION;
    case 2:
    case "DETECTION":
      return WorkflowModelUseCase.DETECTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowModelUseCase.UNRECOGNIZED;
  }
}

export function workflowModelUseCaseToJSON(object: WorkflowModelUseCase): string {
  switch (object) {
    case WorkflowModelUseCase.WORKFLOW_MODEL_USE_CASE_NOT_SET:
      return "WORKFLOW_MODEL_USE_CASE_NOT_SET";
    case WorkflowModelUseCase.CLASSIFICATION:
      return "CLASSIFICATION";
    case WorkflowModelUseCase.DETECTION:
      return "DETECTION";
    case WorkflowModelUseCase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DatasetVersionRequestOrigin {
  DATASET_VERSION_REQUEST_ORIGIN_NOT_SET = 0,
  MANUAL = 1,
  TRAINING = 2,
  EVAL_GROUND_TRUTH = 3,
  EVAL_PREDICTIONS = 4,
  UNRECOGNIZED = -1,
}

export function datasetVersionRequestOriginFromJSON(object: any): DatasetVersionRequestOrigin {
  switch (object) {
    case 0:
    case "DATASET_VERSION_REQUEST_ORIGIN_NOT_SET":
      return DatasetVersionRequestOrigin.DATASET_VERSION_REQUEST_ORIGIN_NOT_SET;
    case 1:
    case "MANUAL":
      return DatasetVersionRequestOrigin.MANUAL;
    case 2:
    case "TRAINING":
      return DatasetVersionRequestOrigin.TRAINING;
    case 3:
    case "EVAL_GROUND_TRUTH":
      return DatasetVersionRequestOrigin.EVAL_GROUND_TRUTH;
    case 4:
    case "EVAL_PREDICTIONS":
      return DatasetVersionRequestOrigin.EVAL_PREDICTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatasetVersionRequestOrigin.UNRECOGNIZED;
  }
}

export function datasetVersionRequestOriginToJSON(object: DatasetVersionRequestOrigin): string {
  switch (object) {
    case DatasetVersionRequestOrigin.DATASET_VERSION_REQUEST_ORIGIN_NOT_SET:
      return "DATASET_VERSION_REQUEST_ORIGIN_NOT_SET";
    case DatasetVersionRequestOrigin.MANUAL:
      return "MANUAL";
    case DatasetVersionRequestOrigin.TRAINING:
      return "TRAINING";
    case DatasetVersionRequestOrigin.EVAL_GROUND_TRUTH:
      return "EVAL_GROUND_TRUTH";
    case DatasetVersionRequestOrigin.EVAL_PREDICTIONS:
      return "EVAL_PREDICTIONS";
    case DatasetVersionRequestOrigin.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DatasetVersionMetricsGroupType {
  DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET = 0,
  /**
   * INPUT_TYPE - Group data examples by input type.
   * Examples: images, videos, text, audio.
   */
  INPUT_TYPE = 2,
  /**
   * CONCEPT_ID - Group data examples by concept ID.
   * Examples: inputs with cat concept, inputs with dog concept.
   */
  CONCEPT_ID = 10,
  /**
   * CONCEPTS_COUNT - Group data examples by concepts count.
   * Examples: inputs with 20 concepts, inputs with 21 concepts.
   */
  CONCEPTS_COUNT = 11,
  /**
   * BOUNDING_BOXES_COUNT - Group data examples by bounding boxes count.
   * Examples: inputs with 20 bounding boxes, inputs with 21 bounding boxes.
   */
  BOUNDING_BOXES_COUNT = 20,
  /**
   * POLYGONS_COUNT - Group data examples by polygons count.
   * Examples: inputs with 20 polygons, inputs with 21 polygons.
   */
  POLYGONS_COUNT = 21,
  /**
   * POINTS_COUNT - Group data examples by points count.
   * Examples: inputs with 20 points, inputs with 21 points.
   */
  POINTS_COUNT = 22,
  /**
   * MASKS_COUNT - Group data examples by masks count.
   * Examples: inputs with 20 masks, inputs with 21 masks.
   */
  MASKS_COUNT = 23,
  /**
   * PIXELS_COUNT - Group data examples by pixels count.
   * In order to reduce the number of groups, we use bins.
   * Examples for bin size = 400: inputs with [200000, 200400) pixels, inputs with [200400, 200800) pixels.
   */
  PIXELS_COUNT = 30,
  /**
   * ASPECT_RATIO - Group data examples by aspect ratio.
   * In order to reduce the number of groups, we use bins.
   * Examples for bin size = 0.1: inputs with [0.5, 0.6) aspect ratio, inputs with [0.6, 0.7) aspect ratio.
   */
  ASPECT_RATIO = 31,
  UNRECOGNIZED = -1,
}

export function datasetVersionMetricsGroupTypeFromJSON(object: any): DatasetVersionMetricsGroupType {
  switch (object) {
    case 0:
    case "DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET":
      return DatasetVersionMetricsGroupType.DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET;
    case 2:
    case "INPUT_TYPE":
      return DatasetVersionMetricsGroupType.INPUT_TYPE;
    case 10:
    case "CONCEPT_ID":
      return DatasetVersionMetricsGroupType.CONCEPT_ID;
    case 11:
    case "CONCEPTS_COUNT":
      return DatasetVersionMetricsGroupType.CONCEPTS_COUNT;
    case 20:
    case "BOUNDING_BOXES_COUNT":
      return DatasetVersionMetricsGroupType.BOUNDING_BOXES_COUNT;
    case 21:
    case "POLYGONS_COUNT":
      return DatasetVersionMetricsGroupType.POLYGONS_COUNT;
    case 22:
    case "POINTS_COUNT":
      return DatasetVersionMetricsGroupType.POINTS_COUNT;
    case 23:
    case "MASKS_COUNT":
      return DatasetVersionMetricsGroupType.MASKS_COUNT;
    case 30:
    case "PIXELS_COUNT":
      return DatasetVersionMetricsGroupType.PIXELS_COUNT;
    case 31:
    case "ASPECT_RATIO":
      return DatasetVersionMetricsGroupType.ASPECT_RATIO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatasetVersionMetricsGroupType.UNRECOGNIZED;
  }
}

export function datasetVersionMetricsGroupTypeToJSON(object: DatasetVersionMetricsGroupType): string {
  switch (object) {
    case DatasetVersionMetricsGroupType.DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET:
      return "DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET";
    case DatasetVersionMetricsGroupType.INPUT_TYPE:
      return "INPUT_TYPE";
    case DatasetVersionMetricsGroupType.CONCEPT_ID:
      return "CONCEPT_ID";
    case DatasetVersionMetricsGroupType.CONCEPTS_COUNT:
      return "CONCEPTS_COUNT";
    case DatasetVersionMetricsGroupType.BOUNDING_BOXES_COUNT:
      return "BOUNDING_BOXES_COUNT";
    case DatasetVersionMetricsGroupType.POLYGONS_COUNT:
      return "POLYGONS_COUNT";
    case DatasetVersionMetricsGroupType.POINTS_COUNT:
      return "POINTS_COUNT";
    case DatasetVersionMetricsGroupType.MASKS_COUNT:
      return "MASKS_COUNT";
    case DatasetVersionMetricsGroupType.PIXELS_COUNT:
      return "PIXELS_COUNT";
    case DatasetVersionMetricsGroupType.ASPECT_RATIO:
      return "ASPECT_RATIO";
    case DatasetVersionMetricsGroupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DatasetVersionExportFormat {
  DATASET_VERSION_EXPORT_FORMAT_NOT_SET = 0,
  /**
   * CLARIFAI_DATA_PROTOBUF - CLARIFAI_DATA_PROTOBUF is the proprietary Clarifai API Data format. It
   * is a ZIP-archive containing batches of serialized InputBatch protobuf messages.
   *
   * Note that only the "id" and "data" fields of exported inputs are set.
   */
  CLARIFAI_DATA_PROTOBUF = 1,
  /**
   * CLARIFAI_DATA_JSON - CLARIFAI_DATA_JSON is the proprietary Clarifai API Data format in JSON. It
   * is a ZIP-archive containing batches of serialized InputBatch JSON messages.
   *
   * Note that only the "id" and "data" fields of exported inputs are set.
   */
  CLARIFAI_DATA_JSON = 3,
  /**
   * COCO - COCO is the data format used by Common Objects in Context. It is a
   * ZIP-archive containing JSON files with the dataset version annotations.
   * See https://cocodataset.org/#format-data.
   */
  COCO = 2,
  UNRECOGNIZED = -1,
}

export function datasetVersionExportFormatFromJSON(object: any): DatasetVersionExportFormat {
  switch (object) {
    case 0:
    case "DATASET_VERSION_EXPORT_FORMAT_NOT_SET":
      return DatasetVersionExportFormat.DATASET_VERSION_EXPORT_FORMAT_NOT_SET;
    case 1:
    case "CLARIFAI_DATA_PROTOBUF":
      return DatasetVersionExportFormat.CLARIFAI_DATA_PROTOBUF;
    case 3:
    case "CLARIFAI_DATA_JSON":
      return DatasetVersionExportFormat.CLARIFAI_DATA_JSON;
    case 2:
    case "COCO":
      return DatasetVersionExportFormat.COCO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatasetVersionExportFormat.UNRECOGNIZED;
  }
}

export function datasetVersionExportFormatToJSON(object: DatasetVersionExportFormat): string {
  switch (object) {
    case DatasetVersionExportFormat.DATASET_VERSION_EXPORT_FORMAT_NOT_SET:
      return "DATASET_VERSION_EXPORT_FORMAT_NOT_SET";
    case DatasetVersionExportFormat.CLARIFAI_DATA_PROTOBUF:
      return "CLARIFAI_DATA_PROTOBUF";
    case DatasetVersionExportFormat.CLARIFAI_DATA_JSON:
      return "CLARIFAI_DATA_JSON";
    case DatasetVersionExportFormat.COCO:
      return "COCO";
    case DatasetVersionExportFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExpirationAction {
  EXPIRATION_ACTION_NOT_SET = 0,
  /** DELAY - Progressively delay the execution of operations */
  DELAY = 1,
  /** EXPIRY - Cease functioning */
  EXPIRY = 2,
  UNRECOGNIZED = -1,
}

export function expirationActionFromJSON(object: any): ExpirationAction {
  switch (object) {
    case 0:
    case "EXPIRATION_ACTION_NOT_SET":
      return ExpirationAction.EXPIRATION_ACTION_NOT_SET;
    case 1:
    case "DELAY":
      return ExpirationAction.DELAY;
    case 2:
    case "EXPIRY":
      return ExpirationAction.EXPIRY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExpirationAction.UNRECOGNIZED;
  }
}

export function expirationActionToJSON(object: ExpirationAction): string {
  switch (object) {
    case ExpirationAction.EXPIRATION_ACTION_NOT_SET:
      return "EXPIRATION_ACTION_NOT_SET";
    case ExpirationAction.DELAY:
      return "DELAY";
    case ExpirationAction.EXPIRY:
      return "EXPIRY";
    case ExpirationAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LicenseScope {
  LICENSE_SCOPE_NOT_SET = 0,
  PREDICT = 1,
  TRAIN = 2,
  SEARCH = 3,
  UNRECOGNIZED = -1,
}

export function licenseScopeFromJSON(object: any): LicenseScope {
  switch (object) {
    case 0:
    case "LICENSE_SCOPE_NOT_SET":
      return LicenseScope.LICENSE_SCOPE_NOT_SET;
    case 1:
    case "PREDICT":
      return LicenseScope.PREDICT;
    case 2:
    case "TRAIN":
      return LicenseScope.TRAIN;
    case 3:
    case "SEARCH":
      return LicenseScope.SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LicenseScope.UNRECOGNIZED;
  }
}

export function licenseScopeToJSON(object: LicenseScope): string {
  switch (object) {
    case LicenseScope.LICENSE_SCOPE_NOT_SET:
      return "LICENSE_SCOPE_NOT_SET";
    case LicenseScope.PREDICT:
      return "PREDICT";
    case LicenseScope.TRAIN:
      return "TRAIN";
    case LicenseScope.SEARCH:
      return "SEARCH";
    case LicenseScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LicenseType {
  UNKNOWN_LICENSE_TYPE = 0,
  FIRST_PARTY = 1,
  OPEN_SOURCE = 2,
  CLOSED_SOURCE = 3,
  UNRECOGNIZED = -1,
}

export function licenseTypeFromJSON(object: any): LicenseType {
  switch (object) {
    case 0:
    case "UNKNOWN_LICENSE_TYPE":
      return LicenseType.UNKNOWN_LICENSE_TYPE;
    case 1:
    case "FIRST_PARTY":
      return LicenseType.FIRST_PARTY;
    case 2:
    case "OPEN_SOURCE":
      return LicenseType.OPEN_SOURCE;
    case 3:
    case "CLOSED_SOURCE":
      return LicenseType.CLOSED_SOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LicenseType.UNRECOGNIZED;
  }
}

export function licenseTypeToJSON(object: LicenseType): string {
  switch (object) {
    case LicenseType.UNKNOWN_LICENSE_TYPE:
      return "UNKNOWN_LICENSE_TYPE";
    case LicenseType.FIRST_PARTY:
      return "FIRST_PARTY";
    case LicenseType.OPEN_SOURCE:
      return "OPEN_SOURCE";
    case LicenseType.CLOSED_SOURCE:
      return "CLOSED_SOURCE";
    case LicenseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DeployRestriction {
  /** USAGE_RESTRICTION_NOT_SET - Default uninitialized state. */
  USAGE_RESTRICTION_NOT_SET = 0,
  /** NO_LIMITS - No restrictions on usage. */
  NO_LIMITS = 1,
  /** SHARED_COMPUTE_ONLY - Model can only be used on shared compute resources. */
  SHARED_COMPUTE_ONLY = 2,
  /** DEDICATED_COMPUTE_ONLY - Model can only be used on dedicated compute resources. */
  DEDICATED_COMPUTE_ONLY = 3,
  UNRECOGNIZED = -1,
}

export function deployRestrictionFromJSON(object: any): DeployRestriction {
  switch (object) {
    case 0:
    case "USAGE_RESTRICTION_NOT_SET":
      return DeployRestriction.USAGE_RESTRICTION_NOT_SET;
    case 1:
    case "NO_LIMITS":
      return DeployRestriction.NO_LIMITS;
    case 2:
    case "SHARED_COMPUTE_ONLY":
      return DeployRestriction.SHARED_COMPUTE_ONLY;
    case 3:
    case "DEDICATED_COMPUTE_ONLY":
      return DeployRestriction.DEDICATED_COMPUTE_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeployRestriction.UNRECOGNIZED;
  }
}

export function deployRestrictionToJSON(object: DeployRestriction): string {
  switch (object) {
    case DeployRestriction.USAGE_RESTRICTION_NOT_SET:
      return "USAGE_RESTRICTION_NOT_SET";
    case DeployRestriction.NO_LIMITS:
      return "NO_LIMITS";
    case DeployRestriction.SHARED_COMPUTE_ONLY:
      return "SHARED_COMPUTE_ONLY";
    case DeployRestriction.DEDICATED_COMPUTE_ONLY:
      return "DEDICATED_COMPUTE_ONLY";
    case DeployRestriction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DataType {
  /** UNDEFINED - Default value, should not be used */
  UNDEFINED = 0,
  STRING = 1,
  UINT8 = 2,
  INT32 = 3,
  INT64 = 4,
  FP32 = 5,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "UNDEFINED":
      return DataType.UNDEFINED;
    case 1:
    case "STRING":
      return DataType.STRING;
    case 2:
    case "UINT8":
      return DataType.UINT8;
    case 3:
    case "INT32":
      return DataType.INT32;
    case 4:
    case "INT64":
      return DataType.INT64;
    case 5:
    case "FP32":
      return DataType.FP32;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.UNDEFINED:
      return "UNDEFINED";
    case DataType.STRING:
      return "STRING";
    case DataType.UINT8:
      return "UINT8";
    case DataType.INT32:
      return "INT32";
    case DataType.INT64:
      return "INT64";
    case DataType.FP32:
      return "FP32";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ValueComparator {
  CONCEPT_THRESHOLD_NOT_SET = 0,
  /** GREATER_THAN - input > value */
  GREATER_THAN = 1,
  /** GREATER_THAN_OR_EQUAL - input >= value */
  GREATER_THAN_OR_EQUAL = 2,
  /** LESS_THAN - input < value */
  LESS_THAN = 3,
  /** LESS_THAN_OR_EQUAL - input <= value */
  LESS_THAN_OR_EQUAL = 4,
  /** EQUAL - input == value */
  EQUAL = 5,
  UNRECOGNIZED = -1,
}

export function valueComparatorFromJSON(object: any): ValueComparator {
  switch (object) {
    case 0:
    case "CONCEPT_THRESHOLD_NOT_SET":
      return ValueComparator.CONCEPT_THRESHOLD_NOT_SET;
    case 1:
    case "GREATER_THAN":
      return ValueComparator.GREATER_THAN;
    case 2:
    case "GREATER_THAN_OR_EQUAL":
      return ValueComparator.GREATER_THAN_OR_EQUAL;
    case 3:
    case "LESS_THAN":
      return ValueComparator.LESS_THAN;
    case 4:
    case "LESS_THAN_OR_EQUAL":
      return ValueComparator.LESS_THAN_OR_EQUAL;
    case 5:
    case "EQUAL":
      return ValueComparator.EQUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValueComparator.UNRECOGNIZED;
  }
}

export function valueComparatorToJSON(object: ValueComparator): string {
  switch (object) {
    case ValueComparator.CONCEPT_THRESHOLD_NOT_SET:
      return "CONCEPT_THRESHOLD_NOT_SET";
    case ValueComparator.GREATER_THAN:
      return "GREATER_THAN";
    case ValueComparator.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case ValueComparator.LESS_THAN:
      return "LESS_THAN";
    case ValueComparator.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case ValueComparator.EQUAL:
      return "EQUAL";
    case ValueComparator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EvaluationType {
  Undefined = 0,
  /** Classification - default */
  Classification = 1,
  Detection = 2,
  Segmentation = 3,
  Clustering = 4,
  Tracker = 5,
  Generation = 6,
  UNRECOGNIZED = -1,
}

export function evaluationTypeFromJSON(object: any): EvaluationType {
  switch (object) {
    case 0:
    case "Undefined":
      return EvaluationType.Undefined;
    case 1:
    case "Classification":
      return EvaluationType.Classification;
    case 2:
    case "Detection":
      return EvaluationType.Detection;
    case 3:
    case "Segmentation":
      return EvaluationType.Segmentation;
    case 4:
    case "Clustering":
      return EvaluationType.Clustering;
    case 5:
    case "Tracker":
      return EvaluationType.Tracker;
    case 6:
    case "Generation":
      return EvaluationType.Generation;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EvaluationType.UNRECOGNIZED;
  }
}

export function evaluationTypeToJSON(object: EvaluationType): string {
  switch (object) {
    case EvaluationType.Undefined:
      return "Undefined";
    case EvaluationType.Classification:
      return "Classification";
    case EvaluationType.Detection:
      return "Detection";
    case EvaluationType.Segmentation:
      return "Segmentation";
    case EvaluationType.Clustering:
      return "Clustering";
    case EvaluationType.Tracker:
      return "Tracker";
    case EvaluationType.Generation:
      return "Generation";
    case EvaluationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum APIEventType {
  API_EVENT_TYPE_NOT_SET = 0,
  /** ON_PREM_PREDICT - On Prem event types */
  ON_PREM_PREDICT = 1,
  ON_PREM_TRAIN = 2,
  ON_PREM_SEARCH = 3,
  UNRECOGNIZED = -1,
}

export function aPIEventTypeFromJSON(object: any): APIEventType {
  switch (object) {
    case 0:
    case "API_EVENT_TYPE_NOT_SET":
      return APIEventType.API_EVENT_TYPE_NOT_SET;
    case 1:
    case "ON_PREM_PREDICT":
      return APIEventType.ON_PREM_PREDICT;
    case 2:
    case "ON_PREM_TRAIN":
      return APIEventType.ON_PREM_TRAIN;
    case 3:
    case "ON_PREM_SEARCH":
      return APIEventType.ON_PREM_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return APIEventType.UNRECOGNIZED;
  }
}

export function aPIEventTypeToJSON(object: APIEventType): string {
  switch (object) {
    case APIEventType.API_EVENT_TYPE_NOT_SET:
      return "API_EVENT_TYPE_NOT_SET";
    case APIEventType.ON_PREM_PREDICT:
      return "ON_PREM_PREDICT";
    case APIEventType.ON_PREM_TRAIN:
      return "ON_PREM_TRAIN";
    case APIEventType.ON_PREM_SEARCH:
      return "ON_PREM_SEARCH";
    case APIEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UsageIntervalType {
  /** undef - undef UsageIntervalType is so that the interval field can be forced to be included */
  undef = 0,
  day = 1,
  month = 2,
  year = 3,
  UNRECOGNIZED = -1,
}

export function usageIntervalTypeFromJSON(object: any): UsageIntervalType {
  switch (object) {
    case 0:
    case "undef":
      return UsageIntervalType.undef;
    case 1:
    case "day":
      return UsageIntervalType.day;
    case 2:
    case "month":
      return UsageIntervalType.month;
    case 3:
    case "year":
      return UsageIntervalType.year;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UsageIntervalType.UNRECOGNIZED;
  }
}

export function usageIntervalTypeToJSON(object: UsageIntervalType): string {
  switch (object) {
    case UsageIntervalType.undef:
      return "undef";
    case UsageIntervalType.day:
      return "day";
    case UsageIntervalType.month:
      return "month";
    case UsageIntervalType.year:
      return "year";
    case UsageIntervalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AnnotationDataType {
  ANNOTATION_DATA_TYPE_NOT_SET = 0,
  TAG = 1,
  BOUNDING_BOX = 2,
  POLYGON = 4,
  POINT = 8,
  SPAN = 16,
  MASK = 32,
  UNRECOGNIZED = -1,
}

export function annotationDataTypeFromJSON(object: any): AnnotationDataType {
  switch (object) {
    case 0:
    case "ANNOTATION_DATA_TYPE_NOT_SET":
      return AnnotationDataType.ANNOTATION_DATA_TYPE_NOT_SET;
    case 1:
    case "TAG":
      return AnnotationDataType.TAG;
    case 2:
    case "BOUNDING_BOX":
      return AnnotationDataType.BOUNDING_BOX;
    case 4:
    case "POLYGON":
      return AnnotationDataType.POLYGON;
    case 8:
    case "POINT":
      return AnnotationDataType.POINT;
    case 16:
    case "SPAN":
      return AnnotationDataType.SPAN;
    case 32:
    case "MASK":
      return AnnotationDataType.MASK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotationDataType.UNRECOGNIZED;
  }
}

export function annotationDataTypeToJSON(object: AnnotationDataType): string {
  switch (object) {
    case AnnotationDataType.ANNOTATION_DATA_TYPE_NOT_SET:
      return "ANNOTATION_DATA_TYPE_NOT_SET";
    case AnnotationDataType.TAG:
      return "TAG";
    case AnnotationDataType.BOUNDING_BOX:
      return "BOUNDING_BOX";
    case AnnotationDataType.POLYGON:
      return "POLYGON";
    case AnnotationDataType.POINT:
      return "POINT";
    case AnnotationDataType.SPAN:
      return "SPAN";
    case AnnotationDataType.MASK:
      return "MASK";
    case AnnotationDataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RoleType {
  TEAM = 0,
  ORG = 1,
  UNRECOGNIZED = -1,
}

export function roleTypeFromJSON(object: any): RoleType {
  switch (object) {
    case 0:
    case "TEAM":
      return RoleType.TEAM;
    case 1:
    case "ORG":
      return RoleType.ORG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoleType.UNRECOGNIZED;
  }
}

export function roleTypeToJSON(object: RoleType): string {
  switch (object) {
    case RoleType.TEAM:
      return "TEAM";
    case RoleType.ORG:
      return "ORG";
    case RoleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StatValueAggType {
  SUM = 0,
  AVG = 1,
  UNRECOGNIZED = -1,
}

export function statValueAggTypeFromJSON(object: any): StatValueAggType {
  switch (object) {
    case 0:
    case "SUM":
      return StatValueAggType.SUM;
    case 1:
    case "AVG":
      return StatValueAggType.AVG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatValueAggType.UNRECOGNIZED;
  }
}

export function statValueAggTypeToJSON(object: StatValueAggType): string {
  switch (object) {
    case StatValueAggType.SUM:
      return "SUM";
    case StatValueAggType.AVG:
      return "AVG";
    case StatValueAggType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StatTimeAggType {
  NO_TIME_AGG = 0,
  YEAR = 1,
  MONTH = 2,
  WEEK = 3,
  DAY = 4,
  HOUR = 5,
  MINUTE = 6,
  UNRECOGNIZED = -1,
}

export function statTimeAggTypeFromJSON(object: any): StatTimeAggType {
  switch (object) {
    case 0:
    case "NO_TIME_AGG":
      return StatTimeAggType.NO_TIME_AGG;
    case 1:
    case "YEAR":
      return StatTimeAggType.YEAR;
    case 2:
    case "MONTH":
      return StatTimeAggType.MONTH;
    case 3:
    case "WEEK":
      return StatTimeAggType.WEEK;
    case 4:
    case "DAY":
      return StatTimeAggType.DAY;
    case 5:
    case "HOUR":
      return StatTimeAggType.HOUR;
    case 6:
    case "MINUTE":
      return StatTimeAggType.MINUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatTimeAggType.UNRECOGNIZED;
  }
}

export function statTimeAggTypeToJSON(object: StatTimeAggType): string {
  switch (object) {
    case StatTimeAggType.NO_TIME_AGG:
      return "NO_TIME_AGG";
    case StatTimeAggType.YEAR:
      return "YEAR";
    case StatTimeAggType.MONTH:
      return "MONTH";
    case StatTimeAggType.WEEK:
      return "WEEK";
    case StatTimeAggType.DAY:
      return "DAY";
    case StatTimeAggType.HOUR:
      return "HOUR";
    case StatTimeAggType.MINUTE:
      return "MINUTE";
    case StatTimeAggType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ValidationErrorType {
  VALIDATION_ERROR_TYPE_NOT_SET = 0,
  RESTRICTED = 1,
  DATABASE = 2,
  FORMAT = 3,
  UNRECOGNIZED = -1,
}

export function validationErrorTypeFromJSON(object: any): ValidationErrorType {
  switch (object) {
    case 0:
    case "VALIDATION_ERROR_TYPE_NOT_SET":
      return ValidationErrorType.VALIDATION_ERROR_TYPE_NOT_SET;
    case 1:
    case "RESTRICTED":
      return ValidationErrorType.RESTRICTED;
    case 2:
    case "DATABASE":
      return ValidationErrorType.DATABASE;
    case 3:
    case "FORMAT":
      return ValidationErrorType.FORMAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValidationErrorType.UNRECOGNIZED;
  }
}

export function validationErrorTypeToJSON(object: ValidationErrorType): string {
  switch (object) {
    case ValidationErrorType.VALIDATION_ERROR_TYPE_NOT_SET:
      return "VALIDATION_ERROR_TYPE_NOT_SET";
    case ValidationErrorType.RESTRICTED:
      return "RESTRICTED";
    case ValidationErrorType.DATABASE:
      return "DATABASE";
    case ValidationErrorType.FORMAT:
      return "FORMAT";
    case ValidationErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InputIDConflictResolution {
  /** INPUT_ID_CONFLICT_RESOLUTION_NOT_SET - Defaults to SKIP */
  INPUT_ID_CONFLICT_RESOLUTION_NOT_SET = 0,
  /** SKIP - Mark duplicate inputs as error and skip processing them. */
  SKIP = 1,
  /** SUFFIX - Add a suffix to inputs with conflicting IDs. Attempts numeric suffixes "-1" to "-9" and then a randomized suffix. Identical ID's in the same request are still treated as errors. */
  SUFFIX = 2,
  UNRECOGNIZED = -1,
}

export function inputIDConflictResolutionFromJSON(object: any): InputIDConflictResolution {
  switch (object) {
    case 0:
    case "INPUT_ID_CONFLICT_RESOLUTION_NOT_SET":
      return InputIDConflictResolution.INPUT_ID_CONFLICT_RESOLUTION_NOT_SET;
    case 1:
    case "SKIP":
      return InputIDConflictResolution.SKIP;
    case 2:
    case "SUFFIX":
      return InputIDConflictResolution.SUFFIX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InputIDConflictResolution.UNRECOGNIZED;
  }
}

export function inputIDConflictResolutionToJSON(object: InputIDConflictResolution): string {
  switch (object) {
    case InputIDConflictResolution.INPUT_ID_CONFLICT_RESOLUTION_NOT_SET:
      return "INPUT_ID_CONFLICT_RESOLUTION_NOT_SET";
    case InputIDConflictResolution.SKIP:
      return "SKIP";
    case InputIDConflictResolution.SUFFIX:
      return "SUFFIX";
    case InputIDConflictResolution.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RunnerMethodType {
  UNKNOWN = 0,
  /** UNARY_UNARY - single request, single response. predict() in code */
  UNARY_UNARY = 1,
  /** UNARY_STREAMING - single request, streamed response. generate() in code */
  UNARY_STREAMING = 2,
  /** STREAMING_UNARY - stream of requests, single response. */
  STREAMING_UNARY = 3,
  /** STREAMING_STREAMING - stream of requests, stream of responses. stream() in code */
  STREAMING_STREAMING = 4,
  UNRECOGNIZED = -1,
}

export function runnerMethodTypeFromJSON(object: any): RunnerMethodType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return RunnerMethodType.UNKNOWN;
    case 1:
    case "UNARY_UNARY":
      return RunnerMethodType.UNARY_UNARY;
    case 2:
    case "UNARY_STREAMING":
      return RunnerMethodType.UNARY_STREAMING;
    case 3:
    case "STREAMING_UNARY":
      return RunnerMethodType.STREAMING_UNARY;
    case 4:
    case "STREAMING_STREAMING":
      return RunnerMethodType.STREAMING_STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunnerMethodType.UNRECOGNIZED;
  }
}

export function runnerMethodTypeToJSON(object: RunnerMethodType): string {
  switch (object) {
    case RunnerMethodType.UNKNOWN:
      return "UNKNOWN";
    case RunnerMethodType.UNARY_UNARY:
      return "UNARY_UNARY";
    case RunnerMethodType.UNARY_STREAMING:
      return "UNARY_STREAMING";
    case RunnerMethodType.STREAMING_UNARY:
      return "STREAMING_UNARY";
    case RunnerMethodType.STREAMING_STREAMING:
      return "STREAMING_STREAMING";
    case RunnerMethodType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EventType {
  EVENT_TYPE_NOT_SET = 0,
  /** ORGANIZATION_MEMBER_ADD - Event types related to organization memberships and teams: 100 - 199 */
  ORGANIZATION_MEMBER_ADD = 100,
  ORGANIZATION_MEMBER_CHANGE = 101,
  ORGANIZATION_MEMBER_REMOVE = 102,
  ORGANIZATION_MEMBER_INVITATION_CREATE = 103,
  ORGANIZATION_MEMBER_INVITATION_CANCEL = 104,
  ORGANIZATION_MEMBER_INVITATION_ACCEPT = 105,
  ORGANIZATION_MEMBER_INVITATION_DECLINE = 106,
  ORGANIZATION_TEAM_CREATE = 107,
  ORGANIZATION_TEAM_UPDATE = 108,
  ORGANIZATION_TEAM_DELETE = 109,
  ORGANIZATION_TEAM_MEMBER_ADD = 110,
  ORGANIZATION_TEAM_MEMBER_REMOVE = 111,
  ORGANIZATION_TEAM_APP_ADD = 112,
  ORGANIZATION_TEAM_APP_REMOVE = 113,
  /** MODULE_CREATE - Event types related to modules: 200 - 299 */
  MODULE_CREATE = 200,
  MODULE_UPDATE = 201,
  MODULE_DELETE = 202,
  MODULE_VERSION_CREATE = 203,
  MODULE_VERSION_UPDATE = 204,
  MODULE_VERSION_DELETE = 205,
  /** MODEL_CREATE - Event types related to models: 300 - 399 */
  MODEL_CREATE = 300,
  MODEL_UPDATE = 301,
  MODEL_DELETE = 302,
  MODEL_VERSION_CREATE = 303,
  MODEL_VERSION_UPDATE = 304,
  MODEL_VERSION_DELETE = 305,
  /** WORKFLOW_CREATE - Event types related to workflows: 400 - 499 */
  WORKFLOW_CREATE = 400,
  WORKFLOW_UPDATE = 401,
  WORKFLOW_DELETE = 402,
  WORKFLOW_VERSION_CREATE = 403,
  WORKFLOW_VERSION_UPDATE = 404,
  WORKFLOW_VERSION_DELETE = 405,
  /** APPLICATION_CREATE - Event types related to applications: 600 - 699 */
  APPLICATION_CREATE = 600,
  APPLICATION_UPDATE = 601,
  APPLICATION_DELETE = 602,
  /** COLLABORATOR_ADD - Event types related to collaborators: 700 - 799 */
  COLLABORATOR_ADD = 700,
  COLLABORATOR_UPDATE = 701,
  COLLABORATOR_REMOVE = 702,
  /** USER_UPDATE - Event types related to users: 800 - 899 */
  USER_UPDATE = 800,
  /** COMPUTE_CLUSTER_CREATE - Event types related to compute clusters: 900-999 */
  COMPUTE_CLUSTER_CREATE = 900,
  COMPUTE_CLUSTER_DELETE = 901,
  /** NODEPOOL_CREATE - Event types related to nodepools: 1000-1099 */
  NODEPOOL_CREATE = 1000,
  NODEPOOL_UPDATE = 1001,
  NODEPOOL_DELETE = 1002,
  /** DEPLOYMENT_CREATE - Event types related to deployments: 1100-1199 */
  DEPLOYMENT_CREATE = 1100,
  DEPLOYMENT_UPDATE = 1101,
  DEPLOYMENT_DELETE = 1102,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EVENT_TYPE_NOT_SET":
      return EventType.EVENT_TYPE_NOT_SET;
    case 100:
    case "ORGANIZATION_MEMBER_ADD":
      return EventType.ORGANIZATION_MEMBER_ADD;
    case 101:
    case "ORGANIZATION_MEMBER_CHANGE":
      return EventType.ORGANIZATION_MEMBER_CHANGE;
    case 102:
    case "ORGANIZATION_MEMBER_REMOVE":
      return EventType.ORGANIZATION_MEMBER_REMOVE;
    case 103:
    case "ORGANIZATION_MEMBER_INVITATION_CREATE":
      return EventType.ORGANIZATION_MEMBER_INVITATION_CREATE;
    case 104:
    case "ORGANIZATION_MEMBER_INVITATION_CANCEL":
      return EventType.ORGANIZATION_MEMBER_INVITATION_CANCEL;
    case 105:
    case "ORGANIZATION_MEMBER_INVITATION_ACCEPT":
      return EventType.ORGANIZATION_MEMBER_INVITATION_ACCEPT;
    case 106:
    case "ORGANIZATION_MEMBER_INVITATION_DECLINE":
      return EventType.ORGANIZATION_MEMBER_INVITATION_DECLINE;
    case 107:
    case "ORGANIZATION_TEAM_CREATE":
      return EventType.ORGANIZATION_TEAM_CREATE;
    case 108:
    case "ORGANIZATION_TEAM_UPDATE":
      return EventType.ORGANIZATION_TEAM_UPDATE;
    case 109:
    case "ORGANIZATION_TEAM_DELETE":
      return EventType.ORGANIZATION_TEAM_DELETE;
    case 110:
    case "ORGANIZATION_TEAM_MEMBER_ADD":
      return EventType.ORGANIZATION_TEAM_MEMBER_ADD;
    case 111:
    case "ORGANIZATION_TEAM_MEMBER_REMOVE":
      return EventType.ORGANIZATION_TEAM_MEMBER_REMOVE;
    case 112:
    case "ORGANIZATION_TEAM_APP_ADD":
      return EventType.ORGANIZATION_TEAM_APP_ADD;
    case 113:
    case "ORGANIZATION_TEAM_APP_REMOVE":
      return EventType.ORGANIZATION_TEAM_APP_REMOVE;
    case 200:
    case "MODULE_CREATE":
      return EventType.MODULE_CREATE;
    case 201:
    case "MODULE_UPDATE":
      return EventType.MODULE_UPDATE;
    case 202:
    case "MODULE_DELETE":
      return EventType.MODULE_DELETE;
    case 203:
    case "MODULE_VERSION_CREATE":
      return EventType.MODULE_VERSION_CREATE;
    case 204:
    case "MODULE_VERSION_UPDATE":
      return EventType.MODULE_VERSION_UPDATE;
    case 205:
    case "MODULE_VERSION_DELETE":
      return EventType.MODULE_VERSION_DELETE;
    case 300:
    case "MODEL_CREATE":
      return EventType.MODEL_CREATE;
    case 301:
    case "MODEL_UPDATE":
      return EventType.MODEL_UPDATE;
    case 302:
    case "MODEL_DELETE":
      return EventType.MODEL_DELETE;
    case 303:
    case "MODEL_VERSION_CREATE":
      return EventType.MODEL_VERSION_CREATE;
    case 304:
    case "MODEL_VERSION_UPDATE":
      return EventType.MODEL_VERSION_UPDATE;
    case 305:
    case "MODEL_VERSION_DELETE":
      return EventType.MODEL_VERSION_DELETE;
    case 400:
    case "WORKFLOW_CREATE":
      return EventType.WORKFLOW_CREATE;
    case 401:
    case "WORKFLOW_UPDATE":
      return EventType.WORKFLOW_UPDATE;
    case 402:
    case "WORKFLOW_DELETE":
      return EventType.WORKFLOW_DELETE;
    case 403:
    case "WORKFLOW_VERSION_CREATE":
      return EventType.WORKFLOW_VERSION_CREATE;
    case 404:
    case "WORKFLOW_VERSION_UPDATE":
      return EventType.WORKFLOW_VERSION_UPDATE;
    case 405:
    case "WORKFLOW_VERSION_DELETE":
      return EventType.WORKFLOW_VERSION_DELETE;
    case 600:
    case "APPLICATION_CREATE":
      return EventType.APPLICATION_CREATE;
    case 601:
    case "APPLICATION_UPDATE":
      return EventType.APPLICATION_UPDATE;
    case 602:
    case "APPLICATION_DELETE":
      return EventType.APPLICATION_DELETE;
    case 700:
    case "COLLABORATOR_ADD":
      return EventType.COLLABORATOR_ADD;
    case 701:
    case "COLLABORATOR_UPDATE":
      return EventType.COLLABORATOR_UPDATE;
    case 702:
    case "COLLABORATOR_REMOVE":
      return EventType.COLLABORATOR_REMOVE;
    case 800:
    case "USER_UPDATE":
      return EventType.USER_UPDATE;
    case 900:
    case "COMPUTE_CLUSTER_CREATE":
      return EventType.COMPUTE_CLUSTER_CREATE;
    case 901:
    case "COMPUTE_CLUSTER_DELETE":
      return EventType.COMPUTE_CLUSTER_DELETE;
    case 1000:
    case "NODEPOOL_CREATE":
      return EventType.NODEPOOL_CREATE;
    case 1001:
    case "NODEPOOL_UPDATE":
      return EventType.NODEPOOL_UPDATE;
    case 1002:
    case "NODEPOOL_DELETE":
      return EventType.NODEPOOL_DELETE;
    case 1100:
    case "DEPLOYMENT_CREATE":
      return EventType.DEPLOYMENT_CREATE;
    case 1101:
    case "DEPLOYMENT_UPDATE":
      return EventType.DEPLOYMENT_UPDATE;
    case 1102:
    case "DEPLOYMENT_DELETE":
      return EventType.DEPLOYMENT_DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EVENT_TYPE_NOT_SET:
      return "EVENT_TYPE_NOT_SET";
    case EventType.ORGANIZATION_MEMBER_ADD:
      return "ORGANIZATION_MEMBER_ADD";
    case EventType.ORGANIZATION_MEMBER_CHANGE:
      return "ORGANIZATION_MEMBER_CHANGE";
    case EventType.ORGANIZATION_MEMBER_REMOVE:
      return "ORGANIZATION_MEMBER_REMOVE";
    case EventType.ORGANIZATION_MEMBER_INVITATION_CREATE:
      return "ORGANIZATION_MEMBER_INVITATION_CREATE";
    case EventType.ORGANIZATION_MEMBER_INVITATION_CANCEL:
      return "ORGANIZATION_MEMBER_INVITATION_CANCEL";
    case EventType.ORGANIZATION_MEMBER_INVITATION_ACCEPT:
      return "ORGANIZATION_MEMBER_INVITATION_ACCEPT";
    case EventType.ORGANIZATION_MEMBER_INVITATION_DECLINE:
      return "ORGANIZATION_MEMBER_INVITATION_DECLINE";
    case EventType.ORGANIZATION_TEAM_CREATE:
      return "ORGANIZATION_TEAM_CREATE";
    case EventType.ORGANIZATION_TEAM_UPDATE:
      return "ORGANIZATION_TEAM_UPDATE";
    case EventType.ORGANIZATION_TEAM_DELETE:
      return "ORGANIZATION_TEAM_DELETE";
    case EventType.ORGANIZATION_TEAM_MEMBER_ADD:
      return "ORGANIZATION_TEAM_MEMBER_ADD";
    case EventType.ORGANIZATION_TEAM_MEMBER_REMOVE:
      return "ORGANIZATION_TEAM_MEMBER_REMOVE";
    case EventType.ORGANIZATION_TEAM_APP_ADD:
      return "ORGANIZATION_TEAM_APP_ADD";
    case EventType.ORGANIZATION_TEAM_APP_REMOVE:
      return "ORGANIZATION_TEAM_APP_REMOVE";
    case EventType.MODULE_CREATE:
      return "MODULE_CREATE";
    case EventType.MODULE_UPDATE:
      return "MODULE_UPDATE";
    case EventType.MODULE_DELETE:
      return "MODULE_DELETE";
    case EventType.MODULE_VERSION_CREATE:
      return "MODULE_VERSION_CREATE";
    case EventType.MODULE_VERSION_UPDATE:
      return "MODULE_VERSION_UPDATE";
    case EventType.MODULE_VERSION_DELETE:
      return "MODULE_VERSION_DELETE";
    case EventType.MODEL_CREATE:
      return "MODEL_CREATE";
    case EventType.MODEL_UPDATE:
      return "MODEL_UPDATE";
    case EventType.MODEL_DELETE:
      return "MODEL_DELETE";
    case EventType.MODEL_VERSION_CREATE:
      return "MODEL_VERSION_CREATE";
    case EventType.MODEL_VERSION_UPDATE:
      return "MODEL_VERSION_UPDATE";
    case EventType.MODEL_VERSION_DELETE:
      return "MODEL_VERSION_DELETE";
    case EventType.WORKFLOW_CREATE:
      return "WORKFLOW_CREATE";
    case EventType.WORKFLOW_UPDATE:
      return "WORKFLOW_UPDATE";
    case EventType.WORKFLOW_DELETE:
      return "WORKFLOW_DELETE";
    case EventType.WORKFLOW_VERSION_CREATE:
      return "WORKFLOW_VERSION_CREATE";
    case EventType.WORKFLOW_VERSION_UPDATE:
      return "WORKFLOW_VERSION_UPDATE";
    case EventType.WORKFLOW_VERSION_DELETE:
      return "WORKFLOW_VERSION_DELETE";
    case EventType.APPLICATION_CREATE:
      return "APPLICATION_CREATE";
    case EventType.APPLICATION_UPDATE:
      return "APPLICATION_UPDATE";
    case EventType.APPLICATION_DELETE:
      return "APPLICATION_DELETE";
    case EventType.COLLABORATOR_ADD:
      return "COLLABORATOR_ADD";
    case EventType.COLLABORATOR_UPDATE:
      return "COLLABORATOR_UPDATE";
    case EventType.COLLABORATOR_REMOVE:
      return "COLLABORATOR_REMOVE";
    case EventType.USER_UPDATE:
      return "USER_UPDATE";
    case EventType.COMPUTE_CLUSTER_CREATE:
      return "COMPUTE_CLUSTER_CREATE";
    case EventType.COMPUTE_CLUSTER_DELETE:
      return "COMPUTE_CLUSTER_DELETE";
    case EventType.NODEPOOL_CREATE:
      return "NODEPOOL_CREATE";
    case EventType.NODEPOOL_UPDATE:
      return "NODEPOOL_UPDATE";
    case EventType.NODEPOOL_DELETE:
      return "NODEPOOL_DELETE";
    case EventType.DEPLOYMENT_CREATE:
      return "DEPLOYMENT_CREATE";
    case EventType.DEPLOYMENT_UPDATE:
      return "DEPLOYMENT_UPDATE";
    case EventType.DEPLOYMENT_DELETE:
      return "DEPLOYMENT_DELETE";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MetricType {
  METRIC_TYPE_NOT_SET = 0,
  MODEL_REQUEST_COUNT = 1,
  MODEL_LATENCY = 2,
  UNRECOGNIZED = -1,
}

export function metricTypeFromJSON(object: any): MetricType {
  switch (object) {
    case 0:
    case "METRIC_TYPE_NOT_SET":
      return MetricType.METRIC_TYPE_NOT_SET;
    case 1:
    case "MODEL_REQUEST_COUNT":
      return MetricType.MODEL_REQUEST_COUNT;
    case 2:
    case "MODEL_LATENCY":
      return MetricType.MODEL_LATENCY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricType.UNRECOGNIZED;
  }
}

export function metricTypeToJSON(object: MetricType): string {
  switch (object) {
    case MetricType.METRIC_TYPE_NOT_SET:
      return "METRIC_TYPE_NOT_SET";
    case MetricType.MODEL_REQUEST_COUNT:
      return "MODEL_REQUEST_COUNT";
    case MetricType.MODEL_LATENCY:
      return "MODEL_LATENCY";
    case MetricType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MetricLabel {
  METRIC_LABEL_NOT_SET = 0,
  APP_ID = 1,
  MODEL_ID = 2,
  MODEL_VERSION_ID = 3,
  CALLER_USER_ID = 4,
  WORKFLOW_ID = 5,
  UNRECOGNIZED = -1,
}

export function metricLabelFromJSON(object: any): MetricLabel {
  switch (object) {
    case 0:
    case "METRIC_LABEL_NOT_SET":
      return MetricLabel.METRIC_LABEL_NOT_SET;
    case 1:
    case "APP_ID":
      return MetricLabel.APP_ID;
    case 2:
    case "MODEL_ID":
      return MetricLabel.MODEL_ID;
    case 3:
    case "MODEL_VERSION_ID":
      return MetricLabel.MODEL_VERSION_ID;
    case 4:
    case "CALLER_USER_ID":
      return MetricLabel.CALLER_USER_ID;
    case 5:
    case "WORKFLOW_ID":
      return MetricLabel.WORKFLOW_ID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricLabel.UNRECOGNIZED;
  }
}

export function metricLabelToJSON(object: MetricLabel): string {
  switch (object) {
    case MetricLabel.METRIC_LABEL_NOT_SET:
      return "METRIC_LABEL_NOT_SET";
    case MetricLabel.APP_ID:
      return "APP_ID";
    case MetricLabel.MODEL_ID:
      return "MODEL_ID";
    case MetricLabel.MODEL_VERSION_ID:
      return "MODEL_VERSION_ID";
    case MetricLabel.CALLER_USER_ID:
      return "CALLER_USER_ID";
    case MetricLabel.WORKFLOW_ID:
      return "WORKFLOW_ID";
    case MetricLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Annotation of an asset with metadata */
export interface Annotation {
  /** The ID for the annotation */
  id: string;
  /** ID of the input this annotation is tied to */
  inputId: string;
  /** The data passed along in this annotation. */
  data:
    | Data
    | undefined;
  /** task_id is deprecated in annotation_info. Use task_id */
  annotationInfo:
    | { [key: string]: any }
    | undefined;
  /**
   * DEPRECATED: Use worker.user.id instead.
   *
   * @deprecated
   */
  userId: string;
  /**
   * DEPRECATED: Use worker.model.model_version.id instead
   *
   * @deprecated
   */
  modelVersionId: string;
  /**
   * DEPRECATED.
   *
   * @deprecated
   */
  embedModelVersionId: string;
  /** Annotation Status */
  status:
    | Status
    | undefined;
  /**
   * When the annotation was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When the annotation was modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * Whether or not this annotation is trusted
   * Will be deprecated
   *
   * @deprecated
   */
  trusted: boolean;
  /** Is this the input level annotation. */
  inputLevel: boolean;
  /**
   * Consensus review related information, e.g.
   * * annotation group
   * * id of annotation parent, in case the annotation was split from another annotation
   */
  consensusInfo:
    | { [key: string]: any }
    | undefined;
  /** The id of the task annotation belongs to */
  taskId: string;
  /** Worker is the worker that created the annotation. */
  worker: Worker | undefined;
}

/** AnnotationTrack of an asset with metadata */
export interface AnnotationTrack {
  /** The ID for the annotation track */
  id: string;
  /** ID of the application this annotation track is tied to */
  appId: string;
  /** ID of the asset this annotation track is tied to */
  inputId: string;
  /** Concept this annotation track */
  concept:
    | Concept
    | undefined;
  /** The user the track belongs to (app owner) */
  userId: string;
  /** AnnotationTrack Status */
  status:
    | Status
    | undefined;
  /** Start frame of the annotation track */
  startFrame: number;
  /** End frame of the annotation track */
  endFrame: number;
  /** When the annotation track was created. */
  createdAt:
    | Date
    | undefined;
  /** When the annotation track was modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * Frame rate of the video track.
   * 1 means it matches the original video FPS.
   * 2 means every second frame, etc.
   * So if you have 30fps original video and frame_rate=3, your annotations in a track are stored at 30fps/3frame_rate=10 frames per second
   */
  frameRate: number;
}

/** Worker is the author of an annotation. */
export interface Worker {
  /**
   * User is the human that created the annotation.
   *
   * By default no real names of users are returned in responses. These can
   * be requested with the 'names' additional field.
   */
  user?:
    | User
    | undefined;
  /** Model is the model that created the annotation. */
  model?:
    | Model
    | undefined;
  /** Workflow is the workflow that created the annotation. */
  workflow?: Workflow | undefined;
}

/** Application with tasks and datasets */
export interface App {
  id: string;
  name: string;
  defaultLanguage: string;
  /**
   * Deprecated, use default_workflow instead.
   *
   * @deprecated
   */
  defaultWorkflowId: string;
  defaultWorkflow:
    | Workflow
    | undefined;
  /**
   * why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already
   * specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
   * This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
   */
  userId: string;
  /**
   * When the app was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When the app was last modified */
  modifiedAt:
    | Date
    | undefined;
  /** if user accept legal consent for face recognition */
  legalConsentStatus: number;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** short description about the app. */
  description: string;
  /** Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds) */
  sampleMs: number;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** data tier id this app is using. */
  dataTierId: string;
  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostAppStars/DeleteAppStars endpoints to star/unstar an app
   */
  isStarred: boolean;
  /**
   * How many users have starred the app (only showed on get/list requests)
   * Computed value, not editable
   */
  starCount: number;
  /**
   * Notes for the application
   * This field should be used for in-depth notes and supports up to 64Kbs.
   */
  notes: string;
  /** Representative image for this app */
  image:
    | Image
    | undefined;
  /**
   * An app marked as a template can be duplicated by any user that can see it,
   * including all visible resources within it.
   */
  isTemplate: boolean | undefined;
  extraInfo:
    | AppExtraInfo
    | undefined;
  /**
   * Where app embeddings are stored
   * postgres (default), qdrant
   */
  embeddingsStorage: App_EmbeddingsStorage;
}

export enum App_EmbeddingsStorage {
  EMBEDDING_STORAGE_NOT_SET = 0,
  POSTGRES = 1,
  QDRANT = 2,
  UNRECOGNIZED = -1,
}

export function app_EmbeddingsStorageFromJSON(object: any): App_EmbeddingsStorage {
  switch (object) {
    case 0:
    case "EMBEDDING_STORAGE_NOT_SET":
      return App_EmbeddingsStorage.EMBEDDING_STORAGE_NOT_SET;
    case 1:
    case "POSTGRES":
      return App_EmbeddingsStorage.POSTGRES;
    case 2:
    case "QDRANT":
      return App_EmbeddingsStorage.QDRANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return App_EmbeddingsStorage.UNRECOGNIZED;
  }
}

export function app_EmbeddingsStorageToJSON(object: App_EmbeddingsStorage): string {
  switch (object) {
    case App_EmbeddingsStorage.EMBEDDING_STORAGE_NOT_SET:
      return "EMBEDDING_STORAGE_NOT_SET";
    case App_EmbeddingsStorage.POSTGRES:
      return "POSTGRES";
    case App_EmbeddingsStorage.QDRANT:
      return "QDRANT";
    case App_EmbeddingsStorage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AppExtraInfo {
  /**
   * Revision marker for this application.
   * The value of the revision changes when
   * * inputs are added, updated or deleted
   * * annotations are added, updated or deleted
   * * inputs are added to or removed from datasets
   * For example, this value can be used to detect if client side caches related to searching should be invalidated.
   * Field not filled in for list endpoints, use GetApp
   */
  searchRevisionMarker: string;
  counts: AppResourceCounts | undefined;
}

/** App query */
export interface AppQuery {
  /** Query by application name. This supports wildcard queries like "gen*" to match "general" as an example. */
  name: string;
}

export interface AppResourceCounts {
  datasets: number;
  models: number;
  workflows: number;
  modules: number;
  inputs: number;
}

/** Collaborator - invited user, who shares an access to an application */
export interface Collaborator {
  /** id of this collaborator */
  id: string;
  /**
   * the app this collaborator has access to
   * FIXME(zeiler): this should be in the user_app_id.app_id already from the endpoint.
   */
  app:
    | App
    | undefined;
  /** who is this collaborator */
  user:
    | User
    | undefined;
  /** the permission this collaborator */
  scopes: string[];
  endpoints: string[];
  /**
   * When the app was shared with. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When the collaborator was updated. */
  modifiedAt:
    | Date
    | undefined;
  /** When the collaborator was removed from app. */
  deletedAt: Date | undefined;
}

/** collaboration includes an app you're invited to work on. */
export interface Collaboration {
  /** the application */
  app:
    | App
    | undefined;
  /** the app owner's info(including user_unique_id, first_name, last_name, primary_email) */
  appOwner:
    | User
    | undefined;
  /** the low-level scope users are shared with for this collaboration */
  scopes: string[];
  /** the endpoint-level scopes users are shared with for this collaboration */
  endpoints: string[];
  /** when is the collaboration created */
  createdAt: Date | undefined;
}

/** Audio asset struct */
export interface Audio {
  /**
   * This is a URL to a publicly accessible image file. The platform will download this file server
   * side and then process.
   */
  url: string;
  /**
   * The base64 field is using image file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   */
  base64: Uint8Array;
  /** If True then you will be allowed to have multiple urls. */
  allowDuplicateUrl: boolean;
  /**
   * The hosted field lists original audio hosted in Clarifai storage. This field is currently used
   * only in response.
   */
  hosted:
    | HostedURL
    | undefined;
  /** audio info */
  audioInfo: AudioInfo | undefined;
}

export interface AudioInfo {
  /** audio format */
  audioFormat: string;
  /** sample rate */
  sampleRate: number;
  /** audio track duration in seconds */
  durationSeconds: number;
  /** audio track bit rate */
  bitRate: number;
}

/** Track proto encodes information of a track over a number of frames */
export interface Track {
  /** track id */
  id: string;
  /**
   * This is a recursive definition which can contain all the concepts,
   * embeddings, etc. that are computed within this track.
   */
  data: Data | undefined;
  timeInfo: TimeInfo | undefined;
  quality: number;
}

/** Cluster data */
export interface Cluster {
  id: string;
  /** Number of annotations tied to the cluster in the app */
  count: number;
  /**
   * The score assigned to this cluster.
   * For List Clusters endpoint, this represents percentage of inputs in the app assigned to this cluster.
   */
  score: number;
  /** Representative hits for cluster (for now we only return 1) */
  hits: Hit[];
  projection: number[];
}

/** Color data */
export interface Color {
  rawHex: string;
  w3c: W3C | undefined;
  value: number;
}

export interface W3C {
  hex: string;
  name: string;
}

/** Common message to identify the app in a url endpoint. */
export interface UserAppIDSet {
  /** Note user_id 'me' is reserved - it is the alias for the id of authorized user */
  userId: string;
  appId: string;
}

/** PatchAction */
export interface PatchAction {
  /**
   * The operation to perform on the patched metadata given a path
   * For now only operations 'overwrite', 'delete, and 'merge' is supported
   */
  op: string;
  /**
   * If the action is 'merge' and there is a conflict, how to resolve it.
   * The options are
   * 'overwrite_by_id', 'remove_by_id', 'merge_by_id','overwrite', 'append' and 'do_nothing'
   * Note that for conflict resolutions '*_by_id' to work on a list, the list should contain
   * objects with an 'id' field which will be used to uniquely identify each field. For example
   * Patching existing json
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": 2
   *     }
   *   ]
   * }
   * with op 'merge' and merge_conflict_resolution 'overwrite_by_id'
   * {
   *   "tag": [
   *     {
   *       "id": "2",
   *       "data": 3
   *     }
   *   ]
   * }
   * would produce
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": 3
   *     }
   *   ]
   * }
   * while with merge_conflict_resolution 'remove_by_id' it would produce
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     }
   *   ]
   * }
   *
   * Option 'append' will simply create a list on conflicts. For example in above example
   * the final result would be
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": [2, 3]
   *     }
   *   ]
   * }
   */
  mergeConflictResolution: string;
  /**
   * Path for the change. For example 'tag[1].data' is a valid path in above example.
   * Default path is root level i.e. ''.
   */
  path: string;
}

/** Concept or tag */
export interface Concept {
  /** The concept's unique id. */
  id: string;
  /** The name of the concept in the given language. */
  name: string;
  /**
   * Used to indicate presence (1.0) or not (0.0) of this concept when making a request.
   * This is also the prediction probability when returning predictions from our API.
   * For convenience we use the default of 1.0 when making requests so the concept you provide is
   * is treated as a positive (1.0) and not a negative (which would be value == 0.0).
   */
  value: number;
  /**
   * When the concept was created. The format is https://www.ietf.org/rfc/rfc3339.txt .
   * Example: "2006-01-02T15:04:05.999999Z". This field is used only in a response.
   */
  createdAt:
    | Date
    | undefined;
  /**
   * The language in which the concept name is in. This is *ONLY* used in the response and setting
   * it in a request is ignored since the default language of your app is used when creating
   * or patching a Concept. To set other languages for your concept use the ConceptLanguage object
   * and its corresponding endpoints.
   */
  language: string;
  /** The application id that this concept is within. This can be ignored by most users. */
  appId: string;
  /** The definition for the concept. Similar to name. This can be ignored by most users. */
  definition: string;
  /**
   * The vocabulary that this concept belongs to. This is useful if you have different unique sets
   * of concepts that you can separate out based on this field. For example "age_appearance" vs
   * "gender_appearance" in a list of concept returned from the demographics model.
   */
  vocabId: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** The user the concept belongs to. */
  userId: string;
  /** Information about keypoints for this concept */
  keypointInfo:
    | KeypointInfo
    | undefined;
  /** Optional extra info. */
  extraInfo:
    | ConceptExtraInfo
    | undefined;
  /**
   * To handle arbitrary json metadata:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** Representative image for the concept */
  image: Image | undefined;
}

export interface KeypointInfo {
  /** Names of the keypoints */
  keypointNames: string[];
  /** Defines the connections between keypoint_names. Each value represents the index in keypoint_names. */
  skeleton: KeypointEdge[];
}

export interface KeypointEdge {
  k1: number;
  k2: number;
}

/**
 * ConceptExtraInfo represents extra information related to a concept that is context-dependent.
 * It is only set when requested in ConceptExtraInfoRequest.
 */
export interface ConceptExtraInfo {
  /** Whether this concept is rankable based on ConceptExtraInfoRequest configuration. */
  isRankable: boolean;
}

/** ConceptCount */
export interface ConceptCount {
  /** The concept's unique id. */
  id: string;
  /** The name of the concept. */
  name: string;
  /** The total count for concepts labeled for all asset statues (processing, to_process, processed, error) */
  conceptTypeCount:
    | ConceptTypeCount
    | undefined;
  /** The detail count for different assets status */
  detailConceptCount: DetailConceptCount | undefined;
}

/** ConceptTypeCount */
export interface ConceptTypeCount {
  /**
   * The number of inputs that have a concept with a value of 1.0 (indicating presence of the
   * concept in an input).
   */
  positive: number;
  /**
   * The number of inputs that have a concept with a value of 0.0 (indicating absence of the
   * concept in an input).
   */
  negative: number;
}

/** DetailConceptCount */
export interface DetailConceptCount {
  /** The concept count for processed assets */
  processed:
    | ConceptTypeCount
    | undefined;
  /** The concept count for to process assets */
  toProcess:
    | ConceptTypeCount
    | undefined;
  /** The concept count for assets with status error */
  errors:
    | ConceptTypeCount
    | undefined;
  /** The concept count for processing assets */
  processing: ConceptTypeCount | undefined;
}

/** ConceptQuery */
export interface ConceptQuery {
  /** The name of the concept to search. */
  name: string;
  /** The language of the concept name in a search. Defaults to English. */
  language: string;
  /**
   * Deprecated: Use workflow.id instead.
   *
   * @deprecated
   */
  workflowId: string;
  /**
   * The concepts must belong to models with specified use cases.
   * Multiple values are joined using an OR condition.
   */
  useCases: WorkflowModelUseCase[];
  model?: Model | undefined;
  workflow?:
    | Workflow
    | undefined;
  /**
   * By default, we return app concepts combined with source (model or workflow) concepts.
   * If source is not set, then we only return app concepts.
   * If ignore_app_concepts is true, then we only return source concepts.
   * When use_cases are set, then ignore_app_concepts is always true, because
   * concept use cases can only be determined in relation to a model or a workflow.
   */
  ignoreAppConcepts: boolean;
}

/** This represents a relation (i.e. edge) between the subject concept and the object concept */
export interface ConceptRelation {
  /** ID of the concept relation */
  id: string;
  /** The subject concept (i.e. source) of the concept relation */
  subjectConcept:
    | Concept
    | undefined;
  /** The subject concept (i.e. destination) of the concept relation */
  objectConcept:
    | Concept
    | undefined;
  /**
   * The predicate (i.e. edge) linking the subject and the object
   * Both subject_concept and object_concept are concepts.
   * The predicate is the type of relationship.
   * That predicate acts on the subject.
   *
   * There are three current types of predicates:
   * 1) "hyponym"
   * 2) "hypernym"
   * 3) "synonym"
   *
   * 1) For example, 'hyponym' is a type of predicate which represents 'is_a_kind_of' relation so
   * the following relationship:
   * 'honey' (subject), 'hyponym' (predicate), 'food' (object)
   * Can more easily be read as:
   * 'honey' 'is a kind of' 'food'
   *
   * 2) The 'hypernym' relation is the opposite of 'hyponym' and when you add one of the
   * relationships the opposite will automatically appear for you in queries.
   *
   * The 'hypernym' can be read as 'is a parent of' so:
   * 'food' (subject), 'hypernym' (predicate), 'honey' (object)
   * Can more easily be read as:
   * 'food' is a parent of 'honey'
   *
   * 3) The 'synonym' relation defines two concepts that essential mean the same thing. This
   * is more like a "is" relationship. So for example a 'synonym' relationship could be:
   * "puppy" is "pup"
   * The reverse is also true once the former is added so:
   * "pup" is "puppy"
   * will appear in queries as well.
   */
  predicate: string;
  /**
   * The knowledge graph id that this edge belongs to. If using the app's global knowledge graph
   * and not a specific one then this should be the empty string "".
   */
  knowledgeGraphId: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility: Visibility | undefined;
}

/** A Knowledge Graph is a logical subsets of edges in the overall Concept Graph */
export interface KnowledgeGraph {
  /** ID of the knowledge graph */
  id: string;
  /** Name of the knowledge graph */
  name: string;
  /** Human readable description of the knowledge graph */
  description: string;
  /** The app that contains the images that correspond to the concepts in the knowledge graph */
  examplesAppId: string;
  /** The app that contains the sample images that we want to show the customer for the concepts in the knowledge graph */
  sampledExamplesAppId: string;
}

/**
 * This represents a link to an outside source for the given concept.
 * The values from here are sticked into Concept message into the name and definition fields when
 * returning from the API in your default language. The "id" field here becomes the "language"
 * field of the Concept message which is a little weird.
 */
export interface ConceptLanguage {
  /** This is the language code for the language such as "en". */
  id: string;
  /** The type of the outside source. */
  name: string;
  /** The ID that is referenced in the source. */
  definition: string;
}

/** Data */
export interface Data {
  /** Input and output images. */
  image:
    | Image
    | undefined;
  /** Input and output videos. */
  video:
    | Video
    | undefined;
  /** A list of concepts. */
  concepts: Concept[];
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** Geography information. */
  geo:
    | Geo
    | undefined;
  /** The dominant colors within an image. */
  colors: Color[];
  /** Clustering centroids for inputs. */
  clusters: Cluster[];
  /** Embedding vectors representing each input. */
  embeddings: Embedding[];
  /** For recursing into localized regions of an input. */
  regions: Region[];
  /** For temporal content like video. */
  frames: Frame[];
  /** Input, output or annotation text. */
  text:
    | Text
    | undefined;
  /** Input and output audio. */
  audio:
    | Audio
    | undefined;
  /** Track information. */
  tracks: Track[];
  /** Time segments information. */
  timeSegments: TimeSegment[];
  /** Holds score, rank, and user, app, input IDs and search hit data */
  hits: Hit[];
  /** Heatmap as 2d image */
  heatmaps: Image[];
  /**
   * For data messages that have multiple parts such as multi-modal
   * requests, we allow you to specify those as a list of Data objects.
   */
  parts: Part[];
  /**
   * A proto representation for numpy arrays, useful to pass information from python SDK to a
   * python based model implementation.
   */
  ndarray:
    | NDArray
    | undefined;
  /** Input and output integer number */
  intValue: number;
  /** Input and output floating number */
  floatValue: number;
  /** Input and output bytes data */
  bytesValue: Uint8Array;
  /** Input and output bool data */
  boolValue: boolean;
  /** Input and output string data */
  stringValue: string;
}

/** A part of data used for multi-modal processing. */
export interface Part {
  /** The data for this part. */
  data:
    | Data
    | undefined;
  /** A unique id for the part. */
  id: string;
}

/** A region within the data. */
export interface Region {
  /** A unique id for the region. */
  id: string;
  /** The details about the location of the region. */
  regionInfo:
    | RegionInfo
    | undefined;
  /**
   * A recursive definition of the data within the Region. For example, this will contain
   * data.concepts if the region also has annotations or predictions of concepts within it.
   */
  data:
    | Data
    | undefined;
  /** This is the confidence score of the overall Region. */
  value: number;
  /** For tracking algorithsm and annotations we tie regions together with this track id. */
  trackId: string;
}

/** The information of the location of the Region. */
export interface RegionInfo {
  /** Details of the region's rectangular bounding box. */
  boundingBox:
    | BoundingBox
    | undefined;
  /** Details of the region's segmentation mask. */
  mask:
    | Mask
    | undefined;
  /** A polygon of points. */
  polygon:
    | Polygon
    | undefined;
  /** A landmark point location. */
  point:
    | Point
    | undefined;
  /** Span char sequence for NLP. */
  span:
    | Span
    | undefined;
  /** Token char sequence for NLP. */
  token:
    | Token
    | undefined;
  /**
   * The locations of detected keypoints, which are to be used in conjunction with the detected concept's skeleton to connect the keypoint locations.
   * These will be in the same order as the respective keypoint_names inside the concept.
   */
  keypointLocations: Point[];
}

/** Rectangular bounding box for a region. */
export interface BoundingBox {
  /** The top left of the bounding box normalized to the data dimension to be within [0-1.0] */
  topRow: number;
  /** The left column of the bounding box normalized to the data dimension to be within [0-1.0] */
  leftCol: number;
  /** The bottom row of the bounding box normalized to the data dimension to be within [0-1.0] */
  bottomRow: number;
  /** The right col of the bounding box normalized to the data dimension to be within [0-1.0] */
  rightCol: number;
}

/** The information of the location of the Frame. */
export interface FrameInfo {
  /**
   * Deprecated. Use Time instead.
   * The index of the frame, informational and optional.
   * Depends on the sampling rate used during processing
   * May be 0 for interpolated frames that are generated for brief time (training) or if new frame is manually added
   *
   * @deprecated
   */
  index: number;
  /**
   * time in the video in milliseconds. This is independent of the sampling rates used during
   * processing.
   */
  time: number;
}

/** A Frame of time-series Data such as a Video. */
export interface Frame {
  /** Information aboue frame such as number and time. */
  frameInfo:
    | FrameInfo
    | undefined;
  /**
   * A recursive definition of the data within the Frame. For example, this will contain
   * data.concepts if the Frame also has annotations or predictions of concepts within it.
   * This can also have data.regions for annotation or predictions of detection regions, which can
   * then recursively have their data field filled in as well.
   */
  data:
    | Data
    | undefined;
  /** An ID for the frame. */
  id: string;
}

/**
 * A representation of a numpy array as a proto.
 * To convert a numpy array 'ndarray' to this proto do:
 * NDArray(buffer=ndarray.tobytes(), shape=ndarray.shape, dtype=str(ndarray.dtype))
 *
 * To convert this proto 'ndarray_proto' to a numpy array:
 * array = np.frombuffer(ndarray_proto.buffer, dtype=ndarray_proto.dtype)
 * array = array.reshape(tuple(ndarray_proto.shape))
 */
export interface NDArray {
  /** The bytes of data from the array from array.tobytes() */
  buffer: Uint8Array;
  /** Simply the shape of the numpy array. array.shape. */
  shape: number[];
  /**
   * Dtype for numpy. You can get it back from this string format using:
   * np.dtype('float32') for example.
   */
  dtype: string;
}

/** Segmentation mask. */
export interface Mask {
  /** The image of the mask in a non-raster format. */
  image: Image | undefined;
}

/** Polygon */
export interface Polygon {
  /** A list of points connected together to form the polygon. */
  points: Point[];
}

/** Point */
export interface Point {
  /**
   * The row location of the point. This has a [0.0-1.0] range with 0.0 being top row and 1.0
   * being the bottom row.
   */
  row: number;
  /**
   * The column location of the point. This has a [0.0-1.0] range with 0.0 being left col and 1.0
   * being the right col.
   */
  col: number;
  /** Depth if applicable for the point. */
  z: number;
  visibility: Point_Visibility;
}

/** Whether this point is visible or occluded */
export enum Point_Visibility {
  /** NOT_SET - Visibility of the point is not set */
  NOT_SET = 0,
  /** VISIBLE - Point is visible */
  VISIBLE = 1,
  /** NOT_VISIBLE - Point is occluded */
  NOT_VISIBLE = 2,
  /** NOT_PRESENT - Point is not in the image */
  NOT_PRESENT = 3,
  UNRECOGNIZED = -1,
}

export function point_VisibilityFromJSON(object: any): Point_Visibility {
  switch (object) {
    case 0:
    case "NOT_SET":
      return Point_Visibility.NOT_SET;
    case 1:
    case "VISIBLE":
      return Point_Visibility.VISIBLE;
    case 2:
    case "NOT_VISIBLE":
      return Point_Visibility.NOT_VISIBLE;
    case 3:
    case "NOT_PRESENT":
      return Point_Visibility.NOT_PRESENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Point_Visibility.UNRECOGNIZED;
  }
}

export function point_VisibilityToJSON(object: Point_Visibility): string {
  switch (object) {
    case Point_Visibility.NOT_SET:
      return "NOT_SET";
    case Point_Visibility.VISIBLE:
      return "VISIBLE";
    case Point_Visibility.NOT_VISIBLE:
      return "NOT_VISIBLE";
    case Point_Visibility.NOT_PRESENT:
      return "NOT_PRESENT";
    case Point_Visibility.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Span {
  charStart: number;
  charEnd: number;
  rawText: string;
}

export interface Token {
  charStart: number;
  charEnd: number;
  rawText: string;
}

/** Embedding */
export interface Embedding {
  vector: number[];
  numDimensions: number;
}

/** GeoPoint */
export interface GeoPoint {
  longitude: number;
  latitude: number;
}

/** GeoLimit */
export interface GeoLimit {
  type: string;
  value: number;
}

/** GeoBoxedPoint */
export interface GeoBoxedPoint {
  geoPoint: GeoPoint | undefined;
}

/** Geo */
export interface Geo {
  geoPoint: GeoPoint | undefined;
  geoLimit:
    | GeoLimit
    | undefined;
  /** NOTE: inconsistency: should have been geo_boxed_points */
  geoBox: GeoBoxedPoint[];
}

/** Image */
export interface Image {
  /**
   * This is a URL to a publicly accessible image file. The platform will download this file server
   * side and then process.
   */
  url: string;
  /**
   * The base64 field is using image file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   */
  base64: Uint8Array;
  allowDuplicateUrl: boolean;
  /** The hosted field lists images in different sizes hosted in Clarifai storage. */
  hosted:
    | HostedURL
    | undefined;
  /** image info for original size. for image info for other sizes, use hosted_image_info */
  imageInfo:
    | ImageInfo
    | undefined;
  /**
   * The map of hosted image info of different sizes (see hosted.sizes), excluding the original image.
   * Note: keys(hosted_image_info) = hosted.sizes - "orig"
   */
  hostedImageInfo: { [key: string]: ImageInfo };
  /** For internal processing of already decoded bytes. */
  decodedBytes: Uint8Array;
}

export interface Image_HostedImageInfoEntry {
  key: string;
  value: ImageInfo | undefined;
}

export interface ImageInfo {
  /** width */
  width: number;
  /** height */
  height: number;
  /** image format */
  format: string;
  /** image color mode */
  colorMode: string;
  /** mode (when used for decoded_bytes) (RGB, RGBA, P, L, etc.) */
  mode: string;
}

/** HostedURL */
export interface HostedURL {
  /** Prefix of the URL of every hosted image. */
  prefix: string;
  /** Suffix of an image stored in different sizes. */
  suffix: string;
  /**
   * The sizes field lists which images of the different sizes are hosted in our storage. The URL
   * of each hosted image can be obtained by joining the prefix, one of the sizes and suffix.
   */
  sizes: string[];
  /**
   * The crossorigin property of html media tag
   * For Secure Data Hosting this needs to be set to 'use-credentials'
   */
  crossorigin: string;
}

/** Input */
export interface Input {
  /** The ID for the input */
  id: string;
  /** The data passed along in this input. */
  data:
    | Data
    | undefined;
  /**
   * When the input was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When the input was modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * This is the status at a per Input level which allows for
   * partial failures.
   */
  status:
    | Status
    | undefined;
  /**
   * List of dataset IDs that this input is part of
   * Currently, this field is ONLY used to
   * * search inputs part of dataset(s), e.g. in `PostSearches`, `PostInputsSearches` and `PostAnnotationsSearches` endpoints, and
   * * to add inputs to dataset(s) in `PostInputs` endpoint.
   * Note that this field is ignored for other endpoints, e.g. `GetInput`, `ListInputs` and `PatchInputs`.
   */
  datasetIds: string[];
}

/**
 * InputBatch is a batch of Input resources. Large amounts of inputs are usually
 * divided into multiple InputBatches.
 */
export interface InputBatch {
  inputs: Input[];
}

/** NOTE: inconsistency: this is weird mix of plural and singular words. */
export interface InputCount {
  processed: number;
  toProcess: number;
  errors: number;
  processing: number;
  reindexed: number;
  toReindex: number;
  reindexErrors: number;
  reindexing: number;
}

/** Dataset */
export interface Dataset {
  /** The ID for the dataset */
  id: string;
  /**
   * When the dataset was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * When the dataset was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** The app the dataset belongs to. */
  appId: string;
  /** The user the dataset belongs to. */
  userId: string;
  /** Description of the dataset */
  description: string;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** Default annotation filter used for this dataset. */
  defaultAnnotationFilter:
    | AnnotationFilter
    | undefined;
  /** Default processing info used for this dataset. */
  defaultProcessingInfo:
    | DatasetVersionProcessingInfo
    | undefined;
  /**
   * Notes for the dataset
   * This field should be used for in-depth notes and supports up to 64Kbs.
   */
  notes: string;
  /**
   * Dataset version associated with this dataset. This is used in listing Datasets
   * and including the latest version.
   */
  version:
    | DatasetVersion
    | undefined;
  /** Whether the dataset is starred by the requesting user. */
  isStarred: boolean;
  /** Number of users that starred this dataset. */
  starCount: number;
  /**
   * bookmark info. When set, this dataset is a bookmarked dataset of this app.
   * Info in this field will allow you to find/access original dataset.
   */
  bookmarkOrigin:
    | BookmarkOrigin
    | undefined;
  /** Representative image for this dataset */
  image: Image | undefined;
}

/**
 * AnnotationFilter is used to create a new dataset version.
 * For now, the filter is simply a wrapper over a Search.
 * In the future, we may add extra fields to customize the filtering.
 */
export interface AnnotationFilter {
  /** The ID for the annotation filter */
  id: string;
  /**
   * When the annotation filter was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * When the annotation filter was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** The user the annotation filter belongs to. */
  userId: string;
  /** The app the annotation filter belongs to. */
  appId: string;
  /** The search that this filter uses. */
  search: Search | undefined;
}

/** DatasetInput */
export interface DatasetInput {
  /**
   * When the input was added to the dataset.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /** The input data. */
  input: Input | undefined;
}

/** DatasetVersion */
export interface DatasetVersion {
  /** The ID for the dataset version */
  id: string;
  /**
   * When the dataset version was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * When the dataset version was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** The app the dataset version belongs to. */
  appId: string;
  /** The user the dataset version belongs to. */
  userId: string;
  /** The dataset the dataset version belongs to. */
  datasetId: string;
  /** The dataset version will be generated based on a single annotation filter. */
  annotationFilterConfig?:
    | AnnotationFilterConfig
    | undefined;
  /** The dataset version will be generated based on model version inferences. */
  modelPredictConfig?:
    | ModelPredictConfig
    | undefined;
  /** Status for this dataset version. */
  status:
    | Status
    | undefined;
  /** Description of the dataset version */
  description: string;
  /**
   * Dataset version processing. If this is not set when the dataset version is
   * created, then the dataset default_processing_info is copied instead. Later
   * updates to default_processing_info will not apply to existing versions.
   */
  processingInfo:
    | DatasetVersionProcessingInfo
    | undefined;
  /** Dataset version metrics */
  metrics: { [key: string]: DatasetVersionMetrics };
  /** Dataset version exports */
  exportInfo:
    | DatasetVersionExportInfo
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** The embedding models to return embeddings for. If empty, no embeddings are returned. */
  embedModelVersionIds: string[];
  /**
   * Read Only. Cannot be Set
   * Origin of request for new dataset version
   */
  requestOrigin: DatasetVersionRequestOrigin;
}

export interface DatasetVersion_MetricsEntry {
  key: string;
  value: DatasetVersionMetrics | undefined;
}

export interface AnnotationFilterConfig {
  /** The annotation filter that is used. */
  annotationFilter:
    | AnnotationFilter
    | undefined;
  /**
   * If true, empty inputs are not included in the dataset version.
   * If false, empty inputs are included in the dataset version.
   * We define an empty input as an input without any annotations after annotation filter is applied.
   */
  ignoreEmptyInputs: boolean;
}

export interface ModelPredictConfig {
  /** Assumed to be owned by the calling users app unless user_id and app_id are filled out. */
  model: Model | undefined;
}

export interface DatasetVersionMetrics {
  /** Number of inputs */
  inputsCount:
    | number
    | undefined;
  /**
   * Number of unlabeled inputs
   * An input is considered unlabeled if it there are no annotations with positive labels for that input.
   */
  unlabeledInputsCount:
    | number
    | undefined;
  /** Number of inputs that have metadata */
  inputsWithMetadataCount:
    | number
    | undefined;
  /** Number of inputs that have geo information */
  inputsWithGeoCount:
    | number
    | undefined;
  /** Number of regions */
  regionsCount:
    | number
    | undefined;
  /**
   * The matrix shows where the regions are located.
   * Example: If the matrix has 2x2 dimensions, then
   * * region_location_matrix[0][0] = the number of regions that appear in the top left corner, i.e. [0,0]..(0.5,0.5)
   * * region_location_matrix[0][1] = the number of regions that appear in the top right corner, i.e. [0,0.5]..[0.5,1]
   * * region_location_matrix[1][0] = the number of regions that appear in the bottom left corner, i.e. [0.5,0]..[1,0.5)
   * * region_location_matrix[1][1] = the number of regions that appear in the bottom right corner, i.e. [0.5,0.5]..[1,1]
   */
  regionLocationMatrix:
    | MatrixUint64
    | undefined;
  /** Number of bounding boxes */
  boundingBoxesCount:
    | number
    | undefined;
  /** Number of polygons */
  polygonsCount:
    | number
    | undefined;
  /** Number of points */
  pointsCount:
    | number
    | undefined;
  /** Number of masks */
  masksCount:
    | number
    | undefined;
  /**
   * Number of inputs that have regions attached
   * Note that this is not a recursive count: if an input contains frames that contains regions, then the region_frames_count is increased, but region_inputs_count is not increased.
   */
  regionInputsCount:
    | number
    | undefined;
  /** Number of frames that have regions attached */
  regionFramesCount:
    | number
    | undefined;
  /** Number of frames */
  framesCount:
    | number
    | undefined;
  /** Number of inputs that have frames attached */
  frameInputsCount:
    | number
    | undefined;
  /** Number of embeddings */
  embeddingsCount:
    | number
    | undefined;
  /** Number of positive tags added at input-level */
  positiveInputTagsCount:
    | number
    | undefined;
  /** Number of positive tags added at region-level */
  positiveRegionTagsCount:
    | number
    | undefined;
  /** Number of positive tags added at frame-level */
  positiveFrameTagsCount: number | undefined;
}

export interface DatasetVersionMetricsGroup {
  parentPath: string;
  type: DatasetVersionMetricsGroupType;
  value: any | undefined;
  metrics: DatasetVersionMetrics | undefined;
}

/**
 * DatasetVersionExportInfo contains information about all exports of a dataset version.
 *
 * If the dataset version has not been exported in a format, then the DatasetVersionExport
 * field for that format is empty instead of having a "not exported" status.
 */
export interface DatasetVersionExportInfo {
  /** clarifai_data_protobuf is a CLARIFAI_DATA_PROTOBUF export of the dataset version. */
  clarifaiDataProtobuf:
    | DatasetVersionExport
    | undefined;
  /** clarifai_data_json is a CLARIFAI_DATA_JSON export of the dataset version. */
  clarifaiDataJson:
    | DatasetVersionExport
    | undefined;
  /** coco is a COCO export of the dataset version. */
  coco: DatasetVersionExport | undefined;
}

/** DatasetVersionExport contains metadata for a single dataset version export. */
export interface DatasetVersionExport {
  /** format is the format of the dataset version export. */
  format: DatasetVersionExportFormat;
  /** status is the current status of the dataset version export. */
  status:
    | Status
    | undefined;
  /** url is the URL from where the dataset version export can be downloaded. */
  url: string;
  /** size is the size of the dataset version export in number of bytes. */
  size: number;
  /** whether to include embeddings in the export or not. */
  includeEmbeddings: boolean;
}

/**
 * DatasetVersionProcessingInfo contains information about processing applied
 * to a dataset version.
 */
export interface DatasetVersionProcessingInfo {
  /**
   * If frame_interpolation_info is set, then these settings are used to
   * interpolate new frame annotation from other video annotations.
   *
   * If frame_interpolation_info is set in the dataset default_processing_info,
   * then it can be disabled for a single dataset version by setting
   * processing_info but not setting processing_info.frame_interpolation_info.
   */
  frameInterpolationInfo: FrameInterpolationInfo | undefined;
}

/**
 * FrameInterpolationInfo contains information about frame annotations
 * interpolated from other video annotations, such as image object-detection
 * regions generated from video object-tracking regions.
 */
export interface FrameInterpolationInfo {
  /**
   * sample_ms is the sampling rate at which frame annotations are interpolated.
   * If sample_ms is zero, then the dataset default_processing_info value is used.
   * If the dataset default is zero or not set, then the input frame prediction
   * sampling rate is used.
   */
  sampleMs: number;
}

/** Key */
export interface Key {
  /** The id of this key, it is used for authorization. */
  id: string;
  /** The type of key, it can be app_specific_key (default) or personal_access_token */
  type: string;
  /** The description */
  description: string;
  /** The low-level scopes this key has */
  scopes: string[];
  /** The endpoint-level scopes this key has */
  endpoints: string[];
  /**
   * The apps that this key give you access to, it is empty if this key is personal_access_token
   * API key can only give you access to a single app.
   */
  apps: App[];
  /**
   * When the key was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When does the key expires, the key won't expire if this is empty */
  expiresAt:
    | Date
    | undefined;
  /** list of idp ids at which key is currently authorized */
  authorizedIdpIds: string[];
}

/**
 * This is the Model object which represents a created model in the platform.
 * Each model has a particular type denoted by the model_type_id.
 * When creating a Model with PostModels the following happens:
 *  - if the ModelType is trainable, then a new ModelVersion is created that is
 *    - UNTRAINED status by default
 *    - TRAINED status if a ModelVersion was included with PretrainedModelConfig in PostModels
 *  - if the ModelType is not trainable, then a new ModelVersion is created with TRAINED status.
 * To modify config settings like OutputInfo for the Model you an use PatchModels. This will
 * also create a new ModelVersion, potentially UNTRAINED following the same rules as above.
 * The fields that are patchable include Model.name, Model.display_name and Model.output_info
 * (except the Model.output_info.type and Model.output_info.type_ext).
 */
export interface Model {
  /** The model's ID. Must be unique within a particular app and URL-friendly. */
  id: string;
  /**
   * DEPRECATED: Please use the model id to name the model.
   *
   * @deprecated
   */
  name: string;
  /**
   * When the model was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   *  the following from the API:
   *  "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** When was the most recent model version created at */
  modifiedAt:
    | Date
    | undefined;
  /** The app the model belongs to. */
  appId: string;
  /**
   * Info about the model's output and configuration.
   * DEPRECATED: Will be moved to model version
   *
   * @deprecated
   */
  outputInfo:
    | OutputInfo
    | undefined;
  /**
   * A particular version of the model, e.g., to specify the version when creating a workflow or
   * when listing Models to include the latest ModelVersion of the model in the response.
   */
  modelVersion:
    | ModelVersion
    | undefined;
  /**
   * DEPRECATED: Please use the model id to name the model.
   *
   * @deprecated
   */
  displayName: string;
  /** The user id that the model belongs to. */
  userId: string;
  /** The default evaluation info. Can be overwritten by eval request. */
  defaultEvalInfo:
    | EvalInfo
    | undefined;
  /**
   * The ModelType.Id that is used for this model. This is used for all versions and you cannot
   * change model_type_id between versions of the same model.
   */
  modelTypeId: string;
  /** The task the model was trained to do */
  task: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** Short description about this model */
  description: string;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
  presets:
    | { [key: string]: any }
    | undefined;
  /**
   * Notes for the model
   * This field should be used for in-depth notes and supports up to 64Kbs.
   */
  notes: string;
  /** Tags from toolkits category */
  toolkits: string[];
  /** Tags from use_cases category */
  useCases: string[];
  /** Tags from languages category. */
  languages: string[];
  /** Tags from languages category with names, only used in responses. */
  languagesFull: FullTag[];
  checkConsents: string[];
  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostModelStars/DeleteModelStars endpoints to star/unstar a model
   */
  isStarred: boolean;
  /**
   * How many users have starred the model (only showed on get/list requests)
   * Computed value, not editable
   */
  starCount: number;
  /** Whether it's recommended that this model is used within a workflow */
  workflowRecommended:
    | boolean
    | undefined;
  /**
   * bookmark info. When set, this model is a bookmarked model of this app.
   * Info in this field will allow you to find/access original model.
   */
  bookmarkOrigin:
    | BookmarkOrigin
    | undefined;
  /** Representative image for this model */
  image:
    | Image
    | undefined;
  /** License Type */
  licenseType: LicenseType;
  source: Model_Source;
  /** Creator of Model */
  creator: string;
  versionCount: number;
  billingType: Model_BillingType;
  /**
   * Whether the model should be featured, and if so, the order in which it should be featured.
   * The order is relative to other models that are also featured.
   * Models with a higher order will be featured first.
   */
  featuredOrder:
    | number
    | undefined;
  /** Deploy restriction for the model. */
  deployRestriction: DeployRestriction;
  /**
   * replica_count indicates the number of deployed model replicas.
   * This field is populated when `show_replicas` is true in ListModelsRequest.
   */
  replicaCount: number;
  /** OpenRouter Info for the model */
  openRouterInfo: OpenRouterInfo | undefined;
}

/** Source of Model */
export enum Model_Source {
  UNKNOWN_SOURCE = 0,
  HOSTED = 1,
  WRAPPED = 2,
  UNRECOGNIZED = -1,
}

export function model_SourceFromJSON(object: any): Model_Source {
  switch (object) {
    case 0:
    case "UNKNOWN_SOURCE":
      return Model_Source.UNKNOWN_SOURCE;
    case 1:
    case "HOSTED":
      return Model_Source.HOSTED;
    case 2:
    case "WRAPPED":
      return Model_Source.WRAPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_Source.UNRECOGNIZED;
  }
}

export function model_SourceToJSON(object: Model_Source): string {
  switch (object) {
    case Model_Source.UNKNOWN_SOURCE:
      return "UNKNOWN_SOURCE";
    case Model_Source.HOSTED:
      return "HOSTED";
    case Model_Source.WRAPPED:
      return "WRAPPED";
    case Model_Source.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Model_BillingType {
  Unknown = 0,
  Tokens = 1,
  Ops = 2,
  UNRECOGNIZED = -1,
}

export function model_BillingTypeFromJSON(object: any): Model_BillingType {
  switch (object) {
    case 0:
    case "Unknown":
      return Model_BillingType.Unknown;
    case 1:
    case "Tokens":
      return Model_BillingType.Tokens;
    case 2:
    case "Ops":
      return Model_BillingType.Ops;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_BillingType.UNRECOGNIZED;
  }
}

export function model_BillingTypeToJSON(object: Model_BillingType): string {
  switch (object) {
    case Model_BillingType.Unknown:
      return "Unknown";
    case Model_BillingType.Tokens:
      return "Tokens";
    case Model_BillingType.Ops:
      return "Ops";
    case Model_BillingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OpenRouterInfo {
  params: { [key: string]: any } | undefined;
}

/** A link to a html/markdown/text file that stores reference material tied to a model. */
export interface ModelReference {
  /** Id of the reference */
  id: string;
  /** The id of the model this Model reference is tied to. */
  modelId: string;
  /** address of resource */
  url: string;
  /** name of link */
  name: string;
  /**
   * To handle arbitrary json metadata:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
}

/** ModelVersionInputExample */
export interface ModelVersionInputExample {
  /** user unique id */
  id: string;
  /** external id of model */
  modelId: string;
  /** external id of model version */
  modelVersionId: string;
  /** data to store as example input for model */
  data:
    | Data
    | undefined;
  /** name of link for display */
  name: string;
  /** description of link contents */
  description: string;
}

/**
 * OutputInfo defines some of the settings for each model version that PatchModels can effect. These
 * parameters control some of the training or inference operations that this model can do.
 * As the number of parameters continued to grow when we launched more ModelTypes we decided to move
 * to using the OutputInfo.params field which is a Struct (or JSON object if you're using
 * our JSON REST APIs). This allows each ModelType to define the set of fields, their default values
 * and description of each field so that we can display those in Portal and make the creation of
 * Model's very extensible. The OutputConfig object will eventually go away in favor of
 * output_info.params struct.
 */
export interface OutputInfo {
  /** List of concepts or other output related data for the model. */
  data:
    | Data
    | undefined;
  /**
   * Model configuration...going away in favor of output_info.params and train_params over time.
   * TO BE DEPRECATED
   */
  outputConfig:
    | OutputConfig
    | undefined;
  /** For returning where to look for the Output info if not returning it. */
  message: string;
  /**
   * Map from the api.Data field names to the underlying model graph's outputs. When using a
   * PretrainedModelConfig the values in this map need to match the Triton config.pbtxt output names.
   */
  fieldsMap:
    | { [key: string]: any }
    | undefined;
  /**
   * For predicting with the various ModelType's we accept a Struct (JSON object) worth of args
   * that the ModelTypeField defines. During inference, the settings contained within are sent
   * to the model predictor to alter predictions from this Model.
   */
  params:
    | { [key: string]: any }
    | undefined;
  /**
   * These allow you to specifcy addition fields that a specific model supports beyond those defined
   * in it's ModelType. This field is to be deprecated and will be replaced by MethodSignature
   * proto.
   */
  paramsSpecs: ModelTypeField[];
}

/** InputInfo */
export interface InputInfo {
  /**
   * Map from the api.Data field names to the underlying model graph's inputs. When using a
   * PretrainedModelConfig the values in this map need to match the Triton config.pbtxt input names.
   */
  fieldsMap:
    | { [key: string]: any }
    | undefined;
  /**
   * To control the inputs to the given model we allow a list of parameters
   * defined for each ModelType as a Struct (JSON object) here. During training or inference, the
   * settings contained within are sent to the training processor to alter the training process.
   */
  params:
    | { [key: string]: any }
    | undefined;
  /** For base model to get embeddings from for transfer learned models. */
  baseEmbedModel: Model | undefined;
}

export interface TrainInfo {
  /**
   * To control the training process when PostModelVersions is used we allow a list of parameters
   * defined for each ModelType as a Struct (JSON object) here. During training, the settings
   * contained within are sent to the training processor to alter the training process.
   */
  params:
    | { [key: string]: any }
    | undefined;
  /** The dataset and dataset version this model version was or will be trained on */
  dataset:
    | Dataset
    | undefined;
  /** The model to resume training from. */
  resumeFromModel: Model | undefined;
}

export interface EvalInfo {
  /**
   * To control the evaluation process.
   * Allow a list of parameters.
   */
  params: { [key: string]: any } | undefined;
}

/** DEPRECATED: no longer support importing models from third party toolkits */
export interface ImportInfo {
  /**
   * Used to configure model imports from third-party toolkits.
   * DEPRECATED: no longer support importing models from third party toolkits
   */
  params: { [key: string]: any } | undefined;
}

/**
 * OutputConfig is a collection of parameters controlling either inference or training settings for
 * the given Model. This message will be deprecated over time in favor or output_info.params and
 * train_params in OutputInfo which are cleaner and more extensible for many ModelTypes.
 */
export interface OutputConfig {
  /**
   * For custom concept model training: whether the concept predictions must sum to 1.
   *
   * @deprecated
   */
  conceptsMutuallyExclusive: boolean;
  /**
   * DEPRECATED: For custom models, this is the base model to use for image embeddings.
   * Default is general model.
   *
   * @deprecated
   */
  existingModelId: string;
  /** For concept model predictions: Overrides the default_language for the app in a predict call. */
  language: string;
  /**
   * DEPRECATED: Hyper-parameters for custom training.
   * Use new hyper_params field instead.
   *
   * @deprecated
   */
  hyperParameters: string;
  /**
   * For concept model predictions:  Maximum number of concepts in result. Defaults to 0 which under
   * the hood will return default of 20. We do a server side default in order to control this
   * feature in the future.
   */
  maxConcepts: number;
  /**
   * For concept model predictions: Minimum value of concept's probability score in result.
   * Defaults to 0.0 which means we won't do any thresholding as all probabilities will
   * likely be > 0.0.
   */
  minValue: number;
  /** For concept model predictions: Select concepts in result by name or by id */
  selectConcepts: Concept[];
  /** For custom concept model training: Training timeout of the model (in seconds) */
  trainingTimeout: number;
  /** For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds) */
  sampleMs: number;
  /** For custom model training: Hyperparameters for custom training */
  hyperParams:
    | { [key: string]: any }
    | undefined;
  /**
   * For custom model training: this is the base model version to use for image embeddings.
   * This has to be one of the embed models in the app workflow.
   *
   * @deprecated
   */
  embedModelVersionId: string;
  /**
   * For custom model training: Use this flag to fail on missing positive examples
   * By default we fill in the missing with random examples
   */
  failOnMissingPositiveExamples: boolean;
  /**
   * For custom model training: This is any additional metadata as a JSON object that we want
   * want to persist in the model's output config. This is a useful quick way to set fields for
   * introducing fields for new model types so we don't have to add a new proto field and DB field
   * each time. Please refer to the documentation or model implementation internally for more
   * details on what fields are supported for which models.
   * TODO(zeiler): remove this field after Portal is updated.
   *
   * @deprecated
   */
  modelMetadata: { [key: string]: any } | undefined;
}

/**
 * ModelType is a definition of a set of models that generally have the same input and output fields.
 * This is used to understand more about the possible models in our platform.
 */
export interface ModelType {
  /** A unique identifier for this model type. */
  id: string;
  /** A display title for this model. */
  title: string;
  /** Description of this model type. */
  description: string;
  /**
   * The list of input fields that this model expects as inputs.
   * Used to validate that request input data has the expected fields.
   */
  inputFields: string[];
  /** The list of output fields that this model accepts. */
  outputFields: string[];
  /** Is this model trainable in our platform. */
  trainable: boolean;
  /**
   * Is this model creatable. We have some pre-trained model types that users cannot create yet in
   * model mode.
   */
  creatable: boolean;
  /** Is this model type only for internal users at this time. */
  internalOnly: boolean;
  /** The remaining fields are definitions of the configurable fields that exist. */
  modelTypeFields: ModelTypeField[];
  /**
   * For sequence models we need to know when processing that they require temporal time frames
   * in sequential order. This will be true for model types like trackers as an example.
   */
  requiresSequentialFrames: boolean;
  /** Expected input layers of an uploaded model. */
  expectedInputLayers: ModelLayerInfo[];
  /** Expected output layers of an uploaded model */
  expectedOutputLayers: ModelLayerInfo[];
  /** What type of evaluation is supported for this model type. */
  evaluationType: EvaluationType;
  /**
   * method signature for this model type
   * This will be used in the future to replace input_fields, output_fields, and model_type_fields
   * as it can define any python function call.
   */
  methodSignatures: MethodSignature[];
}

export interface ModelLayerInfo {
  /** The api.Data field this layer will be parsed into */
  dataFieldName: string;
  /** Description of the expected shape. Can support multiple support layer shapes. */
  shapes: LayerShape[];
  /** Brief description about the layer if needed */
  description: string;
  /** Whether this layer should have a label_filename specified and provided */
  requiresLabelFilename: boolean;
}

export interface TritonCondaEnvInfo {
  condaPackUrl: string;
  condaYamlUrl: string;
}

export interface LayerShape {
  /**
   * Supported dimensions
   * Example: [-1,4] is a 2-dimensional array with the first dimension of variablesize, but second dimension with a static size: [[1,2,3,4],[4,5,6,7],...]
   */
  dims: number[];
  /** Max dimension size, applicable to layers that can have flexible sizes. */
  maxDims: number[];
  /** The triton data type */
  dataType: DataType;
  /** Description about the dimensions */
  description: string;
}

/** ModelTypeField stores a field value of a configurable type. */
export interface ModelTypeField {
  /**
   * The path where the value of the field will be stored in the model version object.
   * Example:
   * "output_info.data" would be the Data message in the OutputInfo message.
   * "output_info.output_config.language" is in the OutputConfig message within OutputInfo
   * "input_info.params" is in the params struct within InputInfo.
   * "output_info.params" is in the params struct within OutputInfo.
   * "train_info.params" is in the params struct within TrainInfo.
   * and so on.
   */
  path: string;
  /**
   * The field for this field. This is often used for displaying the field in the UI whereas
   * the DataType enum below defines the specific type of datain the Python function.
   */
  fieldType: ModelTypeField_ModelTypeFieldType;
  /**
   * A default value. We use the Value field because we want to have structured data (just like
   * google.protobuf.Struct but this is just a single value).
   */
  defaultValue:
    | any
    | undefined;
  /** Description for this field. */
  description: string;
  /** Placeholder text for the UI element. */
  placeholder: string;
  /** List of options of the ENUM type and potentially additional fields they bring with them. */
  modelTypeEnumOptions: ModelTypeEnumOption[];
  /** If this field should appear for internal users only. */
  internalOnly: boolean;
  /**
   * If this field is a required field. If True then during validation you won't be able to create
   * a model of this type with providing a value for this field. When False, the ModelType's
   * default_value will be used for this field.
   */
  required: boolean;
  /** If the field_type is RANGE, this must be filled in. */
  modelTypeRangeInfo:
    | ModelTypeRangeInfo
    | undefined;
  /** name of method signature argument */
  name: string;
  /** The type of the argument. */
  type: ModelTypeField_DataType;
  /**
   * type enum, and recursively set type_args with
   * the inner type argumets in complex objects (e.g. List[Tuple[int, str]])
   */
  typeArgs: ModelTypeField[];
  /** this will be use to define whether the method argument supports streaming as an iterator. */
  iterator: boolean;
  /**
   * This specify the default value of the method argument
   * If this argument is not passed, the input is required. If it is explicitly set to None, the input is optional
   * We define this as a string
   * because the default value can be a string, int, float, bool, or a complex object like a JSON
   * The default_value field above should not also be used.
   */
  default: string;
  /** wheather it's a inference param or a modeltype field */
  isParam: boolean;
}

/** These are various types of fields that we have UIs for. */
export enum ModelTypeField_ModelTypeFieldType {
  INVALID_MODEL_TYPE_FIELD_TYPE = 0,
  BOOLEAN = 1,
  STRING = 2,
  NUMBER = 3,
  /** ARRAY_OF_CONCEPTS - For auto-completing to concepts in the app. This goes into an data.concepts field. */
  ARRAY_OF_CONCEPTS = 4,
  /** ARRAY_OF_CONCEPTS_WITH_THRESHOLD - For auto-completing to concepts in the app. This goes into an data.concepts field. */
  ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5,
  /** RANGE - A range for a float value. */
  RANGE = 7,
  /**
   * ENUM - If ENUM is used then the "enum_options" field should also be filled in with the respective ID and description
   * for the different ENUM options.
   */
  ENUM = 8,
  /** COLLABORATORS - For listing collaborators of the app. The field is a string of the collaborator's user_id. */
  COLLABORATORS = 9,
  /** JSON - For arbitrary json object: "{...}" */
  JSON = 10,
  /** ARRAY_OF_NUMBERS - Such as [1.0, 2.0, 3.5] */
  ARRAY_OF_NUMBERS = 11,
  /** WORKFLOW_EMBED_MODELS - For selecting the embed_model_version_id for context based models. */
  WORKFLOW_EMBED_MODELS = 12,
  /** ARRAY_OF_STRINGS - Such as ['a', 'b', 'cantaloupe'] */
  ARRAY_OF_STRINGS = 13,
  /**
   * RECURSIVE_ENUM - If RECURSIVE_ENUM is used then the "enum_options" field should also be filled in with the respective ID and
   * description for the different RECURSIVE_ENUM options, as well as model_type_fields for each enum choice.
   */
  RECURSIVE_ENUM = 14,
  /** PYTHON_CODE - For blocks of code that need to be specified by the user for setup or execution during workflow runs. */
  PYTHON_CODE = 15,
  /** DATASET_ID - For selecting a dataset id in model parameters. String in API request. */
  DATASET_ID = 16,
  /** DATASET_VERSION_ID - For selecting a dataset version id. String. */
  DATASET_VERSION_ID = 17,
  /** ARRAY_OF_MODEL_CONCEPTS - For auto-completing to concepts in the model. */
  ARRAY_OF_MODEL_CONCEPTS = 18,
  /** DATASET - For selecting a dataset */
  DATASET = 19,
  /** DATASET_VERSION - For selecting a dataset version */
  DATASET_VERSION = 20,
  /** ENCRYPTED_STRING - To pass a string downstream, that is encrypted in the DB and API. */
  ENCRYPTED_STRING = 21,
  /** CHECKPOINT_MODEL - For selecting a model version of the same model type to resume training from. */
  CHECKPOINT_MODEL = 22,
  /** ARRAY_OF_SECRETS - For model secrets */
  ARRAY_OF_SECRETS = 23,
  UNRECOGNIZED = -1,
}

export function modelTypeField_ModelTypeFieldTypeFromJSON(object: any): ModelTypeField_ModelTypeFieldType {
  switch (object) {
    case 0:
    case "INVALID_MODEL_TYPE_FIELD_TYPE":
      return ModelTypeField_ModelTypeFieldType.INVALID_MODEL_TYPE_FIELD_TYPE;
    case 1:
    case "BOOLEAN":
      return ModelTypeField_ModelTypeFieldType.BOOLEAN;
    case 2:
    case "STRING":
      return ModelTypeField_ModelTypeFieldType.STRING;
    case 3:
    case "NUMBER":
      return ModelTypeField_ModelTypeFieldType.NUMBER;
    case 4:
    case "ARRAY_OF_CONCEPTS":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_CONCEPTS;
    case 5:
    case "ARRAY_OF_CONCEPTS_WITH_THRESHOLD":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_CONCEPTS_WITH_THRESHOLD;
    case 7:
    case "RANGE":
      return ModelTypeField_ModelTypeFieldType.RANGE;
    case 8:
    case "ENUM":
      return ModelTypeField_ModelTypeFieldType.ENUM;
    case 9:
    case "COLLABORATORS":
      return ModelTypeField_ModelTypeFieldType.COLLABORATORS;
    case 10:
    case "JSON":
      return ModelTypeField_ModelTypeFieldType.JSON;
    case 11:
    case "ARRAY_OF_NUMBERS":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_NUMBERS;
    case 12:
    case "WORKFLOW_EMBED_MODELS":
      return ModelTypeField_ModelTypeFieldType.WORKFLOW_EMBED_MODELS;
    case 13:
    case "ARRAY_OF_STRINGS":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_STRINGS;
    case 14:
    case "RECURSIVE_ENUM":
      return ModelTypeField_ModelTypeFieldType.RECURSIVE_ENUM;
    case 15:
    case "PYTHON_CODE":
      return ModelTypeField_ModelTypeFieldType.PYTHON_CODE;
    case 16:
    case "DATASET_ID":
      return ModelTypeField_ModelTypeFieldType.DATASET_ID;
    case 17:
    case "DATASET_VERSION_ID":
      return ModelTypeField_ModelTypeFieldType.DATASET_VERSION_ID;
    case 18:
    case "ARRAY_OF_MODEL_CONCEPTS":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_MODEL_CONCEPTS;
    case 19:
    case "DATASET":
      return ModelTypeField_ModelTypeFieldType.DATASET;
    case 20:
    case "DATASET_VERSION":
      return ModelTypeField_ModelTypeFieldType.DATASET_VERSION;
    case 21:
    case "ENCRYPTED_STRING":
      return ModelTypeField_ModelTypeFieldType.ENCRYPTED_STRING;
    case 22:
    case "CHECKPOINT_MODEL":
      return ModelTypeField_ModelTypeFieldType.CHECKPOINT_MODEL;
    case 23:
    case "ARRAY_OF_SECRETS":
      return ModelTypeField_ModelTypeFieldType.ARRAY_OF_SECRETS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelTypeField_ModelTypeFieldType.UNRECOGNIZED;
  }
}

export function modelTypeField_ModelTypeFieldTypeToJSON(object: ModelTypeField_ModelTypeFieldType): string {
  switch (object) {
    case ModelTypeField_ModelTypeFieldType.INVALID_MODEL_TYPE_FIELD_TYPE:
      return "INVALID_MODEL_TYPE_FIELD_TYPE";
    case ModelTypeField_ModelTypeFieldType.BOOLEAN:
      return "BOOLEAN";
    case ModelTypeField_ModelTypeFieldType.STRING:
      return "STRING";
    case ModelTypeField_ModelTypeFieldType.NUMBER:
      return "NUMBER";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_CONCEPTS:
      return "ARRAY_OF_CONCEPTS";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_CONCEPTS_WITH_THRESHOLD:
      return "ARRAY_OF_CONCEPTS_WITH_THRESHOLD";
    case ModelTypeField_ModelTypeFieldType.RANGE:
      return "RANGE";
    case ModelTypeField_ModelTypeFieldType.ENUM:
      return "ENUM";
    case ModelTypeField_ModelTypeFieldType.COLLABORATORS:
      return "COLLABORATORS";
    case ModelTypeField_ModelTypeFieldType.JSON:
      return "JSON";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_NUMBERS:
      return "ARRAY_OF_NUMBERS";
    case ModelTypeField_ModelTypeFieldType.WORKFLOW_EMBED_MODELS:
      return "WORKFLOW_EMBED_MODELS";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_STRINGS:
      return "ARRAY_OF_STRINGS";
    case ModelTypeField_ModelTypeFieldType.RECURSIVE_ENUM:
      return "RECURSIVE_ENUM";
    case ModelTypeField_ModelTypeFieldType.PYTHON_CODE:
      return "PYTHON_CODE";
    case ModelTypeField_ModelTypeFieldType.DATASET_ID:
      return "DATASET_ID";
    case ModelTypeField_ModelTypeFieldType.DATASET_VERSION_ID:
      return "DATASET_VERSION_ID";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_MODEL_CONCEPTS:
      return "ARRAY_OF_MODEL_CONCEPTS";
    case ModelTypeField_ModelTypeFieldType.DATASET:
      return "DATASET";
    case ModelTypeField_ModelTypeFieldType.DATASET_VERSION:
      return "DATASET_VERSION";
    case ModelTypeField_ModelTypeFieldType.ENCRYPTED_STRING:
      return "ENCRYPTED_STRING";
    case ModelTypeField_ModelTypeFieldType.CHECKPOINT_MODEL:
      return "CHECKPOINT_MODEL";
    case ModelTypeField_ModelTypeFieldType.ARRAY_OF_SECRETS:
      return "ARRAY_OF_SECRETS";
    case ModelTypeField_ModelTypeFieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * DataType is used in MethodSignature to define all the possible types that a python function
 * may have that we want to support. These include built-ins like int, float, str, bool, and
 * more complex types like JSON, numpy arrays, List, Tuple, Dict (as Named Fields), as well as Clarifai provided
 * unstructured types like Image, Video, Text, etc.
 */
export enum ModelTypeField_DataType {
  NOT_SET = 0,
  /** STR - A string value. */
  STR = 1,
  /** BYTES - A byte string. This is used for binary data. */
  BYTES = 2,
  /** INT - An integer value. */
  INT = 3,
  /** FLOAT - A float value. */
  FLOAT = 4,
  /** BOOL - A boolean value. */
  BOOL = 5,
  /** NDARRAY - A proto representation for numpy arrays. */
  NDARRAY = 6,
  /** JSON_DATA - For arbitrary json object: "{...}" */
  JSON_DATA = 7,
  /** TEXT - For text data */
  TEXT = 8,
  /** IMAGE - A image is a image proto for url or bytes. */
  IMAGE = 9,
  /** CONCEPT - A concept is a concept proto that represents a concept in the app. */
  CONCEPT = 10,
  /** REGION - A region is a bounding box in an image or video frame. */
  REGION = 11,
  /** FRAME - A frame is a single image in a video stream */
  FRAME = 12,
  /** AUDIO - A audio is a audio proto for url or bytes. */
  AUDIO = 13,
  /** VIDEO - A video is a video proto for url or bytes. */
  VIDEO = 14,
  /** NAMED_FIELDS - this can be used to store named fields with values similar to Dict */
  NAMED_FIELDS = 15,
  /** TUPLE - An arg that is a tuple. */
  TUPLE = 16,
  /** LIST - An arg that is a list. */
  LIST = 17,
  UNRECOGNIZED = -1,
}

export function modelTypeField_DataTypeFromJSON(object: any): ModelTypeField_DataType {
  switch (object) {
    case 0:
    case "NOT_SET":
      return ModelTypeField_DataType.NOT_SET;
    case 1:
    case "STR":
      return ModelTypeField_DataType.STR;
    case 2:
    case "BYTES":
      return ModelTypeField_DataType.BYTES;
    case 3:
    case "INT":
      return ModelTypeField_DataType.INT;
    case 4:
    case "FLOAT":
      return ModelTypeField_DataType.FLOAT;
    case 5:
    case "BOOL":
      return ModelTypeField_DataType.BOOL;
    case 6:
    case "NDARRAY":
      return ModelTypeField_DataType.NDARRAY;
    case 7:
    case "JSON_DATA":
      return ModelTypeField_DataType.JSON_DATA;
    case 8:
    case "TEXT":
      return ModelTypeField_DataType.TEXT;
    case 9:
    case "IMAGE":
      return ModelTypeField_DataType.IMAGE;
    case 10:
    case "CONCEPT":
      return ModelTypeField_DataType.CONCEPT;
    case 11:
    case "REGION":
      return ModelTypeField_DataType.REGION;
    case 12:
    case "FRAME":
      return ModelTypeField_DataType.FRAME;
    case 13:
    case "AUDIO":
      return ModelTypeField_DataType.AUDIO;
    case 14:
    case "VIDEO":
      return ModelTypeField_DataType.VIDEO;
    case 15:
    case "NAMED_FIELDS":
      return ModelTypeField_DataType.NAMED_FIELDS;
    case 16:
    case "TUPLE":
      return ModelTypeField_DataType.TUPLE;
    case 17:
    case "LIST":
      return ModelTypeField_DataType.LIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelTypeField_DataType.UNRECOGNIZED;
  }
}

export function modelTypeField_DataTypeToJSON(object: ModelTypeField_DataType): string {
  switch (object) {
    case ModelTypeField_DataType.NOT_SET:
      return "NOT_SET";
    case ModelTypeField_DataType.STR:
      return "STR";
    case ModelTypeField_DataType.BYTES:
      return "BYTES";
    case ModelTypeField_DataType.INT:
      return "INT";
    case ModelTypeField_DataType.FLOAT:
      return "FLOAT";
    case ModelTypeField_DataType.BOOL:
      return "BOOL";
    case ModelTypeField_DataType.NDARRAY:
      return "NDARRAY";
    case ModelTypeField_DataType.JSON_DATA:
      return "JSON_DATA";
    case ModelTypeField_DataType.TEXT:
      return "TEXT";
    case ModelTypeField_DataType.IMAGE:
      return "IMAGE";
    case ModelTypeField_DataType.CONCEPT:
      return "CONCEPT";
    case ModelTypeField_DataType.REGION:
      return "REGION";
    case ModelTypeField_DataType.FRAME:
      return "FRAME";
    case ModelTypeField_DataType.AUDIO:
      return "AUDIO";
    case ModelTypeField_DataType.VIDEO:
      return "VIDEO";
    case ModelTypeField_DataType.NAMED_FIELDS:
      return "NAMED_FIELDS";
    case ModelTypeField_DataType.TUPLE:
      return "TUPLE";
    case ModelTypeField_DataType.LIST:
      return "LIST";
    case ModelTypeField_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ModelTypeRangeInfo */
export interface ModelTypeRangeInfo {
  /** The start of the range as a float. */
  min: number;
  /** The end of the range as a float. */
  max: number;
  /**
   * An optional step size for the range. If provided then only values at that step size will be
   * rounded to. For example if step is 0.02 then 0.0245 will round to 0.02.
   */
  step: number;
}

/** ModelTypeEnumOption */
export interface ModelTypeEnumOption {
  /** The unique value of the enum option. */
  id: string;
  /**
   * List of other ID values that are equivalent with this ID.
   * This allows the user to choose this option by multiple IDs.
   * Example: if enum is "Phone Number Prefix", you could add an option that is selectable by two values:
   * 1. ID: "Estonia"
   * 2. Alias: 37
   */
  aliases: ModelTypeEnumOptionAlias[];
  /** Optional description for this enum option. */
  description: string;
  /**
   * These are additional fields that are specific to this enum choice. This allows
   * us to use enums to control configuration settings as well.
   */
  modelTypeFields: ModelTypeField[];
  /** If this enum option should be internal only. */
  internalOnly: boolean;
  /**
   * Whether this is the recommended enum option. Set to `true` when there
   * are multiple options, and one is shown to be better than the others.
   */
  recommended: boolean;
}

export interface ModelTypeEnumOptionAlias {
  /** Integer alias for id. */
  idInt: number;
  /** String that can contain wild cards and the regex needs to match. */
  wildcardString: string;
}

/** ModelQuery */
export interface ModelQuery {
  /** The name ofthe field. This supports wilcard queries like "gen*" to match "general" as an example. */
  name: string;
  /**
   * Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
   * supported.
   */
  modelTypeId: string;
}

/** ModelVersion */
export interface ModelVersion {
  id: string;
  /** When the version was created. */
  createdAt:
    | Date
    | undefined;
  /** The status of the version (whether it's untrained, training, trained, etc.). */
  status: Status | undefined;
  activeConceptCount: number;
  metrics:
    | EvalMetrics
    | undefined;
  /** number of inputs in the model version */
  totalInputCount: number;
  /**
   * When a model has already been trained externally, you can upload
   * it directly to the platform as a model version directly by
   * setting the PretrainedModelConfig
   */
  pretrainedModelConfig:
    | PretrainedModelConfig
    | undefined;
  /** When training of this version was completed. */
  completedAt:
    | Date
    | undefined;
  /** Description about this version */
  description: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** The app the model version belongs to. */
  appId: string;
  /** The user the model version belongs to. */
  userId: string;
  /** When this model version was last modified */
  modifiedAt:
    | Date
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
  license: string;
  /**
   * Info about the model's output. Besides `output_info.data`, these fields should
   * be reserved for parameters that affect the models outputs when inferencing.
   * `output_info.data` is used to specify the training concepts for this model version.
   */
  outputInfo:
    | OutputInfo
    | undefined;
  /**
   * Info about preprocessing the models inputs, before they are sent to this model for training or inferencing.
   * E.g.: `input_info.base_embed_model` lets us know inputs should be ran through a base model before being sent to an embedding-classifier.
   */
  inputInfo:
    | InputInfo
    | undefined;
  /** Configuration for the training process of this model version. */
  trainInfo:
    | TrainInfo
    | undefined;
  /**
   * Configuration used to import model from third-party toolkits
   * DEPRECATED: no longer support importing models from third party toolkits
   *
   * @deprecated
   */
  importInfo:
    | ImportInfo
    | undefined;
  /** Contains the training logs if available */
  trainLog: string;
  /** The minimum required compute resource for this model for inference. */
  inferenceComputeInfo:
    | ComputeInfo
    | undefined;
  /** Build information for the model version */
  buildInfo:
    | BuildInfo
    | undefined;
  /** Model signature information for the model version */
  methodSignatures: MethodSignature[];
}

/**
 * MethodSignature is a definition of a method that a model can have.
 * This is used to communicate between a python method definition of any arbitrary function
 * to the client or UI on how to call that function from the client side.
 */
export interface MethodSignature {
  /** The name of the method on the server. */
  name: string;
  /** whether the method is for predict(unary-unary), generate(unary-stream), stream(stream-stream) */
  methodType: RunnerMethodType;
  /** description from the docstring of the method on the server. */
  description: string;
  /** input fields and signature of every method arguments */
  inputFields: ModelTypeField[];
  /** output signature of method */
  outputFields: ModelTypeField[];
}

export interface BuildInfo {
  /** Docker image name */
  dockerImageName: string;
  /** Docker image tag */
  dockerImageTag: string;
  /** Docker image digest */
  dockerImageDigest: string;
}

/** ModelVersionExport contains metadata for a single Model version export. */
export interface ModelVersionExport {
  /** status is the current status of the dataset version export. */
  status:
    | Status
    | undefined;
  /** url is the URL from where the model version export can be downloaded. */
  url: string;
  /** size of model file */
  size: number;
}

/** PretrainedModelConfig */
export interface PretrainedModelConfig {
  /**
   * This is the internal id of the pretrained model.
   * Map from the api.Data field names to the Triton config.pbtxt input.
   */
  inputFieldsMap:
    | { [key: string]: any }
    | undefined;
  /** Map from the api.Data field names to the Triton config.pbtxt output. */
  outputFieldsMap:
    | { [key: string]: any }
    | undefined;
  /**
   * Url to a zipped up model in triton format with the following files and folders at the root:
   *  config.pbtxt
   *  version 1 folder that contains model files (onnx graph, torch script, python BE model, and etc.)
   */
  modelZipUrl: string;
  /**
   * Whether to overwrite the model for the existing internal id
   * If this is a local dev model that runs external to the platform, set this to true.
   * This helps during development of models before uploading them to the platform.
   * These models MUST run in an associated compute cluster with cluster_type = "local-dev"
   */
  localDev: boolean;
}

/** TrainStats */
export interface TrainStats {
  lossCurve: LossCurveEntry[];
}

/** LossCurveEntry */
export interface LossCurveEntry {
  /** current epoch */
  epoch: number;
  /** current global step */
  globalStep: number;
  /**
   * current cost
   * FIXME(rigel): this should be loss instead of cost.
   */
  cost: number;
}

/** LabelCount */
export interface LabelCount {
  /** @deprecated */
  conceptName: string;
  count: number;
  concept: Concept | undefined;
}

/** LabelDistribution */
export interface LabelDistribution {
  positiveLabelCounts: LabelCount[];
}

/** NOTE: this is inefficient, should just have the order of the rows/cols */
export interface CooccurrenceMatrixEntry {
  /** concept_id for the row */
  row: string;
  /** concept_id for the col */
  col: string;
  count: number;
}

/** CooccurrenceMatrix */
export interface CooccurrenceMatrix {
  matrix: CooccurrenceMatrixEntry[];
  /** These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix. */
  conceptIds: string[];
}

/** ConfusionMatrixEntry */
export interface ConfusionMatrixEntry {
  predicted: string;
  actual: string;
  value: number;
  predictedConcept: Concept | undefined;
  actualConcept: Concept | undefined;
}

/** ConfusionMatrix */
export interface ConfusionMatrix {
  matrix: ConfusionMatrixEntry[];
  /** These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix. */
  conceptIds: string[];
}

/** ROC */
export interface ROC {
  fpr: number[];
  tpr: number[];
  thresholds: number[];
  fprPerImage: number[];
  fprPerObject: number[];
}

/** PrecisionRecallCurve */
export interface PrecisionRecallCurve {
  recall: number[];
  precision: number[];
  thresholds: number[];
}

/** BinaryMetrics */
export interface BinaryMetrics {
  numPos: number;
  numNeg: number;
  numTot: number;
  rocAuc: number;
  f1: number;
  concept: Concept | undefined;
  rocCurve: ROC | undefined;
  precisionRecallCurve: PrecisionRecallCurve | undefined;
  avgPrecision: number;
  areaName: string;
  areaMin: number;
  areaMax: number;
  iou: number;
}

/** TrackerMetrics */
export interface TrackerMetrics {
  /** Multiple object tracking accuracy */
  motMota: number;
  /** Number of switches between tracks */
  motNumSwitches: number;
  /** MORSE fragmentation rate (a.k.a unique switch rate, only calculated in public sector) */
  morseFrag: number;
  /** Average precision calculated from all processed frames */
  avgPrecision: number;
  /** The concept that we are evaluating the tracker */
  aiid: string;
  /** Same as morse_frag but calculated using MOT mapping/metrics */
  uniqueSwitchRate: number;
}

/** EvalTestSetEntry */
export interface EvalTestSetEntry {
  /** the input information */
  input: Input | undefined;
  predictedConcepts: Concept[];
  /** All the ground truth concepts will be show on the top level */
  groundTruthConcepts: Concept[];
  /**
   * Only region-based/frame-based app contains this annotation
   * Each annotation only contains one region
   * And the concepts is in ground_truth_concepts instead of this annotation
   *
   * @deprecated
   */
  annotation:
    | Annotation
    | undefined;
  /** For region based models, region and associated concepts are stored together. */
  predictedAnnotation: Annotation | undefined;
  groundTruthAnnotation: Annotation | undefined;
}

/** LOPQEvalResult */
export interface LOPQEvalResult {
  /** Rank k for which all metrics are reported. */
  k: number;
  /** Recall @ k assuming the brute force search is the ground truth. */
  recallVsBruteForce: number;
  /** Kendall's tau correlation @ k assuming the brute force search is the ground truth. */
  kendallTauVsBruteForce: number;
  /** The percentage of the most frequent code in the indexed part of evaluation data. */
  mostFrequentCodePercent: number;
  /**
   * Normalized Discounted Cumulative Gain (NDCG) @ k with a ground truth inferred from annotations
   * and/or prediction for this evaluation LOPQ model.
   * NDCG uses individual relevance scores of each returned image to evaluate the usefulness, or
   * gain, of a document based on its position in the result list. The premise of DCG is that
   * highly relevant documents appearing lower in a search result list should be penalized as the
   * graded relevance value is reduced logarithmically proportional to the position of the result.
   * See: https://en.wikipedia.org/wiki/Information_retrieval#Discounted_cumulative_gain
   *
   * To compute the relevance score between two images we consider two cases:
   * 1) Only one label for each image
   * An image is relevant to an image query iff they are labeled the same (score 1), and
   * not relevant otherwise (score 0)
   * 2) Multiple labels for each image
   * Here an image relevancy with respect to a single image query is measured by f-beta score
   * assuming the query image list of labels as ground truth and comparing them with that of
   * the search result. These labels can come from image annotations or if substitute_annotation_misses
   * is set, predictions of base classifier where any prediction with prob < prob_threshold are
   * discarded. To quantify the relevancy score of a single search result we opt to compute precision
   * and recall @ k for simplicity, and combine them with f-beta score to obtain a single number.
   */
  lopqNdcg: number;
  /**
   * Brute force NDCG which gives a baseline to compare to and is a measure of how good
   * the embeddings are.
   */
  bruteForceNdcg: number;
}

/** MetricsSummary */
export interface MetricsSummary {
  /** @deprecated */
  top1Accuracy: number;
  /** @deprecated */
  top5Accuracy: number;
  macroAvgRocAuc: number;
  macroStdRocAuc: number;
  macroAvgF1Score: number;
  macroStdF1Score: number;
  macroAvgPrecision: number;
  macroAvgRecall: number;
  meanAvgPrecisionIou50: number;
  meanAvgPrecisionIouRange: number;
  lopqMetrics: LOPQEvalResult[];
}

/** EvalMetrics */
export interface EvalMetrics {
  status:
    | Status
    | undefined;
  /** user id that owns this evaluation */
  userId: string;
  /** app id that owns this evaluation */
  appId: string;
  /** Id of this evaluation */
  id: string;
  /** Model to evaluate */
  model:
    | Model
    | undefined;
  /** The ground truth dataset */
  groundTruthDataset:
    | Dataset
    | undefined;
  /** The dataset with predictions */
  predictionsDataset: Dataset | undefined;
  summary: MetricsSummary | undefined;
  confusionMatrix: ConfusionMatrix | undefined;
  cooccurrenceMatrix: CooccurrenceMatrix | undefined;
  labelCounts: LabelDistribution | undefined;
  binaryMetrics: BinaryMetrics[];
  testSet: EvalTestSetEntry[];
  metricsByArea: BinaryMetrics[];
  metricsByClass: BinaryMetrics[];
  trackerMetrics: TrackerMetrics[];
  /**
   * Evaluation parameters to pass. Expected to match what
   * is defined in the model type for the respective model.
   */
  evalInfo: EvalInfo | undefined;
  extendedMetrics: ExtendedMetrics | undefined;
}

export interface ExtendedMetrics {
  userMetrics: { [key: string]: any } | undefined;
}

/** FieldsValue */
export interface FieldsValue {
  confusionMatrix: boolean;
  cooccurrenceMatrix: boolean;
  labelCounts: boolean;
  binaryMetrics: boolean;
  testSet: boolean;
  metricsByArea: boolean;
  metricsByClass: boolean;
}

/** Output */
export interface Output {
  /** One of these outputs per Input */
  id: string;
  status:
    | Status
    | undefined;
  /**
   * When the object was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** The model that created this Output. */
  model:
    | Model
    | undefined;
  /**
   * The input that was passed to the model to create this Output. For example if we have an image
   * model then it will take as input here an Input object with Image filled in.
   */
  input:
    | Input
    | undefined;
  /**
   * The output data for this Output. For example if we have a concept model then the predicted
   * concepts will appear here.
   */
  data:
    | Data
    | undefined;
  /** Number of prompt tokens as reported by the model or third-party API. */
  promptTokens: number;
  /** Number of completion tokens as reported by the model or third-party API. */
  completionTokens: number;
}

/** ScopeDeps */
export interface ScopeDeps {
  /** The scope */
  scope: string;
  /** Other scopes that are required. */
  dependingScopes: string[];
}

/** EndpointDeps */
export interface EndpointDeps {
  /** The fully qualified endpoint to */
  endpoint: string;
  /** Other scopes that are required. */
  dependingScopes: string[];
}

/** Hit */
export interface Hit {
  /**
   * This is the score for the ranked Hit results of the search query. This score is a number
   * between 0.0 and 1.0 as it represents a confidence in the search Hit. For example, if you search
   * for "car" and get a close matching Hit, the score should be close to 1.0. If you get a score
   * of close to 0.0 that means it's very disimilar to your query, in this case NOT a "car". There
   * is a special intermediate score of 0.5 that means that the Hit is not really correlated with
   * your search query (ie. not similar or dissimlar to the query) which is a common occurrence
   * when using negate queries.
   * Note: some queries that are just filtering down your app of inputs may just return a score of
   * 1.0 for all Hits.
   */
  score: number;
  /**
   * This is the matched input returned from the search query. This will contain information about
   * the Input such as the url, created_at time and trusted annotation information (for backwards
   * compatibility with apps that existed before Annotations were introduced.
   */
  input:
    | Input
    | undefined;
  /**
   * We also provide back the specific matched annotation for the above input. We do this in order
   * to support more complex Annotation queries in the And message below. For example if we match
   * the search results to a region in your input, or a frame in a video input, this annotation
   * field will be that matched annotation info and the input will be the image/video that the user
   * originally added which contains those regions / frames.
   */
  annotation:
    | Annotation
    | undefined;
  /** The customer-facing id of the user who owns the app the asset came from. */
  userId: string;
  /** The cfid of the app the asset came from. */
  appId: string;
}

export interface HitCount {
  /** The estimated total number of hits for the search query, not just the current page. */
  estimatedTotal: number;
}

/**
 * This is the common building block of a query which is a sequence of And messages ANDed together.
 * Note that some fields are used too RANK results (affect the scores) and some are used to FILTER
 * results (unordered subset of your app's contents). In general, FILTER operations are more
 * efficient queries at scale and when combined with RANK operations can speed up search performance
 * as you effectively operate on a smaller sub-set of your entire app.
 */
export interface And {
  /**
   * FILTER by input.data... information.
   * This can include human provided concepts, geo location info, metadata, etc.
   * This is effectively searching over only the trusted annotation attached to an input in your
   * app. To search by more specific annotation fields use the Annotation object here.
   * ########## Supported fields ##########
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.image.url
   *  - data.metadata.fields - filter by metadata. metadata key&value fields are OR-ed.
   *  - dataset_ids[] - filter by dataset IDs
   *  - id - filter by input ID
   *  - status.code - filter by input status
   */
  input:
    | Input
    | undefined;
  /**
   * RANK based predicted outputs from models such as custom trained models, pre-trained models,
   * etc. This is also where you enter the image url for a visual search because what we're asking
   * the system to do is find output embedding most visually similar to the provided input (that
   * input being in And.output.input.data.image.url for example). This will return the Hits
   * sorted by visual similarity (1.0 being very similar or exact match and 0.0 being very
   * dissimlar). For a search by Output concept, this means we're asking the system to rank
   * the Hits by confidence of our model's predicted Outputs. So for example if the model
   * predicts an image is 0.95 likely there is a "dog" present, that should related directly
   * to the score returned if you search for Output concept "dog" in your query. This provides
   * a natural ranking to search results based on confidence of predictions from the models and
   * is used when ANDing multiple of these types of RANK by Output queries together as well.
   *
   * ########## Supported fields ##########
   *  - data.clusters[].id
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - input.data.image.base64[]
   *  - input.data.image.url
   *  - input.id
   */
  output:
    | Output
    | undefined;
  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
   */
  negate: boolean;
  /**
   * FILTER by annotation information. This is more flexible than just filtering by
   * Input information because in the general case each input can have several annotations.
   * Some example use cases for filtering by annotations:
   * 1) find all the inputs annotated "dog" by worker_id = "XYZ"
   * 2) find all the annotations associated with embed_model_version_id = "123"
   * 3) find all the annotations that are trusted, etc.
   *
   * Since all the annotations under the hood are joined to the embedding model's annotation
   * using worker_id's of other models like cluster models or concept models should be
   * combinable with queries like visual search (a query with Output filled in).
   *
   * ########## Supported fields ##########
   *  - annotation_info.fields - filter by annotation info
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.image.url
   *  - data.metadata.fields - filter by metadata. metadata key&value fields are OR-ed.
   *  - input_id
   *  - input_level
   *  - model_version_id
   *  - status.code
   *  - task_id
   *  - trusted
   *  - user_id
   */
  annotation: Annotation | undefined;
}

/** This is the search query used in /searches, model training requests, bulk data exports, etc. */
export interface Query {
  /**
   * The query syntax is simply a list of And operatiosn that will be ANDed together to fetch
   * results which are returned to the user as Hit messages.
   *
   * Deprecated: Only used by the deprecated PostSearches endpoint. Use filters
   * and ranks instead with PostInputsSearches or PostAnnotationsSearches.
   *
   * @deprecated
   */
  ands: And[];
  /**
   * This allows the query to override any default language the app was setup in when doing Concept
   * based searches. This currently only affects public Models Output searches when those public
   * Models have translations for their Concepts.
   */
  language: string;
  /**
   * filters in this query
   * e.q. only fetch annotations that have certain metadata
   */
  filters: Filter[];
  /**
   * rankings in this query
   * e.g. visual search by a url
   */
  ranks: Rank[];
}

/** This is the new Search object used in saved searches. */
export interface Search {
  /** Search query. */
  query:
    | Query
    | undefined;
  /**
   * Customer facing, external ID for search to be saved. Provided by the user, e.g. "saved-search-1.
   * It is unique per application.
   */
  id: string;
  /** Application that owns this saved search. */
  applicationId: string;
  /** Human readable display name of the saved search. */
  name: string;
  /**
   * "As of" timestamp, indicating a time in the past as of which we want to
   * retrieve the annotations satisfying the query.
   */
  asOf:
    | Date
    | undefined;
  /** Git hash of the code that ran the filter. */
  gitHash: string;
  /** When the saved search was created. */
  createdAt:
    | Date
    | undefined;
  /** When the saved search was updated. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The search algorithm to be used.
   * Options are are 'nearest_neighbor', 'brute_force', and 'avg_concept_brute_force'
   * The last two perform a brute force search visual search instead of a more scalable distributed
   * nearest neighbor search and should be used by advanced users only.
   * If not specified we default to nearest neighbor
   */
  algorithm: string;
  /**
   * If true, save this search, and exit without executing the search.
   * If false execute the query
   */
  save: boolean;
  /**
   * Minimum value of confidence threshold score in result.
   * Defaults to 0.0 which means we won't do any thresholding as all probabilities will
   * likely be > 0.0.
   */
  minValue: number;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility: Visibility | undefined;
  metric: Search_Metric;
}

/**
 * Metric used for search. Can be EUCLIDEAN_DISTANCE (default) or COSINE_DISTANCE.
 * Currently only brute force search supports non-eudlicean metrics.
 */
export enum Search_Metric {
  METRIC_NOT_SET = 0,
  EUCLIDEAN_DISTANCE = 1,
  COSINE_DISTANCE = 2,
  UNRECOGNIZED = -1,
}

export function search_MetricFromJSON(object: any): Search_Metric {
  switch (object) {
    case 0:
    case "METRIC_NOT_SET":
      return Search_Metric.METRIC_NOT_SET;
    case 1:
    case "EUCLIDEAN_DISTANCE":
      return Search_Metric.EUCLIDEAN_DISTANCE;
    case 2:
    case "COSINE_DISTANCE":
      return Search_Metric.COSINE_DISTANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Search_Metric.UNRECOGNIZED;
  }
}

export function search_MetricToJSON(object: Search_Metric): string {
  switch (object) {
    case Search_Metric.METRIC_NOT_SET:
      return "METRIC_NOT_SET";
    case Search_Metric.EUCLIDEAN_DISTANCE:
      return "EUCLIDEAN_DISTANCE";
    case Search_Metric.COSINE_DISTANCE:
      return "COSINE_DISTANCE";
    case Search_Metric.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Filter */
export interface Filter {
  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
   */
  negate: boolean;
  /**
   * FILTER by annotation information.
   * ########## Supported fields ##########
   *  # Filter by ID fields
   *  - id                                      - example: `{"id": "xyz"}`
   *  - input_id
   *  - model_version_id
   *  - task_id
   *  - user_id
   *
   *  # Filter by worker fields such as model, workflow and user IDs
   *  - worker.model.model_version.id
   *  - worker.user.id
   *  - worker.workflow.version.id
   *
   *  # Filter by other top-level fields
   *  - annotation_info.fields                  - filter by annotation info
   *  - input_level                             - filter only input-level annotations
   *  - status.code                             - filter by annotation status code
   *  - trusted                                 - filter only trusted annotations
   *
   *  # Filter by space-time info fields, i.e. region, frames and time-segments
   *  - data                                    - filter only annotations without space-time info, e.g. classifications
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
   *  - data.frames[].frame_info                - filter only frame annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
   *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
   *  - data.regions[].region_info.mask         - filter only mask annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
   *  - data.regions[].region_info.point        - filter only point annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
   *  - data.regions[].region_info.polygon      - filter only polygon annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
   *  - data.regions[].region_info.span         - filter only span annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
   *  - data.regions[].track_id                 - filter annotations by track_id
   *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
   *  - data.time_segments[].time_info          - filter only time-segment annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
   *
   *  # Filter by other data fields
   *  - data.clusters[].id
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.geo.geo_box[].geo_point.latitude
   *  - data.geo.geo_box[].geo_point.longitude
   *  - data.geo.geo_limit.type
   *  - data.geo.geo_limit.value
   *  - data.geo.geo_point.latitude
   *  - data.geo.geo_point.longitude
   *  - data.metadata.fields                    - filter by metadata
   *                                            - Important to note: metadata key&value fields are OR-ed.
   *                                            - example with 1 metadata key: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo": {
   *                                                      `          "string_value": "bar"
   *                                                      `        },
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
   *                                            - example with 2 metadata keys: searching by
   *                                                      `{
   *                                                      `  "data": {
   *                                                      `    "metadata": {
   *                                                      `      "fields": {
   *                                                      `        "foo1": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        },
   *                                                      `        "foo2": {
   *                                                      `          "string_value": "bar2"
   *                                                      `        }
   *                                                      `      }
   *                                                      `    }
   *                                                      `  }
   *                                                      `}
   *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
   *  - data.text                               - filter only text annotations
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
   */
  annotation:
    | Annotation
    | undefined;
  /**
   * FILTER by input information.
   * ########## Supported fields ##########
   *  - data.audio                              - filter only audio inputs
   *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
   *  - data.image                              - filter only image inputs
   *                                            - enable using `{"image": {}}`
   *  - data.text                               - filter only text inputs
   *                                            - enable using `{"text": {}}`
   *  - data.video                              - filter only video inputs
   *                                            - enable using `{"video": {}}`
   *  - dataset_ids[]                           - filter by dataset IDs
   *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
   *  - status.code                             - filter by input status
   *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
   */
  input:
    | Input
    | undefined;
  /** Filter by annotation last updated time range. */
  lastUpdatedTimeRange: TimeRange | undefined;
}

/** TimeRange */
export interface TimeRange {
  /** Begin of the time range, optional, inclusive. */
  startTime:
    | Date
    | undefined;
  /** End of the time range, optional, inclusive. */
  endTime: Date | undefined;
}

/** Rank */
export interface Rank {
  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as !dog
   */
  negate: boolean;
  /**
   * RANK by annotation information.
   * ########## Supported fields ##########
   *  - data.concepts[].id
   *  - data.concepts[].name
   *  - data.concepts[].value
   *  - data.embeddings[].num_dimensions
   *  - data.embeddings[].vector[]
   *  - data.image.base64[]
   *  - data.image.url
   *  - data.text.raw
   *  - input_id
   *  - model_version_id
   */
  annotation: Annotation | undefined;
}

/** AnnotationSearchMetrics */
export interface AnnotationSearchMetrics {
  /** The ground truth we are evaluating against */
  groundTruth:
    | Search
    | undefined;
  /** The set we are evaluating */
  searchToEval:
    | Search
    | undefined;
  /** The metric result */
  metrics:
    | EvalMetrics
    | undefined;
  /** data is filled out with the concepts used for this evaluation */
  data:
    | Data
    | undefined;
  /** active_concept_count is the number of concepts for this evaluation */
  activeConceptCount: number;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility: Visibility | undefined;
}

/** Text */
export interface Text {
  /** This is a raw text string. */
  raw: string;
  /** Url to a text file */
  url: string;
  allowDuplicateUrl: boolean;
  /**
   * The hosted field lists original text hosted in Clarifai storage. This field is currently used
   * only in response.
   */
  hosted:
    | HostedURL
    | undefined;
  /** text info */
  textInfo: TextInfo | undefined;
}

export interface TextInfo {
  /** count of characters in text */
  charCount: number;
  /** text encoding */
  encoding: string;
}

/** User */
export interface User {
  id: string;
  /** @deprecated */
  primaryEmail: string;
  firstName: string;
  lastName: string;
  companyName: string;
  jobTitle: string;
  jobRole: string;
  /** This specifies user intent when registering on clarifai */
  intention: string;
  /** This specifies how one got to know about clarifai */
  referralSource: string;
  /** @deprecated */
  billType: string;
  /**
   * When the user was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** @deprecated */
  dateGdprConsent:
    | Date
    | undefined;
  /** @deprecated */
  dateTosConsent:
    | Date
    | undefined;
  /** @deprecated */
  dateMarketingConsent:
    | Date
    | undefined;
  /** @deprecated */
  datePiiConsent:
    | Date
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @deprecated
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** @deprecated */
  emailAddresses: EmailAddress[];
  /** @deprecated */
  twoFactorAuthEnabled: boolean;
  /** @deprecated */
  teamsCount: number;
  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostUserStars/DeleteUserStars endpoints to star/unstar an user
   */
  isStarred: boolean;
  /**
   * How many users have starred the user (only showed on get/list requests)
   * Computed value, not editable
   */
  starCount: number;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * This is all the personal information of a user. GetUser/ListUsers will not return this
   * information unless the caller has the UserAccounts_Get scope on their key or is the user
   * themselves.
   */
  userDetail:
    | UserDetail
    | undefined;
  /** Representative image for this User (a.k.a. Profile or cover photo) */
  image: Image | undefined;
}

/**
 * This message holds the confidential information from the User object that we don't want to expose
 * to other users. It will be accessible only from /users/{user_id}/account and with the User scopes.
 */
export interface UserDetail {
  primaryEmail: string;
  billType: string;
  dateGdprConsent: Date | undefined;
  dateTosConsent: Date | undefined;
  dateMarketingConsent: Date | undefined;
  datePiiConsent:
    | Date
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
  emailAddresses: EmailAddress[];
  twoFactorAuthEnabled: boolean;
  teamsCount: number;
  country: string;
  state: string;
  commitmentValue: CommitmentValue | undefined;
}

/** EmailAddress */
export interface EmailAddress {
  email: string;
  primary: boolean;
  verified: boolean;
}

/** Password */
export interface Password {
  /** unencrypted password string */
  plaintext: string;
}

/** PasswordViolations */
export interface PasswordViolations {
  /** when new password length is shorter than minimum length set */
  minimumLength: boolean;
  /** when new password length is longer than maximum length set */
  maximumLength: boolean;
  /** there is no upper case letter in the new password when there should be at least one */
  upperCaseNeeded: boolean;
  /** there is no lower case letter in the new password when there should be at least one */
  lowerCaseNeeded: boolean;
  /** there is no numerics in the new password when there should be at least one */
  numericNeeded: boolean;
  /** there is no special character in the new password when there should be at least one */
  nonAlphanumericNeeded: boolean;
  /** when one of the N most recent old password is reused, N is specified by password_reuse_epoch in db.password_policies */
  passwordReuse: boolean;
  /** when either user's first, middle or last name is used in the new password */
  excludeNames: boolean;
  /** when first part of user's email (exact string or after removing special characters) is used in the new password */
  excludeEmail: boolean;
  /** when there are confusing letters in the new password, such as o (first character of 'omega') vs 0 (zero) */
  noConfusingLetters: boolean;
  /** when there are simple password patterns used, such as 12345678 or aaaaaaa1 */
  noSimplePasswords: boolean;
  /** when there are common vocabs from the common vocab list used */
  noCommonVocabs: boolean;
  /** when the current password is contained in the new password or vice versa */
  noOverlapWithOld: boolean;
  /** when password has to be changed becauase it's too old */
  passwordLifespan: boolean;
}

/** Commitment Value - used to track users' commitment amount and type */
export interface CommitmentValue {
  /** The commitment value, in cents */
  value: number;
  /** The commitment type, can be either 'monthly' or 'annual' */
  type: CommitmentValue_CommitmentType;
}

export enum CommitmentValue_CommitmentType {
  TYPE_NOT_SET = 0,
  MONTHLY = 1,
  ANNUAL = 2,
  UNRECOGNIZED = -1,
}

export function commitmentValue_CommitmentTypeFromJSON(object: any): CommitmentValue_CommitmentType {
  switch (object) {
    case 0:
    case "TYPE_NOT_SET":
      return CommitmentValue_CommitmentType.TYPE_NOT_SET;
    case 1:
    case "MONTHLY":
      return CommitmentValue_CommitmentType.MONTHLY;
    case 2:
    case "ANNUAL":
      return CommitmentValue_CommitmentType.ANNUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommitmentValue_CommitmentType.UNRECOGNIZED;
  }
}

export function commitmentValue_CommitmentTypeToJSON(object: CommitmentValue_CommitmentType): string {
  switch (object) {
    case CommitmentValue_CommitmentType.TYPE_NOT_SET:
      return "TYPE_NOT_SET";
    case CommitmentValue_CommitmentType.MONTHLY:
      return "MONTHLY";
    case CommitmentValue_CommitmentType.ANNUAL:
      return "ANNUAL";
    case CommitmentValue_CommitmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Video */
export interface Video {
  /**
   * This is a URL to a publicly accessible video file. The platform will download this file server
   * side and then process.
   */
  url: string;
  /**
   * The base64 field is using video file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   */
  base64: Uint8Array;
  allowDuplicateUrl: boolean;
  /**
   * URL of thumbnail image, which is currently frame at position of 1s. This field is currently
   * used only in response.
   * Deprecated in favour of thumbnail_hosted, which also contains alternate sizes of thumbnail
   *
   * @deprecated
   */
  thumbnailUrl: string;
  /**
   * The hosted field lists original video hosted in Clarifai storage. This field is currently used
   * only in response.
   */
  hosted:
    | HostedURL
    | undefined;
  /**
   * The hosted field lists various sizes of the vide thumbnail hosted in Clarifai storage, with 'thumbnail' as the full size
   * This field is currently used only in response.
   */
  hostedThumbnail:
    | HostedURL
    | undefined;
  /** video info */
  videoInfo: VideoInfo | undefined;
}

export interface VideoInfo {
  /** width */
  width: number;
  /** height */
  height: number;
  /** Frames per second of the video. */
  fps: number;
  /** video format */
  videoFormat: string;
  /** video track bit rate */
  bitRate: number;
  /** video frame count */
  frameCount: number;
  /** video duration in seconds */
  durationSeconds: number;
}

/** Workflow */
export interface Workflow {
  /** The workflows's unique id. */
  id: string;
  /** The app the workflow belongs to */
  appId: string;
  /**
   * When the workflow was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /**
   * The list of nodes retrieved from latest workflow version.
   * Each node can specify an input node that it connects to in order to define the graph.
   */
  nodes: WorkflowNode[];
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** The user the workflow belongs to */
  userId: string;
  /** When the workflow was last modified */
  modifiedAt:
    | Date
    | undefined;
  /** Info about the workflow version used to return the latest version when listing Workflows. */
  version:
    | WorkflowVersion
    | undefined;
  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostWorkflowStars/DeleteWorkflowStars endpoints to star/unstar a workflow
   */
  isStarred: boolean;
  /**
   * How many users have starred the workflow (only showed on get/list requests)
   * Computed value, not editable
   */
  starCount: number;
  /** Short description about this workflow */
  description: string;
  /**
   * Notes for the workflow
   * This field should be used for in-depth notes and supports up to 64Kbs.
   */
  notes: string;
  /** Tags from use_cases category */
  useCases: string[];
  /** Tags for check consents */
  checkConsents: string[];
  /**
   * bookmark info. When set, this workflow is a bookmarked workflow of this app.
   * Info in this field will allow you to find/access original workflow.
   */
  bookmarkOrigin:
    | BookmarkOrigin
    | undefined;
  /** Representative image for this workflow */
  image: Image | undefined;
}

/** WorkflowVersion */
export interface WorkflowVersion {
  /** Id of this version. */
  id: string;
  /** Workflow id for this version. */
  workflowId: string;
  /**
   * When the version was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the version was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * The list of nodes that make up the workflow version. Each node can specify an input node
   * that it connects to in order to define the graph.
   */
  nodes: WorkflowNode[];
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** The app the workflow version belongs to. */
  appId: string;
  /** The user the workflow version belongs to. */
  userId: string;
  /** Short description about this workflow version */
  description: string;
  /** License associated to this workflow version */
  license: string;
  /**
   * If a model version associated with the workflow version is deleted, the workflow version
   * will be marked as deprecated.
   */
  isDeprecated: boolean;
}

/** WorkflowNode */
export interface WorkflowNode {
  /**
   * An identifier for this node in the graph. This is used when connecting NodeInputs
   * together.
   */
  id: string;
  /**
   * The model that will do the processing at this node. We only vlidate the model.id and
   * model.model_version.id fields.
   */
  model:
    | Model
    | undefined;
  /**
   * Each WorkflowNode can connect to multiple input nodes so that we can handle multi-model data
   * and more complex workflow operations.
   */
  nodeInputs: NodeInput[];
  /** suppress the output for workflow prediction */
  suppressOutput: boolean;
  /**
   * Used to override the output_info.data and output_info.params of the model specified by the node.
   * Values for fields_map, message, and output_config are ignored.
   */
  outputInfoOverride: OutputInfo | undefined;
}

/** NodeInput represents inputs to a node of the graph. */
export interface NodeInput {
  /** The id to a connected WorkflowNode which will be used as an input for current WorkflowNode. */
  nodeId: string;
}

/**
 * WorkflowResult
 * One result per input in the workflow.
 */
export interface WorkflowResult {
  id: string;
  status:
    | Status
    | undefined;
  /**
   * When the object was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** The input that ran through the workflow to generate the outputs in this WorkflowResult. */
  input:
    | Input
    | undefined;
  /** For each model in the workflow we return an Output. */
  outputs: Output[];
  /** Indicate if the output of this model is suppressed. */
  suppressOutput: boolean;
}

/** WorkflowState */
export interface WorkflowState {
  /**
   * A unique ID for the workflow state.
   * To start saving a state in a PostWorkflowResults request set this ID to "init"
   * and it will return a newly generated unique state id that you can then pass in subsequent
   * PostWorkflowResults calls. These state expire after 5 minutes between calls.
   */
  id: string;
}

/** AppDuplication */
export interface AppDuplication {
  /** The unique identifier of an app duplication job. */
  id: string;
  /**
   * The destination application where resources are written.
   *
   * If the destination does not exist, then the fields from the request are
   * used to create the application. If a field is not set or not supported,
   * then it will be copied from the source app, unless otherwise noted.
   *
   * Note: this field can be empty when reading app duplication jobs in cases
   * where the app has been deleted or is just not visible to the caller.
   *
   * ########## Supported fields ##########
   *  - description
   *  - id      - if not set, then generated automatically
   *  - user_id - if not set, then the calling user is used as the app owner
   */
  destinationApp:
    | App
    | undefined;
  /**
   * The ID of an existing app you want to copy data into.
   *
   * If not provided, then we will create a new application as the destination instead.
   * The various new_app_* fields can be used to set fields of this new application.
   *
   * Deprecated: Use destination_app.id with an existing ID instead.
   *
   * @deprecated
   */
  existingAppId: string;
  /**
   * The ID to use when creating a new application.
   * You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
   *
   * If not provided, then it will be generated automatically.
   *
   * Deprecated: Use destination_app.id with a new ID instead.
   *
   * @deprecated
   */
  newAppId: string;
  /**
   * The name to use when creating a new application.
   * You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
   *
   * If not provided, then the ID of the new application is also used as the name.
   *
   * Deprecated: Application names are deprecated, use application IDs instead.
   *
   * @deprecated
   */
  newAppName: string;
  /** The status of the app duplication job. */
  status:
    | Status
    | undefined;
  /** The time when the app duplication job was created. */
  createdAt:
    | Date
    | undefined;
  /** The last time when the app duplication job status was updated. */
  lastModifiedAt:
    | Date
    | undefined;
  /** The filter specifies which resources are copied by the app duplication job. */
  filter:
    | AppDuplicationFilters
    | undefined;
  /**
   * Copy progress for each resource type requested by the filter. Possible fields:
   *  - inputs
   *  - concepts
   *  - annotations
   *  - models
   *  - workflows
   *  - installed_module_versions
   */
  progress: AppCopyProgress[];
}

export interface AppCopyProgress {
  field: string;
  value: number;
}

/** AppDuplicationFilters */
export interface AppDuplicationFilters {
  /**
   * Copy inputs. Requires that copy_concepts is also set.
   * Note that this will still copy input-level annotations even if copy_annotations is not set.
   */
  copyInputs: boolean;
  /** Copy concepts. */
  copyConcepts: boolean;
  /** Copy annotations. Requires that copy_inputs and copy_concepts are also set. */
  copyAnnotations: boolean;
  /** Copy models. Requires that copy_concepts is also set. */
  copyModels: boolean;
  /** Copy workflows. */
  copyWorkflows: boolean;
  /** Copy installed module versions. */
  copyInstalledModuleVersions: boolean;
}

/** LabelOrder */
export interface LabelOrder {
  /** id of the order */
  id: string;
  /** name of the order */
  name: string;
  /**
   * status of the order.
   * pending (QA lead review the order),
   * in progress (labeling in progress),
   * ready for release (passed clarifai QA and client can review)
   * success (released)
   */
  status:
    | Status
    | undefined;
  /** if set to true, automatically release the labels once passed clarifai review. */
  autoRelease: boolean;
  /** allow input without any tag. */
  allowEmptyTag: boolean;
  /** User desired estimation when the task should be done */
  desiredFulfillTime:
    | Date
    | undefined;
  /** Clarifai estimation when the task should be done . */
  estimateFulfillTime:
    | Date
    | undefined;
  /** task for this label order */
  task:
    | Task
    | undefined;
  /**
   * When the label order was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the label order was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt: Date | undefined;
}

/** Task is the work that needs to be done for labeling the inputs in an app. */
export interface Task {
  /** Unique ID for the task. */
  id: string;
  /**
   * When the task was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the task was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** Task type. */
  type: Task_TaskType;
  /** Description of the task. */
  description: string;
  /** Worker details. */
  worker:
    | TaskWorker
    | undefined;
  /**
   * List of concept ids used in the work of this task.
   * DEPRECATED: Use task.concepts instead.
   *
   * @deprecated
   */
  conceptIds: string[];
  /** List of inputs used in this task will be taken from this source. */
  inputSource:
    | TaskInputSource
    | undefined;
  /** For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds) */
  sampleMs: number;
  /** AI assistant details. */
  aiAssistant:
    | TaskAIAssistant
    | undefined;
  /** Review details. */
  review:
    | TaskReview
    | undefined;
  /** Status of this task. */
  status:
    | Status
    | undefined;
  /** Add a title for this task to quickly recognise it in a list of tasks. */
  name: string;
  aiAssistParams:
    | AiAssistParameters
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** The app the task belongs to. */
  appId: string;
  /** The user the task belongs to. */
  userId: string;
  /** The label order the task belongs to. */
  labelOrderId: string;
  /** Ignore Task.concept_ids field if Task.TaskConcept are supplied. */
  concepts: TaskConcept[];
  /**
   * Specify whether existing Annotations within the same app that are generated by other auto annotation tasks
   * with the specified Concept from the selected Model or Workflow should deleted before executing the Task
   */
  deletePreviousAnnotations: boolean;
  /** Tasks metrics are filled in upon user-request. */
  metrics:
    | TaskMetrics
    | undefined;
  /** Priority of the task */
  priority: Task_TaskPriority;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
}

export enum Task_TaskType {
  TYPE_NOT_SET = 0,
  /** CONCEPTS_CLASSIFICATION - Concepts classification tasks annotate concepts for the overall image, frame of video or section of text. */
  CONCEPTS_CLASSIFICATION = 1,
  /** BOUNDING_BOX_DETECTION - Bounding box detection tasks annotate rectangular bounding box regions around each concept in an image, frame of video or section of text. */
  BOUNDING_BOX_DETECTION = 2,
  /** POLYGON_DETECTION - Polygon detection tasks annotate free-form regions around concepts in an image, frame of video or section of text. */
  POLYGON_DETECTION = 3,
  UNRECOGNIZED = -1,
}

export function task_TaskTypeFromJSON(object: any): Task_TaskType {
  switch (object) {
    case 0:
    case "TYPE_NOT_SET":
      return Task_TaskType.TYPE_NOT_SET;
    case 1:
    case "CONCEPTS_CLASSIFICATION":
      return Task_TaskType.CONCEPTS_CLASSIFICATION;
    case 2:
    case "BOUNDING_BOX_DETECTION":
      return Task_TaskType.BOUNDING_BOX_DETECTION;
    case 3:
    case "POLYGON_DETECTION":
      return Task_TaskType.POLYGON_DETECTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_TaskType.UNRECOGNIZED;
  }
}

export function task_TaskTypeToJSON(object: Task_TaskType): string {
  switch (object) {
    case Task_TaskType.TYPE_NOT_SET:
      return "TYPE_NOT_SET";
    case Task_TaskType.CONCEPTS_CLASSIFICATION:
      return "CONCEPTS_CLASSIFICATION";
    case Task_TaskType.BOUNDING_BOX_DETECTION:
      return "BOUNDING_BOX_DETECTION";
    case Task_TaskType.POLYGON_DETECTION:
      return "POLYGON_DETECTION";
    case Task_TaskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Task_TaskPriority {
  TASK_PRIORITY_NOT_SET = 0,
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3,
  UNRECOGNIZED = -1,
}

export function task_TaskPriorityFromJSON(object: any): Task_TaskPriority {
  switch (object) {
    case 0:
    case "TASK_PRIORITY_NOT_SET":
      return Task_TaskPriority.TASK_PRIORITY_NOT_SET;
    case 1:
    case "LOW":
      return Task_TaskPriority.LOW;
    case 2:
    case "MEDIUM":
      return Task_TaskPriority.MEDIUM;
    case 3:
    case "HIGH":
      return Task_TaskPriority.HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_TaskPriority.UNRECOGNIZED;
  }
}

export function task_TaskPriorityToJSON(object: Task_TaskPriority): string {
  switch (object) {
    case Task_TaskPriority.TASK_PRIORITY_NOT_SET:
      return "TASK_PRIORITY_NOT_SET";
    case Task_TaskPriority.LOW:
      return "LOW";
    case Task_TaskPriority.MEDIUM:
      return "MEDIUM";
    case Task_TaskPriority.HIGH:
      return "HIGH";
    case Task_TaskPriority.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AiAssistParameters */
export interface AiAssistParameters {
  /** Min and max threshold values for approving annotations by default based on prediction score */
  minThreshold: number;
  maxThreshold: number;
  /** ids of concept relations. Used in AI assist workflow */
  conceptRelationIds: string[];
}

/** TaskWorker includes information about the workers that will work on this task. */
export interface TaskWorker {
  /** Worker strategy. */
  strategy: TaskWorker_TaskWorkerStrategy;
  /**
   * Who will work on this task.
   * DEPRECATED: Use workers.user.id instead.
   *
   * @deprecated
   */
  userIds: string[];
  /**
   * Users who will work on this task.
   * When the 'worker.users' field is additionally requested, then all user
   * info is filled for the workers. Otherwise, only the user 'id' is filled.
   * DEPRECATED: Use workers.user instead.
   *
   * @deprecated
   */
  users: User[];
  partitionedStrategyInfo?:
    | TaskWorkerPartitionedStrategyInfo
    | undefined;
  /**
   * Workers that will work on this task.
   *
   * For Auto Annotation Tasks:
   *   the worker can be either a model or a workflow;
   *   currently only supports 1 worker.
   * For manual labeling Tasks:
   *   the workers can only be users;
   *   no limitation on number of workers.
   */
  workers: Worker[];
  /**
   * Who is doing annotations - human Worker or auto-annotation via Model/Workflow.
   * If set, worker must have be set accordingly to either human worker or model/workflow worker
   */
  type: TaskWorker_WorkerType;
}

export enum TaskWorker_TaskWorkerStrategy {
  WORKER_STRATEGY_NOT_SET = 0,
  /**
   * PARTITIONED - The inputs will be partitioned in several partitions.
   * Each worker will label one or more input partitions.
   * All inputs are assigned at task creation.
   */
  PARTITIONED = 2,
  /**
   * FULL - Each worker will label all inputs from input source.
   * All inputs are assigned at task creation.
   */
  FULL = 3,
  /**
   * DYNAMIC - Each worker will dynamically get 10 inputs assigned at a time.
   * No inputs are assigned at task creation.
   */
  DYNAMIC = 4,
  UNRECOGNIZED = -1,
}

export function taskWorker_TaskWorkerStrategyFromJSON(object: any): TaskWorker_TaskWorkerStrategy {
  switch (object) {
    case 0:
    case "WORKER_STRATEGY_NOT_SET":
      return TaskWorker_TaskWorkerStrategy.WORKER_STRATEGY_NOT_SET;
    case 2:
    case "PARTITIONED":
      return TaskWorker_TaskWorkerStrategy.PARTITIONED;
    case 3:
    case "FULL":
      return TaskWorker_TaskWorkerStrategy.FULL;
    case 4:
    case "DYNAMIC":
      return TaskWorker_TaskWorkerStrategy.DYNAMIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskWorker_TaskWorkerStrategy.UNRECOGNIZED;
  }
}

export function taskWorker_TaskWorkerStrategyToJSON(object: TaskWorker_TaskWorkerStrategy): string {
  switch (object) {
    case TaskWorker_TaskWorkerStrategy.WORKER_STRATEGY_NOT_SET:
      return "WORKER_STRATEGY_NOT_SET";
    case TaskWorker_TaskWorkerStrategy.PARTITIONED:
      return "PARTITIONED";
    case TaskWorker_TaskWorkerStrategy.FULL:
      return "FULL";
    case TaskWorker_TaskWorkerStrategy.DYNAMIC:
      return "DYNAMIC";
    case TaskWorker_TaskWorkerStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TaskWorker_WorkerType {
  /** WORKER_TYPE_NOT_SET - for backward compatibility when task is not setting any type and only sets workers */
  WORKER_TYPE_NOT_SET = 0,
  /** WORKER_HUMAN - only human workers */
  WORKER_HUMAN = 1,
  /** WORKER_AUTO - auto-annotation tasks. Task must set worker as model or workflow */
  WORKER_AUTO = 2,
  UNRECOGNIZED = -1,
}

export function taskWorker_WorkerTypeFromJSON(object: any): TaskWorker_WorkerType {
  switch (object) {
    case 0:
    case "WORKER_TYPE_NOT_SET":
      return TaskWorker_WorkerType.WORKER_TYPE_NOT_SET;
    case 1:
    case "WORKER_HUMAN":
      return TaskWorker_WorkerType.WORKER_HUMAN;
    case 2:
    case "WORKER_AUTO":
      return TaskWorker_WorkerType.WORKER_AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskWorker_WorkerType.UNRECOGNIZED;
  }
}

export function taskWorker_WorkerTypeToJSON(object: TaskWorker_WorkerType): string {
  switch (object) {
    case TaskWorker_WorkerType.WORKER_TYPE_NOT_SET:
      return "WORKER_TYPE_NOT_SET";
    case TaskWorker_WorkerType.WORKER_HUMAN:
      return "WORKER_HUMAN";
    case TaskWorker_WorkerType.WORKER_AUTO:
      return "WORKER_AUTO";
    case TaskWorker_WorkerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskWorkerPartitionedStrategyInfo */
export interface TaskWorkerPartitionedStrategyInfo {
  /** Define how the partitioning should work. */
  type: TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy;
  /** How many workers will label each input. */
  workersPerInput: number;
  /**
   * In case of weighted partitioning, map user ids to weights.
   * Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
   *
   * EXAMPLE:
   * If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
   * then first worker will have assigned 30% of the work,
   * second worker will have assigned 30% of the work,
   * and third worker will have assigned 40% of the work.
   * You may use weights which add up to 100, but it's not necessary.
   * For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
   * because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
   *
   * NOTE:
   * Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
   * It is mathematically impossible to partition the work in such a case.
   * Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
   * Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
   * Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
   * If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
   * Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
   * No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
   * This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
   */
  weights: { [key: string]: any } | undefined;
}

export enum TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
  PARTITIONED_WORKER_STRATEGY_NOT_SET = 0,
  /** EVENLY - Each worker will label (approximately) the same number of inputs. */
  EVENLY = 1,
  /**
   * WEIGHTED - Each worker will have an assigned weight.
   * See weights field for more details.
   */
  WEIGHTED = 2,
  UNRECOGNIZED = -1,
}

export function taskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategyFromJSON(
  object: any,
): TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
  switch (object) {
    case 0:
    case "PARTITIONED_WORKER_STRATEGY_NOT_SET":
      return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.PARTITIONED_WORKER_STRATEGY_NOT_SET;
    case 1:
    case "EVENLY":
      return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.EVENLY;
    case 2:
    case "WEIGHTED":
      return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.WEIGHTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.UNRECOGNIZED;
  }
}

export function taskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategyToJSON(
  object: TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy,
): string {
  switch (object) {
    case TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.PARTITIONED_WORKER_STRATEGY_NOT_SET:
      return "PARTITIONED_WORKER_STRATEGY_NOT_SET";
    case TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.EVENLY:
      return "EVENLY";
    case TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.WEIGHTED:
      return "WEIGHTED";
    case TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskInputSource */
export interface TaskInputSource {
  /** Type of input source. */
  type: TaskInputSource_TaskInputSourceType;
  /** If type is SAVED_SEARCH, then this is the saved search id. */
  id: string;
}

export enum TaskInputSource_TaskInputSourceType {
  INPUT_SOURCE_TYPE_NOT_SET = 0,
  /** ALL_INPUTS - Use all inputs in the app. */
  ALL_INPUTS = 1,
  /** SAVED_SEARCH - Use the inputs from a saved search. */
  SAVED_SEARCH = 2,
  /** DATASET - Inputs from a dataset. */
  DATASET = 3,
  UNRECOGNIZED = -1,
}

export function taskInputSource_TaskInputSourceTypeFromJSON(object: any): TaskInputSource_TaskInputSourceType {
  switch (object) {
    case 0:
    case "INPUT_SOURCE_TYPE_NOT_SET":
      return TaskInputSource_TaskInputSourceType.INPUT_SOURCE_TYPE_NOT_SET;
    case 1:
    case "ALL_INPUTS":
      return TaskInputSource_TaskInputSourceType.ALL_INPUTS;
    case 2:
    case "SAVED_SEARCH":
      return TaskInputSource_TaskInputSourceType.SAVED_SEARCH;
    case 3:
    case "DATASET":
      return TaskInputSource_TaskInputSourceType.DATASET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskInputSource_TaskInputSourceType.UNRECOGNIZED;
  }
}

export function taskInputSource_TaskInputSourceTypeToJSON(object: TaskInputSource_TaskInputSourceType): string {
  switch (object) {
    case TaskInputSource_TaskInputSourceType.INPUT_SOURCE_TYPE_NOT_SET:
      return "INPUT_SOURCE_TYPE_NOT_SET";
    case TaskInputSource_TaskInputSourceType.ALL_INPUTS:
      return "ALL_INPUTS";
    case TaskInputSource_TaskInputSourceType.SAVED_SEARCH:
      return "SAVED_SEARCH";
    case TaskInputSource_TaskInputSourceType.DATASET:
      return "DATASET";
    case TaskInputSource_TaskInputSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskReview */
export interface TaskReview {
  /** Task review strategy. */
  strategy: TaskReview_TaskReviewStrategy;
  /**
   * Who will review this task.
   * DEPRECATED: Use users.id instead.
   *
   * @deprecated
   */
  userIds: string[];
  /**
   * Users who will review this task.
   * When the 'review.users' field is additionally requested, then all user
   * info is filled for the reviewers. Otherwise, only the user 'id' is filled.
   */
  users: User[];
  manualStrategyInfo?: TaskReviewManualStrategyInfo | undefined;
  consensusStrategyInfo?: TaskReviewConsensusStrategyInfo | undefined;
}

export enum TaskReview_TaskReviewStrategy {
  TASK_REVIEW_STRATEGY_NOT_SET = 0,
  /**
   * NONE - No review is needed.
   * When a labeler labels an input, the annotations are immediately approved.
   */
  NONE = 1,
  /** MANUAL - Human reviewers will review the work done by labelers. */
  MANUAL = 2,
  /**
   * CONSENSUS - Automatically approve inputs when labelers reach consensus.
   * If consensus is not reached, then it will fallback to human reviewers.
   */
  CONSENSUS = 3,
  UNRECOGNIZED = -1,
}

export function taskReview_TaskReviewStrategyFromJSON(object: any): TaskReview_TaskReviewStrategy {
  switch (object) {
    case 0:
    case "TASK_REVIEW_STRATEGY_NOT_SET":
      return TaskReview_TaskReviewStrategy.TASK_REVIEW_STRATEGY_NOT_SET;
    case 1:
    case "NONE":
      return TaskReview_TaskReviewStrategy.NONE;
    case 2:
    case "MANUAL":
      return TaskReview_TaskReviewStrategy.MANUAL;
    case 3:
    case "CONSENSUS":
      return TaskReview_TaskReviewStrategy.CONSENSUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskReview_TaskReviewStrategy.UNRECOGNIZED;
  }
}

export function taskReview_TaskReviewStrategyToJSON(object: TaskReview_TaskReviewStrategy): string {
  switch (object) {
    case TaskReview_TaskReviewStrategy.TASK_REVIEW_STRATEGY_NOT_SET:
      return "TASK_REVIEW_STRATEGY_NOT_SET";
    case TaskReview_TaskReviewStrategy.NONE:
      return "NONE";
    case TaskReview_TaskReviewStrategy.MANUAL:
      return "MANUAL";
    case TaskReview_TaskReviewStrategy.CONSENSUS:
      return "CONSENSUS";
    case TaskReview_TaskReviewStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TaskReviewManualStrategyInfo */
export interface TaskReviewManualStrategyInfo {
  /** This field represents the percentage of inputs that will be reviewed by reviewers. It is a value between 0 and 1. */
  samplePercentage: number;
  /** Deprecated: Use consensus_strategy_info.approval_threshold_reviewers. */
  approvalThreshold: number;
}

/** TaskReviewConsensusStrategyInfo */
export interface TaskReviewConsensusStrategyInfo {
  /**
   * Deprecated: Use approval_threshold_labelers.
   *
   * @deprecated
   */
  approvalThreshold: number;
  /**
   * The number of labelers that need to agree in order to automatically approve an annotation.
   * When 0, labelers consensus is disabled.
   * When 1, the labels are automatically approved once a single labeler labels the input.
   * When greater than 1, the labels are automatically approved when the specified number of labelers agree.
   * If the number of labelers that agree is less than the specified number, then the input will reviewed by reviewers.
   */
  approvalThresholdLabelers: number;
  /**
   * The number of reviewers that need to agree in order to approve an input.
   * Currently, the only allowed values are:
   * 0  - when not set, it defaults to 1
   * 1  - only a single reviewer needs to approve each labeled input
   * -1 - an input will be approved when all reviewers approve it
   */
  approvalThresholdReviewers: number;
}

/** TaskAIAssistant */
export interface TaskAIAssistant {
  /**
   * The worker is helped by an AI assistant.
   * This field is the workflow id which is used to assist the worker with predictions.
   * If empty, then AI assistant is disabled.
   *
   * @deprecated
   */
  workflowId: string;
  workflow: Workflow | undefined;
}

export interface TaskAssignment {
  id: string;
  /**
   * Creation time.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent modification time.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** Assigned worker. */
  worker:
    | Worker
    | undefined;
  /** Assigned input. */
  input:
    | Input
    | undefined;
  /**
   * Assignment status.
   * Read as: This is the status of the work assigned to worker W, on input I in task T.
   */
  status: Status | undefined;
}

/**
 * TaskStatusCountPerUser can represent one of the following:
 * * count of task annotations created by a worker for each valid status,
 * * count of task inputs assigned to a worker  (i.e. task assignments) for each valid status
 */
export interface TaskStatusCountPerUser {
  /**
   * Deprecated: Use worker instead.
   *
   * @deprecated
   */
  userId: string;
  pending: number;
  awaitingReview: number;
  success: number;
  reviewDenied: number;
  awaitingConsensusReview: number;
  worker: Worker | undefined;
}

export interface ThresholdRange {
  /**
   * The range used to filter over concept values.
   * e.g. GREATER_THAN_OR_EQUAL_TO 0.7 -> is_lower_inclusive = true, lower = 0.7, is_upper_inclusive = true, upper = 1.0
   * e.g. (0.3, 0.75] -> is_lower_inclusive = false, lower = 0.3, is_upper_inclusive = true, upper = 0.75
   */
  isLowerInclusive: boolean;
  isUpperInclusive: boolean;
  lower: number;
  upper: number;
}

export interface TaskConceptAutoAnnotationConfig {
  /**
   * Filter annotations by their annotation data type.
   * This is a bit-mask field that holds multiple AnnotationDataType values that are combined in an OR fashion.
   * Example: if annotation_data_types = 34, then we filter annotations that appear as a mask or a bounding box,
   * because MASK = 32 and BOUNDING_BOX = 2.
   */
  annotationDataTypes: number;
  /**
   * Filter annotations by concept value.
   * Only concepts that fit in the threshold will be used to generate annotations.
   */
  thresholdRange:
    | ThresholdRange
    | undefined;
  /** The output annotations will be created using this status code. */
  statusCode: StatusCode;
}

export interface TaskConcept {
  /** For auto annotation, id/name and value, user + app id must be specified. For other tasks, only the id field is required. */
  concept: Concept | undefined;
  autoAnnotationConfig: TaskConceptAutoAnnotationConfig | undefined;
}

export interface TaskMetrics {
  work: TaskWorkMetrics | undefined;
  review: TaskReviewMetrics | undefined;
  inputSource: TaskInputSourceMetrics | undefined;
}

export interface TaskWorkMetrics {
  /** Estimated number of inputs that workers have worked on. */
  inputsCountEstimated: number;
  /**
   * Estimated percent of inputs that workers have worked on.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   */
  inputsPercentEstimated: number;
}

export interface TaskReviewMetrics {
  /**
   * Estimated number of fully reviewed inputs.
   * An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
   * Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
   * Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
   * Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
   */
  inputsCountEstimated: number;
  /**
   * Estimated percent of review work that was finished.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   */
  inputsPercentEstimated: number;
  /**
   * Estimated number of reviewed inputs per reviewer index.
   * The reviewer indexes are based on task.review.users.
   * An input is considered reviewed by a reviewer if:
   * * the reviewer approved the input
   * * the reviewer rejected the input
   * Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work & review process is restarted.
   * The reviewer will have to review the input again after work has been completed.
   * As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
   */
  inputsCountEstimatedPerReviewer: number[];
  /**
   * The number of inputs actually available for review for each reviewer.
   * Most times, this equals task.metrics.input_source.inputs_count_estimated.
   * Several situations may result in different values:
   * * When task has no review, then this is 0 for each reviewer.
   * * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
   * * When task has consensus review with approval_threshold_labelers > 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
   * * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
   */
  inputsReviewableCountEstimatedPerReviewer: number[];
  /**
   * Estimated percent of review work that was finished per reviewer.
   * This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
   * Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
   * As the counts are estimated, the percentage is also estimated.
   * However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
   */
  inputsPercentEstimatedPerReviewer: number[];
}

export interface TaskInputSourceMetrics {
  /** Estimated number of inputs that are in the source of data */
  inputsCountEstimated: number;
}

/** Role represents a list of permissions */
export interface Role {
  id: string;
  /**
   * When the role was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the role was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt: Date | undefined;
  name: string;
  description: string;
  /** The low-level scopes this role has */
  scopes: string[];
  /** The endpoint-level scopes this role has */
  endpoints: string[];
  /** Type of the role 'team' or 'org' */
  type: RoleType;
}

/** Represents a group of users. */
export interface Team {
  /** Identify the team (unique). */
  id: string;
  /**
   * When the team was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the team was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** Name the team. */
  name: string;
  /** When a new application is assigned to the team without an explicit role, then the default role will be used */
  defaultRoleId: string;
}

/**
 * Collector is a data pathway from a CollectorSource to an app to collect data automatically.
 * For example, a CollectorSource
 */
export interface Collector {
  /** Unique ID for the collector. */
  id: string;
  /** Human readable description for the collector. */
  description: string;
  /**
   * When the collector is created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /**
   * This is a workflow to run inline in model predict calls. It should ONLY have very fast and
   * light-weight models in it as it will effect the speed of the predictions being made.
   * This workflow's purpose is to filter down the inputs to queue for the collector to process.
   * The input to this workflow is going to be the OUTPUT of the model, not the input to the model
   * since we want to encourage having fast workflows that can also take advantage of the model
   * outputs to make deciions (for example: thresholding based on concepts). If the workflow
   * output has any field that is non-empty then the input will be queued for the collector
   * to process with the post_queue_workflow_id.
   *
   * As a simpler alternative, pre_queue_random_sample can be set to just use random sampling instead.
   */
  preQueueWorkflowId: string;
  /**
   * Instead of needing to create a new workflow for pre_queue_workflow_id, if just random sampling
   * of the model inputs is required, then pre_queue_random_sample can be set to a value from (0-1]
   * to denote the fraction of inputs to collect.
   */
  preQueueRandomSample: number;
  /**
   * A workflow to run to after the collector is processing the queued input. This workflow
   * uses the original input to the model as input to the workflow so that you can run additional
   * models as well on that input to decide whether to queue the model or not. If the workflow
   * output has any field that is non-empty then it will be passed on to POST /inputs to
   * the destination app.
   */
  postQueueWorkflowId: string;
  /**
   * The source of the collector to feed data into this app.
   * Note(zeiler): if we wanted more than one source per collector we could make this it's own
   * object and introduce /collectors/{collector_id}/sources
   * We will keep it simple for now and have just one source per collector since a user can make
   * more than one collector in the same app anyways.
   */
  collectorSource:
    | CollectorSource
    | undefined;
  /**
   * Status for the collector. This allows you to pause a collector without having to delete it as
   * an example.
   */
  status:
    | Status
    | undefined;
  /**
   * Whether to collect outputs or not. Default is false. If selected, outputs from the
   * original model predict call will be posted as annotations along with the input with success status.
   */
  collectOutputs: boolean;
}

/**
 * Configuration for the source to collect data from.
 * Only one of the fields can be present at a time.
 */
export interface CollectorSource {
  /**
   * Collect from the inputs passed in for PostModelOutputs predictions of a specific model.
   * This does not apply to models used within workflows, only PostModelOutputs calls.
   */
  apiPostModelOutputsCollectorSource: APIPostModelOutputsCollectorSource | undefined;
}

/**
 * This is configuration for using the inputs send for model prediction in our API as
 * as the source for data.
 */
export interface APIPostModelOutputsCollectorSource {
  /**
   * To define the model that we should collect from we need to specify the following 4 IDs:
   * The User ID of the model we want to collect from.
   * This is User B in the example.
   */
  modelUserId: string;
  /** The App ID of the model we want to collect from. */
  modelAppId: string;
  /** The Model ID of the model we want to collect from. */
  modelId: string;
  /** The Version ID of the model we want to collect from. */
  modelVersionId: string;
  /**
   * This key is used to POST /inputs into your app by the collector. It can be an API key or a
   * PAT. This needs the permissions that are needed for POST /inputs for the app_id this
   * Collector is defined in.
   */
  postInputsKeyId: string;
  /**
   * This is a private field that defaults to the app owner for public users.
   * If this is left blank then this collector will collect from ALL users calling the given model.
   */
  callerUserId: string;
}

/** StatValue */
export interface StatValue {
  /** The time of the event. Defaults to now(). */
  time:
    | Date
    | undefined;
  /** A value for the metric you're recording. */
  value: number;
  /**
   * List of tags to attach to this stat. Each should contain one colon so that the first part will
   * be used as a tag group while the second being the tag itself. For example: ["task_id:a",
   * "worker_id:1"]. These tag groups like "task_id" or "worker_id" are important for aggregating
   * values in the StatValueAggregateQuery.
   */
  tags: string[];
}

/** StatValueAggregateResult */
export interface StatValueAggregateResult {
  /** The list of repeated aggregate values and their counts. */
  statValueAggregates: StatValueAggregate[];
  /** The query that created these results. */
  statValueAggregateQuery: StatValueAggregateQuery | undefined;
}

/** StatValueAggregate */
export interface StatValueAggregate {
  /**
   * The time of the aggregation. For example, if you aggregate over "HOUR" buckets then you can
   * expect each hour that has atleast one value (matching the rest of your query fields) will have
   * a StatValueAggregate with the time filled into that hour.
   */
  time:
    | Date
    | undefined;
  /** The value aggregated according to the stat_value_agg_type */
  aggregateValue: number;
  /** The count of the stat values that were used in this aggregation. */
  count: number;
  /**
   * The tags for this aggregated_value and count. This will be filled in if tag groups were used in
   * the query to group aggregations.
   */
  tags: string[];
}

/** StatValueAggregateQuery */
export interface StatValueAggregateQuery {
  /**
   * These tags are used to filter down the values before they are aggregated. For example,
   * if you want to aggregate values for "task_id:a" you could specify that as a tag here.
   */
  tags: string[];
  /**
   * These are tag groups to aggregate over. So for example if you added stat values with tags
   * "task_id:a" and others with "task_id:b", then added ["task_id"] to the task group, it the
   * aggregation would return StatValueAggregate values for each task_id. If you provide more than
   * one tag_group the response will return all rolled up combinations of them. For example
   * ["task_id", "something"] where "something:1" and "something:2" were used as tags for some
   * values then you'd get StatValueAggregate values back for:
   * task_id | something
   * a       | 1
   * a       | 2
   * b       | 1
   * b       | 1
   */
  tagGroups: string[];
  /**
   * Aggregation function to use over the values. Count(value) is also always returns.
   * Defaults to 'sum' if not provided.
   */
  statValueAggType: StatValueAggType;
  /**
   * Aggregation bins for time where the values will be aggregated at this bin granualarity.
   * And the "time" field will be returned in StatValueAggregate object.
   * If not provided then bins are not used, and all time is aggregated over.
   */
  statTimeAggType: StatTimeAggType;
  /**
   * If provided the time range over which values will be >= this time. If not provided then
   * all values will be used back to start of time.
   */
  startTime:
    | Date
    | undefined;
  /**
   * If provided the time range over which values will be <= this time. If not provided then all
   * values will be used up until now().
   */
  endTime: Date | undefined;
}

/** PCAProjectionComparator */
export interface PCAProjectionComparator {
  /** Within what distance do we consider two annotations duplicates */
  distanceThreshold: number;
  /** What cluster model version generated these */
  modelVersionId: string;
}

/** DuplicateAnnotationsResults */
export interface DuplicateAnnotationsResults {
  duplicateCfid: string[];
  uniqueCount: number;
}

/**
 * Visibility represents how visible the given resource is to other users.
 * When authenticating a request we can tell if a user is a collaborator or a teammate for the
 * the app that contains the resource and set their allowed visibility. We use that to restrict
 * what they are allowed to see:
 * If AllowedVisibility is PRIVATE then we allow PRIVATE (10), ORG (30), PUBLIC (50)
 * If AllowedVisibility is ORG then we allow ORG (30), PUBLIC (50)
 * If AllowedVisibility is PUBLIC then we allow PUBLIC (50) only.
 */
export interface Visibility {
  gettable: Visibility_Gettable;
}

/** Gettable defined the level of access for GET operations for this resource. */
export enum Visibility_Gettable {
  /** UNKNOWN_VISIBILITY - Default value not allowed. */
  UNKNOWN_VISIBILITY = 0,
  /** PRIVATE - PRIVATE requires collaborator or team permissions in order to GET this resource. */
  PRIVATE = 10,
  /**
   * ORG - ORG requires you to be in the same org in order to GET this resource, but don't have to be a
   * teammate or collaborator.
   */
  ORG = 30,
  /**
   * PUBLIC - PUBLIC opens up GET access to the resource to any user on the platform even if they are not
   * a teammate or collaborator.
   */
  PUBLIC = 50,
  UNRECOGNIZED = -1,
}

export function visibility_GettableFromJSON(object: any): Visibility_Gettable {
  switch (object) {
    case 0:
    case "UNKNOWN_VISIBILITY":
      return Visibility_Gettable.UNKNOWN_VISIBILITY;
    case 10:
    case "PRIVATE":
      return Visibility_Gettable.PRIVATE;
    case 30:
    case "ORG":
      return Visibility_Gettable.ORG;
    case 50:
    case "PUBLIC":
      return Visibility_Gettable.PUBLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Visibility_Gettable.UNRECOGNIZED;
  }
}

export function visibility_GettableToJSON(object: Visibility_Gettable): string {
  switch (object) {
    case Visibility_Gettable.UNKNOWN_VISIBILITY:
      return "UNKNOWN_VISIBILITY";
    case Visibility_Gettable.PRIVATE:
      return "PRIVATE";
    case Visibility_Gettable.ORG:
      return "ORG";
    case Visibility_Gettable.PUBLIC:
      return "PUBLIC";
    case Visibility_Gettable.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FullTag {
  /** Display name of the tag. Ex. "English" */
  name: string;
  /** Id value for referencing. Ex. "en" */
  id: string;
}

/** TimeSegment */
export interface TimeSegment {
  /** A unique id for the time segment. */
  id: string;
  data: Data | undefined;
  timeInfo: TimeInfo | undefined;
}

/** TimeInfo */
export interface TimeInfo {
  /** Number of frames */
  numFrames: number;
  /** Timestamp where track begins. */
  beginTime: number;
  /** Timestamp where track ends. */
  endTime: number;
}

/** DatasetStar */
export interface DatasetStar {
  datasetId: string;
}

/** ModuleStar */
export interface ModuleStar {
  /** Module id of the star */
  moduleId: string;
}

/** An app module that a user created in our app module marketplace. */
export interface Module {
  /** A unique ID for this app module. */
  id: string;
  /** A short description for this app module to be used in grids of modules. */
  description: string;
  /** When the app module was created. */
  createdAt:
    | Date
    | undefined;
  /** When the app module was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   * Defaults to PRIVATE if not provided.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   * This is an optional arg.
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** The creator of the app module. */
  userId: string;
  /** The app_id this module was created in. */
  appId: string;
  /**
   * A ModuleVersion which is used when listing modules to include the latest module version
   * in the response.
   */
  moduleVersion:
    | ModuleVersion
    | undefined;
  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostModuleStars/DeleteModuleStars endpoints to star/unstar a module
   */
  isStarred: boolean;
  /**
   * How many users have starred the module (only showed on get/list requests)
   * Computed value, not editable
   */
  starCount: number;
  /**
   * bookmark info. When set, this module is a bookmarked module of this app.
   * Info in this field will allow you to find/access original module.
   */
  bookmarkOrigin:
    | BookmarkOrigin
    | undefined;
  /** Representative image for this module */
  image: Image | undefined;
}

/** A specific version of an app module that is available for assigning to apps. */
export interface ModuleVersion {
  /** A name for this version like 1_0, 1_1_0, etc. */
  id: string;
  /** The module this version belongs to. */
  moduleId: string;
  /** The app_id this module version belongs to. */
  appId: string;
  /** The user_id this module version belongs to. */
  userId: string;
  /** A short description for this version. */
  description: string;
  /**
   * A markdown formatted string to detailed description of the app module.
   * This is within each version so that it can be change version to version.
   */
  notes: string;
  /** When the app module version was created. */
  createdAt:
    | Date
    | undefined;
  /** When the app module version was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The code repo of the streamlit app.
   * If you are still developing your Module you should create a ModuleVersion
   * with an empty git_commit_url and then create an InstalledModuleVersion
   * with a pre-deployed deploy_url (such as localhost or streamlit cloud).
   * Once you are ready to create a production, create a new ModuleVersion with
   * the ready git url to a specific commit that you would like to be reviewed by the
   * Clarifai team for approval within our community. You cannot publish a ModuleVersion
   * is reviewed and approved. Please only provide the git_commit_url when you're
   * ready for a review. This url needs to include a specific commit, for example:
   * https://github.com/user/repo/commit/767ff9c08ba3429c8e7b8825da148555
   */
  gitCommitUrl: string;
  moduleNav:
    | ModuleVersion_ModuleNav
    | undefined;
  /**
   * A boolean to mark if Clarifai has approved this app version.
   * This cannot be set in the request to True.
   */
  approved: boolean;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   * Defaults to PRIVATE if not provided.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   * This is an optional arg.
   */
  metadata: { [key: string]: any } | undefined;
}

export interface ModuleVersion_ModuleSubNav {
  /**
   * This is the display title for a navbar element to link to a specific page.
   * The name for this subnav element to show in the sidebar.
   */
  title: string;
  /** The query param name */
  queryKey: string;
  /** The query param value */
  queryValue: string;
}

export interface ModuleVersion_ModuleNav {
  /**
   * This is the left side title for this module and for browser tab title of the module.
   * We have this in the version so that users can change those settings
   * when releasing a new version of their module.
   */
  title: string;
  /** A list of subnav elements to put under the module title. */
  moduleSubNavs: ModuleVersion_ModuleSubNav[];
}

export interface InstalledModuleVersion {
  /** A unique id for this install. This will be used in the browser url. */
  id: string;
  /**
   * The installed module version provided here so that we users don't need to do an additional
   * fetch. When creating a new InstalledModuleVersion you should provide the:
   * module_version.user_id
   * module_version.app_id
   * module_version.module_id
   * module_version.id
   * in order to uniquely define which module version.
   */
  moduleVersion:
    | ModuleVersion
    | undefined;
  /**
   * The app_id the ModuleVersion is installed into (not necessary where the ModuleVersion was
   * created). This doesn't have to be provided in requests to install, but will be returned in
   * responses.
   */
  appId: string;
  /**
   * The user that the app belongs to where the ModuleVersion is installed into (not necessary where
   * the ModuleVersion was created). This doesn't have to be provided in requests to install, but
   * will be returned in responses.
   */
  userId: string;
  /** When the install was created. */
  createdAt:
    | Date
    | undefined;
  /** When the install was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The URL of where this app module version is deployed.
   * If you provide this deploy_url when creating the install then it will
   * be treated as a pre-deployed module. You can only use a pre-deployed module
   * in when installing to an app_id that you own as the creator of the module.
   * If you want to install someone elses module or to rely on Clarifai deploying
   * your module for you, leave deploy_url empty when creating the install.
   * If it is left empty, then deployment will occur when this module version is
   * installed into an app using the git_commit_url of the ModuleVersion.
   */
  deployUrl: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible. For the InstalledModuleVersion this allows the app owner who
   * installed the module version to decide if they want other users of their app to have
   * the added functionality that the modules version provides to their app.
   * Defaults to PRIVATE if not provided.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * The key ID to use for making requests to the API for this module.
   * This key is associated to this installed module version by PostInstalledModuleVersionsKey
   * request. The key is associated with the CALLER not the App Owner where this module is installed
   * nor the author of the module. This allows the module to act on behalf of the caller at all
   * times so we get proper permissions the caller has (such as if they are stranger, teammate or
   * collaborator). This key should be a personal access token to enable modules to work across apps
   * and have necessary abilities beyond what app-specific keys offer.
   */
  keyId: string;
}

export interface BulkOperation {
  /** id of the Bulk Operation task */
  id: string;
  inputIds?: InputIDs | undefined;
  search?: Search | undefined;
  dataset?: Dataset | undefined;
  annotationSearch?:
    | Search
    | undefined;
  /** Operation to perform */
  operation:
    | Operation
    | undefined;
  /** Application ID that this Operation was created from */
  appId: string;
  /** Status (pending, in-progress, completed, failed) of the operation */
  status:
    | Status
    | undefined;
  /** Progress of an on-going Bulk Operation task */
  progress:
    | Progress
    | undefined;
  /** User id that created this operation */
  createdBy: string;
  /**
   * When the operation was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   */
  createdAt:
    | Date
    | undefined;
  /** Last time the status got updated */
  lastModifiedAt: Date | undefined;
}

export interface InputIDs {
  inputIds: string[];
}

export interface Progress {
  processed: number;
  lastProcessedId: string;
}

export interface Operation {
  addConcepts?: AddConcepts | undefined;
  deleteConcepts?: DeleteConcepts | undefined;
  addMetadata?: AddMetadata | undefined;
  deleteMetadata?: DeleteMetadata | undefined;
  overwriteGeo?: OverwriteGeo | undefined;
  deleteGeo?: DeleteGeo | undefined;
  deleteFromDataset?: DeleteFromDataset | undefined;
  addToDataset?: AddToDataset | undefined;
  splitIntoDatasets?: SplitIntoDatasets | undefined;
  deleteAnnotations?: DeleteAnnotations | undefined;
}

export interface AddConcepts {
  concepts: Concept[];
}

export interface DeleteConcepts {
  concepts: Concept[];
  userIds: string[];
}

export interface AddMetadata {
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
}

export interface DeleteMetadata {
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
}

export interface OverwriteGeo {
  /** Geo info */
  geo: Geo | undefined;
}

export interface DeleteGeo {
}

export interface AddToDataset {
  datasetId: string;
}

export interface DeleteFromDataset {
  datasetId: string;
}

export interface SplitIntoDatasets {
  datasetSplits: DatasetSplit[];
  method: SplitIntoDatasets_DatasetSplitMethod;
}

export enum SplitIntoDatasets_DatasetSplitMethod {
  NOT_SET = 0,
  /** RANDOM_PERCENTAGE_SPLIT - We will randomly split inputs into the datasets */
  RANDOM_PERCENTAGE_SPLIT = 1,
  UNRECOGNIZED = -1,
}

export function splitIntoDatasets_DatasetSplitMethodFromJSON(object: any): SplitIntoDatasets_DatasetSplitMethod {
  switch (object) {
    case 0:
    case "NOT_SET":
      return SplitIntoDatasets_DatasetSplitMethod.NOT_SET;
    case 1:
    case "RANDOM_PERCENTAGE_SPLIT":
      return SplitIntoDatasets_DatasetSplitMethod.RANDOM_PERCENTAGE_SPLIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SplitIntoDatasets_DatasetSplitMethod.UNRECOGNIZED;
  }
}

export function splitIntoDatasets_DatasetSplitMethodToJSON(object: SplitIntoDatasets_DatasetSplitMethod): string {
  switch (object) {
    case SplitIntoDatasets_DatasetSplitMethod.NOT_SET:
      return "NOT_SET";
    case SplitIntoDatasets_DatasetSplitMethod.RANDOM_PERCENTAGE_SPLIT:
      return "RANDOM_PERCENTAGE_SPLIT";
    case SplitIntoDatasets_DatasetSplitMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DatasetSplit {
  /** Expected to have ID */
  dataset:
    | Dataset
    | undefined;
  /**
   * For RANDOM_PERCENTAGE_SPLIT.
   * Values from (0,100]
   */
  percentage?: number | undefined;
}

/** This operation takes no data (payload). */
export interface DeleteAnnotations {
}

export interface InputsAddJob {
  /** id of the job */
  id: string;
  /** If call back url is set, we will send a Post request to this endpoint with job status. */
  callBackUrl: string;
  /** Personal Access Token to the application to which inputs are added */
  appPat: string;
  /** Progress of an on-going Input Ingestion task */
  progress:
    | InputsAddJobProgress
    | undefined;
  /**
   * When the job was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the job was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** Sub-jobs that extract inputs from the cloud and/or archives */
  extractionJobs: InputsExtractionJob[];
  /** Archive uploads */
  uploads: Upload[];
  /** Status of the job */
  status: Status | undefined;
}

export interface InputsAddJobProgress {
  pendingCount: number;
  inProgressCount: number;
  successCount: number;
  failedCount: number;
}

export interface Upload {
  /** ID of upload */
  id: string;
  /**
   * When the upload was started.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the upload was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /**
   * When the upload will expire and be deleted
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  expiresAt:
    | Date
    | undefined;
  /** Status of the upload */
  status:
    | Status
    | undefined;
  /** name of uploaded content (e.g. filename) */
  contentName: string;
  /** Total size of the upload content */
  contentLength: number;
  /** Url of uploaded content */
  contentUrl: string;
}

export interface UploadContentPart {
  rangeStart: number;
  partNumber: number;
  data: Uint8Array;
}

export interface InputsExtractionJob {
  status:
    | Status
    | undefined;
  /** ID of extraction job */
  id: string;
  /** Url of archive or bucket */
  url: string;
  /** Progress counts of the job */
  progress:
    | InputsExtractionJobProgress
    | undefined;
  /**
   * When the extraction job was started.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  createdAt:
    | Date
    | undefined;
  /**
   * Most recent time when the extraction job was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  modifiedAt:
    | Date
    | undefined;
  /** How to handle input ID conflicts. */
  inputIdConflictResolution: InputIDConflictResolution;
  /** Fields set in the template are added to all generated inputs */
  inputTemplate: Input | undefined;
}

export interface InputsExtractionJobProgress {
  audioInputsCount: number;
  imageInputsCount: number;
  videoInputsCount: number;
  textInputsCount: number;
  pendingArchivesCount: number;
  inProgressArchivesCount: number;
  completedArchivesCount: number;
  failedArchivesCount: number;
}

export interface InputsDataSource {
  /**
   * Collect statistics about created inputs in job with given ID.
   * On Post call:
   * * If job ID is empty, then job is automatically created with random ID.
   * * If job ID is non-empty, then a new job will be created with given ID.
   */
  inputsAddJobId: string;
  url:
    | DataSourceURL
    | undefined;
  /** How to handle input ID conflicts. */
  inputIdConflictResolution: InputIDConflictResolution;
  /** Fields set in the template will also be added to all generated inputs */
  inputTemplate: Input | undefined;
}

export interface DataSourceURL {
  /** Supported providers are AWS S3, Azure blob, GCP cloud storage. */
  url: string;
  /** Credentials that would allow access to the provided url */
  credentials: DataSourceCredentials | undefined;
}

export interface DataSourceCredentials {
  /** AWS S3 credentials for authentication. */
  s3Creds?:
    | AWSCreds
    | undefined;
  /** GCP Cloud Storage uses service account key data(creds.json) as Byte array for authentication. */
  gcpCreds?:
    | Uint8Array
    | undefined;
  /** Azure Blob credentials for authentication. */
  azureBlobCreds?: AzureBlobCreds | undefined;
}

/** AWS S3 storage credentials. */
export interface AWSCreds {
  region: string;
  id: string;
  secret: string;
  token: string;
}

/** Azure Blob storage credentials. */
export interface AzureBlobCreds {
  accountName: string;
  accountKey: string;
}

export interface InputsUpload {
  /**
   * Collect statistics about created inputs in job with given ID.
   * * If job ID is empty, then job is automatically created with random ID.
   * * If job ID is non-empty, then a new job will be created with given ID.
   */
  inputsAddJobId: string;
  /**
   * Personal Access Token to the application to which inputs are added
   * Deprecated: No need to send app_pat, it will be generated internally if not present
   *
   * @deprecated
   */
  appPat: string;
  upload:
    | Upload
    | undefined;
  /** How to handle input ID conflicts. */
  inputIdConflictResolution: InputIDConflictResolution;
  /** Fields set in the template will also be added to all generated inputs */
  inputTemplate: Input | undefined;
}

export interface BookmarkOrigin {
  /** original resource id */
  id: string;
  /** original resource app id */
  appId: string;
  /** original resource user id */
  userId: string;
  /** resource type. */
  resourceType: BookmarkOrigin_BookmarkType;
}

export enum BookmarkOrigin_BookmarkType {
  unknown = 0,
  model = 1,
  workflow = 2,
  dataset = 3,
  module = 4,
  UNRECOGNIZED = -1,
}

export function bookmarkOrigin_BookmarkTypeFromJSON(object: any): BookmarkOrigin_BookmarkType {
  switch (object) {
    case 0:
    case "unknown":
      return BookmarkOrigin_BookmarkType.unknown;
    case 1:
    case "model":
      return BookmarkOrigin_BookmarkType.model;
    case 2:
    case "workflow":
      return BookmarkOrigin_BookmarkType.workflow;
    case 3:
    case "dataset":
      return BookmarkOrigin_BookmarkType.dataset;
    case 4:
    case "module":
      return BookmarkOrigin_BookmarkType.module;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BookmarkOrigin_BookmarkType.UNRECOGNIZED;
  }
}

export function bookmarkOrigin_BookmarkTypeToJSON(object: BookmarkOrigin_BookmarkType): string {
  switch (object) {
    case BookmarkOrigin_BookmarkType.unknown:
      return "unknown";
    case BookmarkOrigin_BookmarkType.model:
      return "model";
    case BookmarkOrigin_BookmarkType.workflow:
      return "workflow";
    case BookmarkOrigin_BookmarkType.dataset:
      return "dataset";
    case BookmarkOrigin_BookmarkType.module:
      return "module";
    case BookmarkOrigin_BookmarkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A worker for compute within a nodepool of instances.
 * This asks the API for work
 */
export interface Runner {
  /**
   * A unique ID for this runner.
   * This is a UUID since runners can be automatically orchestrated.
   */
  id: string;
  /** short description about the runner. */
  description: string;
  /** When the runner was created. */
  createdAt:
    | Date
    | undefined;
  /** When the runner was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   * This is an optional arg.
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /**
   * Labels to match in order to find work.
   *
   * @deprecated
   */
  labels: string[];
  /**
   * Instead of just matching on labels we might want to have more explicit matching of what
   * work this runner is looking for.
   * The thing that the autoscaling config applies to for this nodepool.
   */
  worker:
    | Worker
    | undefined;
  /**
   * Runners are defined within nodepools so this field needs the id and user_id of the nodepool
   * to be provided when creating a Runner.
   * This nodepool must be accessible to you or an org you are part of.
   */
  nodepool:
    | Nodepool
    | undefined;
  /**
   * //////////////////////////
   * Need resources on the runner so we can schedule this Runner into the Nodepool.
   * If this runner is being orchestrated for a model then the orchestrator will set this to the
   * model resource requirements. If a workflow then it'll compute those requirements and set
   * populate this resource field.
   * Having this on the underlying object like Model and Workflow allows us to represent the minimum
   * requirements on those object, which may be less than what the Runner allocates (as a safety
   * margin for the runner to for sure run the resource).
   */
  computeInfo:
    | ComputeInfo
    | undefined;
  /**
   * Number of replicas that this runner should have up.
   * We keep it separate from ComputeInfo which defines how many resources each replica needs.
   */
  numReplicas: number;
}

/**
 * A nodepool is a set of nodes dedicated for a given user's compute needs.
 * This compute will typically be consumed by runners and in the future other objects
 * like UI modules may be assigned to node pools.
 */
export interface Nodepool {
  /** The user defined ID of the nodepool. */
  id: string;
  /** Short description about the nodepool. */
  description: string;
  /** When the nodepool was created. */
  createdAt:
    | Date
    | undefined;
  /** When the nodepool was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /** Which cluster this nodepool is within. */
  computeCluster: ComputeCluster | undefined;
  nodeCapacityType: NodeCapacityType | undefined;
  instanceTypes: InstanceType[];
  /**
   * Minimum number of instances in this nodepool. This allows the nodepool to scale down to this
   * amount. This is the user desired minimum.
   */
  minInstances: number;
  /**
   * An upper limit on the number of instances in this nodepool. This allows the nodepool to scale
   * up to this amount. This is the user desired maximum.
   */
  maxInstances: number;
  /** The actual minimum number of instances. Enforced by the user's plan limits. */
  enforcedMinInstances: number;
  /** The actual maximum number of instances. Enforced by the user's plan limits. */
  enforcedMaxInstances: number;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * To handle arbitrary json metadata:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata: { [key: string]: any } | undefined;
}

/**
 * Type of nodes that are ok for instances in this pool.
 * If both spot and on-demand are provided then the runner will be able to run on either
 * with a preference for spot until they are not available.
 */
export interface NodeCapacityType {
  capacityTypes: NodeCapacityType_CapacityType[];
}

export enum NodeCapacityType_CapacityType {
  UKNOWN_CAPACITY_TYPE = 0,
  ON_DEMAND_TYPE = 1,
  SPOT_TYPE = 2,
  UNRECOGNIZED = -1,
}

export function nodeCapacityType_CapacityTypeFromJSON(object: any): NodeCapacityType_CapacityType {
  switch (object) {
    case 0:
    case "UKNOWN_CAPACITY_TYPE":
      return NodeCapacityType_CapacityType.UKNOWN_CAPACITY_TYPE;
    case 1:
    case "ON_DEMAND_TYPE":
      return NodeCapacityType_CapacityType.ON_DEMAND_TYPE;
    case 2:
    case "SPOT_TYPE":
      return NodeCapacityType_CapacityType.SPOT_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeCapacityType_CapacityType.UNRECOGNIZED;
  }
}

export function nodeCapacityType_CapacityTypeToJSON(object: NodeCapacityType_CapacityType): string {
  switch (object) {
    case NodeCapacityType_CapacityType.UKNOWN_CAPACITY_TYPE:
      return "UKNOWN_CAPACITY_TYPE";
    case NodeCapacityType_CapacityType.ON_DEMAND_TYPE:
      return "ON_DEMAND_TYPE";
    case NodeCapacityType_CapacityType.SPOT_TYPE:
      return "SPOT_TYPE";
    case NodeCapacityType_CapacityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The instance types that will be available in this pool of nodes.
 * Clarifai offers multiple different choices that combine cpu cores, memory and accelerator.
 */
export interface InstanceType {
  id: string;
  /** Short description of instance type. */
  description: string;
  computeInfo: ComputeInfo | undefined;
  price: string;
  /** The cloud provider where this instance type is available, if any. */
  cloudProvider:
    | CloudProvider
    | undefined;
  /** The region where this instance type is available, if any. */
  region: string;
  /** The capacity types allowed for this instance type. If empty - all capacity types are allowed. */
  allowedCapacityTypes: NodeCapacityType | undefined;
}

/**
 * CloudProvider represents the entity that provides the infrastructure where the Nodepools are deployed.
 * This could be a public cloud provider like AWS, GCP, Azure, etc., or a self-hosted infrastructure.
 */
export interface CloudProvider {
  /** Unique identifier of the cloud provider. */
  id: string;
  /** Name of the cloud provider. */
  name: string;
}

/**
 * We define a cluster here to be used in Nodepools and by the cloud provider.
 * There will be one cloud provider per Cluster.
 * This allows us to define Clusters that are VPCs within one physical cloud and have that
 * managed by one cloud provider which can list all nodepools for that VPC to deploy them and
 * orchestrate work within them.
 */
export interface ComputeCluster {
  id: string;
  /** Short description of cluster region. */
  description: string;
  /**
   * The cloud provider where this cluster is hosted.
   * Some example cloud provider IDs may be aws, gcp, azure, local, kubernetes, etc.
   */
  cloudProvider:
    | CloudProvider
    | undefined;
  /**
   * The region. The naming here depends on the cluster choice above and will be validated
   * against which clusters+regions that Clarifai currently supports.
   */
  region: string;
  /** The user/org that this compute cluster belongs to. */
  userId: string;
  /** When the compute cluster was created. */
  createdAt:
    | Date
    | undefined;
  /** When the compute cluster was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * We offer different types of compute clusters such as:
   * 'shared' which only Clarifai can create.
   * 'dedicated' where you're in control of defining the nodepools within the cluster
   * 'local-dev' which means you're responsible for starting runners manually which is great for local
   * development but not recommended for production use cases.
   */
  clusterType: string;
  /**
   * Managed by represents who is responsible for the cluster.
   * This is currently either "clarifai" where we fully manage the infrastructure.
   * Or, "user" where the user is responsible for the underlying infrastructure.
   */
  managedBy: string;
  /**
   * Key to use within the compute cluster for all requests to the API.
   * You can post with the key.id filled in to set the key for the compute cluster.
   * The responses will intentionaly only return the description of the key for security
   * purposes since you may have other people through orgs/teams having access to this compute
   * cluster who should not view your key.
   * This must be a valid key created before creating the ComputeCluster.
   * Deleting this key will not be prevented, which means all resources in this ComputeCluster
   * will lose connection to the API, so delete keys at your own risk.
   * The user_id who owns the key must match the user_id provided in the ComputeCluster.
   */
  key: Key | undefined;
}

/**
 * These are the resource needs of a given API object such as a model.
 * This is what they require as a minimum to run and will be used upon scheduling
 * as the request and limit for the k8s pod. If we want to separate limits and requests in the
 * future we can allow setting a limits ComputeInfo and a requests ComputeInfo.
 */
export interface ComputeInfo {
  /**
   * Amount of CPUs to use as a limit. This follows kubernetes notation like: "1", "100m", "4.5", etc.
   * See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
   * For instances, this is the instance's CPU count.
   * For runners, this is the maximum amount of CPU that the runner pod can use.
   */
  cpuLimit: string;
  /**
   * Amount of CPU memory to use as a limit. This follows kubernetes notation like:
   * 1Ki, 1500Mi, 3Gi, 4Ti, etc.
   * See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
   * For instances, this is the instance's CPU memory.
   * For runners, this is the maximum amount of CPU memory that the runner pod can use.
   */
  cpuMemory: string;
  /**
   * Amount of CPUs to use as a minimum. This follows kubernetes notation like: "1", "100m", "4.5", etc.
   * See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
   * For runners, this is the minimum amount of CPU requested for the runner pod.
   * Optional. If unspecified, a small default is used.
   */
  cpuRequests: string;
  /**
   * Amount of CPU memory to use as a minimum. This follows kubernetes notation like:
   * 1Ki, 1500Mi, 3Gi, 4Ti, etc.
   * For runners, this is the minimum amount of CPU memory requested for the runner pod.
   * Optional. If unspecified, a small default is used.
   */
  cpuMemoryRequests: string;
  /** Amount of GPU/TPUs to use. */
  numAccelerators: number;
  /**
   * Amount of accelerator/GPU memory to use as a minimum.
   * This is defined per accelerator.
   * This follows the format used by kubernetes like 1Ki, 2Mi, 3Gi, 4Ti.
   * See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
   */
  acceleratorMemory: string;
  /**
   * Or should it be removed completely and use the nodepool accelerator type itself.
   * These are the supported accelerators that the model can run on.
   */
  acceleratorType: string[];
}

/**
 * It might be better to do this as runner autoscaling so that resources
 * of a model are very simply what that model needs at minimum.
 * Note that resources for things like modes inside runners are not
 * related to how many replicas of those runners are needed to handle traffic.
 */
export interface AutoscaleConfig {
  /**
   * The minimum number of replicas for the runner to have.
   * Defaults to 0 which means autoscaling can scale down to zero.
   * If you want a replica always up then set to >= 1.
   */
  minReplicas: number;
  /** The maximium number of replicas to scale up the runner to. */
  maxReplicas: number;
  /** The number of seconds of traffic history to consider when autoscaling. */
  trafficHistorySeconds: number;
  /** The time to wait before scaling down after the last request. */
  scaleDownDelaySeconds: number;
  /** The time to wait between scaling up replicas without burst traffic. */
  scaleUpDelaySeconds: number;
  /**
   * Depending on your plan you may be able to enable packing of resources into a single node
   * for more compute and cost efficiency.
   */
  disablePacking: boolean;
  /** The idle time before scaling down to zero */
  scaleToZeroDelaySeconds: number;
}

/**
 * A deployment allows you to configure how runners for a particular type of resource will
 * scale up and down. These are unique per user_id, nodepool and model so for differnet nodepools
 * you can scale differently.
 */
export interface Deployment {
  /** An id for this configured deployment. */
  id: string;
  /** The user who owns the deployment. These live in the user/org account. */
  userId: string;
  /** How to autoscale the object. */
  autoscaleConfig:
    | AutoscaleConfig
    | undefined;
  /**
   * You can configure different autoscaling per nodepool(s).
   * These nodepools have to be also owned by the same user_id/org as this deployment.
   * If there is more than one nodepool we use the model's ComputeInfo to match
   * with what the nodepool provides to decide which one can handle it combined with the
   * NodepoolRank below. Note: even within a single nodepool if it is heterogeneous then
   * we need a way to rank scheduling choices when we don't know how to decide (like a model
   * supports
   */
  nodepools: Nodepool[];
  schedulingChoice: Deployment_SchedulingChoice;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * To handle arbitrary json metadata:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** Short description of deployment. */
  description: string;
  /**
   * The thing that the autoscaling config applies to for this nodepool.
   * For a given user_id, nodepool_id, and object ID we can only have one deployment as it defines
   */
  worker:
    | Worker
    | undefined;
  /** When the deployment was created. */
  createdAt:
    | Date
    | undefined;
  /** When the deployment was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /** When to always deploy latest model version */
  deployLatestVersion: boolean;
}

/**
 * In some scenarios it may not be obvous how we should schedule a resource to underlying nodes
 * within the nodepool(s) above. The SchedulerChoice allows us to specify how to decide which
 * nodepool to use when there are multiple nodepools and how to decide which type of node
 * within a nodepool if there are multiple types.
 * If here are multiple nondepools then a decision on which to use comes into play
 * if it is not specified in the prediction request.
 * Even with a single nodepool a choice may come up such as when a resource that needs scheduling
 * has not specified the accelerator types it supports and the nodepool has multiple types.
 */
export enum Deployment_SchedulingChoice {
  UNKNOWN_SCHEDULING_CHOICE = 0,
  /** FAIL - fail if there is any ambiguity. */
  FAIL = 1,
  /** RANDOM - randomly pick amongst the nodepools/nodes to assign. */
  RANDOM = 2,
  /** PRICE - choose the compute that is cheaper */
  PRICE = 3,
  /** PERFORMANCE - schedule to the fastest known iption. */
  PERFORMANCE = 4,
  /** NETWORK - optimize based on network latency. */
  NETWORK = 5,
  /** UTILIZATION - send to the least used nodepool based on it's capacity. */
  UTILIZATION = 6,
  /** PREFER_SPOT - choose spot instances over on-demand */
  PREFER_SPOT = 7,
  /** PREFER_ONDEMAND - choose on-demand instances over spot. */
  PREFER_ONDEMAND = 8,
  UNRECOGNIZED = -1,
}

export function deployment_SchedulingChoiceFromJSON(object: any): Deployment_SchedulingChoice {
  switch (object) {
    case 0:
    case "UNKNOWN_SCHEDULING_CHOICE":
      return Deployment_SchedulingChoice.UNKNOWN_SCHEDULING_CHOICE;
    case 1:
    case "FAIL":
      return Deployment_SchedulingChoice.FAIL;
    case 2:
    case "RANDOM":
      return Deployment_SchedulingChoice.RANDOM;
    case 3:
    case "PRICE":
      return Deployment_SchedulingChoice.PRICE;
    case 4:
    case "PERFORMANCE":
      return Deployment_SchedulingChoice.PERFORMANCE;
    case 5:
    case "NETWORK":
      return Deployment_SchedulingChoice.NETWORK;
    case 6:
    case "UTILIZATION":
      return Deployment_SchedulingChoice.UTILIZATION;
    case 7:
    case "PREFER_SPOT":
      return Deployment_SchedulingChoice.PREFER_SPOT;
    case 8:
    case "PREFER_ONDEMAND":
      return Deployment_SchedulingChoice.PREFER_ONDEMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Deployment_SchedulingChoice.UNRECOGNIZED;
  }
}

export function deployment_SchedulingChoiceToJSON(object: Deployment_SchedulingChoice): string {
  switch (object) {
    case Deployment_SchedulingChoice.UNKNOWN_SCHEDULING_CHOICE:
      return "UNKNOWN_SCHEDULING_CHOICE";
    case Deployment_SchedulingChoice.FAIL:
      return "FAIL";
    case Deployment_SchedulingChoice.RANDOM:
      return "RANDOM";
    case Deployment_SchedulingChoice.PRICE:
      return "PRICE";
    case Deployment_SchedulingChoice.PERFORMANCE:
      return "PERFORMANCE";
    case Deployment_SchedulingChoice.NETWORK:
      return "NETWORK";
    case Deployment_SchedulingChoice.UTILIZATION:
      return "UTILIZATION";
    case Deployment_SchedulingChoice.PREFER_SPOT:
      return "PREFER_SPOT";
    case Deployment_SchedulingChoice.PREFER_ONDEMAND:
      return "PREFER_ONDEMAND";
    case Deployment_SchedulingChoice.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ////////////////////////////////////////
 * Don't need RunnerSelector if we're opening up endpoints for deployments.
 * ////////////////////////////////////////
 * The RunnerSelector is an optional field we can provide during runtime
 * of model/workflow predictions to specify which particular runner we want to process the work.
 * This can optionally be used to select a particular nodepool and then within that nodepool
 * a particular runner.
 */
export interface RunnerSelector {
  /**
   * A particular nodepool for the resource to be run within. This request the id and user_id of
   * the nodepool to be specified. Runners will be scaled according to a deployment for the given
   * resource to be run. There should not be more than one deployment in this nodepool for the
   * particular resource to run. If no deployments then default autoscaling will be used.
   */
  nodepool:
    | Nodepool
    | undefined;
  /** Optionally a partcular runner within the nodepool. */
  runner:
    | Runner
    | undefined;
  /** Optionally a partcular deployment within the nodepool. */
  deployment: Deployment | undefined;
}

/** Processing info tells the runner how to process a RunnerItem */
export interface ProcessingInfo {
  /** The type of method witin the runner to call. */
  runnerMethodType: RunnerMethodType;
  /**
   * A status of the processing. We use this for signalling end of a request stream, a runner
   * item's processing should be cancelled, etc.
   */
  status:
    | Status
    | undefined;
  /** Internal field to track processing. Runners will not have access to this. */
  processingId: string;
}

/**
 * AuditLogTarget is a resource on which an operation recorded in an
 * audit log was performed.
 */
export interface AuditLogTarget {
  user?: User | undefined;
  role?: Role | undefined;
  team?: Team | undefined;
  app?: App | undefined;
  module?: Module | undefined;
  moduleVersion?: ModuleVersion | undefined;
  workflow?: Workflow | undefined;
  workflowVersion?: WorkflowVersion | undefined;
  model?: Model | undefined;
  modelVersion?: ModelVersion | undefined;
  computeCluster?: ComputeCluster | undefined;
  nodepool?: Nodepool | undefined;
  deployment?: Deployment | undefined;
}

/** AuditLogEntry is a single operation recorded in an audit log. */
export interface AuditLogEntry {
  /** Time of the operation. */
  timestamp:
    | Date
    | undefined;
  /** User that performed the operation. */
  user:
    | User
    | undefined;
  /** Type of operation that was performed. */
  operation: EventType;
  /** A human-readable description of the operation. */
  description: string;
  /**
   * Targets of the operation. For example,
   * - when creating a new model, the targets would be the application and the model,
   * - when adding a team member, the targets would be the team and the member.
   */
  targets: AuditLogTarget[];
  /**
   * Additional human-readable details of the operation. For example,
   * when patching a resource, these would list what was changed.
   */
  details: string[];
  /** Was the operation successful? */
  success: boolean;
  /** Request that triggered the operation. */
  reqId: string;
  /** IP address where the request originated from. */
  sourceIp: string;
}

/** AuditLogQuery is a query for audit log entries. */
export interface AuditLogQuery {
  /** Query operations within this time range. */
  timestampFrom: Date | undefined;
  timestampTo:
    | Date
    | undefined;
  /** Query operations by these users. */
  userIds: string[];
  /** Query these types of operations. */
  operations: EventType[];
  /** Query operations with these targets. */
  targets: AuditLogTarget[];
  /** Query operations by success. */
  success:
    | boolean
    | undefined;
  /** Query operations by source IP address. */
  sourceIps: string[];
}

export interface WorkflowVersionEvaluationMetric {
  id: string;
  summary: string;
  description: string;
  /** Metric data type - string, float, int */
  dataType: WorkflowVersionEvaluationMetric_DataType;
  visualisationType: WorkflowVersionEvaluationMetric_VisualisationType;
}

/** Enum for data types */
export enum WorkflowVersionEvaluationMetric_DataType {
  DATA_TYPE_NOT_SET = 0,
  FLOAT = 1,
  UNRECOGNIZED = -1,
}

export function workflowVersionEvaluationMetric_DataTypeFromJSON(
  object: any,
): WorkflowVersionEvaluationMetric_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_NOT_SET":
      return WorkflowVersionEvaluationMetric_DataType.DATA_TYPE_NOT_SET;
    case 1:
    case "FLOAT":
      return WorkflowVersionEvaluationMetric_DataType.FLOAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowVersionEvaluationMetric_DataType.UNRECOGNIZED;
  }
}

export function workflowVersionEvaluationMetric_DataTypeToJSON(
  object: WorkflowVersionEvaluationMetric_DataType,
): string {
  switch (object) {
    case WorkflowVersionEvaluationMetric_DataType.DATA_TYPE_NOT_SET:
      return "DATA_TYPE_NOT_SET";
    case WorkflowVersionEvaluationMetric_DataType.FLOAT:
      return "FLOAT";
    case WorkflowVersionEvaluationMetric_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum for visualization types */
export enum WorkflowVersionEvaluationMetric_VisualisationType {
  VISUALIZATION_TYPE_NOT_SET = 0,
  CONFUSION_MATRIX = 1,
  PRECISION_RECALL_CURVE = 2,
  ROC_AUC_CURVE = 3,
  UNRECOGNIZED = -1,
}

export function workflowVersionEvaluationMetric_VisualisationTypeFromJSON(
  object: any,
): WorkflowVersionEvaluationMetric_VisualisationType {
  switch (object) {
    case 0:
    case "VISUALIZATION_TYPE_NOT_SET":
      return WorkflowVersionEvaluationMetric_VisualisationType.VISUALIZATION_TYPE_NOT_SET;
    case 1:
    case "CONFUSION_MATRIX":
      return WorkflowVersionEvaluationMetric_VisualisationType.CONFUSION_MATRIX;
    case 2:
    case "PRECISION_RECALL_CURVE":
      return WorkflowVersionEvaluationMetric_VisualisationType.PRECISION_RECALL_CURVE;
    case 3:
    case "ROC_AUC_CURVE":
      return WorkflowVersionEvaluationMetric_VisualisationType.ROC_AUC_CURVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowVersionEvaluationMetric_VisualisationType.UNRECOGNIZED;
  }
}

export function workflowVersionEvaluationMetric_VisualisationTypeToJSON(
  object: WorkflowVersionEvaluationMetric_VisualisationType,
): string {
  switch (object) {
    case WorkflowVersionEvaluationMetric_VisualisationType.VISUALIZATION_TYPE_NOT_SET:
      return "VISUALIZATION_TYPE_NOT_SET";
    case WorkflowVersionEvaluationMetric_VisualisationType.CONFUSION_MATRIX:
      return "CONFUSION_MATRIX";
    case WorkflowVersionEvaluationMetric_VisualisationType.PRECISION_RECALL_CURVE:
      return "PRECISION_RECALL_CURVE";
    case WorkflowVersionEvaluationMetric_VisualisationType.ROC_AUC_CURVE:
      return "ROC_AUC_CURVE";
    case WorkflowVersionEvaluationMetric_VisualisationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WorkflowVersionEvaluationTemplate {
  id: string;
  description: string;
  /** Applicable for the task types like TextClassification, TextGeneration, etc */
  taskTypes: WorkflowVersionEvaluationTemplate_TaskType[];
  /** The Workflow Evaluation template metrics */
  workflowVersionEvaluationMetrics: WorkflowVersionEvaluationMetric[];
}

export enum WorkflowVersionEvaluationTemplate_TaskType {
  TASK_TYPE_NOT_SET = 0,
  TEXT_CLASSIFICATION = 1,
  UNRECOGNIZED = -1,
}

export function workflowVersionEvaluationTemplate_TaskTypeFromJSON(
  object: any,
): WorkflowVersionEvaluationTemplate_TaskType {
  switch (object) {
    case 0:
    case "TASK_TYPE_NOT_SET":
      return WorkflowVersionEvaluationTemplate_TaskType.TASK_TYPE_NOT_SET;
    case 1:
    case "TEXT_CLASSIFICATION":
      return WorkflowVersionEvaluationTemplate_TaskType.TEXT_CLASSIFICATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowVersionEvaluationTemplate_TaskType.UNRECOGNIZED;
  }
}

export function workflowVersionEvaluationTemplate_TaskTypeToJSON(
  object: WorkflowVersionEvaluationTemplate_TaskType,
): string {
  switch (object) {
    case WorkflowVersionEvaluationTemplate_TaskType.TASK_TYPE_NOT_SET:
      return "TASK_TYPE_NOT_SET";
    case WorkflowVersionEvaluationTemplate_TaskType.TEXT_CLASSIFICATION:
      return "TEXT_CLASSIFICATION";
    case WorkflowVersionEvaluationTemplate_TaskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ComputePlaneMetrics captures the compute plane metrics to send back to the control plane.
 * Each message should have the meta filled and one or more of the other fields.
 */
export interface ComputePlaneMetrics {
  /** Who and where the metrics are from. */
  meta:
    | ComputeSourceMetadata
    | undefined;
  /** e.g. aws, azure, on-prem. */
  cloud: string;
  /** e.g. us-east, us-west. */
  region: string;
  /** e.g. t3a.medium, g5.xlarge. */
  instanceType: string;
  /** e.g. spot, on-demand. */
  reservationType: string;
  /** Metrics billing */
  reservationPrice: number;
  /** Runtime in seconds. */
  runtimeS: number;
  /** Metrics for latency. */
  timestamp:
    | Date
    | undefined;
  /** e.g. NodeProvisioned, NodeTerminated, ModelDeployed, ModelScheduled, ModelReady. */
  eventType: string;
  /** GPU metrics. */
  gpuMetrics: GpuMetrics[];
  /** Hostname of the node. */
  hostname: string;
  /** CPU metrics. */
  cpuMetrics: CpuMetrics[];
}

export interface GpuMetrics {
  /** GPU UUID. */
  uuid: string;
  /** GPU model name. e.g. NVIDIA_A10G */
  modelName: string;
  /** GPU utilization. e.g. DCGM_FI_DEV_GPU_UTIL */
  utilizationPct: number;
  /** Tensor utilization. e.g. DCGM_FI_PROF_PIPE_TENSOR_ACTIVE */
  tensorUtilizationPct: number;
  /** Memory utilization. e.g. DCGM_FI_PROF_DRAM_ACTIVE */
  memoryUtilizationPct: number;
}

export interface CpuMetrics {
  /** Time of the event. */
  timestamp:
    | Date
    | undefined;
  /** CPU utilization. */
  cpuUtilizationPct: number;
  /** Memory utilization. */
  memoryUtilizationPct: number;
  /** CPU millicores. */
  millicores: number;
  /** Memory bytes. */
  memoryBytes: number;
}

/** LogEntry is a single technical log entry (e.g. service log, stack traces, etc). */
export interface LogEntry {
  /** Text of the log entry. */
  message: string;
  /** The type of log entry. Examples: model, agent, build, training. */
  logType: string;
  /** URL to log file or stream. */
  url: string;
  /** Who and where the metrics are from. */
  meta: ComputeSourceMetadata | undefined;
}

/** ComputeSourceMetadata describes the source of something computed. The who and where. */
export interface ComputeSourceMetadata {
  /** The user app id, if any. */
  userAppId:
    | UserAppIDSet
    | undefined;
  /** The Model ID, if any. */
  modelId: string;
  /** The Version ID, if any. */
  modelVersionId: string;
  /** Workflow Id, if any. */
  workflowId: string;
  /** Compute Cluster, Nodepool, Runner. */
  computeClusterUserId: string;
  computeClusterId: string;
  nodepoolId: string;
  runnerId: string;
  /** Pipeline related data, if any */
  pipelineId: string;
  pipelineVersionId: string;
  pipelineVersionRunId: string;
  /** Pipeline step related data for pipeline step builds. */
  pipelineStepId: string;
  pipelineStepVersionId: string;
}

export interface WorkflowVersionEvaluation {
  /** Customer-Facing / External ID of the workflow version evaluation. */
  id: string;
  /** Workflow version that is being evaluated. */
  workflowVersion:
    | WorkflowVersion
    | undefined;
  /** The target node id that is being evaluated. */
  targetNodeId: string;
  /** The dataset version that contains the ground-truth and is used for evaluation. */
  groundTruthDatasetVersion:
    | DatasetVersion
    | undefined;
  /** The dataset version that contains the predictions and is used for evaluation. */
  predictionsDatasetVersion:
    | DatasetVersion
    | undefined;
  /** Evaluation template that is used for evaluation. */
  workflowVersionEvaluationTemplate:
    | WorkflowVersionEvaluationTemplate
    | undefined;
  /** The user the workflow version evaluation belongs to. */
  userId: string;
  /** The app the workflow version evaluation belongs to. */
  appId: string;
  /** Results of the evaluation. */
  workflowEvaluationResult:
    | WorkflowEvaluationResult
    | undefined;
  /** Status of the evaluation */
  status:
    | Status
    | undefined;
  /** When the workflow version evaluation was created. */
  createdAt:
    | Date
    | undefined;
  /** When the workflow version evaluation was modified. */
  modifiedAt: Date | undefined;
}

export interface WorkflowEvaluationResult {
  /** The summary of the evaluation result. */
  summary: WorkflowEvaluationResultSummary | undefined;
}

export interface WorkflowEvaluationResultSummary {
  /** The evaluation metrics. */
  evaluationMetricValues: EvaluationMetricValue[];
}

export interface EvaluationMetricValue {
  /** The metric values */
  evaluationMetricId: string;
  /** Aggregated metric value */
  metricValue:
    | MetricValue
    | undefined;
  /** explanation for the value */
  explanation: string;
  /** Metric values for each concept */
  perConceptValues: { [key: string]: MetricValue };
}

export interface EvaluationMetricValue_PerConceptValuesEntry {
  key: string;
  value: MetricValue | undefined;
}

export interface InputEvaluationMetricValue {
  /** The metric values */
  evaluationMetricId: string;
  /** Aggregated metric value */
  metricValue:
    | MetricValue
    | undefined;
  /** explanation for the value */
  explanation: string;
  /** Metric values for each region */
  perRegionValues: { [key: string]: MetricValue };
}

export interface InputEvaluationMetricValue_PerRegionValuesEntry {
  key: string;
  value: MetricValue | undefined;
}

export interface MetricValue {
  stringValue?: string | undefined;
  floatValue?: number | undefined;
  intValue?: number | undefined;
}

/** The evaluation result at the input/sample level */
export interface WorkflowEvaluationInputResult {
  inputEvaluationMetricValues: InputEvaluationMetricValue[];
}

export interface WorkflowVersionEvaluationData {
  /** the data example id */
  id: string;
  input: Input | undefined;
  groundTruths: Data[];
  predictions: Data[];
  workflowEvaluationSampleResult: WorkflowEvaluationInputResult | undefined;
}

export interface ArgoOrchestrationSpec {
  /**
   * The API version of the orchestration specification.
   * Example: "argoproj.io/v1alpha1", "argoproj.io/v1beta1"
   */
  apiVersion: string;
  /** The JSON representation of the Argo orchestration specification. */
  specJson: string;
}

export interface OrchestrationSpec {
  /** Argo orchestration specification */
  argoOrchestrationSpec?: ArgoOrchestrationSpec | undefined;
}

export interface PipelineStepInputParam {
  /** The name of the input parameter. */
  name: string;
  /** The default value of the input parameter. */
  defaultValue: string;
  /** The description of the input parameter. */
  description: string;
  /** The accepted values for the input parameter. */
  acceptedValues: string[];
}

export interface PipelineStep {
  /** The ID of the pipeline step. */
  id: string;
  /** The user the pipeline step belongs to */
  userId: string;
  /** Description of the pipeline step */
  description: string;
  /** Latest Pipeline Step Version */
  pipelineStepVersion:
    | PipelineStepVersion
    | undefined;
  /**
   * The visibility field represents whether this is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** When the pipeline step was created */
  createdAt:
    | Date
    | undefined;
  /** When the pipeline step was last modified */
  modifiedAt: Date | undefined;
}

export interface OrchestrationStepSpec {
  /** Argo orchestration step template */
  argoOrchestrationStepSpec?: ArgoOrchestrationStepSpec | undefined;
}

export interface ArgoOrchestrationStepSpec {
  /**
   * The API version of the orchestration W.
   * Example: "argoproj.io/v1alpha1", "argoproj.io/v1beta1"
   */
  apiVersion: string;
  /** The JSON representation of the Argo Workflow Template */
  specJson: string;
}

export interface PipelineStepVersion {
  /** The ID of the pipeline step version. */
  id: string;
  /** The user the pipeline step version belongs to */
  userId: string;
  /** The app the pipeline step version belongs to */
  appId: string;
  /** Description of the pipeline step version */
  description: string;
  /** Pipeline Step */
  pipelineStep:
    | PipelineStep
    | undefined;
  /** Orchestration Step Specification using oneof */
  orchestrationStepSpec:
    | OrchestrationStepSpec
    | undefined;
  /** The pipeline step version input parameters */
  pipelineStepInputParams: PipelineStepInputParam[];
  /** Pipeline step Status - Created, Building Artifacts, Completed, Failed */
  status:
    | Status
    | undefined;
  /** The minimum required compute resource to run the pipeline step as part of a Pipeline */
  pipelineStepComputeInfo:
    | ComputeInfo
    | undefined;
  /** Build information for the pipeline step */
  buildInfo:
    | BuildInfo
    | undefined;
  /**
   * The visibility field represents whether this is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** When the pipeline step was created */
  createdAt:
    | Date
    | undefined;
  /** When the pipeline step was last modified */
  modifiedAt: Date | undefined;
}

export interface Pipeline {
  id: string;
  /** The user the pipeline belongs to */
  userId: string;
  /** The app the pipeline belongs to */
  appId: string;
  /** Latest Pipeline Version */
  pipelineVersion:
    | PipelineVersion
    | undefined;
  /** Short description about this pipeline */
  description: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /** Notes for the Pipeline. This field should be used for in-depth notes and supports up to 64Kbs. */
  notes: string;
  /**
   * To handle arbitrary json metadata, use a struct field
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** When the pipeline was created */
  createdAt:
    | Date
    | undefined;
  /** When the pipeline was last modified */
  modifiedAt: Date | undefined;
}

export interface PipelineVersion {
  id: string;
  /** The app the pipeline version belongs to. */
  appId: string;
  /** The user the pipeline version belongs to. */
  userId: string;
  /** Orchestration Specification using oneof */
  orchestrationSpec:
    | OrchestrationSpec
    | undefined;
  /** Pipeline's Id */
  pipelineId: string;
  /** Short description about this pipeline version */
  description: string;
  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   */
  visibility:
    | Visibility
    | undefined;
  /**
   * To handle arbitrary json metadata, use a struct field
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** When the pipeline was created */
  createdAt:
    | Date
    | undefined;
  /** When the pipeline was last modified */
  modifiedAt: Date | undefined;
}

export interface OrchestrationStatus {
  /** Status for Argo Workflow */
  argoStatus?:
    | ArgoOrchestrationStatus
    | undefined;
  /** This will help us with filtering the PipelineVersionRuns based on status */
  status: Status | undefined;
}

/** Argo Workflow Status message */
export interface ArgoOrchestrationStatus {
  /** Refer https://pkg.go.dev/github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1#WorkflowStatus */
  status: string;
}

export interface PipelineVersionRun {
  id: string;
  /** Pipeline Version associated with this run */
  pipelineVersion:
    | PipelineVersion
    | undefined;
  /** Nodepool(s) used for the Pipeline Version Run */
  nodepools: Nodepool[];
  /** Orchestration Status for this run, supporting multiple orchestration systems */
  orchestrationStatus:
    | OrchestrationStatus
    | undefined;
  /** The user the pipeline belongs to */
  userId: string;
  /** The app the pipeline belongs to */
  appId: string;
  /** When the pipeline was created */
  createdAt:
    | Date
    | undefined;
  /** When the pipeline was last modified */
  modifiedAt: Date | undefined;
}

export interface Secret {
  /** The name of the secret, corresponds to id in model_version.output_info.params.secrets */
  id: string;
  /** The user the secret belongs to. */
  userId: string;
  /** The value of the secret. */
  value: string;
  /** The version of the secret. */
  version: number;
  /** The description of the secret. */
  description: string;
  /** When the secret was created. */
  createdAt:
    | Date
    | undefined;
  /** When the secret was last modified. */
  modifiedAt:
    | Date
    | undefined;
  /** When the secret will expire. */
  expiresAt: Date | undefined;
}

export interface MetricData {
  matrixData?: MetricData_MatrixData | undefined;
}

export interface MetricData_Label {
  name: MetricLabel;
  value: string;
}

export interface MetricData_MetricSample {
  /**
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   */
  timestamp: Date | undefined;
  value: number;
}

export interface MetricData_MatrixData {
  series: MetricData_MatrixData_TimeSeries[];
}

export interface MetricData_MatrixData_TimeSeries {
  labels: MetricData_Label[];
  value: MetricData_MetricSample[];
}

export interface MetricAggregate {
  operator: MetricAggregate_Operator;
  labels: MetricLabel[];
}

export enum MetricAggregate_Operator {
  OPERATOR_NOT_SET = 0,
  AVG = 1,
  SUM = 2,
  MAX = 3,
  MIN = 4,
  P95 = 5,
  P99 = 6,
  P50 = 7,
  COUNT = 8,
  UNRECOGNIZED = -1,
}

export function metricAggregate_OperatorFromJSON(object: any): MetricAggregate_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_NOT_SET":
      return MetricAggregate_Operator.OPERATOR_NOT_SET;
    case 1:
    case "AVG":
      return MetricAggregate_Operator.AVG;
    case 2:
    case "SUM":
      return MetricAggregate_Operator.SUM;
    case 3:
    case "MAX":
      return MetricAggregate_Operator.MAX;
    case 4:
    case "MIN":
      return MetricAggregate_Operator.MIN;
    case 5:
    case "P95":
      return MetricAggregate_Operator.P95;
    case 6:
    case "P99":
      return MetricAggregate_Operator.P99;
    case 7:
    case "P50":
      return MetricAggregate_Operator.P50;
    case 8:
    case "COUNT":
      return MetricAggregate_Operator.COUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MetricAggregate_Operator.UNRECOGNIZED;
  }
}

export function metricAggregate_OperatorToJSON(object: MetricAggregate_Operator): string {
  switch (object) {
    case MetricAggregate_Operator.OPERATOR_NOT_SET:
      return "OPERATOR_NOT_SET";
    case MetricAggregate_Operator.AVG:
      return "AVG";
    case MetricAggregate_Operator.SUM:
      return "SUM";
    case MetricAggregate_Operator.MAX:
      return "MAX";
    case MetricAggregate_Operator.MIN:
      return "MIN";
    case MetricAggregate_Operator.P95:
      return "P95";
    case MetricAggregate_Operator.P99:
      return "P99";
    case MetricAggregate_Operator.P50:
      return "P50";
    case MetricAggregate_Operator.COUNT:
      return "COUNT";
    case MetricAggregate_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MetricFilter {
  label: MetricLabel;
  equals?: string | undefined;
  in?: MetricFilter_MultiValues | undefined;
}

export interface MetricFilter_MultiValues {
  in: string[];
}

export interface MetricSearchQuery {
  metricType: MetricType;
  /** start time of the search window */
  startTime:
    | Date
    | undefined;
  /** end time of the search window */
  endTime:
    | Date
    | undefined;
  /** duration string https://pkg.go.dev/time#ParseDuration */
  resolution: string;
  /** ANDed */
  filters: MetricFilter[];
  aggregate: MetricAggregate | undefined;
}

function createBaseAnnotation(): Annotation {
  return {
    id: "",
    inputId: "",
    data: undefined,
    annotationInfo: undefined,
    userId: "",
    modelVersionId: "",
    embedModelVersionId: "",
    status: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
    trusted: false,
    inputLevel: false,
    consensusInfo: undefined,
    taskId: "",
    worker: undefined,
  };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.annotationInfo !== undefined) {
      Struct.encode(Struct.wrap(message.annotationInfo), writer.uint32(106).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(122).string(message.userId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(130).string(message.modelVersionId);
    }
    if (message.embedModelVersionId !== "") {
      writer.uint32(114).string(message.embedModelVersionId);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(74).fork()).join();
    }
    if (message.trusted !== false) {
      writer.uint32(80).bool(message.trusted);
    }
    if (message.inputLevel !== false) {
      writer.uint32(136).bool(message.inputLevel);
    }
    if (message.consensusInfo !== undefined) {
      Struct.encode(Struct.wrap(message.consensusInfo), writer.uint32(146).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(154).string(message.taskId);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.annotationInfo = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.embedModelVersionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.inputLevel = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.consensusInfo = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      annotationInfo: isObject(object.annotationInfo) ? object.annotationInfo : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      embedModelVersionId: isSet(object.embedModelVersionId) ? globalThis.String(object.embedModelVersionId) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
      inputLevel: isSet(object.inputLevel) ? globalThis.Boolean(object.inputLevel) : false,
      consensusInfo: isObject(object.consensusInfo) ? object.consensusInfo : undefined,
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.annotationInfo !== undefined) {
      obj.annotationInfo = message.annotationInfo;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.embedModelVersionId !== "") {
      obj.embedModelVersionId = message.embedModelVersionId;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    if (message.inputLevel !== false) {
      obj.inputLevel = message.inputLevel;
    }
    if (message.consensusInfo !== undefined) {
      obj.consensusInfo = message.consensusInfo;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Annotation>, I>>(base?: I): Annotation {
    return Annotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Annotation>, I>>(object: I): Annotation {
    const message = createBaseAnnotation();
    message.id = object.id ?? "";
    message.inputId = object.inputId ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.annotationInfo = object.annotationInfo ?? undefined;
    message.userId = object.userId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.embedModelVersionId = object.embedModelVersionId ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.trusted = object.trusted ?? false;
    message.inputLevel = object.inputLevel ?? false;
    message.consensusInfo = object.consensusInfo ?? undefined;
    message.taskId = object.taskId ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    return message;
  },
};

function createBaseAnnotationTrack(): AnnotationTrack {
  return {
    id: "",
    appId: "",
    inputId: "",
    concept: undefined,
    userId: "",
    status: undefined,
    startFrame: 0,
    endFrame: 0,
    createdAt: undefined,
    modifiedAt: undefined,
    frameRate: 0,
  };
}

export const AnnotationTrack: MessageFns<AnnotationTrack> = {
  encode(message: AnnotationTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.concept !== undefined) {
      Concept.encode(message.concept, writer.uint32(34).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(50).fork()).join();
    }
    if (message.startFrame !== 0) {
      writer.uint32(56).uint32(message.startFrame);
    }
    if (message.endFrame !== 0) {
      writer.uint32(64).uint32(message.endFrame);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(82).fork()).join();
    }
    if (message.frameRate !== 0) {
      writer.uint32(88).uint32(message.frameRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.concept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.startFrame = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.endFrame = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.frameRate = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationTrack {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      concept: isSet(object.concept) ? Concept.fromJSON(object.concept) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      startFrame: isSet(object.startFrame) ? globalThis.Number(object.startFrame) : 0,
      endFrame: isSet(object.endFrame) ? globalThis.Number(object.endFrame) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
    };
  },

  toJSON(message: AnnotationTrack): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.concept !== undefined) {
      obj.concept = Concept.toJSON(message.concept);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.startFrame !== 0) {
      obj.startFrame = Math.round(message.startFrame);
    }
    if (message.endFrame !== 0) {
      obj.endFrame = Math.round(message.endFrame);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.frameRate !== 0) {
      obj.frameRate = Math.round(message.frameRate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotationTrack>, I>>(base?: I): AnnotationTrack {
    return AnnotationTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotationTrack>, I>>(object: I): AnnotationTrack {
    const message = createBaseAnnotationTrack();
    message.id = object.id ?? "";
    message.appId = object.appId ?? "";
    message.inputId = object.inputId ?? "";
    message.concept = (object.concept !== undefined && object.concept !== null)
      ? Concept.fromPartial(object.concept)
      : undefined;
    message.userId = object.userId ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.startFrame = object.startFrame ?? 0;
    message.endFrame = object.endFrame ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.frameRate = object.frameRate ?? 0;
    return message;
  },
};

function createBaseWorker(): Worker {
  return { user: undefined, model: undefined, workflow: undefined };
}

export const Worker: MessageFns<Worker> = {
  encode(message: Worker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).join();
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
    };
  },

  toJSON(message: Worker): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker>, I>>(base?: I): Worker {
    return Worker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker>, I>>(object: I): Worker {
    const message = createBaseWorker();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    return message;
  },
};

function createBaseApp(): App {
  return {
    id: "",
    name: "",
    defaultLanguage: "",
    defaultWorkflowId: "",
    defaultWorkflow: undefined,
    userId: "",
    createdAt: undefined,
    modifiedAt: undefined,
    legalConsentStatus: 0,
    metadata: undefined,
    description: "",
    sampleMs: 0,
    visibility: undefined,
    dataTierId: "",
    isStarred: false,
    starCount: 0,
    notes: "",
    image: undefined,
    isTemplate: undefined,
    extraInfo: undefined,
    embeddingsStorage: 0,
  };
}

export const App: MessageFns<App> = {
  encode(message: App, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.defaultLanguage !== "") {
      writer.uint32(26).string(message.defaultLanguage);
    }
    if (message.defaultWorkflowId !== "") {
      writer.uint32(34).string(message.defaultWorkflowId);
    }
    if (message.defaultWorkflow !== undefined) {
      Workflow.encode(message.defaultWorkflow, writer.uint32(186).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(138).fork()).join();
    }
    if (message.legalConsentStatus !== 0) {
      writer.uint32(56).uint32(message.legalConsentStatus);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(106).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(114).string(message.description);
    }
    if (message.sampleMs !== 0) {
      writer.uint32(120).uint32(message.sampleMs);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(130).fork()).join();
    }
    if (message.dataTierId !== "") {
      writer.uint32(146).string(message.dataTierId);
    }
    if (message.isStarred !== false) {
      writer.uint32(152).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(160).int32(message.starCount);
    }
    if (message.notes !== "") {
      writer.uint32(170).string(message.notes);
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(178).fork()).join();
    }
    if (message.isTemplate !== undefined) {
      BoolValue.encode({ value: message.isTemplate! }, writer.uint32(202).fork()).join();
    }
    if (message.extraInfo !== undefined) {
      AppExtraInfo.encode(message.extraInfo, writer.uint32(194).fork()).join();
    }
    if (message.embeddingsStorage !== 0) {
      writer.uint32(208).int32(message.embeddingsStorage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): App {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultLanguage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultWorkflowId = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.defaultWorkflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.legalConsentStatus = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.sampleMs = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.dataTierId = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.isTemplate = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.extraInfo = AppExtraInfo.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.embeddingsStorage = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): App {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      defaultLanguage: isSet(object.defaultLanguage) ? globalThis.String(object.defaultLanguage) : "",
      defaultWorkflowId: isSet(object.defaultWorkflowId) ? globalThis.String(object.defaultWorkflowId) : "",
      defaultWorkflow: isSet(object.defaultWorkflow) ? Workflow.fromJSON(object.defaultWorkflow) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      legalConsentStatus: isSet(object.legalConsentStatus) ? globalThis.Number(object.legalConsentStatus) : 0,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      sampleMs: isSet(object.sampleMs) ? globalThis.Number(object.sampleMs) : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      dataTierId: isSet(object.dataTierId) ? globalThis.String(object.dataTierId) : "",
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      isTemplate: isSet(object.isTemplate) ? Boolean(object.isTemplate) : undefined,
      extraInfo: isSet(object.extraInfo) ? AppExtraInfo.fromJSON(object.extraInfo) : undefined,
      embeddingsStorage: isSet(object.embeddingsStorage) ? app_EmbeddingsStorageFromJSON(object.embeddingsStorage) : 0,
    };
  },

  toJSON(message: App): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.defaultLanguage !== "") {
      obj.defaultLanguage = message.defaultLanguage;
    }
    if (message.defaultWorkflowId !== "") {
      obj.defaultWorkflowId = message.defaultWorkflowId;
    }
    if (message.defaultWorkflow !== undefined) {
      obj.defaultWorkflow = Workflow.toJSON(message.defaultWorkflow);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.legalConsentStatus !== 0) {
      obj.legalConsentStatus = Math.round(message.legalConsentStatus);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.sampleMs !== 0) {
      obj.sampleMs = Math.round(message.sampleMs);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.dataTierId !== "") {
      obj.dataTierId = message.dataTierId;
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.isTemplate !== undefined) {
      obj.isTemplate = message.isTemplate;
    }
    if (message.extraInfo !== undefined) {
      obj.extraInfo = AppExtraInfo.toJSON(message.extraInfo);
    }
    if (message.embeddingsStorage !== 0) {
      obj.embeddingsStorage = app_EmbeddingsStorageToJSON(message.embeddingsStorage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<App>, I>>(base?: I): App {
    return App.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<App>, I>>(object: I): App {
    const message = createBaseApp();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.defaultLanguage = object.defaultLanguage ?? "";
    message.defaultWorkflowId = object.defaultWorkflowId ?? "";
    message.defaultWorkflow = (object.defaultWorkflow !== undefined && object.defaultWorkflow !== null)
      ? Workflow.fromPartial(object.defaultWorkflow)
      : undefined;
    message.userId = object.userId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.legalConsentStatus = object.legalConsentStatus ?? 0;
    message.metadata = object.metadata ?? undefined;
    message.description = object.description ?? "";
    message.sampleMs = object.sampleMs ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.dataTierId = object.dataTierId ?? "";
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.notes = object.notes ?? "";
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.isTemplate = object.isTemplate ?? undefined;
    message.extraInfo = (object.extraInfo !== undefined && object.extraInfo !== null)
      ? AppExtraInfo.fromPartial(object.extraInfo)
      : undefined;
    message.embeddingsStorage = object.embeddingsStorage ?? 0;
    return message;
  },
};

function createBaseAppExtraInfo(): AppExtraInfo {
  return { searchRevisionMarker: "", counts: undefined };
}

export const AppExtraInfo: MessageFns<AppExtraInfo> = {
  encode(message: AppExtraInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchRevisionMarker !== "") {
      writer.uint32(10).string(message.searchRevisionMarker);
    }
    if (message.counts !== undefined) {
      AppResourceCounts.encode(message.counts, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppExtraInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchRevisionMarker = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.counts = AppResourceCounts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppExtraInfo {
    return {
      searchRevisionMarker: isSet(object.searchRevisionMarker) ? globalThis.String(object.searchRevisionMarker) : "",
      counts: isSet(object.counts) ? AppResourceCounts.fromJSON(object.counts) : undefined,
    };
  },

  toJSON(message: AppExtraInfo): unknown {
    const obj: any = {};
    if (message.searchRevisionMarker !== "") {
      obj.searchRevisionMarker = message.searchRevisionMarker;
    }
    if (message.counts !== undefined) {
      obj.counts = AppResourceCounts.toJSON(message.counts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppExtraInfo>, I>>(base?: I): AppExtraInfo {
    return AppExtraInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppExtraInfo>, I>>(object: I): AppExtraInfo {
    const message = createBaseAppExtraInfo();
    message.searchRevisionMarker = object.searchRevisionMarker ?? "";
    message.counts = (object.counts !== undefined && object.counts !== null)
      ? AppResourceCounts.fromPartial(object.counts)
      : undefined;
    return message;
  },
};

function createBaseAppQuery(): AppQuery {
  return { name: "" };
}

export const AppQuery: MessageFns<AppQuery> = {
  encode(message: AppQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppQuery {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: AppQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppQuery>, I>>(base?: I): AppQuery {
    return AppQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppQuery>, I>>(object: I): AppQuery {
    const message = createBaseAppQuery();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAppResourceCounts(): AppResourceCounts {
  return { datasets: 0, models: 0, workflows: 0, modules: 0, inputs: 0 };
}

export const AppResourceCounts: MessageFns<AppResourceCounts> = {
  encode(message: AppResourceCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasets !== 0) {
      writer.uint32(8).int64(message.datasets);
    }
    if (message.models !== 0) {
      writer.uint32(16).int64(message.models);
    }
    if (message.workflows !== 0) {
      writer.uint32(24).int64(message.workflows);
    }
    if (message.modules !== 0) {
      writer.uint32(32).int64(message.modules);
    }
    if (message.inputs !== 0) {
      writer.uint32(40).int64(message.inputs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppResourceCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppResourceCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.datasets = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.models = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.workflows = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modules = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.inputs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppResourceCounts {
    return {
      datasets: isSet(object.datasets) ? globalThis.Number(object.datasets) : 0,
      models: isSet(object.models) ? globalThis.Number(object.models) : 0,
      workflows: isSet(object.workflows) ? globalThis.Number(object.workflows) : 0,
      modules: isSet(object.modules) ? globalThis.Number(object.modules) : 0,
      inputs: isSet(object.inputs) ? globalThis.Number(object.inputs) : 0,
    };
  },

  toJSON(message: AppResourceCounts): unknown {
    const obj: any = {};
    if (message.datasets !== 0) {
      obj.datasets = Math.round(message.datasets);
    }
    if (message.models !== 0) {
      obj.models = Math.round(message.models);
    }
    if (message.workflows !== 0) {
      obj.workflows = Math.round(message.workflows);
    }
    if (message.modules !== 0) {
      obj.modules = Math.round(message.modules);
    }
    if (message.inputs !== 0) {
      obj.inputs = Math.round(message.inputs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppResourceCounts>, I>>(base?: I): AppResourceCounts {
    return AppResourceCounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppResourceCounts>, I>>(object: I): AppResourceCounts {
    const message = createBaseAppResourceCounts();
    message.datasets = object.datasets ?? 0;
    message.models = object.models ?? 0;
    message.workflows = object.workflows ?? 0;
    message.modules = object.modules ?? 0;
    message.inputs = object.inputs ?? 0;
    return message;
  },
};

function createBaseCollaborator(): Collaborator {
  return {
    id: "",
    app: undefined,
    user: undefined,
    scopes: [],
    endpoints: [],
    createdAt: undefined,
    modifiedAt: undefined,
    deletedAt: undefined,
  };
}

export const Collaborator: MessageFns<Collaborator> = {
  encode(message: Collaborator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(18).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    for (const v of message.scopes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(42).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(58).fork()).join();
    }
    if (message.deletedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deletedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collaborator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollaborator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deletedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collaborator {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      deletedAt: isSet(object.deletedAt) ? fromJsonTimestamp(object.deletedAt) : undefined,
    };
  },

  toJSON(message: Collaborator): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.deletedAt !== undefined) {
      obj.deletedAt = message.deletedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Collaborator>, I>>(base?: I): Collaborator {
    return Collaborator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Collaborator>, I>>(object: I): Collaborator {
    const message = createBaseCollaborator();
    message.id = object.id ?? "";
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.deletedAt = object.deletedAt ?? undefined;
    return message;
  },
};

function createBaseCollaboration(): Collaboration {
  return { app: undefined, appOwner: undefined, scopes: [], endpoints: [], createdAt: undefined };
}

export const Collaboration: MessageFns<Collaboration> = {
  encode(message: Collaboration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(10).fork()).join();
    }
    if (message.appOwner !== undefined) {
      User.encode(message.appOwner, writer.uint32(18).fork()).join();
    }
    for (const v of message.scopes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collaboration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollaboration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appOwner = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collaboration {
    return {
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
      appOwner: isSet(object.appOwner) ? User.fromJSON(object.appOwner) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: Collaboration): unknown {
    const obj: any = {};
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    if (message.appOwner !== undefined) {
      obj.appOwner = User.toJSON(message.appOwner);
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Collaboration>, I>>(base?: I): Collaboration {
    return Collaboration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Collaboration>, I>>(object: I): Collaboration {
    const message = createBaseCollaboration();
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    message.appOwner = (object.appOwner !== undefined && object.appOwner !== null)
      ? User.fromPartial(object.appOwner)
      : undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseAudio(): Audio {
  return { url: "", base64: new Uint8Array(0), allowDuplicateUrl: false, hosted: undefined, audioInfo: undefined };
}

export const Audio: MessageFns<Audio> = {
  encode(message: Audio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.base64.length !== 0) {
      writer.uint32(18).bytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      writer.uint32(32).bool(message.allowDuplicateUrl);
    }
    if (message.hosted !== undefined) {
      HostedURL.encode(message.hosted, writer.uint32(42).fork()).join();
    }
    if (message.audioInfo !== undefined) {
      AudioInfo.encode(message.audioInfo, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Audio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64 = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowDuplicateUrl = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hosted = HostedURL.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audioInfo = AudioInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Audio {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      base64: isSet(object.base64) ? bytesFromBase64(object.base64) : new Uint8Array(0),
      allowDuplicateUrl: isSet(object.allowDuplicateUrl) ? globalThis.Boolean(object.allowDuplicateUrl) : false,
      hosted: isSet(object.hosted) ? HostedURL.fromJSON(object.hosted) : undefined,
      audioInfo: isSet(object.audioInfo) ? AudioInfo.fromJSON(object.audioInfo) : undefined,
    };
  },

  toJSON(message: Audio): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.base64.length !== 0) {
      obj.base64 = base64FromBytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      obj.allowDuplicateUrl = message.allowDuplicateUrl;
    }
    if (message.hosted !== undefined) {
      obj.hosted = HostedURL.toJSON(message.hosted);
    }
    if (message.audioInfo !== undefined) {
      obj.audioInfo = AudioInfo.toJSON(message.audioInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Audio>, I>>(base?: I): Audio {
    return Audio.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Audio>, I>>(object: I): Audio {
    const message = createBaseAudio();
    message.url = object.url ?? "";
    message.base64 = object.base64 ?? new Uint8Array(0);
    message.allowDuplicateUrl = object.allowDuplicateUrl ?? false;
    message.hosted = (object.hosted !== undefined && object.hosted !== null)
      ? HostedURL.fromPartial(object.hosted)
      : undefined;
    message.audioInfo = (object.audioInfo !== undefined && object.audioInfo !== null)
      ? AudioInfo.fromPartial(object.audioInfo)
      : undefined;
    return message;
  },
};

function createBaseAudioInfo(): AudioInfo {
  return { audioFormat: "", sampleRate: 0, durationSeconds: 0, bitRate: 0 };
}

export const AudioInfo: MessageFns<AudioInfo> = {
  encode(message: AudioInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioFormat !== "") {
      writer.uint32(10).string(message.audioFormat);
    }
    if (message.sampleRate !== 0) {
      writer.uint32(16).int32(message.sampleRate);
    }
    if (message.durationSeconds !== 0) {
      writer.uint32(29).float(message.durationSeconds);
    }
    if (message.bitRate !== 0) {
      writer.uint32(32).int32(message.bitRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.audioFormat = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sampleRate = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.durationSeconds = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bitRate = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioInfo {
    return {
      audioFormat: isSet(object.audioFormat) ? globalThis.String(object.audioFormat) : "",
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
      bitRate: isSet(object.bitRate) ? globalThis.Number(object.bitRate) : 0,
    };
  },

  toJSON(message: AudioInfo): unknown {
    const obj: any = {};
    if (message.audioFormat !== "") {
      obj.audioFormat = message.audioFormat;
    }
    if (message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = message.durationSeconds;
    }
    if (message.bitRate !== 0) {
      obj.bitRate = Math.round(message.bitRate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioInfo>, I>>(base?: I): AudioInfo {
    return AudioInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioInfo>, I>>(object: I): AudioInfo {
    const message = createBaseAudioInfo();
    message.audioFormat = object.audioFormat ?? "";
    message.sampleRate = object.sampleRate ?? 0;
    message.durationSeconds = object.durationSeconds ?? 0;
    message.bitRate = object.bitRate ?? 0;
    return message;
  },
};

function createBaseTrack(): Track {
  return { id: "", data: undefined, timeInfo: undefined, quality: 0 };
}

export const Track: MessageFns<Track> = {
  encode(message: Track, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.timeInfo !== undefined) {
      TimeInfo.encode(message.timeInfo, writer.uint32(34).fork()).join();
    }
    if (message.quality !== 0) {
      writer.uint32(45).float(message.quality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Track {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeInfo = TimeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.quality = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Track {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      timeInfo: isSet(object.timeInfo) ? TimeInfo.fromJSON(object.timeInfo) : undefined,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
    };
  },

  toJSON(message: Track): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.timeInfo !== undefined) {
      obj.timeInfo = TimeInfo.toJSON(message.timeInfo);
    }
    if (message.quality !== 0) {
      obj.quality = message.quality;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Track>, I>>(base?: I): Track {
    return Track.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Track>, I>>(object: I): Track {
    const message = createBaseTrack();
    message.id = object.id ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.timeInfo = (object.timeInfo !== undefined && object.timeInfo !== null)
      ? TimeInfo.fromPartial(object.timeInfo)
      : undefined;
    message.quality = object.quality ?? 0;
    return message;
  },
};

function createBaseCluster(): Cluster {
  return { id: "", count: 0, score: 0, hits: [], projection: [] };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    for (const v of message.hits) {
      Hit.encode(v!, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.projection) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hits.push(Hit.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag === 45) {
            message.projection.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.projection.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      hits: globalThis.Array.isArray(object?.hits) ? object.hits.map((e: any) => Hit.fromJSON(e)) : [],
      projection: globalThis.Array.isArray(object?.projection)
        ? object.projection.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.hits?.length) {
      obj.hits = message.hits.map((e) => Hit.toJSON(e));
    }
    if (message.projection?.length) {
      obj.projection = message.projection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cluster>, I>>(base?: I): Cluster {
    return Cluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cluster>, I>>(object: I): Cluster {
    const message = createBaseCluster();
    message.id = object.id ?? "";
    message.count = object.count ?? 0;
    message.score = object.score ?? 0;
    message.hits = object.hits?.map((e) => Hit.fromPartial(e)) || [];
    message.projection = object.projection?.map((e) => e) || [];
    return message;
  },
};

function createBaseColor(): Color {
  return { rawHex: "", w3c: undefined, value: 0 };
}

export const Color: MessageFns<Color> = {
  encode(message: Color, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawHex !== "") {
      writer.uint32(10).string(message.rawHex);
    }
    if (message.w3c !== undefined) {
      W3C.encode(message.w3c, writer.uint32(18).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Color {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawHex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.w3c = W3C.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Color {
    return {
      rawHex: isSet(object.rawHex) ? globalThis.String(object.rawHex) : "",
      w3c: isSet(object.w3c) ? W3C.fromJSON(object.w3c) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Color): unknown {
    const obj: any = {};
    if (message.rawHex !== "") {
      obj.rawHex = message.rawHex;
    }
    if (message.w3c !== undefined) {
      obj.w3c = W3C.toJSON(message.w3c);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Color>, I>>(base?: I): Color {
    return Color.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Color>, I>>(object: I): Color {
    const message = createBaseColor();
    message.rawHex = object.rawHex ?? "";
    message.w3c = (object.w3c !== undefined && object.w3c !== null) ? W3C.fromPartial(object.w3c) : undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseW3C(): W3C {
  return { hex: "", name: "" };
}

export const W3C: MessageFns<W3C> = {
  encode(message: W3C, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hex !== "") {
      writer.uint32(10).string(message.hex);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): W3C {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseW3C();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): W3C {
    return {
      hex: isSet(object.hex) ? globalThis.String(object.hex) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: W3C): unknown {
    const obj: any = {};
    if (message.hex !== "") {
      obj.hex = message.hex;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<W3C>, I>>(base?: I): W3C {
    return W3C.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<W3C>, I>>(object: I): W3C {
    const message = createBaseW3C();
    message.hex = object.hex ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserAppIDSet(): UserAppIDSet {
  return { userId: "", appId: "" };
}

export const UserAppIDSet: MessageFns<UserAppIDSet> = {
  encode(message: UserAppIDSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserAppIDSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAppIDSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAppIDSet {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
    };
  },

  toJSON(message: UserAppIDSet): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserAppIDSet>, I>>(base?: I): UserAppIDSet {
    return UserAppIDSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserAppIDSet>, I>>(object: I): UserAppIDSet {
    const message = createBaseUserAppIDSet();
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    return message;
  },
};

function createBasePatchAction(): PatchAction {
  return { op: "", mergeConflictResolution: "", path: "" };
}

export const PatchAction: MessageFns<PatchAction> = {
  encode(message: PatchAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== "") {
      writer.uint32(10).string(message.op);
    }
    if (message.mergeConflictResolution !== "") {
      writer.uint32(18).string(message.mergeConflictResolution);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.op = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mergeConflictResolution = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchAction {
    return {
      op: isSet(object.op) ? globalThis.String(object.op) : "",
      mergeConflictResolution: isSet(object.mergeConflictResolution)
        ? globalThis.String(object.mergeConflictResolution)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: PatchAction): unknown {
    const obj: any = {};
    if (message.op !== "") {
      obj.op = message.op;
    }
    if (message.mergeConflictResolution !== "") {
      obj.mergeConflictResolution = message.mergeConflictResolution;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatchAction>, I>>(base?: I): PatchAction {
    return PatchAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatchAction>, I>>(object: I): PatchAction {
    const message = createBasePatchAction();
    message.op = object.op ?? "";
    message.mergeConflictResolution = object.mergeConflictResolution ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseConcept(): Concept {
  return {
    id: "",
    name: "",
    value: 0,
    createdAt: undefined,
    language: "",
    appId: "",
    definition: "",
    vocabId: "",
    visibility: undefined,
    userId: "",
    keypointInfo: undefined,
    extraInfo: undefined,
    metadata: undefined,
    image: undefined,
  };
}

export const Concept: MessageFns<Concept> = {
  encode(message: Concept, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(42).string(message.language);
    }
    if (message.appId !== "") {
      writer.uint32(50).string(message.appId);
    }
    if (message.definition !== "") {
      writer.uint32(58).string(message.definition);
    }
    if (message.vocabId !== "") {
      writer.uint32(66).string(message.vocabId);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(74).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(82).string(message.userId);
    }
    if (message.keypointInfo !== undefined) {
      KeypointInfo.encode(message.keypointInfo, writer.uint32(90).fork()).join();
    }
    if (message.extraInfo !== undefined) {
      ConceptExtraInfo.encode(message.extraInfo, writer.uint32(98).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(106).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Concept {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConcept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.vocabId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.keypointInfo = KeypointInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.extraInfo = ConceptExtraInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Concept {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      vocabId: isSet(object.vocabId) ? globalThis.String(object.vocabId) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      keypointInfo: isSet(object.keypointInfo) ? KeypointInfo.fromJSON(object.keypointInfo) : undefined,
      extraInfo: isSet(object.extraInfo) ? ConceptExtraInfo.fromJSON(object.extraInfo) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: Concept): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.vocabId !== "") {
      obj.vocabId = message.vocabId;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.keypointInfo !== undefined) {
      obj.keypointInfo = KeypointInfo.toJSON(message.keypointInfo);
    }
    if (message.extraInfo !== undefined) {
      obj.extraInfo = ConceptExtraInfo.toJSON(message.extraInfo);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Concept>, I>>(base?: I): Concept {
    return Concept.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Concept>, I>>(object: I): Concept {
    const message = createBaseConcept();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.language = object.language ?? "";
    message.appId = object.appId ?? "";
    message.definition = object.definition ?? "";
    message.vocabId = object.vocabId ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.userId = object.userId ?? "";
    message.keypointInfo = (object.keypointInfo !== undefined && object.keypointInfo !== null)
      ? KeypointInfo.fromPartial(object.keypointInfo)
      : undefined;
    message.extraInfo = (object.extraInfo !== undefined && object.extraInfo !== null)
      ? ConceptExtraInfo.fromPartial(object.extraInfo)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseKeypointInfo(): KeypointInfo {
  return { keypointNames: [], skeleton: [] };
}

export const KeypointInfo: MessageFns<KeypointInfo> = {
  encode(message: KeypointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keypointNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.skeleton) {
      KeypointEdge.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeypointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeypointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keypointNames.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.skeleton.push(KeypointEdge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeypointInfo {
    return {
      keypointNames: globalThis.Array.isArray(object?.keypointNames)
        ? object.keypointNames.map((e: any) => globalThis.String(e))
        : [],
      skeleton: globalThis.Array.isArray(object?.skeleton)
        ? object.skeleton.map((e: any) => KeypointEdge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeypointInfo): unknown {
    const obj: any = {};
    if (message.keypointNames?.length) {
      obj.keypointNames = message.keypointNames;
    }
    if (message.skeleton?.length) {
      obj.skeleton = message.skeleton.map((e) => KeypointEdge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeypointInfo>, I>>(base?: I): KeypointInfo {
    return KeypointInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeypointInfo>, I>>(object: I): KeypointInfo {
    const message = createBaseKeypointInfo();
    message.keypointNames = object.keypointNames?.map((e) => e) || [];
    message.skeleton = object.skeleton?.map((e) => KeypointEdge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeypointEdge(): KeypointEdge {
  return { k1: 0, k2: 0 };
}

export const KeypointEdge: MessageFns<KeypointEdge> = {
  encode(message: KeypointEdge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.k1 !== 0) {
      writer.uint32(8).uint32(message.k1);
    }
    if (message.k2 !== 0) {
      writer.uint32(16).uint32(message.k2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeypointEdge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeypointEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.k1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.k2 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeypointEdge {
    return {
      k1: isSet(object.k1) ? globalThis.Number(object.k1) : 0,
      k2: isSet(object.k2) ? globalThis.Number(object.k2) : 0,
    };
  },

  toJSON(message: KeypointEdge): unknown {
    const obj: any = {};
    if (message.k1 !== 0) {
      obj.k1 = Math.round(message.k1);
    }
    if (message.k2 !== 0) {
      obj.k2 = Math.round(message.k2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeypointEdge>, I>>(base?: I): KeypointEdge {
    return KeypointEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeypointEdge>, I>>(object: I): KeypointEdge {
    const message = createBaseKeypointEdge();
    message.k1 = object.k1 ?? 0;
    message.k2 = object.k2 ?? 0;
    return message;
  },
};

function createBaseConceptExtraInfo(): ConceptExtraInfo {
  return { isRankable: false };
}

export const ConceptExtraInfo: MessageFns<ConceptExtraInfo> = {
  encode(message: ConceptExtraInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isRankable !== false) {
      writer.uint32(8).bool(message.isRankable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptExtraInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isRankable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptExtraInfo {
    return { isRankable: isSet(object.isRankable) ? globalThis.Boolean(object.isRankable) : false };
  },

  toJSON(message: ConceptExtraInfo): unknown {
    const obj: any = {};
    if (message.isRankable !== false) {
      obj.isRankable = message.isRankable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptExtraInfo>, I>>(base?: I): ConceptExtraInfo {
    return ConceptExtraInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptExtraInfo>, I>>(object: I): ConceptExtraInfo {
    const message = createBaseConceptExtraInfo();
    message.isRankable = object.isRankable ?? false;
    return message;
  },
};

function createBaseConceptCount(): ConceptCount {
  return { id: "", name: "", conceptTypeCount: undefined, detailConceptCount: undefined };
}

export const ConceptCount: MessageFns<ConceptCount> = {
  encode(message: ConceptCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.conceptTypeCount !== undefined) {
      ConceptTypeCount.encode(message.conceptTypeCount, writer.uint32(26).fork()).join();
    }
    if (message.detailConceptCount !== undefined) {
      DetailConceptCount.encode(message.detailConceptCount, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conceptTypeCount = ConceptTypeCount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.detailConceptCount = DetailConceptCount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptCount {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      conceptTypeCount: isSet(object.conceptTypeCount) ? ConceptTypeCount.fromJSON(object.conceptTypeCount) : undefined,
      detailConceptCount: isSet(object.detailConceptCount)
        ? DetailConceptCount.fromJSON(object.detailConceptCount)
        : undefined,
    };
  },

  toJSON(message: ConceptCount): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.conceptTypeCount !== undefined) {
      obj.conceptTypeCount = ConceptTypeCount.toJSON(message.conceptTypeCount);
    }
    if (message.detailConceptCount !== undefined) {
      obj.detailConceptCount = DetailConceptCount.toJSON(message.detailConceptCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptCount>, I>>(base?: I): ConceptCount {
    return ConceptCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptCount>, I>>(object: I): ConceptCount {
    const message = createBaseConceptCount();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.conceptTypeCount = (object.conceptTypeCount !== undefined && object.conceptTypeCount !== null)
      ? ConceptTypeCount.fromPartial(object.conceptTypeCount)
      : undefined;
    message.detailConceptCount = (object.detailConceptCount !== undefined && object.detailConceptCount !== null)
      ? DetailConceptCount.fromPartial(object.detailConceptCount)
      : undefined;
    return message;
  },
};

function createBaseConceptTypeCount(): ConceptTypeCount {
  return { positive: 0, negative: 0 };
}

export const ConceptTypeCount: MessageFns<ConceptTypeCount> = {
  encode(message: ConceptTypeCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.positive !== 0) {
      writer.uint32(8).uint32(message.positive);
    }
    if (message.negative !== 0) {
      writer.uint32(16).uint32(message.negative);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptTypeCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptTypeCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.positive = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.negative = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptTypeCount {
    return {
      positive: isSet(object.positive) ? globalThis.Number(object.positive) : 0,
      negative: isSet(object.negative) ? globalThis.Number(object.negative) : 0,
    };
  },

  toJSON(message: ConceptTypeCount): unknown {
    const obj: any = {};
    if (message.positive !== 0) {
      obj.positive = Math.round(message.positive);
    }
    if (message.negative !== 0) {
      obj.negative = Math.round(message.negative);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptTypeCount>, I>>(base?: I): ConceptTypeCount {
    return ConceptTypeCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptTypeCount>, I>>(object: I): ConceptTypeCount {
    const message = createBaseConceptTypeCount();
    message.positive = object.positive ?? 0;
    message.negative = object.negative ?? 0;
    return message;
  },
};

function createBaseDetailConceptCount(): DetailConceptCount {
  return { processed: undefined, toProcess: undefined, errors: undefined, processing: undefined };
}

export const DetailConceptCount: MessageFns<DetailConceptCount> = {
  encode(message: DetailConceptCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== undefined) {
      ConceptTypeCount.encode(message.processed, writer.uint32(10).fork()).join();
    }
    if (message.toProcess !== undefined) {
      ConceptTypeCount.encode(message.toProcess, writer.uint32(18).fork()).join();
    }
    if (message.errors !== undefined) {
      ConceptTypeCount.encode(message.errors, writer.uint32(26).fork()).join();
    }
    if (message.processing !== undefined) {
      ConceptTypeCount.encode(message.processing, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailConceptCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailConceptCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processed = ConceptTypeCount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toProcess = ConceptTypeCount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors = ConceptTypeCount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processing = ConceptTypeCount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailConceptCount {
    return {
      processed: isSet(object.processed) ? ConceptTypeCount.fromJSON(object.processed) : undefined,
      toProcess: isSet(object.toProcess) ? ConceptTypeCount.fromJSON(object.toProcess) : undefined,
      errors: isSet(object.errors) ? ConceptTypeCount.fromJSON(object.errors) : undefined,
      processing: isSet(object.processing) ? ConceptTypeCount.fromJSON(object.processing) : undefined,
    };
  },

  toJSON(message: DetailConceptCount): unknown {
    const obj: any = {};
    if (message.processed !== undefined) {
      obj.processed = ConceptTypeCount.toJSON(message.processed);
    }
    if (message.toProcess !== undefined) {
      obj.toProcess = ConceptTypeCount.toJSON(message.toProcess);
    }
    if (message.errors !== undefined) {
      obj.errors = ConceptTypeCount.toJSON(message.errors);
    }
    if (message.processing !== undefined) {
      obj.processing = ConceptTypeCount.toJSON(message.processing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailConceptCount>, I>>(base?: I): DetailConceptCount {
    return DetailConceptCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailConceptCount>, I>>(object: I): DetailConceptCount {
    const message = createBaseDetailConceptCount();
    message.processed = (object.processed !== undefined && object.processed !== null)
      ? ConceptTypeCount.fromPartial(object.processed)
      : undefined;
    message.toProcess = (object.toProcess !== undefined && object.toProcess !== null)
      ? ConceptTypeCount.fromPartial(object.toProcess)
      : undefined;
    message.errors = (object.errors !== undefined && object.errors !== null)
      ? ConceptTypeCount.fromPartial(object.errors)
      : undefined;
    message.processing = (object.processing !== undefined && object.processing !== null)
      ? ConceptTypeCount.fromPartial(object.processing)
      : undefined;
    return message;
  },
};

function createBaseConceptQuery(): ConceptQuery {
  return {
    name: "",
    language: "",
    workflowId: "",
    useCases: [],
    model: undefined,
    workflow: undefined,
    ignoreAppConcepts: false,
  };
}

export const ConceptQuery: MessageFns<ConceptQuery> = {
  encode(message: ConceptQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    if (message.workflowId !== "") {
      writer.uint32(26).string(message.workflowId);
    }
    writer.uint32(34).fork();
    for (const v of message.useCases) {
      writer.int32(v);
    }
    writer.join();
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(42).fork()).join();
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(50).fork()).join();
    }
    if (message.ignoreAppConcepts !== false) {
      writer.uint32(56).bool(message.ignoreAppConcepts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.useCases.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.useCases.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ignoreAppConcepts = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptQuery {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      useCases: globalThis.Array.isArray(object?.useCases)
        ? object.useCases.map((e: any) => workflowModelUseCaseFromJSON(e))
        : [],
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
      ignoreAppConcepts: isSet(object.ignoreAppConcepts) ? globalThis.Boolean(object.ignoreAppConcepts) : false,
    };
  },

  toJSON(message: ConceptQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.useCases?.length) {
      obj.useCases = message.useCases.map((e) => workflowModelUseCaseToJSON(e));
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    if (message.ignoreAppConcepts !== false) {
      obj.ignoreAppConcepts = message.ignoreAppConcepts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptQuery>, I>>(base?: I): ConceptQuery {
    return ConceptQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptQuery>, I>>(object: I): ConceptQuery {
    const message = createBaseConceptQuery();
    message.name = object.name ?? "";
    message.language = object.language ?? "";
    message.workflowId = object.workflowId ?? "";
    message.useCases = object.useCases?.map((e) => e) || [];
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    message.ignoreAppConcepts = object.ignoreAppConcepts ?? false;
    return message;
  },
};

function createBaseConceptRelation(): ConceptRelation {
  return {
    id: "",
    subjectConcept: undefined,
    objectConcept: undefined,
    predicate: "",
    knowledgeGraphId: "",
    visibility: undefined,
  };
}

export const ConceptRelation: MessageFns<ConceptRelation> = {
  encode(message: ConceptRelation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subjectConcept !== undefined) {
      Concept.encode(message.subjectConcept, writer.uint32(18).fork()).join();
    }
    if (message.objectConcept !== undefined) {
      Concept.encode(message.objectConcept, writer.uint32(26).fork()).join();
    }
    if (message.predicate !== "") {
      writer.uint32(34).string(message.predicate);
    }
    if (message.knowledgeGraphId !== "") {
      writer.uint32(42).string(message.knowledgeGraphId);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectConcept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.objectConcept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.predicate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.knowledgeGraphId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptRelation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subjectConcept: isSet(object.subjectConcept) ? Concept.fromJSON(object.subjectConcept) : undefined,
      objectConcept: isSet(object.objectConcept) ? Concept.fromJSON(object.objectConcept) : undefined,
      predicate: isSet(object.predicate) ? globalThis.String(object.predicate) : "",
      knowledgeGraphId: isSet(object.knowledgeGraphId) ? globalThis.String(object.knowledgeGraphId) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
    };
  },

  toJSON(message: ConceptRelation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subjectConcept !== undefined) {
      obj.subjectConcept = Concept.toJSON(message.subjectConcept);
    }
    if (message.objectConcept !== undefined) {
      obj.objectConcept = Concept.toJSON(message.objectConcept);
    }
    if (message.predicate !== "") {
      obj.predicate = message.predicate;
    }
    if (message.knowledgeGraphId !== "") {
      obj.knowledgeGraphId = message.knowledgeGraphId;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptRelation>, I>>(base?: I): ConceptRelation {
    return ConceptRelation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptRelation>, I>>(object: I): ConceptRelation {
    const message = createBaseConceptRelation();
    message.id = object.id ?? "";
    message.subjectConcept = (object.subjectConcept !== undefined && object.subjectConcept !== null)
      ? Concept.fromPartial(object.subjectConcept)
      : undefined;
    message.objectConcept = (object.objectConcept !== undefined && object.objectConcept !== null)
      ? Concept.fromPartial(object.objectConcept)
      : undefined;
    message.predicate = object.predicate ?? "";
    message.knowledgeGraphId = object.knowledgeGraphId ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    return message;
  },
};

function createBaseKnowledgeGraph(): KnowledgeGraph {
  return { id: "", name: "", description: "", examplesAppId: "", sampledExamplesAppId: "" };
}

export const KnowledgeGraph: MessageFns<KnowledgeGraph> = {
  encode(message: KnowledgeGraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.examplesAppId !== "") {
      writer.uint32(34).string(message.examplesAppId);
    }
    if (message.sampledExamplesAppId !== "") {
      writer.uint32(42).string(message.sampledExamplesAppId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeGraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.examplesAppId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sampledExamplesAppId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeGraph {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      examplesAppId: isSet(object.examplesAppId) ? globalThis.String(object.examplesAppId) : "",
      sampledExamplesAppId: isSet(object.sampledExamplesAppId) ? globalThis.String(object.sampledExamplesAppId) : "",
    };
  },

  toJSON(message: KnowledgeGraph): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.examplesAppId !== "") {
      obj.examplesAppId = message.examplesAppId;
    }
    if (message.sampledExamplesAppId !== "") {
      obj.sampledExamplesAppId = message.sampledExamplesAppId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KnowledgeGraph>, I>>(base?: I): KnowledgeGraph {
    return KnowledgeGraph.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KnowledgeGraph>, I>>(object: I): KnowledgeGraph {
    const message = createBaseKnowledgeGraph();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.examplesAppId = object.examplesAppId ?? "";
    message.sampledExamplesAppId = object.sampledExamplesAppId ?? "";
    return message;
  },
};

function createBaseConceptLanguage(): ConceptLanguage {
  return { id: "", name: "", definition: "" };
}

export const ConceptLanguage: MessageFns<ConceptLanguage> = {
  encode(message: ConceptLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(26).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptLanguage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: ConceptLanguage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConceptLanguage>, I>>(base?: I): ConceptLanguage {
    return ConceptLanguage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConceptLanguage>, I>>(object: I): ConceptLanguage {
    const message = createBaseConceptLanguage();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseData(): Data {
  return {
    image: undefined,
    video: undefined,
    concepts: [],
    metadata: undefined,
    geo: undefined,
    colors: [],
    clusters: [],
    embeddings: [],
    regions: [],
    frames: [],
    text: undefined,
    audio: undefined,
    tracks: [],
    timeSegments: [],
    hits: [],
    heatmaps: [],
    parts: [],
    ndarray: undefined,
    intValue: 0,
    floatValue: 0,
    bytesValue: new Uint8Array(0),
    boolValue: false,
    stringValue: "",
  };
}

export const Data: MessageFns<Data> = {
  encode(message: Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    if (message.video !== undefined) {
      Video.encode(message.video, writer.uint32(18).fork()).join();
    }
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(42).fork()).join();
    }
    if (message.geo !== undefined) {
      Geo.encode(message.geo, writer.uint32(50).fork()).join();
    }
    for (const v of message.colors) {
      Color.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.clusters) {
      Cluster.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.embeddings) {
      Embedding.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.regions) {
      Region.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.frames) {
      Frame.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(106).fork()).join();
    }
    if (message.audio !== undefined) {
      Audio.encode(message.audio, writer.uint32(114).fork()).join();
    }
    for (const v of message.tracks) {
      Track.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.timeSegments) {
      TimeSegment.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.hits) {
      Hit.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.heatmaps) {
      Image.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.parts) {
      Part.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.ndarray !== undefined) {
      NDArray.encode(message.ndarray, writer.uint32(162).fork()).join();
    }
    if (message.intValue !== 0) {
      writer.uint32(168).int64(message.intValue);
    }
    if (message.floatValue !== 0) {
      writer.uint32(177).double(message.floatValue);
    }
    if (message.bytesValue.length !== 0) {
      writer.uint32(186).bytes(message.bytesValue);
    }
    if (message.boolValue !== false) {
      writer.uint32(192).bool(message.boolValue);
    }
    if (message.stringValue !== "") {
      writer.uint32(202).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.video = Video.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.geo = Geo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.colors.push(Color.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clusters.push(Cluster.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.embeddings.push(Embedding.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.regions.push(Region.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.frames.push(Frame.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.audio = Audio.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tracks.push(Track.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.timeSegments.push(TimeSegment.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.hits.push(Hit.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.heatmaps.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.parts.push(Part.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.ndarray = NDArray.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.intValue = longToNumber(reader.int64());
          continue;
        }
        case 22: {
          if (tag !== 177) {
            break;
          }

          message.floatValue = reader.double();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.bytesValue = reader.bytes();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data {
    return {
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      video: isSet(object.video) ? Video.fromJSON(object.video) : undefined,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      geo: isSet(object.geo) ? Geo.fromJSON(object.geo) : undefined,
      colors: globalThis.Array.isArray(object?.colors) ? object.colors.map((e: any) => Color.fromJSON(e)) : [],
      clusters: globalThis.Array.isArray(object?.clusters) ? object.clusters.map((e: any) => Cluster.fromJSON(e)) : [],
      embeddings: globalThis.Array.isArray(object?.embeddings)
        ? object.embeddings.map((e: any) => Embedding.fromJSON(e))
        : [],
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => Region.fromJSON(e)) : [],
      frames: globalThis.Array.isArray(object?.frames) ? object.frames.map((e: any) => Frame.fromJSON(e)) : [],
      text: isSet(object.text) ? Text.fromJSON(object.text) : undefined,
      audio: isSet(object.audio) ? Audio.fromJSON(object.audio) : undefined,
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => Track.fromJSON(e)) : [],
      timeSegments: globalThis.Array.isArray(object?.timeSegments)
        ? object.timeSegments.map((e: any) => TimeSegment.fromJSON(e))
        : [],
      hits: globalThis.Array.isArray(object?.hits) ? object.hits.map((e: any) => Hit.fromJSON(e)) : [],
      heatmaps: globalThis.Array.isArray(object?.heatmaps) ? object.heatmaps.map((e: any) => Image.fromJSON(e)) : [],
      parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => Part.fromJSON(e)) : [],
      ndarray: isSet(object.ndarray) ? NDArray.fromJSON(object.ndarray) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : 0,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : 0,
      bytesValue: isSet(object.bytesValue) ? bytesFromBase64(object.bytesValue) : new Uint8Array(0),
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : false,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : "",
    };
  },

  toJSON(message: Data): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.video !== undefined) {
      obj.video = Video.toJSON(message.video);
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.geo !== undefined) {
      obj.geo = Geo.toJSON(message.geo);
    }
    if (message.colors?.length) {
      obj.colors = message.colors.map((e) => Color.toJSON(e));
    }
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.embeddings?.length) {
      obj.embeddings = message.embeddings.map((e) => Embedding.toJSON(e));
    }
    if (message.regions?.length) {
      obj.regions = message.regions.map((e) => Region.toJSON(e));
    }
    if (message.frames?.length) {
      obj.frames = message.frames.map((e) => Frame.toJSON(e));
    }
    if (message.text !== undefined) {
      obj.text = Text.toJSON(message.text);
    }
    if (message.audio !== undefined) {
      obj.audio = Audio.toJSON(message.audio);
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => Track.toJSON(e));
    }
    if (message.timeSegments?.length) {
      obj.timeSegments = message.timeSegments.map((e) => TimeSegment.toJSON(e));
    }
    if (message.hits?.length) {
      obj.hits = message.hits.map((e) => Hit.toJSON(e));
    }
    if (message.heatmaps?.length) {
      obj.heatmaps = message.heatmaps.map((e) => Image.toJSON(e));
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => Part.toJSON(e));
    }
    if (message.ndarray !== undefined) {
      obj.ndarray = NDArray.toJSON(message.ndarray);
    }
    if (message.intValue !== 0) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.floatValue !== 0) {
      obj.floatValue = message.floatValue;
    }
    if (message.bytesValue.length !== 0) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.boolValue !== false) {
      obj.boolValue = message.boolValue;
    }
    if (message.stringValue !== "") {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Data>, I>>(base?: I): Data {
    return Data.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Data>, I>>(object: I): Data {
    const message = createBaseData();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.video = (object.video !== undefined && object.video !== null) ? Video.fromPartial(object.video) : undefined;
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    message.metadata = object.metadata ?? undefined;
    message.geo = (object.geo !== undefined && object.geo !== null) ? Geo.fromPartial(object.geo) : undefined;
    message.colors = object.colors?.map((e) => Color.fromPartial(e)) || [];
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || [];
    message.embeddings = object.embeddings?.map((e) => Embedding.fromPartial(e)) || [];
    message.regions = object.regions?.map((e) => Region.fromPartial(e)) || [];
    message.frames = object.frames?.map((e) => Frame.fromPartial(e)) || [];
    message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
    message.audio = (object.audio !== undefined && object.audio !== null) ? Audio.fromPartial(object.audio) : undefined;
    message.tracks = object.tracks?.map((e) => Track.fromPartial(e)) || [];
    message.timeSegments = object.timeSegments?.map((e) => TimeSegment.fromPartial(e)) || [];
    message.hits = object.hits?.map((e) => Hit.fromPartial(e)) || [];
    message.heatmaps = object.heatmaps?.map((e) => Image.fromPartial(e)) || [];
    message.parts = object.parts?.map((e) => Part.fromPartial(e)) || [];
    message.ndarray = (object.ndarray !== undefined && object.ndarray !== null)
      ? NDArray.fromPartial(object.ndarray)
      : undefined;
    message.intValue = object.intValue ?? 0;
    message.floatValue = object.floatValue ?? 0;
    message.bytesValue = object.bytesValue ?? new Uint8Array(0);
    message.boolValue = object.boolValue ?? false;
    message.stringValue = object.stringValue ?? "";
    return message;
  },
};

function createBasePart(): Part {
  return { data: undefined, id: "" };
}

export const Part: MessageFns<Part> = {
  encode(message: Part, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Part {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Part {
    return {
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: Part): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Part>, I>>(base?: I): Part {
    return Part.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Part>, I>>(object: I): Part {
    const message = createBasePart();
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRegion(): Region {
  return { id: "", regionInfo: undefined, data: undefined, value: 0, trackId: "" };
}

export const Region: MessageFns<Region> = {
  encode(message: Region, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.regionInfo !== undefined) {
      RegionInfo.encode(message.regionInfo, writer.uint32(18).fork()).join();
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(37).float(message.value);
    }
    if (message.trackId !== "") {
      writer.uint32(42).string(message.trackId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Region {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regionInfo = RegionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.trackId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Region {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      regionInfo: isSet(object.regionInfo) ? RegionInfo.fromJSON(object.regionInfo) : undefined,
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      trackId: isSet(object.trackId) ? globalThis.String(object.trackId) : "",
    };
  },

  toJSON(message: Region): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.regionInfo !== undefined) {
      obj.regionInfo = RegionInfo.toJSON(message.regionInfo);
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.trackId !== "") {
      obj.trackId = message.trackId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Region>, I>>(base?: I): Region {
    return Region.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Region>, I>>(object: I): Region {
    const message = createBaseRegion();
    message.id = object.id ?? "";
    message.regionInfo = (object.regionInfo !== undefined && object.regionInfo !== null)
      ? RegionInfo.fromPartial(object.regionInfo)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.value = object.value ?? 0;
    message.trackId = object.trackId ?? "";
    return message;
  },
};

function createBaseRegionInfo(): RegionInfo {
  return {
    boundingBox: undefined,
    mask: undefined,
    polygon: undefined,
    point: undefined,
    span: undefined,
    token: undefined,
    keypointLocations: [],
  };
}

export const RegionInfo: MessageFns<RegionInfo> = {
  encode(message: RegionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boundingBox !== undefined) {
      BoundingBox.encode(message.boundingBox, writer.uint32(10).fork()).join();
    }
    if (message.mask !== undefined) {
      Mask.encode(message.mask, writer.uint32(34).fork()).join();
    }
    if (message.polygon !== undefined) {
      Polygon.encode(message.polygon, writer.uint32(42).fork()).join();
    }
    if (message.point !== undefined) {
      Point.encode(message.point, writer.uint32(50).fork()).join();
    }
    if (message.span !== undefined) {
      Span.encode(message.span, writer.uint32(58).fork()).join();
    }
    if (message.token !== undefined) {
      Token.encode(message.token, writer.uint32(66).fork()).join();
    }
    for (const v of message.keypointLocations) {
      Point.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.boundingBox = BoundingBox.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mask = Mask.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.polygon = Polygon.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.point = Point.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.span = Span.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.token = Token.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.keypointLocations.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegionInfo {
    return {
      boundingBox: isSet(object.boundingBox) ? BoundingBox.fromJSON(object.boundingBox) : undefined,
      mask: isSet(object.mask) ? Mask.fromJSON(object.mask) : undefined,
      polygon: isSet(object.polygon) ? Polygon.fromJSON(object.polygon) : undefined,
      point: isSet(object.point) ? Point.fromJSON(object.point) : undefined,
      span: isSet(object.span) ? Span.fromJSON(object.span) : undefined,
      token: isSet(object.token) ? Token.fromJSON(object.token) : undefined,
      keypointLocations: globalThis.Array.isArray(object?.keypointLocations)
        ? object.keypointLocations.map((e: any) => Point.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RegionInfo): unknown {
    const obj: any = {};
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingBox.toJSON(message.boundingBox);
    }
    if (message.mask !== undefined) {
      obj.mask = Mask.toJSON(message.mask);
    }
    if (message.polygon !== undefined) {
      obj.polygon = Polygon.toJSON(message.polygon);
    }
    if (message.point !== undefined) {
      obj.point = Point.toJSON(message.point);
    }
    if (message.span !== undefined) {
      obj.span = Span.toJSON(message.span);
    }
    if (message.token !== undefined) {
      obj.token = Token.toJSON(message.token);
    }
    if (message.keypointLocations?.length) {
      obj.keypointLocations = message.keypointLocations.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegionInfo>, I>>(base?: I): RegionInfo {
    return RegionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegionInfo>, I>>(object: I): RegionInfo {
    const message = createBaseRegionInfo();
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingBox.fromPartial(object.boundingBox)
      : undefined;
    message.mask = (object.mask !== undefined && object.mask !== null) ? Mask.fromPartial(object.mask) : undefined;
    message.polygon = (object.polygon !== undefined && object.polygon !== null)
      ? Polygon.fromPartial(object.polygon)
      : undefined;
    message.point = (object.point !== undefined && object.point !== null) ? Point.fromPartial(object.point) : undefined;
    message.span = (object.span !== undefined && object.span !== null) ? Span.fromPartial(object.span) : undefined;
    message.token = (object.token !== undefined && object.token !== null) ? Token.fromPartial(object.token) : undefined;
    message.keypointLocations = object.keypointLocations?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoundingBox(): BoundingBox {
  return { topRow: 0, leftCol: 0, bottomRow: 0, rightCol: 0 };
}

export const BoundingBox: MessageFns<BoundingBox> = {
  encode(message: BoundingBox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topRow !== 0) {
      writer.uint32(13).float(message.topRow);
    }
    if (message.leftCol !== 0) {
      writer.uint32(21).float(message.leftCol);
    }
    if (message.bottomRow !== 0) {
      writer.uint32(29).float(message.bottomRow);
    }
    if (message.rightCol !== 0) {
      writer.uint32(37).float(message.rightCol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.topRow = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.leftCol = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.bottomRow = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.rightCol = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoundingBox {
    return {
      topRow: isSet(object.topRow) ? globalThis.Number(object.topRow) : 0,
      leftCol: isSet(object.leftCol) ? globalThis.Number(object.leftCol) : 0,
      bottomRow: isSet(object.bottomRow) ? globalThis.Number(object.bottomRow) : 0,
      rightCol: isSet(object.rightCol) ? globalThis.Number(object.rightCol) : 0,
    };
  },

  toJSON(message: BoundingBox): unknown {
    const obj: any = {};
    if (message.topRow !== 0) {
      obj.topRow = message.topRow;
    }
    if (message.leftCol !== 0) {
      obj.leftCol = message.leftCol;
    }
    if (message.bottomRow !== 0) {
      obj.bottomRow = message.bottomRow;
    }
    if (message.rightCol !== 0) {
      obj.rightCol = message.rightCol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoundingBox>, I>>(base?: I): BoundingBox {
    return BoundingBox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoundingBox>, I>>(object: I): BoundingBox {
    const message = createBaseBoundingBox();
    message.topRow = object.topRow ?? 0;
    message.leftCol = object.leftCol ?? 0;
    message.bottomRow = object.bottomRow ?? 0;
    message.rightCol = object.rightCol ?? 0;
    return message;
  },
};

function createBaseFrameInfo(): FrameInfo {
  return { index: 0, time: 0 };
}

export const FrameInfo: MessageFns<FrameInfo> = {
  encode(message: FrameInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.time !== 0) {
      writer.uint32(16).uint32(message.time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrameInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrameInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrameInfo {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
    };
  },

  toJSON(message: FrameInfo): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FrameInfo>, I>>(base?: I): FrameInfo {
    return FrameInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FrameInfo>, I>>(object: I): FrameInfo {
    const message = createBaseFrameInfo();
    message.index = object.index ?? 0;
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseFrame(): Frame {
  return { frameInfo: undefined, data: undefined, id: "" };
}

export const Frame: MessageFns<Frame> = {
  encode(message: Frame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frameInfo !== undefined) {
      FrameInfo.encode(message.frameInfo, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.frameInfo = FrameInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frame {
    return {
      frameInfo: isSet(object.frameInfo) ? FrameInfo.fromJSON(object.frameInfo) : undefined,
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: Frame): unknown {
    const obj: any = {};
    if (message.frameInfo !== undefined) {
      obj.frameInfo = FrameInfo.toJSON(message.frameInfo);
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Frame>, I>>(base?: I): Frame {
    return Frame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Frame>, I>>(object: I): Frame {
    const message = createBaseFrame();
    message.frameInfo = (object.frameInfo !== undefined && object.frameInfo !== null)
      ? FrameInfo.fromPartial(object.frameInfo)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNDArray(): NDArray {
  return { buffer: new Uint8Array(0), shape: [], dtype: "" };
}

export const NDArray: MessageFns<NDArray> = {
  encode(message: NDArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buffer.length !== 0) {
      writer.uint32(10).bytes(message.buffer);
    }
    writer.uint32(18).fork();
    for (const v of message.shape) {
      writer.uint32(v);
    }
    writer.join();
    if (message.dtype !== "") {
      writer.uint32(26).string(message.dtype);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NDArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNDArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buffer = reader.bytes();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.shape.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.shape.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dtype = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NDArray {
    return {
      buffer: isSet(object.buffer) ? bytesFromBase64(object.buffer) : new Uint8Array(0),
      shape: globalThis.Array.isArray(object?.shape) ? object.shape.map((e: any) => globalThis.Number(e)) : [],
      dtype: isSet(object.dtype) ? globalThis.String(object.dtype) : "",
    };
  },

  toJSON(message: NDArray): unknown {
    const obj: any = {};
    if (message.buffer.length !== 0) {
      obj.buffer = base64FromBytes(message.buffer);
    }
    if (message.shape?.length) {
      obj.shape = message.shape.map((e) => Math.round(e));
    }
    if (message.dtype !== "") {
      obj.dtype = message.dtype;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NDArray>, I>>(base?: I): NDArray {
    return NDArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NDArray>, I>>(object: I): NDArray {
    const message = createBaseNDArray();
    message.buffer = object.buffer ?? new Uint8Array(0);
    message.shape = object.shape?.map((e) => e) || [];
    message.dtype = object.dtype ?? "";
    return message;
  },
};

function createBaseMask(): Mask {
  return { image: undefined };
}

export const Mask: MessageFns<Mask> = {
  encode(message: Mask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mask {
    return { image: isSet(object.image) ? Image.fromJSON(object.image) : undefined };
  },

  toJSON(message: Mask): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mask>, I>>(base?: I): Mask {
    return Mask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mask>, I>>(object: I): Mask {
    const message = createBaseMask();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBasePolygon(): Polygon {
  return { points: [] };
}

export const Polygon: MessageFns<Polygon> = {
  encode(message: Polygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Polygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Polygon {
    return { points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [] };
  },

  toJSON(message: Polygon): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Polygon>, I>>(base?: I): Polygon {
    return Polygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Polygon>, I>>(object: I): Polygon {
    const message = createBasePolygon();
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBasePoint(): Point {
  return { row: 0, col: 0, z: 0, visibility: 0 };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== 0) {
      writer.uint32(13).float(message.row);
    }
    if (message.col !== 0) {
      writer.uint32(21).float(message.col);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.visibility !== 0) {
      writer.uint32(32).int32(message.visibility);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.row = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.col = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visibility = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      row: isSet(object.row) ? globalThis.Number(object.row) : 0,
      col: isSet(object.col) ? globalThis.Number(object.col) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      visibility: isSet(object.visibility) ? point_VisibilityFromJSON(object.visibility) : 0,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.row !== 0) {
      obj.row = message.row;
    }
    if (message.col !== 0) {
      obj.col = message.col;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.visibility !== 0) {
      obj.visibility = point_VisibilityToJSON(message.visibility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.row = object.row ?? 0;
    message.col = object.col ?? 0;
    message.z = object.z ?? 0;
    message.visibility = object.visibility ?? 0;
    return message;
  },
};

function createBaseSpan(): Span {
  return { charStart: 0, charEnd: 0, rawText: "" };
}

export const Span: MessageFns<Span> = {
  encode(message: Span, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.charStart !== 0) {
      writer.uint32(8).uint32(message.charStart);
    }
    if (message.charEnd !== 0) {
      writer.uint32(16).uint32(message.charEnd);
    }
    if (message.rawText !== "") {
      writer.uint32(26).string(message.rawText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.charStart = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.charEnd = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span {
    return {
      charStart: isSet(object.charStart) ? globalThis.Number(object.charStart) : 0,
      charEnd: isSet(object.charEnd) ? globalThis.Number(object.charEnd) : 0,
      rawText: isSet(object.rawText) ? globalThis.String(object.rawText) : "",
    };
  },

  toJSON(message: Span): unknown {
    const obj: any = {};
    if (message.charStart !== 0) {
      obj.charStart = Math.round(message.charStart);
    }
    if (message.charEnd !== 0) {
      obj.charEnd = Math.round(message.charEnd);
    }
    if (message.rawText !== "") {
      obj.rawText = message.rawText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Span>, I>>(base?: I): Span {
    return Span.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Span>, I>>(object: I): Span {
    const message = createBaseSpan();
    message.charStart = object.charStart ?? 0;
    message.charEnd = object.charEnd ?? 0;
    message.rawText = object.rawText ?? "";
    return message;
  },
};

function createBaseToken(): Token {
  return { charStart: 0, charEnd: 0, rawText: "" };
}

export const Token: MessageFns<Token> = {
  encode(message: Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.charStart !== 0) {
      writer.uint32(8).uint32(message.charStart);
    }
    if (message.charEnd !== 0) {
      writer.uint32(16).uint32(message.charEnd);
    }
    if (message.rawText !== "") {
      writer.uint32(26).string(message.rawText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.charStart = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.charEnd = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Token {
    return {
      charStart: isSet(object.charStart) ? globalThis.Number(object.charStart) : 0,
      charEnd: isSet(object.charEnd) ? globalThis.Number(object.charEnd) : 0,
      rawText: isSet(object.rawText) ? globalThis.String(object.rawText) : "",
    };
  },

  toJSON(message: Token): unknown {
    const obj: any = {};
    if (message.charStart !== 0) {
      obj.charStart = Math.round(message.charStart);
    }
    if (message.charEnd !== 0) {
      obj.charEnd = Math.round(message.charEnd);
    }
    if (message.rawText !== "") {
      obj.rawText = message.rawText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
    return Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
    const message = createBaseToken();
    message.charStart = object.charStart ?? 0;
    message.charEnd = object.charEnd ?? 0;
    message.rawText = object.rawText ?? "";
    return message;
  },
};

function createBaseEmbedding(): Embedding {
  return { vector: [], numDimensions: 0 };
}

export const Embedding: MessageFns<Embedding> = {
  encode(message: Embedding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    if (message.numDimensions !== 0) {
      writer.uint32(16).uint32(message.numDimensions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Embedding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbedding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numDimensions = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Embedding {
    return {
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      numDimensions: isSet(object.numDimensions) ? globalThis.Number(object.numDimensions) : 0,
    };
  },

  toJSON(message: Embedding): unknown {
    const obj: any = {};
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.numDimensions !== 0) {
      obj.numDimensions = Math.round(message.numDimensions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Embedding>, I>>(base?: I): Embedding {
    return Embedding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Embedding>, I>>(object: I): Embedding {
    const message = createBaseEmbedding();
    message.vector = object.vector?.map((e) => e) || [];
    message.numDimensions = object.numDimensions ?? 0;
    return message;
  },
};

function createBaseGeoPoint(): GeoPoint {
  return { longitude: 0, latitude: 0 };
}

export const GeoPoint: MessageFns<GeoPoint> = {
  encode(message: GeoPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longitude !== 0) {
      writer.uint32(13).float(message.longitude);
    }
    if (message.latitude !== 0) {
      writer.uint32(21).float(message.latitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.longitude = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.latitude = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoPoint {
    return {
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
    };
  },

  toJSON(message: GeoPoint): unknown {
    const obj: any = {};
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoPoint>, I>>(base?: I): GeoPoint {
    return GeoPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoPoint>, I>>(object: I): GeoPoint {
    const message = createBaseGeoPoint();
    message.longitude = object.longitude ?? 0;
    message.latitude = object.latitude ?? 0;
    return message;
  },
};

function createBaseGeoLimit(): GeoLimit {
  return { type: "", value: 0 };
}

export const GeoLimit: MessageFns<GeoLimit> = {
  encode(message: GeoLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoLimit {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GeoLimit): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoLimit>, I>>(base?: I): GeoLimit {
    return GeoLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoLimit>, I>>(object: I): GeoLimit {
    const message = createBaseGeoLimit();
    message.type = object.type ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGeoBoxedPoint(): GeoBoxedPoint {
  return { geoPoint: undefined };
}

export const GeoBoxedPoint: MessageFns<GeoBoxedPoint> = {
  encode(message: GeoBoxedPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geoPoint !== undefined) {
      GeoPoint.encode(message.geoPoint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoBoxedPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoBoxedPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geoPoint = GeoPoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoBoxedPoint {
    return { geoPoint: isSet(object.geoPoint) ? GeoPoint.fromJSON(object.geoPoint) : undefined };
  },

  toJSON(message: GeoBoxedPoint): unknown {
    const obj: any = {};
    if (message.geoPoint !== undefined) {
      obj.geoPoint = GeoPoint.toJSON(message.geoPoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoBoxedPoint>, I>>(base?: I): GeoBoxedPoint {
    return GeoBoxedPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoBoxedPoint>, I>>(object: I): GeoBoxedPoint {
    const message = createBaseGeoBoxedPoint();
    message.geoPoint = (object.geoPoint !== undefined && object.geoPoint !== null)
      ? GeoPoint.fromPartial(object.geoPoint)
      : undefined;
    return message;
  },
};

function createBaseGeo(): Geo {
  return { geoPoint: undefined, geoLimit: undefined, geoBox: [] };
}

export const Geo: MessageFns<Geo> = {
  encode(message: Geo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geoPoint !== undefined) {
      GeoPoint.encode(message.geoPoint, writer.uint32(10).fork()).join();
    }
    if (message.geoLimit !== undefined) {
      GeoLimit.encode(message.geoLimit, writer.uint32(18).fork()).join();
    }
    for (const v of message.geoBox) {
      GeoBoxedPoint.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Geo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geoPoint = GeoPoint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.geoLimit = GeoLimit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.geoBox.push(GeoBoxedPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Geo {
    return {
      geoPoint: isSet(object.geoPoint) ? GeoPoint.fromJSON(object.geoPoint) : undefined,
      geoLimit: isSet(object.geoLimit) ? GeoLimit.fromJSON(object.geoLimit) : undefined,
      geoBox: globalThis.Array.isArray(object?.geoBox) ? object.geoBox.map((e: any) => GeoBoxedPoint.fromJSON(e)) : [],
    };
  },

  toJSON(message: Geo): unknown {
    const obj: any = {};
    if (message.geoPoint !== undefined) {
      obj.geoPoint = GeoPoint.toJSON(message.geoPoint);
    }
    if (message.geoLimit !== undefined) {
      obj.geoLimit = GeoLimit.toJSON(message.geoLimit);
    }
    if (message.geoBox?.length) {
      obj.geoBox = message.geoBox.map((e) => GeoBoxedPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Geo>, I>>(base?: I): Geo {
    return Geo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Geo>, I>>(object: I): Geo {
    const message = createBaseGeo();
    message.geoPoint = (object.geoPoint !== undefined && object.geoPoint !== null)
      ? GeoPoint.fromPartial(object.geoPoint)
      : undefined;
    message.geoLimit = (object.geoLimit !== undefined && object.geoLimit !== null)
      ? GeoLimit.fromPartial(object.geoLimit)
      : undefined;
    message.geoBox = object.geoBox?.map((e) => GeoBoxedPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseImage(): Image {
  return {
    url: "",
    base64: new Uint8Array(0),
    allowDuplicateUrl: false,
    hosted: undefined,
    imageInfo: undefined,
    hostedImageInfo: {},
    decodedBytes: new Uint8Array(0),
  };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.base64.length !== 0) {
      writer.uint32(18).bytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      writer.uint32(32).bool(message.allowDuplicateUrl);
    }
    if (message.hosted !== undefined) {
      HostedURL.encode(message.hosted, writer.uint32(42).fork()).join();
    }
    if (message.imageInfo !== undefined) {
      ImageInfo.encode(message.imageInfo, writer.uint32(50).fork()).join();
    }
    Object.entries(message.hostedImageInfo).forEach(([key, value]) => {
      Image_HostedImageInfoEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.decodedBytes.length !== 0) {
      writer.uint32(66).bytes(message.decodedBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64 = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowDuplicateUrl = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hosted = HostedURL.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageInfo = ImageInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Image_HostedImageInfoEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.hostedImageInfo[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.decodedBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      base64: isSet(object.base64) ? bytesFromBase64(object.base64) : new Uint8Array(0),
      allowDuplicateUrl: isSet(object.allowDuplicateUrl) ? globalThis.Boolean(object.allowDuplicateUrl) : false,
      hosted: isSet(object.hosted) ? HostedURL.fromJSON(object.hosted) : undefined,
      imageInfo: isSet(object.imageInfo) ? ImageInfo.fromJSON(object.imageInfo) : undefined,
      hostedImageInfo: isObject(object.hostedImageInfo)
        ? Object.entries(object.hostedImageInfo).reduce<{ [key: string]: ImageInfo }>((acc, [key, value]) => {
          acc[key] = ImageInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      decodedBytes: isSet(object.decodedBytes) ? bytesFromBase64(object.decodedBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.base64.length !== 0) {
      obj.base64 = base64FromBytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      obj.allowDuplicateUrl = message.allowDuplicateUrl;
    }
    if (message.hosted !== undefined) {
      obj.hosted = HostedURL.toJSON(message.hosted);
    }
    if (message.imageInfo !== undefined) {
      obj.imageInfo = ImageInfo.toJSON(message.imageInfo);
    }
    if (message.hostedImageInfo) {
      const entries = Object.entries(message.hostedImageInfo);
      if (entries.length > 0) {
        obj.hostedImageInfo = {};
        entries.forEach(([k, v]) => {
          obj.hostedImageInfo[k] = ImageInfo.toJSON(v);
        });
      }
    }
    if (message.decodedBytes.length !== 0) {
      obj.decodedBytes = base64FromBytes(message.decodedBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Image>, I>>(base?: I): Image {
    return Image.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image>, I>>(object: I): Image {
    const message = createBaseImage();
    message.url = object.url ?? "";
    message.base64 = object.base64 ?? new Uint8Array(0);
    message.allowDuplicateUrl = object.allowDuplicateUrl ?? false;
    message.hosted = (object.hosted !== undefined && object.hosted !== null)
      ? HostedURL.fromPartial(object.hosted)
      : undefined;
    message.imageInfo = (object.imageInfo !== undefined && object.imageInfo !== null)
      ? ImageInfo.fromPartial(object.imageInfo)
      : undefined;
    message.hostedImageInfo = Object.entries(object.hostedImageInfo ?? {}).reduce<{ [key: string]: ImageInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ImageInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.decodedBytes = object.decodedBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseImage_HostedImageInfoEntry(): Image_HostedImageInfoEntry {
  return { key: "", value: undefined };
}

export const Image_HostedImageInfoEntry: MessageFns<Image_HostedImageInfoEntry> = {
  encode(message: Image_HostedImageInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ImageInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image_HostedImageInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage_HostedImageInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ImageInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image_HostedImageInfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ImageInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Image_HostedImageInfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ImageInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Image_HostedImageInfoEntry>, I>>(base?: I): Image_HostedImageInfoEntry {
    return Image_HostedImageInfoEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image_HostedImageInfoEntry>, I>>(object: I): Image_HostedImageInfoEntry {
    const message = createBaseImage_HostedImageInfoEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ImageInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseImageInfo(): ImageInfo {
  return { width: 0, height: 0, format: "", colorMode: "", mode: "" };
}

export const ImageInfo: MessageFns<ImageInfo> = {
  encode(message: ImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.colorMode !== "") {
      writer.uint32(34).string(message.colorMode);
    }
    if (message.mode !== "") {
      writer.uint32(42).string(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.colorMode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageInfo {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      colorMode: isSet(object.colorMode) ? globalThis.String(object.colorMode) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
    };
  },

  toJSON(message: ImageInfo): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.colorMode !== "") {
      obj.colorMode = message.colorMode;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageInfo>, I>>(base?: I): ImageInfo {
    return ImageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageInfo>, I>>(object: I): ImageInfo {
    const message = createBaseImageInfo();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.format = object.format ?? "";
    message.colorMode = object.colorMode ?? "";
    message.mode = object.mode ?? "";
    return message;
  },
};

function createBaseHostedURL(): HostedURL {
  return { prefix: "", suffix: "", sizes: [], crossorigin: "" };
}

export const HostedURL: MessageFns<HostedURL> = {
  encode(message: HostedURL, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefix !== "") {
      writer.uint32(10).string(message.prefix);
    }
    if (message.suffix !== "") {
      writer.uint32(18).string(message.suffix);
    }
    for (const v of message.sizes) {
      writer.uint32(26).string(v!);
    }
    if (message.crossorigin !== "") {
      writer.uint32(34).string(message.crossorigin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostedURL {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostedURL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.suffix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sizes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.crossorigin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostedURL {
    return {
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      suffix: isSet(object.suffix) ? globalThis.String(object.suffix) : "",
      sizes: globalThis.Array.isArray(object?.sizes) ? object.sizes.map((e: any) => globalThis.String(e)) : [],
      crossorigin: isSet(object.crossorigin) ? globalThis.String(object.crossorigin) : "",
    };
  },

  toJSON(message: HostedURL): unknown {
    const obj: any = {};
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.suffix !== "") {
      obj.suffix = message.suffix;
    }
    if (message.sizes?.length) {
      obj.sizes = message.sizes;
    }
    if (message.crossorigin !== "") {
      obj.crossorigin = message.crossorigin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostedURL>, I>>(base?: I): HostedURL {
    return HostedURL.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostedURL>, I>>(object: I): HostedURL {
    const message = createBaseHostedURL();
    message.prefix = object.prefix ?? "";
    message.suffix = object.suffix ?? "";
    message.sizes = object.sizes?.map((e) => e) || [];
    message.crossorigin = object.crossorigin ?? "";
    return message;
  },
};

function createBaseInput(): Input {
  return { id: "", data: undefined, createdAt: undefined, modifiedAt: undefined, status: undefined, datasetIds: [] };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(42).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(50).fork()).join();
    }
    for (const v of message.datasetIds) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.datasetIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      datasetIds: globalThis.Array.isArray(object?.datasetIds)
        ? object.datasetIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Input): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.datasetIds?.length) {
      obj.datasetIds = message.datasetIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Input>, I>>(base?: I): Input {
    return Input.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Input>, I>>(object: I): Input {
    const message = createBaseInput();
    message.id = object.id ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.datasetIds = object.datasetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseInputBatch(): InputBatch {
  return { inputs: [] };
}

export const InputBatch: MessageFns<InputBatch> = {
  encode(message: InputBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputBatch {
    return { inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [] };
  },

  toJSON(message: InputBatch): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputBatch>, I>>(base?: I): InputBatch {
    return InputBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputBatch>, I>>(object: I): InputBatch {
    const message = createBaseInputBatch();
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInputCount(): InputCount {
  return {
    processed: 0,
    toProcess: 0,
    errors: 0,
    processing: 0,
    reindexed: 0,
    toReindex: 0,
    reindexErrors: 0,
    reindexing: 0,
  };
}

export const InputCount: MessageFns<InputCount> = {
  encode(message: InputCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== 0) {
      writer.uint32(8).uint32(message.processed);
    }
    if (message.toProcess !== 0) {
      writer.uint32(16).uint32(message.toProcess);
    }
    if (message.errors !== 0) {
      writer.uint32(24).uint32(message.errors);
    }
    if (message.processing !== 0) {
      writer.uint32(32).uint32(message.processing);
    }
    if (message.reindexed !== 0) {
      writer.uint32(40).uint32(message.reindexed);
    }
    if (message.toReindex !== 0) {
      writer.uint32(48).uint32(message.toReindex);
    }
    if (message.reindexErrors !== 0) {
      writer.uint32(56).uint32(message.reindexErrors);
    }
    if (message.reindexing !== 0) {
      writer.uint32(64).uint32(message.reindexing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processed = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toProcess = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errors = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.processing = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reindexed = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.toReindex = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.reindexErrors = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.reindexing = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputCount {
    return {
      processed: isSet(object.processed) ? globalThis.Number(object.processed) : 0,
      toProcess: isSet(object.toProcess) ? globalThis.Number(object.toProcess) : 0,
      errors: isSet(object.errors) ? globalThis.Number(object.errors) : 0,
      processing: isSet(object.processing) ? globalThis.Number(object.processing) : 0,
      reindexed: isSet(object.reindexed) ? globalThis.Number(object.reindexed) : 0,
      toReindex: isSet(object.toReindex) ? globalThis.Number(object.toReindex) : 0,
      reindexErrors: isSet(object.reindexErrors) ? globalThis.Number(object.reindexErrors) : 0,
      reindexing: isSet(object.reindexing) ? globalThis.Number(object.reindexing) : 0,
    };
  },

  toJSON(message: InputCount): unknown {
    const obj: any = {};
    if (message.processed !== 0) {
      obj.processed = Math.round(message.processed);
    }
    if (message.toProcess !== 0) {
      obj.toProcess = Math.round(message.toProcess);
    }
    if (message.errors !== 0) {
      obj.errors = Math.round(message.errors);
    }
    if (message.processing !== 0) {
      obj.processing = Math.round(message.processing);
    }
    if (message.reindexed !== 0) {
      obj.reindexed = Math.round(message.reindexed);
    }
    if (message.toReindex !== 0) {
      obj.toReindex = Math.round(message.toReindex);
    }
    if (message.reindexErrors !== 0) {
      obj.reindexErrors = Math.round(message.reindexErrors);
    }
    if (message.reindexing !== 0) {
      obj.reindexing = Math.round(message.reindexing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputCount>, I>>(base?: I): InputCount {
    return InputCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputCount>, I>>(object: I): InputCount {
    const message = createBaseInputCount();
    message.processed = object.processed ?? 0;
    message.toProcess = object.toProcess ?? 0;
    message.errors = object.errors ?? 0;
    message.processing = object.processing ?? 0;
    message.reindexed = object.reindexed ?? 0;
    message.toReindex = object.toReindex ?? 0;
    message.reindexErrors = object.reindexErrors ?? 0;
    message.reindexing = object.reindexing ?? 0;
    return message;
  },
};

function createBaseDataset(): Dataset {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    appId: "",
    userId: "",
    description: "",
    metadata: undefined,
    visibility: undefined,
    defaultAnnotationFilter: undefined,
    defaultProcessingInfo: undefined,
    notes: "",
    version: undefined,
    isStarred: false,
    starCount: 0,
    bookmarkOrigin: undefined,
    image: undefined,
  };
}

export const Dataset: MessageFns<Dataset> = {
  encode(message: Dataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(74).fork()).join();
    }
    if (message.defaultAnnotationFilter !== undefined) {
      AnnotationFilter.encode(message.defaultAnnotationFilter, writer.uint32(98).fork()).join();
    }
    if (message.defaultProcessingInfo !== undefined) {
      DatasetVersionProcessingInfo.encode(message.defaultProcessingInfo, writer.uint32(130).fork()).join();
    }
    if (message.notes !== "") {
      writer.uint32(90).string(message.notes);
    }
    if (message.version !== undefined) {
      DatasetVersion.encode(message.version, writer.uint32(106).fork()).join();
    }
    if (message.isStarred !== false) {
      writer.uint32(112).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(120).int32(message.starCount);
    }
    if (message.bookmarkOrigin !== undefined) {
      BookmarkOrigin.encode(message.bookmarkOrigin, writer.uint32(138).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.defaultAnnotationFilter = AnnotationFilter.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.defaultProcessingInfo = DatasetVersionProcessingInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.version = DatasetVersion.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bookmarkOrigin = BookmarkOrigin.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dataset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      defaultAnnotationFilter: isSet(object.defaultAnnotationFilter)
        ? AnnotationFilter.fromJSON(object.defaultAnnotationFilter)
        : undefined,
      defaultProcessingInfo: isSet(object.defaultProcessingInfo)
        ? DatasetVersionProcessingInfo.fromJSON(object.defaultProcessingInfo)
        : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      version: isSet(object.version) ? DatasetVersion.fromJSON(object.version) : undefined,
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      bookmarkOrigin: isSet(object.bookmarkOrigin) ? BookmarkOrigin.fromJSON(object.bookmarkOrigin) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: Dataset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.defaultAnnotationFilter !== undefined) {
      obj.defaultAnnotationFilter = AnnotationFilter.toJSON(message.defaultAnnotationFilter);
    }
    if (message.defaultProcessingInfo !== undefined) {
      obj.defaultProcessingInfo = DatasetVersionProcessingInfo.toJSON(message.defaultProcessingInfo);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.version !== undefined) {
      obj.version = DatasetVersion.toJSON(message.version);
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.bookmarkOrigin !== undefined) {
      obj.bookmarkOrigin = BookmarkOrigin.toJSON(message.bookmarkOrigin);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dataset>, I>>(base?: I): Dataset {
    return Dataset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dataset>, I>>(object: I): Dataset {
    const message = createBaseDataset();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.description = object.description ?? "";
    message.metadata = object.metadata ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.defaultAnnotationFilter =
      (object.defaultAnnotationFilter !== undefined && object.defaultAnnotationFilter !== null)
        ? AnnotationFilter.fromPartial(object.defaultAnnotationFilter)
        : undefined;
    message.defaultProcessingInfo =
      (object.defaultProcessingInfo !== undefined && object.defaultProcessingInfo !== null)
        ? DatasetVersionProcessingInfo.fromPartial(object.defaultProcessingInfo)
        : undefined;
    message.notes = object.notes ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? DatasetVersion.fromPartial(object.version)
      : undefined;
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.bookmarkOrigin = (object.bookmarkOrigin !== undefined && object.bookmarkOrigin !== null)
      ? BookmarkOrigin.fromPartial(object.bookmarkOrigin)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseAnnotationFilter(): AnnotationFilter {
  return { id: "", createdAt: undefined, modifiedAt: undefined, userId: "", appId: "", search: undefined };
}

export const AnnotationFilter: MessageFns<AnnotationFilter> = {
  encode(message: AnnotationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    if (message.search !== undefined) {
      Search.encode(message.search, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.search = Search.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationFilter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      search: isSet(object.search) ? Search.fromJSON(object.search) : undefined,
    };
  },

  toJSON(message: AnnotationFilter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.search !== undefined) {
      obj.search = Search.toJSON(message.search);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotationFilter>, I>>(base?: I): AnnotationFilter {
    return AnnotationFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotationFilter>, I>>(object: I): AnnotationFilter {
    const message = createBaseAnnotationFilter();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.search = (object.search !== undefined && object.search !== null)
      ? Search.fromPartial(object.search)
      : undefined;
    return message;
  },
};

function createBaseDatasetInput(): DatasetInput {
  return { createdAt: undefined, input: undefined };
}

export const DatasetInput: MessageFns<DatasetInput> = {
  encode(message: DatasetInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(10).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetInput {
    return {
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: DatasetInput): unknown {
    const obj: any = {};
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetInput>, I>>(base?: I): DatasetInput {
    return DatasetInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetInput>, I>>(object: I): DatasetInput {
    const message = createBaseDatasetInput();
    message.createdAt = object.createdAt ?? undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    return message;
  },
};

function createBaseDatasetVersion(): DatasetVersion {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    appId: "",
    userId: "",
    datasetId: "",
    annotationFilterConfig: undefined,
    modelPredictConfig: undefined,
    status: undefined,
    description: "",
    processingInfo: undefined,
    metrics: {},
    exportInfo: undefined,
    metadata: undefined,
    visibility: undefined,
    embedModelVersionIds: [],
    requestOrigin: 0,
  };
}

export const DatasetVersion: MessageFns<DatasetVersion> = {
  encode(message: DatasetVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.datasetId !== "") {
      writer.uint32(50).string(message.datasetId);
    }
    if (message.annotationFilterConfig !== undefined) {
      AnnotationFilterConfig.encode(message.annotationFilterConfig, writer.uint32(122).fork()).join();
    }
    if (message.modelPredictConfig !== undefined) {
      ModelPredictConfig.encode(message.modelPredictConfig, writer.uint32(146).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.processingInfo !== undefined) {
      DatasetVersionProcessingInfo.encode(message.processingInfo, writer.uint32(154).fork()).join();
    }
    Object.entries(message.metrics).forEach(([key, value]) => {
      DatasetVersion_MetricsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.exportInfo !== undefined) {
      DatasetVersionExportInfo.encode(message.exportInfo, writer.uint32(138).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(98).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(106).fork()).join();
    }
    for (const v of message.embedModelVersionIds) {
      writer.uint32(114).string(v!);
    }
    if (message.requestOrigin !== 0) {
      writer.uint32(160).int32(message.requestOrigin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.annotationFilterConfig = AnnotationFilterConfig.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.modelPredictConfig = ModelPredictConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.processingInfo = DatasetVersionProcessingInfo.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = DatasetVersion_MetricsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.metrics[entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.exportInfo = DatasetVersionExportInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.embedModelVersionIds.push(reader.string());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.requestOrigin = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      annotationFilterConfig: isSet(object.annotationFilterConfig)
        ? AnnotationFilterConfig.fromJSON(object.annotationFilterConfig)
        : undefined,
      modelPredictConfig: isSet(object.modelPredictConfig)
        ? ModelPredictConfig.fromJSON(object.modelPredictConfig)
        : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      processingInfo: isSet(object.processingInfo)
        ? DatasetVersionProcessingInfo.fromJSON(object.processingInfo)
        : undefined,
      metrics: isObject(object.metrics)
        ? Object.entries(object.metrics).reduce<{ [key: string]: DatasetVersionMetrics }>((acc, [key, value]) => {
          acc[key] = DatasetVersionMetrics.fromJSON(value);
          return acc;
        }, {})
        : {},
      exportInfo: isSet(object.exportInfo) ? DatasetVersionExportInfo.fromJSON(object.exportInfo) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      embedModelVersionIds: globalThis.Array.isArray(object?.embedModelVersionIds)
        ? object.embedModelVersionIds.map((e: any) => globalThis.String(e))
        : [],
      requestOrigin: isSet(object.requestOrigin) ? datasetVersionRequestOriginFromJSON(object.requestOrigin) : 0,
    };
  },

  toJSON(message: DatasetVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.annotationFilterConfig !== undefined) {
      obj.annotationFilterConfig = AnnotationFilterConfig.toJSON(message.annotationFilterConfig);
    }
    if (message.modelPredictConfig !== undefined) {
      obj.modelPredictConfig = ModelPredictConfig.toJSON(message.modelPredictConfig);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.processingInfo !== undefined) {
      obj.processingInfo = DatasetVersionProcessingInfo.toJSON(message.processingInfo);
    }
    if (message.metrics) {
      const entries = Object.entries(message.metrics);
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = DatasetVersionMetrics.toJSON(v);
        });
      }
    }
    if (message.exportInfo !== undefined) {
      obj.exportInfo = DatasetVersionExportInfo.toJSON(message.exportInfo);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.embedModelVersionIds?.length) {
      obj.embedModelVersionIds = message.embedModelVersionIds;
    }
    if (message.requestOrigin !== 0) {
      obj.requestOrigin = datasetVersionRequestOriginToJSON(message.requestOrigin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersion>, I>>(base?: I): DatasetVersion {
    return DatasetVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersion>, I>>(object: I): DatasetVersion {
    const message = createBaseDatasetVersion();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.annotationFilterConfig =
      (object.annotationFilterConfig !== undefined && object.annotationFilterConfig !== null)
        ? AnnotationFilterConfig.fromPartial(object.annotationFilterConfig)
        : undefined;
    message.modelPredictConfig = (object.modelPredictConfig !== undefined && object.modelPredictConfig !== null)
      ? ModelPredictConfig.fromPartial(object.modelPredictConfig)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.description = object.description ?? "";
    message.processingInfo = (object.processingInfo !== undefined && object.processingInfo !== null)
      ? DatasetVersionProcessingInfo.fromPartial(object.processingInfo)
      : undefined;
    message.metrics = Object.entries(object.metrics ?? {}).reduce<{ [key: string]: DatasetVersionMetrics }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DatasetVersionMetrics.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.exportInfo = (object.exportInfo !== undefined && object.exportInfo !== null)
      ? DatasetVersionExportInfo.fromPartial(object.exportInfo)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.embedModelVersionIds = object.embedModelVersionIds?.map((e) => e) || [];
    message.requestOrigin = object.requestOrigin ?? 0;
    return message;
  },
};

function createBaseDatasetVersion_MetricsEntry(): DatasetVersion_MetricsEntry {
  return { key: "", value: undefined };
}

export const DatasetVersion_MetricsEntry: MessageFns<DatasetVersion_MetricsEntry> = {
  encode(message: DatasetVersion_MetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DatasetVersionMetrics.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersion_MetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersion_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DatasetVersionMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersion_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DatasetVersionMetrics.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DatasetVersion_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DatasetVersionMetrics.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersion_MetricsEntry>, I>>(base?: I): DatasetVersion_MetricsEntry {
    return DatasetVersion_MetricsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersion_MetricsEntry>, I>>(object: I): DatasetVersion_MetricsEntry {
    const message = createBaseDatasetVersion_MetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DatasetVersionMetrics.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnnotationFilterConfig(): AnnotationFilterConfig {
  return { annotationFilter: undefined, ignoreEmptyInputs: false };
}

export const AnnotationFilterConfig: MessageFns<AnnotationFilterConfig> = {
  encode(message: AnnotationFilterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationFilter !== undefined) {
      AnnotationFilter.encode(message.annotationFilter, writer.uint32(10).fork()).join();
    }
    if (message.ignoreEmptyInputs !== false) {
      writer.uint32(16).bool(message.ignoreEmptyInputs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationFilterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationFilterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.annotationFilter = AnnotationFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ignoreEmptyInputs = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationFilterConfig {
    return {
      annotationFilter: isSet(object.annotationFilter) ? AnnotationFilter.fromJSON(object.annotationFilter) : undefined,
      ignoreEmptyInputs: isSet(object.ignoreEmptyInputs) ? globalThis.Boolean(object.ignoreEmptyInputs) : false,
    };
  },

  toJSON(message: AnnotationFilterConfig): unknown {
    const obj: any = {};
    if (message.annotationFilter !== undefined) {
      obj.annotationFilter = AnnotationFilter.toJSON(message.annotationFilter);
    }
    if (message.ignoreEmptyInputs !== false) {
      obj.ignoreEmptyInputs = message.ignoreEmptyInputs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotationFilterConfig>, I>>(base?: I): AnnotationFilterConfig {
    return AnnotationFilterConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotationFilterConfig>, I>>(object: I): AnnotationFilterConfig {
    const message = createBaseAnnotationFilterConfig();
    message.annotationFilter = (object.annotationFilter !== undefined && object.annotationFilter !== null)
      ? AnnotationFilter.fromPartial(object.annotationFilter)
      : undefined;
    message.ignoreEmptyInputs = object.ignoreEmptyInputs ?? false;
    return message;
  },
};

function createBaseModelPredictConfig(): ModelPredictConfig {
  return { model: undefined };
}

export const ModelPredictConfig: MessageFns<ModelPredictConfig> = {
  encode(message: ModelPredictConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelPredictConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelPredictConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelPredictConfig {
    return { model: isSet(object.model) ? Model.fromJSON(object.model) : undefined };
  },

  toJSON(message: ModelPredictConfig): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelPredictConfig>, I>>(base?: I): ModelPredictConfig {
    return ModelPredictConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelPredictConfig>, I>>(object: I): ModelPredictConfig {
    const message = createBaseModelPredictConfig();
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseDatasetVersionMetrics(): DatasetVersionMetrics {
  return {
    inputsCount: undefined,
    unlabeledInputsCount: undefined,
    inputsWithMetadataCount: undefined,
    inputsWithGeoCount: undefined,
    regionsCount: undefined,
    regionLocationMatrix: undefined,
    boundingBoxesCount: undefined,
    polygonsCount: undefined,
    pointsCount: undefined,
    masksCount: undefined,
    regionInputsCount: undefined,
    regionFramesCount: undefined,
    framesCount: undefined,
    frameInputsCount: undefined,
    embeddingsCount: undefined,
    positiveInputTagsCount: undefined,
    positiveRegionTagsCount: undefined,
    positiveFrameTagsCount: undefined,
  };
}

export const DatasetVersionMetrics: MessageFns<DatasetVersionMetrics> = {
  encode(message: DatasetVersionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsCount !== undefined) {
      UInt64Value.encode({ value: message.inputsCount! }, writer.uint32(10).fork()).join();
    }
    if (message.unlabeledInputsCount !== undefined) {
      UInt64Value.encode({ value: message.unlabeledInputsCount! }, writer.uint32(50).fork()).join();
    }
    if (message.inputsWithMetadataCount !== undefined) {
      UInt64Value.encode({ value: message.inputsWithMetadataCount! }, writer.uint32(66).fork()).join();
    }
    if (message.inputsWithGeoCount !== undefined) {
      UInt64Value.encode({ value: message.inputsWithGeoCount! }, writer.uint32(74).fork()).join();
    }
    if (message.regionsCount !== undefined) {
      UInt64Value.encode({ value: message.regionsCount! }, writer.uint32(162).fork()).join();
    }
    if (message.regionLocationMatrix !== undefined) {
      MatrixUint64.encode(message.regionLocationMatrix, writer.uint32(170).fork()).join();
    }
    if (message.boundingBoxesCount !== undefined) {
      UInt64Value.encode({ value: message.boundingBoxesCount! }, writer.uint32(178).fork()).join();
    }
    if (message.polygonsCount !== undefined) {
      UInt64Value.encode({ value: message.polygonsCount! }, writer.uint32(186).fork()).join();
    }
    if (message.pointsCount !== undefined) {
      UInt64Value.encode({ value: message.pointsCount! }, writer.uint32(194).fork()).join();
    }
    if (message.masksCount !== undefined) {
      UInt64Value.encode({ value: message.masksCount! }, writer.uint32(202).fork()).join();
    }
    if (message.regionInputsCount !== undefined) {
      UInt64Value.encode({ value: message.regionInputsCount! }, writer.uint32(482).fork()).join();
    }
    if (message.regionFramesCount !== undefined) {
      UInt64Value.encode({ value: message.regionFramesCount! }, writer.uint32(490).fork()).join();
    }
    if (message.framesCount !== undefined) {
      UInt64Value.encode({ value: message.framesCount! }, writer.uint32(242).fork()).join();
    }
    if (message.frameInputsCount !== undefined) {
      UInt64Value.encode({ value: message.frameInputsCount! }, writer.uint32(562).fork()).join();
    }
    if (message.embeddingsCount !== undefined) {
      UInt64Value.encode({ value: message.embeddingsCount! }, writer.uint32(322).fork()).join();
    }
    if (message.positiveInputTagsCount !== undefined) {
      UInt64Value.encode({ value: message.positiveInputTagsCount! }, writer.uint32(402).fork()).join();
    }
    if (message.positiveRegionTagsCount !== undefined) {
      UInt64Value.encode({ value: message.positiveRegionTagsCount! }, writer.uint32(410).fork()).join();
    }
    if (message.positiveFrameTagsCount !== undefined) {
      UInt64Value.encode({ value: message.positiveFrameTagsCount! }, writer.uint32(418).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unlabeledInputsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputsWithMetadataCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inputsWithGeoCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.regionsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.regionLocationMatrix = MatrixUint64.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.boundingBoxesCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.polygonsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.pointsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.masksCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.regionInputsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.regionFramesCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.framesCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 70: {
          if (tag !== 562) {
            break;
          }

          message.frameInputsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.embeddingsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.positiveInputTagsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.positiveRegionTagsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.positiveFrameTagsCount = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersionMetrics {
    return {
      inputsCount: isSet(object.inputsCount) ? Number(object.inputsCount) : undefined,
      unlabeledInputsCount: isSet(object.unlabeledInputsCount) ? Number(object.unlabeledInputsCount) : undefined,
      inputsWithMetadataCount: isSet(object.inputsWithMetadataCount)
        ? Number(object.inputsWithMetadataCount)
        : undefined,
      inputsWithGeoCount: isSet(object.inputsWithGeoCount) ? Number(object.inputsWithGeoCount) : undefined,
      regionsCount: isSet(object.regionsCount) ? Number(object.regionsCount) : undefined,
      regionLocationMatrix: isSet(object.regionLocationMatrix)
        ? MatrixUint64.fromJSON(object.regionLocationMatrix)
        : undefined,
      boundingBoxesCount: isSet(object.boundingBoxesCount) ? Number(object.boundingBoxesCount) : undefined,
      polygonsCount: isSet(object.polygonsCount) ? Number(object.polygonsCount) : undefined,
      pointsCount: isSet(object.pointsCount) ? Number(object.pointsCount) : undefined,
      masksCount: isSet(object.masksCount) ? Number(object.masksCount) : undefined,
      regionInputsCount: isSet(object.regionInputsCount) ? Number(object.regionInputsCount) : undefined,
      regionFramesCount: isSet(object.regionFramesCount) ? Number(object.regionFramesCount) : undefined,
      framesCount: isSet(object.framesCount) ? Number(object.framesCount) : undefined,
      frameInputsCount: isSet(object.frameInputsCount) ? Number(object.frameInputsCount) : undefined,
      embeddingsCount: isSet(object.embeddingsCount) ? Number(object.embeddingsCount) : undefined,
      positiveInputTagsCount: isSet(object.positiveInputTagsCount) ? Number(object.positiveInputTagsCount) : undefined,
      positiveRegionTagsCount: isSet(object.positiveRegionTagsCount)
        ? Number(object.positiveRegionTagsCount)
        : undefined,
      positiveFrameTagsCount: isSet(object.positiveFrameTagsCount) ? Number(object.positiveFrameTagsCount) : undefined,
    };
  },

  toJSON(message: DatasetVersionMetrics): unknown {
    const obj: any = {};
    if (message.inputsCount !== undefined) {
      obj.inputsCount = message.inputsCount;
    }
    if (message.unlabeledInputsCount !== undefined) {
      obj.unlabeledInputsCount = message.unlabeledInputsCount;
    }
    if (message.inputsWithMetadataCount !== undefined) {
      obj.inputsWithMetadataCount = message.inputsWithMetadataCount;
    }
    if (message.inputsWithGeoCount !== undefined) {
      obj.inputsWithGeoCount = message.inputsWithGeoCount;
    }
    if (message.regionsCount !== undefined) {
      obj.regionsCount = message.regionsCount;
    }
    if (message.regionLocationMatrix !== undefined) {
      obj.regionLocationMatrix = MatrixUint64.toJSON(message.regionLocationMatrix);
    }
    if (message.boundingBoxesCount !== undefined) {
      obj.boundingBoxesCount = message.boundingBoxesCount;
    }
    if (message.polygonsCount !== undefined) {
      obj.polygonsCount = message.polygonsCount;
    }
    if (message.pointsCount !== undefined) {
      obj.pointsCount = message.pointsCount;
    }
    if (message.masksCount !== undefined) {
      obj.masksCount = message.masksCount;
    }
    if (message.regionInputsCount !== undefined) {
      obj.regionInputsCount = message.regionInputsCount;
    }
    if (message.regionFramesCount !== undefined) {
      obj.regionFramesCount = message.regionFramesCount;
    }
    if (message.framesCount !== undefined) {
      obj.framesCount = message.framesCount;
    }
    if (message.frameInputsCount !== undefined) {
      obj.frameInputsCount = message.frameInputsCount;
    }
    if (message.embeddingsCount !== undefined) {
      obj.embeddingsCount = message.embeddingsCount;
    }
    if (message.positiveInputTagsCount !== undefined) {
      obj.positiveInputTagsCount = message.positiveInputTagsCount;
    }
    if (message.positiveRegionTagsCount !== undefined) {
      obj.positiveRegionTagsCount = message.positiveRegionTagsCount;
    }
    if (message.positiveFrameTagsCount !== undefined) {
      obj.positiveFrameTagsCount = message.positiveFrameTagsCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersionMetrics>, I>>(base?: I): DatasetVersionMetrics {
    return DatasetVersionMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersionMetrics>, I>>(object: I): DatasetVersionMetrics {
    const message = createBaseDatasetVersionMetrics();
    message.inputsCount = object.inputsCount ?? undefined;
    message.unlabeledInputsCount = object.unlabeledInputsCount ?? undefined;
    message.inputsWithMetadataCount = object.inputsWithMetadataCount ?? undefined;
    message.inputsWithGeoCount = object.inputsWithGeoCount ?? undefined;
    message.regionsCount = object.regionsCount ?? undefined;
    message.regionLocationMatrix = (object.regionLocationMatrix !== undefined && object.regionLocationMatrix !== null)
      ? MatrixUint64.fromPartial(object.regionLocationMatrix)
      : undefined;
    message.boundingBoxesCount = object.boundingBoxesCount ?? undefined;
    message.polygonsCount = object.polygonsCount ?? undefined;
    message.pointsCount = object.pointsCount ?? undefined;
    message.masksCount = object.masksCount ?? undefined;
    message.regionInputsCount = object.regionInputsCount ?? undefined;
    message.regionFramesCount = object.regionFramesCount ?? undefined;
    message.framesCount = object.framesCount ?? undefined;
    message.frameInputsCount = object.frameInputsCount ?? undefined;
    message.embeddingsCount = object.embeddingsCount ?? undefined;
    message.positiveInputTagsCount = object.positiveInputTagsCount ?? undefined;
    message.positiveRegionTagsCount = object.positiveRegionTagsCount ?? undefined;
    message.positiveFrameTagsCount = object.positiveFrameTagsCount ?? undefined;
    return message;
  },
};

function createBaseDatasetVersionMetricsGroup(): DatasetVersionMetricsGroup {
  return { parentPath: "", type: 0, value: undefined, metrics: undefined };
}

export const DatasetVersionMetricsGroup: MessageFns<DatasetVersionMetricsGroup> = {
  encode(message: DatasetVersionMetricsGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentPath !== "") {
      writer.uint32(10).string(message.parentPath);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    if (message.metrics !== undefined) {
      DatasetVersionMetrics.encode(message.metrics, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersionMetricsGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersionMetricsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metrics = DatasetVersionMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersionMetricsGroup {
    return {
      parentPath: isSet(object.parentPath) ? globalThis.String(object.parentPath) : "",
      type: isSet(object.type) ? datasetVersionMetricsGroupTypeFromJSON(object.type) : 0,
      value: isSet(object?.value) ? object.value : undefined,
      metrics: isSet(object.metrics) ? DatasetVersionMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: DatasetVersionMetricsGroup): unknown {
    const obj: any = {};
    if (message.parentPath !== "") {
      obj.parentPath = message.parentPath;
    }
    if (message.type !== 0) {
      obj.type = datasetVersionMetricsGroupTypeToJSON(message.type);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.metrics !== undefined) {
      obj.metrics = DatasetVersionMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersionMetricsGroup>, I>>(base?: I): DatasetVersionMetricsGroup {
    return DatasetVersionMetricsGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersionMetricsGroup>, I>>(object: I): DatasetVersionMetricsGroup {
    const message = createBaseDatasetVersionMetricsGroup();
    message.parentPath = object.parentPath ?? "";
    message.type = object.type ?? 0;
    message.value = object.value ?? undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? DatasetVersionMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseDatasetVersionExportInfo(): DatasetVersionExportInfo {
  return { clarifaiDataProtobuf: undefined, clarifaiDataJson: undefined, coco: undefined };
}

export const DatasetVersionExportInfo: MessageFns<DatasetVersionExportInfo> = {
  encode(message: DatasetVersionExportInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clarifaiDataProtobuf !== undefined) {
      DatasetVersionExport.encode(message.clarifaiDataProtobuf, writer.uint32(10).fork()).join();
    }
    if (message.clarifaiDataJson !== undefined) {
      DatasetVersionExport.encode(message.clarifaiDataJson, writer.uint32(26).fork()).join();
    }
    if (message.coco !== undefined) {
      DatasetVersionExport.encode(message.coco, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersionExportInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersionExportInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clarifaiDataProtobuf = DatasetVersionExport.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clarifaiDataJson = DatasetVersionExport.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coco = DatasetVersionExport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersionExportInfo {
    return {
      clarifaiDataProtobuf: isSet(object.clarifaiDataProtobuf)
        ? DatasetVersionExport.fromJSON(object.clarifaiDataProtobuf)
        : undefined,
      clarifaiDataJson: isSet(object.clarifaiDataJson)
        ? DatasetVersionExport.fromJSON(object.clarifaiDataJson)
        : undefined,
      coco: isSet(object.coco) ? DatasetVersionExport.fromJSON(object.coco) : undefined,
    };
  },

  toJSON(message: DatasetVersionExportInfo): unknown {
    const obj: any = {};
    if (message.clarifaiDataProtobuf !== undefined) {
      obj.clarifaiDataProtobuf = DatasetVersionExport.toJSON(message.clarifaiDataProtobuf);
    }
    if (message.clarifaiDataJson !== undefined) {
      obj.clarifaiDataJson = DatasetVersionExport.toJSON(message.clarifaiDataJson);
    }
    if (message.coco !== undefined) {
      obj.coco = DatasetVersionExport.toJSON(message.coco);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersionExportInfo>, I>>(base?: I): DatasetVersionExportInfo {
    return DatasetVersionExportInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersionExportInfo>, I>>(object: I): DatasetVersionExportInfo {
    const message = createBaseDatasetVersionExportInfo();
    message.clarifaiDataProtobuf = (object.clarifaiDataProtobuf !== undefined && object.clarifaiDataProtobuf !== null)
      ? DatasetVersionExport.fromPartial(object.clarifaiDataProtobuf)
      : undefined;
    message.clarifaiDataJson = (object.clarifaiDataJson !== undefined && object.clarifaiDataJson !== null)
      ? DatasetVersionExport.fromPartial(object.clarifaiDataJson)
      : undefined;
    message.coco = (object.coco !== undefined && object.coco !== null)
      ? DatasetVersionExport.fromPartial(object.coco)
      : undefined;
    return message;
  },
};

function createBaseDatasetVersionExport(): DatasetVersionExport {
  return { format: 0, status: undefined, url: "", size: 0, includeEmbeddings: false };
}

export const DatasetVersionExport: MessageFns<DatasetVersionExport> = {
  encode(message: DatasetVersionExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.size !== 0) {
      writer.uint32(32).uint64(message.size);
    }
    if (message.includeEmbeddings !== false) {
      writer.uint32(40).bool(message.includeEmbeddings);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersionExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersionExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeEmbeddings = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersionExport {
    return {
      format: isSet(object.format) ? datasetVersionExportFormatFromJSON(object.format) : 0,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      includeEmbeddings: isSet(object.includeEmbeddings) ? globalThis.Boolean(object.includeEmbeddings) : false,
    };
  },

  toJSON(message: DatasetVersionExport): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = datasetVersionExportFormatToJSON(message.format);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.includeEmbeddings !== false) {
      obj.includeEmbeddings = message.includeEmbeddings;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersionExport>, I>>(base?: I): DatasetVersionExport {
    return DatasetVersionExport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersionExport>, I>>(object: I): DatasetVersionExport {
    const message = createBaseDatasetVersionExport();
    message.format = object.format ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.url = object.url ?? "";
    message.size = object.size ?? 0;
    message.includeEmbeddings = object.includeEmbeddings ?? false;
    return message;
  },
};

function createBaseDatasetVersionProcessingInfo(): DatasetVersionProcessingInfo {
  return { frameInterpolationInfo: undefined };
}

export const DatasetVersionProcessingInfo: MessageFns<DatasetVersionProcessingInfo> = {
  encode(message: DatasetVersionProcessingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frameInterpolationInfo !== undefined) {
      FrameInterpolationInfo.encode(message.frameInterpolationInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetVersionProcessingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetVersionProcessingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.frameInterpolationInfo = FrameInterpolationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetVersionProcessingInfo {
    return {
      frameInterpolationInfo: isSet(object.frameInterpolationInfo)
        ? FrameInterpolationInfo.fromJSON(object.frameInterpolationInfo)
        : undefined,
    };
  },

  toJSON(message: DatasetVersionProcessingInfo): unknown {
    const obj: any = {};
    if (message.frameInterpolationInfo !== undefined) {
      obj.frameInterpolationInfo = FrameInterpolationInfo.toJSON(message.frameInterpolationInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetVersionProcessingInfo>, I>>(base?: I): DatasetVersionProcessingInfo {
    return DatasetVersionProcessingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetVersionProcessingInfo>, I>>(object: I): DatasetVersionProcessingInfo {
    const message = createBaseDatasetVersionProcessingInfo();
    message.frameInterpolationInfo =
      (object.frameInterpolationInfo !== undefined && object.frameInterpolationInfo !== null)
        ? FrameInterpolationInfo.fromPartial(object.frameInterpolationInfo)
        : undefined;
    return message;
  },
};

function createBaseFrameInterpolationInfo(): FrameInterpolationInfo {
  return { sampleMs: 0 };
}

export const FrameInterpolationInfo: MessageFns<FrameInterpolationInfo> = {
  encode(message: FrameInterpolationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleMs !== 0) {
      writer.uint32(8).uint32(message.sampleMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrameInterpolationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrameInterpolationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sampleMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrameInterpolationInfo {
    return { sampleMs: isSet(object.sampleMs) ? globalThis.Number(object.sampleMs) : 0 };
  },

  toJSON(message: FrameInterpolationInfo): unknown {
    const obj: any = {};
    if (message.sampleMs !== 0) {
      obj.sampleMs = Math.round(message.sampleMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FrameInterpolationInfo>, I>>(base?: I): FrameInterpolationInfo {
    return FrameInterpolationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FrameInterpolationInfo>, I>>(object: I): FrameInterpolationInfo {
    const message = createBaseFrameInterpolationInfo();
    message.sampleMs = object.sampleMs ?? 0;
    return message;
  },
};

function createBaseKey(): Key {
  return {
    id: "",
    type: "",
    description: "",
    scopes: [],
    endpoints: [],
    apps: [],
    createdAt: undefined,
    expiresAt: undefined,
    authorizedIdpIds: [],
  };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.scopes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(50).fork()).join();
    }
    for (const v of message.authorizedIdpIds) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.authorizedIdpIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      authorizedIdpIds: globalThis.Array.isArray(object?.authorizedIdpIds)
        ? object.authorizedIdpIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.authorizedIdpIds?.length) {
      obj.authorizedIdpIds = message.authorizedIdpIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key>, I>>(base?: I): Key {
    return Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key>, I>>(object: I): Key {
    const message = createBaseKey();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.description = object.description ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.authorizedIdpIds = object.authorizedIdpIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseModel(): Model {
  return {
    id: "",
    name: "",
    createdAt: undefined,
    modifiedAt: undefined,
    appId: "",
    outputInfo: undefined,
    modelVersion: undefined,
    displayName: "",
    userId: "",
    defaultEvalInfo: undefined,
    modelTypeId: "",
    task: "",
    visibility: undefined,
    description: "",
    metadata: undefined,
    presets: undefined,
    notes: "",
    toolkits: [],
    useCases: [],
    languages: [],
    languagesFull: [],
    checkConsents: [],
    isStarred: false,
    starCount: 0,
    workflowRecommended: undefined,
    bookmarkOrigin: undefined,
    image: undefined,
    licenseType: 0,
    source: 0,
    creator: "",
    versionCount: 0,
    billingType: 0,
    featuredOrder: undefined,
    deployRestriction: 0,
    replicaCount: 0,
    openRouterInfo: undefined,
  };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(154).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.outputInfo !== undefined) {
      OutputInfo.encode(message.outputInfo, writer.uint32(42).fork()).join();
    }
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(message.modelVersion, writer.uint32(50).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(58).string(message.displayName);
    }
    if (message.userId !== "") {
      writer.uint32(74).string(message.userId);
    }
    if (message.defaultEvalInfo !== undefined) {
      EvalInfo.encode(message.defaultEvalInfo, writer.uint32(242).fork()).join();
    }
    if (message.modelTypeId !== "") {
      writer.uint32(114).string(message.modelTypeId);
    }
    if (message.task !== "") {
      writer.uint32(210).string(message.task);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(122).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(130).string(message.description);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(138).fork()).join();
    }
    if (message.presets !== undefined) {
      Struct.encode(Struct.wrap(message.presets), writer.uint32(218).fork()).join();
    }
    if (message.notes !== "") {
      writer.uint32(146).string(message.notes);
    }
    for (const v of message.toolkits) {
      writer.uint32(162).string(v!);
    }
    for (const v of message.useCases) {
      writer.uint32(170).string(v!);
    }
    for (const v of message.languages) {
      writer.uint32(202).string(v!);
    }
    for (const v of message.languagesFull) {
      FullTag.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.checkConsents) {
      writer.uint32(258).string(v!);
    }
    if (message.isStarred !== false) {
      writer.uint32(176).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(184).int32(message.starCount);
    }
    if (message.workflowRecommended !== undefined) {
      BoolValue.encode({ value: message.workflowRecommended! }, writer.uint32(234).fork()).join();
    }
    if (message.bookmarkOrigin !== undefined) {
      BookmarkOrigin.encode(message.bookmarkOrigin, writer.uint32(266).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(274).fork()).join();
    }
    if (message.licenseType !== 0) {
      writer.uint32(280).int32(message.licenseType);
    }
    if (message.source !== 0) {
      writer.uint32(288).int32(message.source);
    }
    if (message.creator !== "") {
      writer.uint32(298).string(message.creator);
    }
    if (message.versionCount !== 0) {
      writer.uint32(304).int32(message.versionCount);
    }
    if (message.billingType !== 0) {
      writer.uint32(320).int32(message.billingType);
    }
    if (message.featuredOrder !== undefined) {
      Int32Value.encode({ value: message.featuredOrder! }, writer.uint32(330).fork()).join();
    }
    if (message.deployRestriction !== 0) {
      writer.uint32(336).int32(message.deployRestriction);
    }
    if (message.replicaCount !== 0) {
      writer.uint32(344).uint32(message.replicaCount);
    }
    if (message.openRouterInfo !== undefined) {
      OpenRouterInfo.encode(message.openRouterInfo, writer.uint32(354).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputInfo = OutputInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.defaultEvalInfo = EvalInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.modelTypeId = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.task = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.presets = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.toolkits.push(reader.string());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.useCases.push(reader.string());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.languages.push(reader.string());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.languagesFull.push(FullTag.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.checkConsents.push(reader.string());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.workflowRecommended = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.bookmarkOrigin = BookmarkOrigin.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.versionCount = reader.int32();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.billingType = reader.int32() as any;
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.featuredOrder = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }

          message.deployRestriction = reader.int32() as any;
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.replicaCount = reader.uint32();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.openRouterInfo = OpenRouterInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      outputInfo: isSet(object.outputInfo) ? OutputInfo.fromJSON(object.outputInfo) : undefined,
      modelVersion: isSet(object.modelVersion) ? ModelVersion.fromJSON(object.modelVersion) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      defaultEvalInfo: isSet(object.defaultEvalInfo) ? EvalInfo.fromJSON(object.defaultEvalInfo) : undefined,
      modelTypeId: isSet(object.modelTypeId) ? globalThis.String(object.modelTypeId) : "",
      task: isSet(object.task) ? globalThis.String(object.task) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      presets: isObject(object.presets) ? object.presets : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      toolkits: globalThis.Array.isArray(object?.toolkits) ? object.toolkits.map((e: any) => globalThis.String(e)) : [],
      useCases: globalThis.Array.isArray(object?.useCases) ? object.useCases.map((e: any) => globalThis.String(e)) : [],
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => globalThis.String(e))
        : [],
      languagesFull: globalThis.Array.isArray(object?.languagesFull)
        ? object.languagesFull.map((e: any) => FullTag.fromJSON(e))
        : [],
      checkConsents: globalThis.Array.isArray(object?.checkConsents)
        ? object.checkConsents.map((e: any) => globalThis.String(e))
        : [],
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      workflowRecommended: isSet(object.workflowRecommended) ? Boolean(object.workflowRecommended) : undefined,
      bookmarkOrigin: isSet(object.bookmarkOrigin) ? BookmarkOrigin.fromJSON(object.bookmarkOrigin) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      licenseType: isSet(object.licenseType) ? licenseTypeFromJSON(object.licenseType) : 0,
      source: isSet(object.source) ? model_SourceFromJSON(object.source) : 0,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      versionCount: isSet(object.versionCount) ? globalThis.Number(object.versionCount) : 0,
      billingType: isSet(object.billingType) ? model_BillingTypeFromJSON(object.billingType) : 0,
      featuredOrder: isSet(object.featuredOrder) ? Number(object.featuredOrder) : undefined,
      deployRestriction: isSet(object.deployRestriction) ? deployRestrictionFromJSON(object.deployRestriction) : 0,
      replicaCount: isSet(object.replicaCount) ? globalThis.Number(object.replicaCount) : 0,
      openRouterInfo: isSet(object.openRouterInfo) ? OpenRouterInfo.fromJSON(object.openRouterInfo) : undefined,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.outputInfo !== undefined) {
      obj.outputInfo = OutputInfo.toJSON(message.outputInfo);
    }
    if (message.modelVersion !== undefined) {
      obj.modelVersion = ModelVersion.toJSON(message.modelVersion);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.defaultEvalInfo !== undefined) {
      obj.defaultEvalInfo = EvalInfo.toJSON(message.defaultEvalInfo);
    }
    if (message.modelTypeId !== "") {
      obj.modelTypeId = message.modelTypeId;
    }
    if (message.task !== "") {
      obj.task = message.task;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.presets !== undefined) {
      obj.presets = message.presets;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.toolkits?.length) {
      obj.toolkits = message.toolkits;
    }
    if (message.useCases?.length) {
      obj.useCases = message.useCases;
    }
    if (message.languages?.length) {
      obj.languages = message.languages;
    }
    if (message.languagesFull?.length) {
      obj.languagesFull = message.languagesFull.map((e) => FullTag.toJSON(e));
    }
    if (message.checkConsents?.length) {
      obj.checkConsents = message.checkConsents;
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.workflowRecommended !== undefined) {
      obj.workflowRecommended = message.workflowRecommended;
    }
    if (message.bookmarkOrigin !== undefined) {
      obj.bookmarkOrigin = BookmarkOrigin.toJSON(message.bookmarkOrigin);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.licenseType !== 0) {
      obj.licenseType = licenseTypeToJSON(message.licenseType);
    }
    if (message.source !== 0) {
      obj.source = model_SourceToJSON(message.source);
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.versionCount !== 0) {
      obj.versionCount = Math.round(message.versionCount);
    }
    if (message.billingType !== 0) {
      obj.billingType = model_BillingTypeToJSON(message.billingType);
    }
    if (message.featuredOrder !== undefined) {
      obj.featuredOrder = message.featuredOrder;
    }
    if (message.deployRestriction !== 0) {
      obj.deployRestriction = deployRestrictionToJSON(message.deployRestriction);
    }
    if (message.replicaCount !== 0) {
      obj.replicaCount = Math.round(message.replicaCount);
    }
    if (message.openRouterInfo !== undefined) {
      obj.openRouterInfo = OpenRouterInfo.toJSON(message.openRouterInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.appId = object.appId ?? "";
    message.outputInfo = (object.outputInfo !== undefined && object.outputInfo !== null)
      ? OutputInfo.fromPartial(object.outputInfo)
      : undefined;
    message.modelVersion = (object.modelVersion !== undefined && object.modelVersion !== null)
      ? ModelVersion.fromPartial(object.modelVersion)
      : undefined;
    message.displayName = object.displayName ?? "";
    message.userId = object.userId ?? "";
    message.defaultEvalInfo = (object.defaultEvalInfo !== undefined && object.defaultEvalInfo !== null)
      ? EvalInfo.fromPartial(object.defaultEvalInfo)
      : undefined;
    message.modelTypeId = object.modelTypeId ?? "";
    message.task = object.task ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.description = object.description ?? "";
    message.metadata = object.metadata ?? undefined;
    message.presets = object.presets ?? undefined;
    message.notes = object.notes ?? "";
    message.toolkits = object.toolkits?.map((e) => e) || [];
    message.useCases = object.useCases?.map((e) => e) || [];
    message.languages = object.languages?.map((e) => e) || [];
    message.languagesFull = object.languagesFull?.map((e) => FullTag.fromPartial(e)) || [];
    message.checkConsents = object.checkConsents?.map((e) => e) || [];
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.workflowRecommended = object.workflowRecommended ?? undefined;
    message.bookmarkOrigin = (object.bookmarkOrigin !== undefined && object.bookmarkOrigin !== null)
      ? BookmarkOrigin.fromPartial(object.bookmarkOrigin)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.licenseType = object.licenseType ?? 0;
    message.source = object.source ?? 0;
    message.creator = object.creator ?? "";
    message.versionCount = object.versionCount ?? 0;
    message.billingType = object.billingType ?? 0;
    message.featuredOrder = object.featuredOrder ?? undefined;
    message.deployRestriction = object.deployRestriction ?? 0;
    message.replicaCount = object.replicaCount ?? 0;
    message.openRouterInfo = (object.openRouterInfo !== undefined && object.openRouterInfo !== null)
      ? OpenRouterInfo.fromPartial(object.openRouterInfo)
      : undefined;
    return message;
  },
};

function createBaseOpenRouterInfo(): OpenRouterInfo {
  return { params: undefined };
}

export const OpenRouterInfo: MessageFns<OpenRouterInfo> = {
  encode(message: OpenRouterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenRouterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenRouterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenRouterInfo {
    return { params: isObject(object.params) ? object.params : undefined };
  },

  toJSON(message: OpenRouterInfo): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenRouterInfo>, I>>(base?: I): OpenRouterInfo {
    return OpenRouterInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenRouterInfo>, I>>(object: I): OpenRouterInfo {
    const message = createBaseOpenRouterInfo();
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseModelReference(): ModelReference {
  return { id: "", modelId: "", url: "", name: "", metadata: undefined };
}

export const ModelReference: MessageFns<ModelReference> = {
  encode(message: ModelReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelReference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: ModelReference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelReference>, I>>(base?: I): ModelReference {
    return ModelReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelReference>, I>>(object: I): ModelReference {
    const message = createBaseModelReference();
    message.id = object.id ?? "";
    message.modelId = object.modelId ?? "";
    message.url = object.url ?? "";
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseModelVersionInputExample(): ModelVersionInputExample {
  return { id: "", modelId: "", modelVersionId: "", data: undefined, name: "", description: "" };
}

export const ModelVersionInputExample: MessageFns<ModelVersionInputExample> = {
  encode(message: ModelVersionInputExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionInputExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionInputExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionInputExample {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ModelVersionInputExample): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelVersionInputExample>, I>>(base?: I): ModelVersionInputExample {
    return ModelVersionInputExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelVersionInputExample>, I>>(object: I): ModelVersionInputExample {
    const message = createBaseModelVersionInputExample();
    message.id = object.id ?? "";
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseOutputInfo(): OutputInfo {
  return {
    data: undefined,
    outputConfig: undefined,
    message: "",
    fieldsMap: undefined,
    params: undefined,
    paramsSpecs: [],
  };
}

export const OutputInfo: MessageFns<OutputInfo> = {
  encode(message: OutputInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(18).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.fieldsMap !== undefined) {
      Struct.encode(Struct.wrap(message.fieldsMap), writer.uint32(50).fork()).join();
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(58).fork()).join();
    }
    for (const v of message.paramsSpecs) {
      ModelTypeField.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fieldsMap = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.paramsSpecs.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputInfo {
    return {
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      fieldsMap: isObject(object.fieldsMap) ? object.fieldsMap : undefined,
      params: isObject(object.params) ? object.params : undefined,
      paramsSpecs: globalThis.Array.isArray(object?.paramsSpecs)
        ? object.paramsSpecs.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OutputInfo): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.fieldsMap !== undefined) {
      obj.fieldsMap = message.fieldsMap;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.paramsSpecs?.length) {
      obj.paramsSpecs = message.paramsSpecs.map((e) => ModelTypeField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputInfo>, I>>(base?: I): OutputInfo {
    return OutputInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputInfo>, I>>(object: I): OutputInfo {
    const message = createBaseOutputInfo();
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.message = object.message ?? "";
    message.fieldsMap = object.fieldsMap ?? undefined;
    message.params = object.params ?? undefined;
    message.paramsSpecs = object.paramsSpecs?.map((e) => ModelTypeField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInputInfo(): InputInfo {
  return { fieldsMap: undefined, params: undefined, baseEmbedModel: undefined };
}

export const InputInfo: MessageFns<InputInfo> = {
  encode(message: InputInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldsMap !== undefined) {
      Struct.encode(Struct.wrap(message.fieldsMap), writer.uint32(10).fork()).join();
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(18).fork()).join();
    }
    if (message.baseEmbedModel !== undefined) {
      Model.encode(message.baseEmbedModel, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fieldsMap = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseEmbedModel = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputInfo {
    return {
      fieldsMap: isObject(object.fieldsMap) ? object.fieldsMap : undefined,
      params: isObject(object.params) ? object.params : undefined,
      baseEmbedModel: isSet(object.baseEmbedModel) ? Model.fromJSON(object.baseEmbedModel) : undefined,
    };
  },

  toJSON(message: InputInfo): unknown {
    const obj: any = {};
    if (message.fieldsMap !== undefined) {
      obj.fieldsMap = message.fieldsMap;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.baseEmbedModel !== undefined) {
      obj.baseEmbedModel = Model.toJSON(message.baseEmbedModel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputInfo>, I>>(base?: I): InputInfo {
    return InputInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputInfo>, I>>(object: I): InputInfo {
    const message = createBaseInputInfo();
    message.fieldsMap = object.fieldsMap ?? undefined;
    message.params = object.params ?? undefined;
    message.baseEmbedModel = (object.baseEmbedModel !== undefined && object.baseEmbedModel !== null)
      ? Model.fromPartial(object.baseEmbedModel)
      : undefined;
    return message;
  },
};

function createBaseTrainInfo(): TrainInfo {
  return { params: undefined, dataset: undefined, resumeFromModel: undefined };
}

export const TrainInfo: MessageFns<TrainInfo> = {
  encode(message: TrainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(10).fork()).join();
    }
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(18).fork()).join();
    }
    if (message.resumeFromModel !== undefined) {
      Model.encode(message.resumeFromModel, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resumeFromModel = Model.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainInfo {
    return {
      params: isObject(object.params) ? object.params : undefined,
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
      resumeFromModel: isSet(object.resumeFromModel) ? Model.fromJSON(object.resumeFromModel) : undefined,
    };
  },

  toJSON(message: TrainInfo): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    if (message.resumeFromModel !== undefined) {
      obj.resumeFromModel = Model.toJSON(message.resumeFromModel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainInfo>, I>>(base?: I): TrainInfo {
    return TrainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainInfo>, I>>(object: I): TrainInfo {
    const message = createBaseTrainInfo();
    message.params = object.params ?? undefined;
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    message.resumeFromModel = (object.resumeFromModel !== undefined && object.resumeFromModel !== null)
      ? Model.fromPartial(object.resumeFromModel)
      : undefined;
    return message;
  },
};

function createBaseEvalInfo(): EvalInfo {
  return { params: undefined };
}

export const EvalInfo: MessageFns<EvalInfo> = {
  encode(message: EvalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalInfo {
    return { params: isObject(object.params) ? object.params : undefined };
  },

  toJSON(message: EvalInfo): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalInfo>, I>>(base?: I): EvalInfo {
    return EvalInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalInfo>, I>>(object: I): EvalInfo {
    const message = createBaseEvalInfo();
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseImportInfo(): ImportInfo {
  return { params: undefined };
}

export const ImportInfo: MessageFns<ImportInfo> = {
  encode(message: ImportInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportInfo {
    return { params: isObject(object.params) ? object.params : undefined };
  },

  toJSON(message: ImportInfo): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportInfo>, I>>(base?: I): ImportInfo {
    return ImportInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportInfo>, I>>(object: I): ImportInfo {
    const message = createBaseImportInfo();
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseOutputConfig(): OutputConfig {
  return {
    conceptsMutuallyExclusive: false,
    existingModelId: "",
    language: "",
    hyperParameters: "",
    maxConcepts: 0,
    minValue: 0,
    selectConcepts: [],
    trainingTimeout: 0,
    sampleMs: 0,
    hyperParams: undefined,
    embedModelVersionId: "",
    failOnMissingPositiveExamples: false,
    modelMetadata: undefined,
  };
}

export const OutputConfig: MessageFns<OutputConfig> = {
  encode(message: OutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conceptsMutuallyExclusive !== false) {
      writer.uint32(8).bool(message.conceptsMutuallyExclusive);
    }
    if (message.existingModelId !== "") {
      writer.uint32(26).string(message.existingModelId);
    }
    if (message.language !== "") {
      writer.uint32(34).string(message.language);
    }
    if (message.hyperParameters !== "") {
      writer.uint32(42).string(message.hyperParameters);
    }
    if (message.maxConcepts !== 0) {
      writer.uint32(48).uint32(message.maxConcepts);
    }
    if (message.minValue !== 0) {
      writer.uint32(61).float(message.minValue);
    }
    for (const v of message.selectConcepts) {
      Concept.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.trainingTimeout !== 0) {
      writer.uint32(72).uint32(message.trainingTimeout);
    }
    if (message.sampleMs !== 0) {
      writer.uint32(80).uint32(message.sampleMs);
    }
    if (message.hyperParams !== undefined) {
      Struct.encode(Struct.wrap(message.hyperParams), writer.uint32(106).fork()).join();
    }
    if (message.embedModelVersionId !== "") {
      writer.uint32(114).string(message.embedModelVersionId);
    }
    if (message.failOnMissingPositiveExamples !== false) {
      writer.uint32(120).bool(message.failOnMissingPositiveExamples);
    }
    if (message.modelMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.modelMetadata), writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.conceptsMutuallyExclusive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.existingModelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hyperParameters = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxConcepts = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.minValue = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.selectConcepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.trainingTimeout = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sampleMs = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.hyperParams = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.embedModelVersionId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.failOnMissingPositiveExamples = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.modelMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputConfig {
    return {
      conceptsMutuallyExclusive: isSet(object.conceptsMutuallyExclusive)
        ? globalThis.Boolean(object.conceptsMutuallyExclusive)
        : false,
      existingModelId: isSet(object.existingModelId) ? globalThis.String(object.existingModelId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      hyperParameters: isSet(object.hyperParameters) ? globalThis.String(object.hyperParameters) : "",
      maxConcepts: isSet(object.maxConcepts) ? globalThis.Number(object.maxConcepts) : 0,
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      selectConcepts: globalThis.Array.isArray(object?.selectConcepts)
        ? object.selectConcepts.map((e: any) => Concept.fromJSON(e))
        : [],
      trainingTimeout: isSet(object.trainingTimeout) ? globalThis.Number(object.trainingTimeout) : 0,
      sampleMs: isSet(object.sampleMs) ? globalThis.Number(object.sampleMs) : 0,
      hyperParams: isObject(object.hyperParams) ? object.hyperParams : undefined,
      embedModelVersionId: isSet(object.embedModelVersionId) ? globalThis.String(object.embedModelVersionId) : "",
      failOnMissingPositiveExamples: isSet(object.failOnMissingPositiveExamples)
        ? globalThis.Boolean(object.failOnMissingPositiveExamples)
        : false,
      modelMetadata: isObject(object.modelMetadata) ? object.modelMetadata : undefined,
    };
  },

  toJSON(message: OutputConfig): unknown {
    const obj: any = {};
    if (message.conceptsMutuallyExclusive !== false) {
      obj.conceptsMutuallyExclusive = message.conceptsMutuallyExclusive;
    }
    if (message.existingModelId !== "") {
      obj.existingModelId = message.existingModelId;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.hyperParameters !== "") {
      obj.hyperParameters = message.hyperParameters;
    }
    if (message.maxConcepts !== 0) {
      obj.maxConcepts = Math.round(message.maxConcepts);
    }
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.selectConcepts?.length) {
      obj.selectConcepts = message.selectConcepts.map((e) => Concept.toJSON(e));
    }
    if (message.trainingTimeout !== 0) {
      obj.trainingTimeout = Math.round(message.trainingTimeout);
    }
    if (message.sampleMs !== 0) {
      obj.sampleMs = Math.round(message.sampleMs);
    }
    if (message.hyperParams !== undefined) {
      obj.hyperParams = message.hyperParams;
    }
    if (message.embedModelVersionId !== "") {
      obj.embedModelVersionId = message.embedModelVersionId;
    }
    if (message.failOnMissingPositiveExamples !== false) {
      obj.failOnMissingPositiveExamples = message.failOnMissingPositiveExamples;
    }
    if (message.modelMetadata !== undefined) {
      obj.modelMetadata = message.modelMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputConfig>, I>>(base?: I): OutputConfig {
    return OutputConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputConfig>, I>>(object: I): OutputConfig {
    const message = createBaseOutputConfig();
    message.conceptsMutuallyExclusive = object.conceptsMutuallyExclusive ?? false;
    message.existingModelId = object.existingModelId ?? "";
    message.language = object.language ?? "";
    message.hyperParameters = object.hyperParameters ?? "";
    message.maxConcepts = object.maxConcepts ?? 0;
    message.minValue = object.minValue ?? 0;
    message.selectConcepts = object.selectConcepts?.map((e) => Concept.fromPartial(e)) || [];
    message.trainingTimeout = object.trainingTimeout ?? 0;
    message.sampleMs = object.sampleMs ?? 0;
    message.hyperParams = object.hyperParams ?? undefined;
    message.embedModelVersionId = object.embedModelVersionId ?? "";
    message.failOnMissingPositiveExamples = object.failOnMissingPositiveExamples ?? false;
    message.modelMetadata = object.modelMetadata ?? undefined;
    return message;
  },
};

function createBaseModelType(): ModelType {
  return {
    id: "",
    title: "",
    description: "",
    inputFields: [],
    outputFields: [],
    trainable: false,
    creatable: false,
    internalOnly: false,
    modelTypeFields: [],
    requiresSequentialFrames: false,
    expectedInputLayers: [],
    expectedOutputLayers: [],
    evaluationType: 0,
    methodSignatures: [],
  };
}

export const ModelType: MessageFns<ModelType> = {
  encode(message: ModelType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.inputFields) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.outputFields) {
      writer.uint32(50).string(v!);
    }
    if (message.trainable !== false) {
      writer.uint32(64).bool(message.trainable);
    }
    if (message.creatable !== false) {
      writer.uint32(72).bool(message.creatable);
    }
    if (message.internalOnly !== false) {
      writer.uint32(80).bool(message.internalOnly);
    }
    for (const v of message.modelTypeFields) {
      ModelTypeField.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.requiresSequentialFrames !== false) {
      writer.uint32(96).bool(message.requiresSequentialFrames);
    }
    for (const v of message.expectedInputLayers) {
      ModelLayerInfo.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.expectedOutputLayers) {
      ModelLayerInfo.encode(v!, writer.uint32(138).fork()).join();
    }
    if (message.evaluationType !== 0) {
      writer.uint32(144).int32(message.evaluationType);
    }
    for (const v of message.methodSignatures) {
      MethodSignature.encode(v!, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputFields.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputFields.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.trainable = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.creatable = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.internalOnly = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.modelTypeFields.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.requiresSequentialFrames = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.expectedInputLayers.push(ModelLayerInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.expectedOutputLayers.push(ModelLayerInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.evaluationType = reader.int32() as any;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.methodSignatures.push(MethodSignature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelType {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputFields: globalThis.Array.isArray(object?.inputFields)
        ? object.inputFields.map((e: any) => globalThis.String(e))
        : [],
      outputFields: globalThis.Array.isArray(object?.outputFields)
        ? object.outputFields.map((e: any) => globalThis.String(e))
        : [],
      trainable: isSet(object.trainable) ? globalThis.Boolean(object.trainable) : false,
      creatable: isSet(object.creatable) ? globalThis.Boolean(object.creatable) : false,
      internalOnly: isSet(object.internalOnly) ? globalThis.Boolean(object.internalOnly) : false,
      modelTypeFields: globalThis.Array.isArray(object?.modelTypeFields)
        ? object.modelTypeFields.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
      requiresSequentialFrames: isSet(object.requiresSequentialFrames)
        ? globalThis.Boolean(object.requiresSequentialFrames)
        : false,
      expectedInputLayers: globalThis.Array.isArray(object?.expectedInputLayers)
        ? object.expectedInputLayers.map((e: any) => ModelLayerInfo.fromJSON(e))
        : [],
      expectedOutputLayers: globalThis.Array.isArray(object?.expectedOutputLayers)
        ? object.expectedOutputLayers.map((e: any) => ModelLayerInfo.fromJSON(e))
        : [],
      evaluationType: isSet(object.evaluationType) ? evaluationTypeFromJSON(object.evaluationType) : 0,
      methodSignatures: globalThis.Array.isArray(object?.methodSignatures)
        ? object.methodSignatures.map((e: any) => MethodSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelType): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputFields?.length) {
      obj.inputFields = message.inputFields;
    }
    if (message.outputFields?.length) {
      obj.outputFields = message.outputFields;
    }
    if (message.trainable !== false) {
      obj.trainable = message.trainable;
    }
    if (message.creatable !== false) {
      obj.creatable = message.creatable;
    }
    if (message.internalOnly !== false) {
      obj.internalOnly = message.internalOnly;
    }
    if (message.modelTypeFields?.length) {
      obj.modelTypeFields = message.modelTypeFields.map((e) => ModelTypeField.toJSON(e));
    }
    if (message.requiresSequentialFrames !== false) {
      obj.requiresSequentialFrames = message.requiresSequentialFrames;
    }
    if (message.expectedInputLayers?.length) {
      obj.expectedInputLayers = message.expectedInputLayers.map((e) => ModelLayerInfo.toJSON(e));
    }
    if (message.expectedOutputLayers?.length) {
      obj.expectedOutputLayers = message.expectedOutputLayers.map((e) => ModelLayerInfo.toJSON(e));
    }
    if (message.evaluationType !== 0) {
      obj.evaluationType = evaluationTypeToJSON(message.evaluationType);
    }
    if (message.methodSignatures?.length) {
      obj.methodSignatures = message.methodSignatures.map((e) => MethodSignature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelType>, I>>(base?: I): ModelType {
    return ModelType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelType>, I>>(object: I): ModelType {
    const message = createBaseModelType();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.inputFields = object.inputFields?.map((e) => e) || [];
    message.outputFields = object.outputFields?.map((e) => e) || [];
    message.trainable = object.trainable ?? false;
    message.creatable = object.creatable ?? false;
    message.internalOnly = object.internalOnly ?? false;
    message.modelTypeFields = object.modelTypeFields?.map((e) => ModelTypeField.fromPartial(e)) || [];
    message.requiresSequentialFrames = object.requiresSequentialFrames ?? false;
    message.expectedInputLayers = object.expectedInputLayers?.map((e) => ModelLayerInfo.fromPartial(e)) || [];
    message.expectedOutputLayers = object.expectedOutputLayers?.map((e) => ModelLayerInfo.fromPartial(e)) || [];
    message.evaluationType = object.evaluationType ?? 0;
    message.methodSignatures = object.methodSignatures?.map((e) => MethodSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelLayerInfo(): ModelLayerInfo {
  return { dataFieldName: "", shapes: [], description: "", requiresLabelFilename: false };
}

export const ModelLayerInfo: MessageFns<ModelLayerInfo> = {
  encode(message: ModelLayerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataFieldName !== "") {
      writer.uint32(10).string(message.dataFieldName);
    }
    for (const v of message.shapes) {
      LayerShape.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.requiresLabelFilename !== false) {
      writer.uint32(32).bool(message.requiresLabelFilename);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelLayerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelLayerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataFieldName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shapes.push(LayerShape.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requiresLabelFilename = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelLayerInfo {
    return {
      dataFieldName: isSet(object.dataFieldName) ? globalThis.String(object.dataFieldName) : "",
      shapes: globalThis.Array.isArray(object?.shapes) ? object.shapes.map((e: any) => LayerShape.fromJSON(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      requiresLabelFilename: isSet(object.requiresLabelFilename)
        ? globalThis.Boolean(object.requiresLabelFilename)
        : false,
    };
  },

  toJSON(message: ModelLayerInfo): unknown {
    const obj: any = {};
    if (message.dataFieldName !== "") {
      obj.dataFieldName = message.dataFieldName;
    }
    if (message.shapes?.length) {
      obj.shapes = message.shapes.map((e) => LayerShape.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.requiresLabelFilename !== false) {
      obj.requiresLabelFilename = message.requiresLabelFilename;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelLayerInfo>, I>>(base?: I): ModelLayerInfo {
    return ModelLayerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelLayerInfo>, I>>(object: I): ModelLayerInfo {
    const message = createBaseModelLayerInfo();
    message.dataFieldName = object.dataFieldName ?? "";
    message.shapes = object.shapes?.map((e) => LayerShape.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.requiresLabelFilename = object.requiresLabelFilename ?? false;
    return message;
  },
};

function createBaseTritonCondaEnvInfo(): TritonCondaEnvInfo {
  return { condaPackUrl: "", condaYamlUrl: "" };
}

export const TritonCondaEnvInfo: MessageFns<TritonCondaEnvInfo> = {
  encode(message: TritonCondaEnvInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condaPackUrl !== "") {
      writer.uint32(10).string(message.condaPackUrl);
    }
    if (message.condaYamlUrl !== "") {
      writer.uint32(18).string(message.condaYamlUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TritonCondaEnvInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTritonCondaEnvInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.condaPackUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condaYamlUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TritonCondaEnvInfo {
    return {
      condaPackUrl: isSet(object.condaPackUrl) ? globalThis.String(object.condaPackUrl) : "",
      condaYamlUrl: isSet(object.condaYamlUrl) ? globalThis.String(object.condaYamlUrl) : "",
    };
  },

  toJSON(message: TritonCondaEnvInfo): unknown {
    const obj: any = {};
    if (message.condaPackUrl !== "") {
      obj.condaPackUrl = message.condaPackUrl;
    }
    if (message.condaYamlUrl !== "") {
      obj.condaYamlUrl = message.condaYamlUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TritonCondaEnvInfo>, I>>(base?: I): TritonCondaEnvInfo {
    return TritonCondaEnvInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TritonCondaEnvInfo>, I>>(object: I): TritonCondaEnvInfo {
    const message = createBaseTritonCondaEnvInfo();
    message.condaPackUrl = object.condaPackUrl ?? "";
    message.condaYamlUrl = object.condaYamlUrl ?? "";
    return message;
  },
};

function createBaseLayerShape(): LayerShape {
  return { dims: [], maxDims: [], dataType: 0, description: "" };
}

export const LayerShape: MessageFns<LayerShape> = {
  encode(message: LayerShape, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.dims) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.maxDims) {
      writer.int32(v);
    }
    writer.join();
    if (message.dataType !== 0) {
      writer.uint32(24).int32(message.dataType);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayerShape {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayerShape();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.dims.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dims.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.maxDims.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxDims.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayerShape {
    return {
      dims: globalThis.Array.isArray(object?.dims) ? object.dims.map((e: any) => globalThis.Number(e)) : [],
      maxDims: globalThis.Array.isArray(object?.maxDims) ? object.maxDims.map((e: any) => globalThis.Number(e)) : [],
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: LayerShape): unknown {
    const obj: any = {};
    if (message.dims?.length) {
      obj.dims = message.dims.map((e) => Math.round(e));
    }
    if (message.maxDims?.length) {
      obj.maxDims = message.maxDims.map((e) => Math.round(e));
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayerShape>, I>>(base?: I): LayerShape {
    return LayerShape.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayerShape>, I>>(object: I): LayerShape {
    const message = createBaseLayerShape();
    message.dims = object.dims?.map((e) => e) || [];
    message.maxDims = object.maxDims?.map((e) => e) || [];
    message.dataType = object.dataType ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseModelTypeField(): ModelTypeField {
  return {
    path: "",
    fieldType: 0,
    defaultValue: undefined,
    description: "",
    placeholder: "",
    modelTypeEnumOptions: [],
    internalOnly: false,
    required: false,
    modelTypeRangeInfo: undefined,
    name: "",
    type: 0,
    typeArgs: [],
    iterator: false,
    default: "",
    isParam: false,
  };
}

export const ModelTypeField: MessageFns<ModelTypeField> = {
  encode(message: ModelTypeField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.fieldType !== 0) {
      writer.uint32(16).int32(message.fieldType);
    }
    if (message.defaultValue !== undefined) {
      Value.encode(Value.wrap(message.defaultValue), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.placeholder !== "") {
      writer.uint32(42).string(message.placeholder);
    }
    for (const v of message.modelTypeEnumOptions) {
      ModelTypeEnumOption.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.internalOnly !== false) {
      writer.uint32(56).bool(message.internalOnly);
    }
    if (message.required !== false) {
      writer.uint32(64).bool(message.required);
    }
    if (message.modelTypeRangeInfo !== undefined) {
      ModelTypeRangeInfo.encode(message.modelTypeRangeInfo, writer.uint32(74).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(88).int32(message.type);
    }
    for (const v of message.typeArgs) {
      ModelTypeField.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.iterator !== false) {
      writer.uint32(104).bool(message.iterator);
    }
    if (message.default !== "") {
      writer.uint32(114).string(message.default);
    }
    if (message.isParam !== false) {
      writer.uint32(120).bool(message.isParam);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelTypeField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelTypeField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fieldType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.placeholder = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelTypeEnumOptions.push(ModelTypeEnumOption.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.internalOnly = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelTypeRangeInfo = ModelTypeRangeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.typeArgs.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.iterator = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.default = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isParam = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelTypeField {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      fieldType: isSet(object.fieldType) ? modelTypeField_ModelTypeFieldTypeFromJSON(object.fieldType) : 0,
      defaultValue: isSet(object?.defaultValue) ? object.defaultValue : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      placeholder: isSet(object.placeholder) ? globalThis.String(object.placeholder) : "",
      modelTypeEnumOptions: globalThis.Array.isArray(object?.modelTypeEnumOptions)
        ? object.modelTypeEnumOptions.map((e: any) => ModelTypeEnumOption.fromJSON(e))
        : [],
      internalOnly: isSet(object.internalOnly) ? globalThis.Boolean(object.internalOnly) : false,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      modelTypeRangeInfo: isSet(object.modelTypeRangeInfo)
        ? ModelTypeRangeInfo.fromJSON(object.modelTypeRangeInfo)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? modelTypeField_DataTypeFromJSON(object.type) : 0,
      typeArgs: globalThis.Array.isArray(object?.typeArgs)
        ? object.typeArgs.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
      iterator: isSet(object.iterator) ? globalThis.Boolean(object.iterator) : false,
      default: isSet(object.default) ? globalThis.String(object.default) : "",
      isParam: isSet(object.isParam) ? globalThis.Boolean(object.isParam) : false,
    };
  },

  toJSON(message: ModelTypeField): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.fieldType !== 0) {
      obj.fieldType = modelTypeField_ModelTypeFieldTypeToJSON(message.fieldType);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.placeholder !== "") {
      obj.placeholder = message.placeholder;
    }
    if (message.modelTypeEnumOptions?.length) {
      obj.modelTypeEnumOptions = message.modelTypeEnumOptions.map((e) => ModelTypeEnumOption.toJSON(e));
    }
    if (message.internalOnly !== false) {
      obj.internalOnly = message.internalOnly;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.modelTypeRangeInfo !== undefined) {
      obj.modelTypeRangeInfo = ModelTypeRangeInfo.toJSON(message.modelTypeRangeInfo);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = modelTypeField_DataTypeToJSON(message.type);
    }
    if (message.typeArgs?.length) {
      obj.typeArgs = message.typeArgs.map((e) => ModelTypeField.toJSON(e));
    }
    if (message.iterator !== false) {
      obj.iterator = message.iterator;
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    if (message.isParam !== false) {
      obj.isParam = message.isParam;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelTypeField>, I>>(base?: I): ModelTypeField {
    return ModelTypeField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelTypeField>, I>>(object: I): ModelTypeField {
    const message = createBaseModelTypeField();
    message.path = object.path ?? "";
    message.fieldType = object.fieldType ?? 0;
    message.defaultValue = object.defaultValue ?? undefined;
    message.description = object.description ?? "";
    message.placeholder = object.placeholder ?? "";
    message.modelTypeEnumOptions = object.modelTypeEnumOptions?.map((e) => ModelTypeEnumOption.fromPartial(e)) || [];
    message.internalOnly = object.internalOnly ?? false;
    message.required = object.required ?? false;
    message.modelTypeRangeInfo = (object.modelTypeRangeInfo !== undefined && object.modelTypeRangeInfo !== null)
      ? ModelTypeRangeInfo.fromPartial(object.modelTypeRangeInfo)
      : undefined;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.typeArgs = object.typeArgs?.map((e) => ModelTypeField.fromPartial(e)) || [];
    message.iterator = object.iterator ?? false;
    message.default = object.default ?? "";
    message.isParam = object.isParam ?? false;
    return message;
  },
};

function createBaseModelTypeRangeInfo(): ModelTypeRangeInfo {
  return { min: 0, max: 0, step: 0 };
}

export const ModelTypeRangeInfo: MessageFns<ModelTypeRangeInfo> = {
  encode(message: ModelTypeRangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(21).float(message.max);
    }
    if (message.step !== 0) {
      writer.uint32(29).float(message.step);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelTypeRangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelTypeRangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.step = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelTypeRangeInfo {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      step: isSet(object.step) ? globalThis.Number(object.step) : 0,
    };
  },

  toJSON(message: ModelTypeRangeInfo): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.step !== 0) {
      obj.step = message.step;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelTypeRangeInfo>, I>>(base?: I): ModelTypeRangeInfo {
    return ModelTypeRangeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelTypeRangeInfo>, I>>(object: I): ModelTypeRangeInfo {
    const message = createBaseModelTypeRangeInfo();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.step = object.step ?? 0;
    return message;
  },
};

function createBaseModelTypeEnumOption(): ModelTypeEnumOption {
  return { id: "", aliases: [], description: "", modelTypeFields: [], internalOnly: false, recommended: false };
}

export const ModelTypeEnumOption: MessageFns<ModelTypeEnumOption> = {
  encode(message: ModelTypeEnumOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.aliases) {
      ModelTypeEnumOptionAlias.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.modelTypeFields) {
      ModelTypeField.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.internalOnly !== false) {
      writer.uint32(32).bool(message.internalOnly);
    }
    if (message.recommended !== false) {
      writer.uint32(48).bool(message.recommended);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelTypeEnumOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelTypeEnumOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aliases.push(ModelTypeEnumOptionAlias.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelTypeFields.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.internalOnly = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.recommended = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelTypeEnumOption {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      aliases: globalThis.Array.isArray(object?.aliases)
        ? object.aliases.map((e: any) => ModelTypeEnumOptionAlias.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      modelTypeFields: globalThis.Array.isArray(object?.modelTypeFields)
        ? object.modelTypeFields.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
      internalOnly: isSet(object.internalOnly) ? globalThis.Boolean(object.internalOnly) : false,
      recommended: isSet(object.recommended) ? globalThis.Boolean(object.recommended) : false,
    };
  },

  toJSON(message: ModelTypeEnumOption): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases.map((e) => ModelTypeEnumOptionAlias.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.modelTypeFields?.length) {
      obj.modelTypeFields = message.modelTypeFields.map((e) => ModelTypeField.toJSON(e));
    }
    if (message.internalOnly !== false) {
      obj.internalOnly = message.internalOnly;
    }
    if (message.recommended !== false) {
      obj.recommended = message.recommended;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelTypeEnumOption>, I>>(base?: I): ModelTypeEnumOption {
    return ModelTypeEnumOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelTypeEnumOption>, I>>(object: I): ModelTypeEnumOption {
    const message = createBaseModelTypeEnumOption();
    message.id = object.id ?? "";
    message.aliases = object.aliases?.map((e) => ModelTypeEnumOptionAlias.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.modelTypeFields = object.modelTypeFields?.map((e) => ModelTypeField.fromPartial(e)) || [];
    message.internalOnly = object.internalOnly ?? false;
    message.recommended = object.recommended ?? false;
    return message;
  },
};

function createBaseModelTypeEnumOptionAlias(): ModelTypeEnumOptionAlias {
  return { idInt: 0, wildcardString: "" };
}

export const ModelTypeEnumOptionAlias: MessageFns<ModelTypeEnumOptionAlias> = {
  encode(message: ModelTypeEnumOptionAlias, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idInt !== 0) {
      writer.uint32(8).int64(message.idInt);
    }
    if (message.wildcardString !== "") {
      writer.uint32(18).string(message.wildcardString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelTypeEnumOptionAlias {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelTypeEnumOptionAlias();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.idInt = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wildcardString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelTypeEnumOptionAlias {
    return {
      idInt: isSet(object.idInt) ? globalThis.Number(object.idInt) : 0,
      wildcardString: isSet(object.wildcardString) ? globalThis.String(object.wildcardString) : "",
    };
  },

  toJSON(message: ModelTypeEnumOptionAlias): unknown {
    const obj: any = {};
    if (message.idInt !== 0) {
      obj.idInt = Math.round(message.idInt);
    }
    if (message.wildcardString !== "") {
      obj.wildcardString = message.wildcardString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelTypeEnumOptionAlias>, I>>(base?: I): ModelTypeEnumOptionAlias {
    return ModelTypeEnumOptionAlias.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelTypeEnumOptionAlias>, I>>(object: I): ModelTypeEnumOptionAlias {
    const message = createBaseModelTypeEnumOptionAlias();
    message.idInt = object.idInt ?? 0;
    message.wildcardString = object.wildcardString ?? "";
    return message;
  },
};

function createBaseModelQuery(): ModelQuery {
  return { name: "", modelTypeId: "" };
}

export const ModelQuery: MessageFns<ModelQuery> = {
  encode(message: ModelQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.modelTypeId !== "") {
      writer.uint32(26).string(message.modelTypeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelTypeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelQuery {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      modelTypeId: isSet(object.modelTypeId) ? globalThis.String(object.modelTypeId) : "",
    };
  },

  toJSON(message: ModelQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.modelTypeId !== "") {
      obj.modelTypeId = message.modelTypeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelQuery>, I>>(base?: I): ModelQuery {
    return ModelQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelQuery>, I>>(object: I): ModelQuery {
    const message = createBaseModelQuery();
    message.name = object.name ?? "";
    message.modelTypeId = object.modelTypeId ?? "";
    return message;
  },
};

function createBaseModelVersion(): ModelVersion {
  return {
    id: "",
    createdAt: undefined,
    status: undefined,
    activeConceptCount: 0,
    metrics: undefined,
    totalInputCount: 0,
    pretrainedModelConfig: undefined,
    completedAt: undefined,
    description: "",
    visibility: undefined,
    appId: "",
    userId: "",
    modifiedAt: undefined,
    metadata: undefined,
    license: "",
    outputInfo: undefined,
    inputInfo: undefined,
    trainInfo: undefined,
    importInfo: undefined,
    trainLog: "",
    inferenceComputeInfo: undefined,
    buildInfo: undefined,
    methodSignatures: [],
  };
}

export const ModelVersion: MessageFns<ModelVersion> = {
  encode(message: ModelVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    if (message.activeConceptCount !== 0) {
      writer.uint32(32).uint32(message.activeConceptCount);
    }
    if (message.metrics !== undefined) {
      EvalMetrics.encode(message.metrics, writer.uint32(42).fork()).join();
    }
    if (message.totalInputCount !== 0) {
      writer.uint32(48).uint32(message.totalInputCount);
    }
    if (message.pretrainedModelConfig !== undefined) {
      PretrainedModelConfig.encode(message.pretrainedModelConfig, writer.uint32(58).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(82).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(98).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(106).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(114).string(message.userId);
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(122).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(130).fork()).join();
    }
    if (message.license !== "") {
      writer.uint32(138).string(message.license);
    }
    if (message.outputInfo !== undefined) {
      OutputInfo.encode(message.outputInfo, writer.uint32(154).fork()).join();
    }
    if (message.inputInfo !== undefined) {
      InputInfo.encode(message.inputInfo, writer.uint32(162).fork()).join();
    }
    if (message.trainInfo !== undefined) {
      TrainInfo.encode(message.trainInfo, writer.uint32(170).fork()).join();
    }
    if (message.importInfo !== undefined) {
      ImportInfo.encode(message.importInfo, writer.uint32(178).fork()).join();
    }
    if (message.trainLog !== "") {
      writer.uint32(186).string(message.trainLog);
    }
    if (message.inferenceComputeInfo !== undefined) {
      ComputeInfo.encode(message.inferenceComputeInfo, writer.uint32(194).fork()).join();
    }
    if (message.buildInfo !== undefined) {
      BuildInfo.encode(message.buildInfo, writer.uint32(202).fork()).join();
    }
    for (const v of message.methodSignatures) {
      MethodSignature.encode(v!, writer.uint32(210).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activeConceptCount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metrics = EvalMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalInputCount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pretrainedModelConfig = PretrainedModelConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.license = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.outputInfo = OutputInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.inputInfo = InputInfo.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.trainInfo = TrainInfo.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.importInfo = ImportInfo.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.trainLog = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.inferenceComputeInfo = ComputeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.methodSignatures.push(MethodSignature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      activeConceptCount: isSet(object.activeConceptCount) ? globalThis.Number(object.activeConceptCount) : 0,
      metrics: isSet(object.metrics) ? EvalMetrics.fromJSON(object.metrics) : undefined,
      totalInputCount: isSet(object.totalInputCount) ? globalThis.Number(object.totalInputCount) : 0,
      pretrainedModelConfig: isSet(object.pretrainedModelConfig)
        ? PretrainedModelConfig.fromJSON(object.pretrainedModelConfig)
        : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      outputInfo: isSet(object.outputInfo) ? OutputInfo.fromJSON(object.outputInfo) : undefined,
      inputInfo: isSet(object.inputInfo) ? InputInfo.fromJSON(object.inputInfo) : undefined,
      trainInfo: isSet(object.trainInfo) ? TrainInfo.fromJSON(object.trainInfo) : undefined,
      importInfo: isSet(object.importInfo) ? ImportInfo.fromJSON(object.importInfo) : undefined,
      trainLog: isSet(object.trainLog) ? globalThis.String(object.trainLog) : "",
      inferenceComputeInfo: isSet(object.inferenceComputeInfo)
        ? ComputeInfo.fromJSON(object.inferenceComputeInfo)
        : undefined,
      buildInfo: isSet(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : undefined,
      methodSignatures: globalThis.Array.isArray(object?.methodSignatures)
        ? object.methodSignatures.map((e: any) => MethodSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.activeConceptCount !== 0) {
      obj.activeConceptCount = Math.round(message.activeConceptCount);
    }
    if (message.metrics !== undefined) {
      obj.metrics = EvalMetrics.toJSON(message.metrics);
    }
    if (message.totalInputCount !== 0) {
      obj.totalInputCount = Math.round(message.totalInputCount);
    }
    if (message.pretrainedModelConfig !== undefined) {
      obj.pretrainedModelConfig = PretrainedModelConfig.toJSON(message.pretrainedModelConfig);
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.outputInfo !== undefined) {
      obj.outputInfo = OutputInfo.toJSON(message.outputInfo);
    }
    if (message.inputInfo !== undefined) {
      obj.inputInfo = InputInfo.toJSON(message.inputInfo);
    }
    if (message.trainInfo !== undefined) {
      obj.trainInfo = TrainInfo.toJSON(message.trainInfo);
    }
    if (message.importInfo !== undefined) {
      obj.importInfo = ImportInfo.toJSON(message.importInfo);
    }
    if (message.trainLog !== "") {
      obj.trainLog = message.trainLog;
    }
    if (message.inferenceComputeInfo !== undefined) {
      obj.inferenceComputeInfo = ComputeInfo.toJSON(message.inferenceComputeInfo);
    }
    if (message.buildInfo !== undefined) {
      obj.buildInfo = BuildInfo.toJSON(message.buildInfo);
    }
    if (message.methodSignatures?.length) {
      obj.methodSignatures = message.methodSignatures.map((e) => MethodSignature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelVersion>, I>>(base?: I): ModelVersion {
    return ModelVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelVersion>, I>>(object: I): ModelVersion {
    const message = createBaseModelVersion();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.activeConceptCount = object.activeConceptCount ?? 0;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? EvalMetrics.fromPartial(object.metrics)
      : undefined;
    message.totalInputCount = object.totalInputCount ?? 0;
    message.pretrainedModelConfig =
      (object.pretrainedModelConfig !== undefined && object.pretrainedModelConfig !== null)
        ? PretrainedModelConfig.fromPartial(object.pretrainedModelConfig)
        : undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.description = object.description ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.license = object.license ?? "";
    message.outputInfo = (object.outputInfo !== undefined && object.outputInfo !== null)
      ? OutputInfo.fromPartial(object.outputInfo)
      : undefined;
    message.inputInfo = (object.inputInfo !== undefined && object.inputInfo !== null)
      ? InputInfo.fromPartial(object.inputInfo)
      : undefined;
    message.trainInfo = (object.trainInfo !== undefined && object.trainInfo !== null)
      ? TrainInfo.fromPartial(object.trainInfo)
      : undefined;
    message.importInfo = (object.importInfo !== undefined && object.importInfo !== null)
      ? ImportInfo.fromPartial(object.importInfo)
      : undefined;
    message.trainLog = object.trainLog ?? "";
    message.inferenceComputeInfo = (object.inferenceComputeInfo !== undefined && object.inferenceComputeInfo !== null)
      ? ComputeInfo.fromPartial(object.inferenceComputeInfo)
      : undefined;
    message.buildInfo = (object.buildInfo !== undefined && object.buildInfo !== null)
      ? BuildInfo.fromPartial(object.buildInfo)
      : undefined;
    message.methodSignatures = object.methodSignatures?.map((e) => MethodSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMethodSignature(): MethodSignature {
  return { name: "", methodType: 0, description: "", inputFields: [], outputFields: [] };
}

export const MethodSignature: MessageFns<MethodSignature> = {
  encode(message: MethodSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.methodType !== 0) {
      writer.uint32(16).int32(message.methodType);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.inputFields) {
      ModelTypeField.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.outputFields) {
      ModelTypeField.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.methodType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputFields.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputFields.push(ModelTypeField.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MethodSignature {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      methodType: isSet(object.methodType) ? runnerMethodTypeFromJSON(object.methodType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputFields: globalThis.Array.isArray(object?.inputFields)
        ? object.inputFields.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
      outputFields: globalThis.Array.isArray(object?.outputFields)
        ? object.outputFields.map((e: any) => ModelTypeField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MethodSignature): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.methodType !== 0) {
      obj.methodType = runnerMethodTypeToJSON(message.methodType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputFields?.length) {
      obj.inputFields = message.inputFields.map((e) => ModelTypeField.toJSON(e));
    }
    if (message.outputFields?.length) {
      obj.outputFields = message.outputFields.map((e) => ModelTypeField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MethodSignature>, I>>(base?: I): MethodSignature {
    return MethodSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MethodSignature>, I>>(object: I): MethodSignature {
    const message = createBaseMethodSignature();
    message.name = object.name ?? "";
    message.methodType = object.methodType ?? 0;
    message.description = object.description ?? "";
    message.inputFields = object.inputFields?.map((e) => ModelTypeField.fromPartial(e)) || [];
    message.outputFields = object.outputFields?.map((e) => ModelTypeField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildInfo(): BuildInfo {
  return { dockerImageName: "", dockerImageTag: "", dockerImageDigest: "" };
}

export const BuildInfo: MessageFns<BuildInfo> = {
  encode(message: BuildInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dockerImageName !== "") {
      writer.uint32(10).string(message.dockerImageName);
    }
    if (message.dockerImageTag !== "") {
      writer.uint32(18).string(message.dockerImageTag);
    }
    if (message.dockerImageDigest !== "") {
      writer.uint32(26).string(message.dockerImageDigest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dockerImageName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dockerImageTag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dockerImageDigest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildInfo {
    return {
      dockerImageName: isSet(object.dockerImageName) ? globalThis.String(object.dockerImageName) : "",
      dockerImageTag: isSet(object.dockerImageTag) ? globalThis.String(object.dockerImageTag) : "",
      dockerImageDigest: isSet(object.dockerImageDigest) ? globalThis.String(object.dockerImageDigest) : "",
    };
  },

  toJSON(message: BuildInfo): unknown {
    const obj: any = {};
    if (message.dockerImageName !== "") {
      obj.dockerImageName = message.dockerImageName;
    }
    if (message.dockerImageTag !== "") {
      obj.dockerImageTag = message.dockerImageTag;
    }
    if (message.dockerImageDigest !== "") {
      obj.dockerImageDigest = message.dockerImageDigest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildInfo>, I>>(base?: I): BuildInfo {
    return BuildInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildInfo>, I>>(object: I): BuildInfo {
    const message = createBaseBuildInfo();
    message.dockerImageName = object.dockerImageName ?? "";
    message.dockerImageTag = object.dockerImageTag ?? "";
    message.dockerImageDigest = object.dockerImageDigest ?? "";
    return message;
  },
};

function createBaseModelVersionExport(): ModelVersionExport {
  return { status: undefined, url: "", size: 0 };
}

export const ModelVersionExport: MessageFns<ModelVersionExport> = {
  encode(message: ModelVersionExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.size !== 0) {
      writer.uint32(24).int64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionExport {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: ModelVersionExport): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelVersionExport>, I>>(base?: I): ModelVersionExport {
    return ModelVersionExport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelVersionExport>, I>>(object: I): ModelVersionExport {
    const message = createBaseModelVersionExport();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.url = object.url ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBasePretrainedModelConfig(): PretrainedModelConfig {
  return { inputFieldsMap: undefined, outputFieldsMap: undefined, modelZipUrl: "", localDev: false };
}

export const PretrainedModelConfig: MessageFns<PretrainedModelConfig> = {
  encode(message: PretrainedModelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputFieldsMap !== undefined) {
      Struct.encode(Struct.wrap(message.inputFieldsMap), writer.uint32(26).fork()).join();
    }
    if (message.outputFieldsMap !== undefined) {
      Struct.encode(Struct.wrap(message.outputFieldsMap), writer.uint32(34).fork()).join();
    }
    if (message.modelZipUrl !== "") {
      writer.uint32(50).string(message.modelZipUrl);
    }
    if (message.localDev !== false) {
      writer.uint32(64).bool(message.localDev);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PretrainedModelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePretrainedModelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputFieldsMap = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputFieldsMap = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelZipUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.localDev = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PretrainedModelConfig {
    return {
      inputFieldsMap: isObject(object.inputFieldsMap) ? object.inputFieldsMap : undefined,
      outputFieldsMap: isObject(object.outputFieldsMap) ? object.outputFieldsMap : undefined,
      modelZipUrl: isSet(object.modelZipUrl) ? globalThis.String(object.modelZipUrl) : "",
      localDev: isSet(object.localDev) ? globalThis.Boolean(object.localDev) : false,
    };
  },

  toJSON(message: PretrainedModelConfig): unknown {
    const obj: any = {};
    if (message.inputFieldsMap !== undefined) {
      obj.inputFieldsMap = message.inputFieldsMap;
    }
    if (message.outputFieldsMap !== undefined) {
      obj.outputFieldsMap = message.outputFieldsMap;
    }
    if (message.modelZipUrl !== "") {
      obj.modelZipUrl = message.modelZipUrl;
    }
    if (message.localDev !== false) {
      obj.localDev = message.localDev;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PretrainedModelConfig>, I>>(base?: I): PretrainedModelConfig {
    return PretrainedModelConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PretrainedModelConfig>, I>>(object: I): PretrainedModelConfig {
    const message = createBasePretrainedModelConfig();
    message.inputFieldsMap = object.inputFieldsMap ?? undefined;
    message.outputFieldsMap = object.outputFieldsMap ?? undefined;
    message.modelZipUrl = object.modelZipUrl ?? "";
    message.localDev = object.localDev ?? false;
    return message;
  },
};

function createBaseTrainStats(): TrainStats {
  return { lossCurve: [] };
}

export const TrainStats: MessageFns<TrainStats> = {
  encode(message: TrainStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lossCurve) {
      LossCurveEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lossCurve.push(LossCurveEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainStats {
    return {
      lossCurve: globalThis.Array.isArray(object?.lossCurve)
        ? object.lossCurve.map((e: any) => LossCurveEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrainStats): unknown {
    const obj: any = {};
    if (message.lossCurve?.length) {
      obj.lossCurve = message.lossCurve.map((e) => LossCurveEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainStats>, I>>(base?: I): TrainStats {
    return TrainStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainStats>, I>>(object: I): TrainStats {
    const message = createBaseTrainStats();
    message.lossCurve = object.lossCurve?.map((e) => LossCurveEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLossCurveEntry(): LossCurveEntry {
  return { epoch: 0, globalStep: 0, cost: 0 };
}

export const LossCurveEntry: MessageFns<LossCurveEntry> = {
  encode(message: LossCurveEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch !== 0) {
      writer.uint32(8).uint32(message.epoch);
    }
    if (message.globalStep !== 0) {
      writer.uint32(16).uint32(message.globalStep);
    }
    if (message.cost !== 0) {
      writer.uint32(29).float(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LossCurveEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLossCurveEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.globalStep = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.cost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LossCurveEntry {
    return {
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
      globalStep: isSet(object.globalStep) ? globalThis.Number(object.globalStep) : 0,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
    };
  },

  toJSON(message: LossCurveEntry): unknown {
    const obj: any = {};
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    if (message.globalStep !== 0) {
      obj.globalStep = Math.round(message.globalStep);
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LossCurveEntry>, I>>(base?: I): LossCurveEntry {
    return LossCurveEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LossCurveEntry>, I>>(object: I): LossCurveEntry {
    const message = createBaseLossCurveEntry();
    message.epoch = object.epoch ?? 0;
    message.globalStep = object.globalStep ?? 0;
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseLabelCount(): LabelCount {
  return { conceptName: "", count: 0, concept: undefined };
}

export const LabelCount: MessageFns<LabelCount> = {
  encode(message: LabelCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conceptName !== "") {
      writer.uint32(10).string(message.conceptName);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    if (message.concept !== undefined) {
      Concept.encode(message.concept, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conceptName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.concept = Concept.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelCount {
    return {
      conceptName: isSet(object.conceptName) ? globalThis.String(object.conceptName) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      concept: isSet(object.concept) ? Concept.fromJSON(object.concept) : undefined,
    };
  },

  toJSON(message: LabelCount): unknown {
    const obj: any = {};
    if (message.conceptName !== "") {
      obj.conceptName = message.conceptName;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.concept !== undefined) {
      obj.concept = Concept.toJSON(message.concept);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LabelCount>, I>>(base?: I): LabelCount {
    return LabelCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LabelCount>, I>>(object: I): LabelCount {
    const message = createBaseLabelCount();
    message.conceptName = object.conceptName ?? "";
    message.count = object.count ?? 0;
    message.concept = (object.concept !== undefined && object.concept !== null)
      ? Concept.fromPartial(object.concept)
      : undefined;
    return message;
  },
};

function createBaseLabelDistribution(): LabelDistribution {
  return { positiveLabelCounts: [] };
}

export const LabelDistribution: MessageFns<LabelDistribution> = {
  encode(message: LabelDistribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.positiveLabelCounts) {
      LabelCount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelDistribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positiveLabelCounts.push(LabelCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelDistribution {
    return {
      positiveLabelCounts: globalThis.Array.isArray(object?.positiveLabelCounts)
        ? object.positiveLabelCounts.map((e: any) => LabelCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LabelDistribution): unknown {
    const obj: any = {};
    if (message.positiveLabelCounts?.length) {
      obj.positiveLabelCounts = message.positiveLabelCounts.map((e) => LabelCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LabelDistribution>, I>>(base?: I): LabelDistribution {
    return LabelDistribution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LabelDistribution>, I>>(object: I): LabelDistribution {
    const message = createBaseLabelDistribution();
    message.positiveLabelCounts = object.positiveLabelCounts?.map((e) => LabelCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCooccurrenceMatrixEntry(): CooccurrenceMatrixEntry {
  return { row: "", col: "", count: 0 };
}

export const CooccurrenceMatrixEntry: MessageFns<CooccurrenceMatrixEntry> = {
  encode(message: CooccurrenceMatrixEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== "") {
      writer.uint32(10).string(message.row);
    }
    if (message.col !== "") {
      writer.uint32(18).string(message.col);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooccurrenceMatrixEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooccurrenceMatrixEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.row = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.col = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooccurrenceMatrixEntry {
    return {
      row: isSet(object.row) ? globalThis.String(object.row) : "",
      col: isSet(object.col) ? globalThis.String(object.col) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CooccurrenceMatrixEntry): unknown {
    const obj: any = {};
    if (message.row !== "") {
      obj.row = message.row;
    }
    if (message.col !== "") {
      obj.col = message.col;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CooccurrenceMatrixEntry>, I>>(base?: I): CooccurrenceMatrixEntry {
    return CooccurrenceMatrixEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CooccurrenceMatrixEntry>, I>>(object: I): CooccurrenceMatrixEntry {
    const message = createBaseCooccurrenceMatrixEntry();
    message.row = object.row ?? "";
    message.col = object.col ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCooccurrenceMatrix(): CooccurrenceMatrix {
  return { matrix: [], conceptIds: [] };
}

export const CooccurrenceMatrix: MessageFns<CooccurrenceMatrix> = {
  encode(message: CooccurrenceMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matrix) {
      CooccurrenceMatrixEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.conceptIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooccurrenceMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooccurrenceMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matrix.push(CooccurrenceMatrixEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooccurrenceMatrix {
    return {
      matrix: globalThis.Array.isArray(object?.matrix)
        ? object.matrix.map((e: any) => CooccurrenceMatrixEntry.fromJSON(e))
        : [],
      conceptIds: globalThis.Array.isArray(object?.conceptIds)
        ? object.conceptIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CooccurrenceMatrix): unknown {
    const obj: any = {};
    if (message.matrix?.length) {
      obj.matrix = message.matrix.map((e) => CooccurrenceMatrixEntry.toJSON(e));
    }
    if (message.conceptIds?.length) {
      obj.conceptIds = message.conceptIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CooccurrenceMatrix>, I>>(base?: I): CooccurrenceMatrix {
    return CooccurrenceMatrix.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CooccurrenceMatrix>, I>>(object: I): CooccurrenceMatrix {
    const message = createBaseCooccurrenceMatrix();
    message.matrix = object.matrix?.map((e) => CooccurrenceMatrixEntry.fromPartial(e)) || [];
    message.conceptIds = object.conceptIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseConfusionMatrixEntry(): ConfusionMatrixEntry {
  return { predicted: "", actual: "", value: 0, predictedConcept: undefined, actualConcept: undefined };
}

export const ConfusionMatrixEntry: MessageFns<ConfusionMatrixEntry> = {
  encode(message: ConfusionMatrixEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predicted !== "") {
      writer.uint32(10).string(message.predicted);
    }
    if (message.actual !== "") {
      writer.uint32(18).string(message.actual);
    }
    if (message.value !== 0) {
      writer.uint32(37).float(message.value);
    }
    if (message.predictedConcept !== undefined) {
      Concept.encode(message.predictedConcept, writer.uint32(42).fork()).join();
    }
    if (message.actualConcept !== undefined) {
      Concept.encode(message.actualConcept, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfusionMatrixEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfusionMatrixEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predicted = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actual = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.predictedConcept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actualConcept = Concept.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfusionMatrixEntry {
    return {
      predicted: isSet(object.predicted) ? globalThis.String(object.predicted) : "",
      actual: isSet(object.actual) ? globalThis.String(object.actual) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      predictedConcept: isSet(object.predictedConcept) ? Concept.fromJSON(object.predictedConcept) : undefined,
      actualConcept: isSet(object.actualConcept) ? Concept.fromJSON(object.actualConcept) : undefined,
    };
  },

  toJSON(message: ConfusionMatrixEntry): unknown {
    const obj: any = {};
    if (message.predicted !== "") {
      obj.predicted = message.predicted;
    }
    if (message.actual !== "") {
      obj.actual = message.actual;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.predictedConcept !== undefined) {
      obj.predictedConcept = Concept.toJSON(message.predictedConcept);
    }
    if (message.actualConcept !== undefined) {
      obj.actualConcept = Concept.toJSON(message.actualConcept);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfusionMatrixEntry>, I>>(base?: I): ConfusionMatrixEntry {
    return ConfusionMatrixEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfusionMatrixEntry>, I>>(object: I): ConfusionMatrixEntry {
    const message = createBaseConfusionMatrixEntry();
    message.predicted = object.predicted ?? "";
    message.actual = object.actual ?? "";
    message.value = object.value ?? 0;
    message.predictedConcept = (object.predictedConcept !== undefined && object.predictedConcept !== null)
      ? Concept.fromPartial(object.predictedConcept)
      : undefined;
    message.actualConcept = (object.actualConcept !== undefined && object.actualConcept !== null)
      ? Concept.fromPartial(object.actualConcept)
      : undefined;
    return message;
  },
};

function createBaseConfusionMatrix(): ConfusionMatrix {
  return { matrix: [], conceptIds: [] };
}

export const ConfusionMatrix: MessageFns<ConfusionMatrix> = {
  encode(message: ConfusionMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matrix) {
      ConfusionMatrixEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.conceptIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfusionMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfusionMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matrix.push(ConfusionMatrixEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conceptIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfusionMatrix {
    return {
      matrix: globalThis.Array.isArray(object?.matrix)
        ? object.matrix.map((e: any) => ConfusionMatrixEntry.fromJSON(e))
        : [],
      conceptIds: globalThis.Array.isArray(object?.conceptIds)
        ? object.conceptIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConfusionMatrix): unknown {
    const obj: any = {};
    if (message.matrix?.length) {
      obj.matrix = message.matrix.map((e) => ConfusionMatrixEntry.toJSON(e));
    }
    if (message.conceptIds?.length) {
      obj.conceptIds = message.conceptIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfusionMatrix>, I>>(base?: I): ConfusionMatrix {
    return ConfusionMatrix.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfusionMatrix>, I>>(object: I): ConfusionMatrix {
    const message = createBaseConfusionMatrix();
    message.matrix = object.matrix?.map((e) => ConfusionMatrixEntry.fromPartial(e)) || [];
    message.conceptIds = object.conceptIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseROC(): ROC {
  return { fpr: [], tpr: [], thresholds: [], fprPerImage: [], fprPerObject: [] };
}

export const ROC: MessageFns<ROC> = {
  encode(message: ROC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fpr) {
      writer.uint32(13).float(v!);
    }
    for (const v of message.tpr) {
      writer.uint32(21).float(v!);
    }
    for (const v of message.thresholds) {
      writer.uint32(29).float(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.fprPerImage) {
      writer.float(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.fprPerObject) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ROC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseROC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.fpr.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fpr.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.tpr.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tpr.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 29) {
            message.thresholds.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.thresholds.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 37) {
            message.fprPerImage.push(reader.float());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fprPerImage.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 45) {
            message.fprPerObject.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fprPerObject.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ROC {
    return {
      fpr: globalThis.Array.isArray(object?.fpr) ? object.fpr.map((e: any) => globalThis.Number(e)) : [],
      tpr: globalThis.Array.isArray(object?.tpr) ? object.tpr.map((e: any) => globalThis.Number(e)) : [],
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => globalThis.Number(e))
        : [],
      fprPerImage: globalThis.Array.isArray(object?.fprPerImage)
        ? object.fprPerImage.map((e: any) => globalThis.Number(e))
        : [],
      fprPerObject: globalThis.Array.isArray(object?.fprPerObject)
        ? object.fprPerObject.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ROC): unknown {
    const obj: any = {};
    if (message.fpr?.length) {
      obj.fpr = message.fpr;
    }
    if (message.tpr?.length) {
      obj.tpr = message.tpr;
    }
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds;
    }
    if (message.fprPerImage?.length) {
      obj.fprPerImage = message.fprPerImage;
    }
    if (message.fprPerObject?.length) {
      obj.fprPerObject = message.fprPerObject;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ROC>, I>>(base?: I): ROC {
    return ROC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ROC>, I>>(object: I): ROC {
    const message = createBaseROC();
    message.fpr = object.fpr?.map((e) => e) || [];
    message.tpr = object.tpr?.map((e) => e) || [];
    message.thresholds = object.thresholds?.map((e) => e) || [];
    message.fprPerImage = object.fprPerImage?.map((e) => e) || [];
    message.fprPerObject = object.fprPerObject?.map((e) => e) || [];
    return message;
  },
};

function createBasePrecisionRecallCurve(): PrecisionRecallCurve {
  return { recall: [], precision: [], thresholds: [] };
}

export const PrecisionRecallCurve: MessageFns<PrecisionRecallCurve> = {
  encode(message: PrecisionRecallCurve, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recall) {
      writer.uint32(13).float(v!);
    }
    for (const v of message.precision) {
      writer.uint32(21).float(v!);
    }
    for (const v of message.thresholds) {
      writer.uint32(29).float(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrecisionRecallCurve {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrecisionRecallCurve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.recall.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.recall.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.precision.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.precision.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 29) {
            message.thresholds.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.thresholds.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrecisionRecallCurve {
    return {
      recall: globalThis.Array.isArray(object?.recall) ? object.recall.map((e: any) => globalThis.Number(e)) : [],
      precision: globalThis.Array.isArray(object?.precision)
        ? object.precision.map((e: any) => globalThis.Number(e))
        : [],
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PrecisionRecallCurve): unknown {
    const obj: any = {};
    if (message.recall?.length) {
      obj.recall = message.recall;
    }
    if (message.precision?.length) {
      obj.precision = message.precision;
    }
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrecisionRecallCurve>, I>>(base?: I): PrecisionRecallCurve {
    return PrecisionRecallCurve.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrecisionRecallCurve>, I>>(object: I): PrecisionRecallCurve {
    const message = createBasePrecisionRecallCurve();
    message.recall = object.recall?.map((e) => e) || [];
    message.precision = object.precision?.map((e) => e) || [];
    message.thresholds = object.thresholds?.map((e) => e) || [];
    return message;
  },
};

function createBaseBinaryMetrics(): BinaryMetrics {
  return {
    numPos: 0,
    numNeg: 0,
    numTot: 0,
    rocAuc: 0,
    f1: 0,
    concept: undefined,
    rocCurve: undefined,
    precisionRecallCurve: undefined,
    avgPrecision: 0,
    areaName: "",
    areaMin: 0,
    areaMax: 0,
    iou: 0,
  };
}

export const BinaryMetrics: MessageFns<BinaryMetrics> = {
  encode(message: BinaryMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numPos !== 0) {
      writer.uint32(8).uint32(message.numPos);
    }
    if (message.numNeg !== 0) {
      writer.uint32(16).uint32(message.numNeg);
    }
    if (message.numTot !== 0) {
      writer.uint32(24).uint32(message.numTot);
    }
    if (message.rocAuc !== 0) {
      writer.uint32(37).float(message.rocAuc);
    }
    if (message.f1 !== 0) {
      writer.uint32(45).float(message.f1);
    }
    if (message.concept !== undefined) {
      Concept.encode(message.concept, writer.uint32(50).fork()).join();
    }
    if (message.rocCurve !== undefined) {
      ROC.encode(message.rocCurve, writer.uint32(58).fork()).join();
    }
    if (message.precisionRecallCurve !== undefined) {
      PrecisionRecallCurve.encode(message.precisionRecallCurve, writer.uint32(66).fork()).join();
    }
    if (message.avgPrecision !== 0) {
      writer.uint32(77).float(message.avgPrecision);
    }
    if (message.areaName !== "") {
      writer.uint32(82).string(message.areaName);
    }
    if (message.areaMin !== 0) {
      writer.uint32(89).double(message.areaMin);
    }
    if (message.areaMax !== 0) {
      writer.uint32(97).double(message.areaMax);
    }
    if (message.iou !== 0) {
      writer.uint32(109).float(message.iou);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numPos = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numNeg = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numTot = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.rocAuc = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.f1 = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.concept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rocCurve = ROC.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.precisionRecallCurve = PrecisionRecallCurve.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.avgPrecision = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.areaName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.areaMin = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.areaMax = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.iou = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryMetrics {
    return {
      numPos: isSet(object.numPos) ? globalThis.Number(object.numPos) : 0,
      numNeg: isSet(object.numNeg) ? globalThis.Number(object.numNeg) : 0,
      numTot: isSet(object.numTot) ? globalThis.Number(object.numTot) : 0,
      rocAuc: isSet(object.rocAuc) ? globalThis.Number(object.rocAuc) : 0,
      f1: isSet(object.f1) ? globalThis.Number(object.f1) : 0,
      concept: isSet(object.concept) ? Concept.fromJSON(object.concept) : undefined,
      rocCurve: isSet(object.rocCurve) ? ROC.fromJSON(object.rocCurve) : undefined,
      precisionRecallCurve: isSet(object.precisionRecallCurve)
        ? PrecisionRecallCurve.fromJSON(object.precisionRecallCurve)
        : undefined,
      avgPrecision: isSet(object.avgPrecision) ? globalThis.Number(object.avgPrecision) : 0,
      areaName: isSet(object.areaName) ? globalThis.String(object.areaName) : "",
      areaMin: isSet(object.areaMin) ? globalThis.Number(object.areaMin) : 0,
      areaMax: isSet(object.areaMax) ? globalThis.Number(object.areaMax) : 0,
      iou: isSet(object.iou) ? globalThis.Number(object.iou) : 0,
    };
  },

  toJSON(message: BinaryMetrics): unknown {
    const obj: any = {};
    if (message.numPos !== 0) {
      obj.numPos = Math.round(message.numPos);
    }
    if (message.numNeg !== 0) {
      obj.numNeg = Math.round(message.numNeg);
    }
    if (message.numTot !== 0) {
      obj.numTot = Math.round(message.numTot);
    }
    if (message.rocAuc !== 0) {
      obj.rocAuc = message.rocAuc;
    }
    if (message.f1 !== 0) {
      obj.f1 = message.f1;
    }
    if (message.concept !== undefined) {
      obj.concept = Concept.toJSON(message.concept);
    }
    if (message.rocCurve !== undefined) {
      obj.rocCurve = ROC.toJSON(message.rocCurve);
    }
    if (message.precisionRecallCurve !== undefined) {
      obj.precisionRecallCurve = PrecisionRecallCurve.toJSON(message.precisionRecallCurve);
    }
    if (message.avgPrecision !== 0) {
      obj.avgPrecision = message.avgPrecision;
    }
    if (message.areaName !== "") {
      obj.areaName = message.areaName;
    }
    if (message.areaMin !== 0) {
      obj.areaMin = message.areaMin;
    }
    if (message.areaMax !== 0) {
      obj.areaMax = message.areaMax;
    }
    if (message.iou !== 0) {
      obj.iou = message.iou;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BinaryMetrics>, I>>(base?: I): BinaryMetrics {
    return BinaryMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BinaryMetrics>, I>>(object: I): BinaryMetrics {
    const message = createBaseBinaryMetrics();
    message.numPos = object.numPos ?? 0;
    message.numNeg = object.numNeg ?? 0;
    message.numTot = object.numTot ?? 0;
    message.rocAuc = object.rocAuc ?? 0;
    message.f1 = object.f1 ?? 0;
    message.concept = (object.concept !== undefined && object.concept !== null)
      ? Concept.fromPartial(object.concept)
      : undefined;
    message.rocCurve = (object.rocCurve !== undefined && object.rocCurve !== null)
      ? ROC.fromPartial(object.rocCurve)
      : undefined;
    message.precisionRecallCurve = (object.precisionRecallCurve !== undefined && object.precisionRecallCurve !== null)
      ? PrecisionRecallCurve.fromPartial(object.precisionRecallCurve)
      : undefined;
    message.avgPrecision = object.avgPrecision ?? 0;
    message.areaName = object.areaName ?? "";
    message.areaMin = object.areaMin ?? 0;
    message.areaMax = object.areaMax ?? 0;
    message.iou = object.iou ?? 0;
    return message;
  },
};

function createBaseTrackerMetrics(): TrackerMetrics {
  return { motMota: 0, motNumSwitches: 0, morseFrag: 0, avgPrecision: 0, aiid: "", uniqueSwitchRate: 0 };
}

export const TrackerMetrics: MessageFns<TrackerMetrics> = {
  encode(message: TrackerMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.motMota !== 0) {
      writer.uint32(13).float(message.motMota);
    }
    if (message.motNumSwitches !== 0) {
      writer.uint32(16).int32(message.motNumSwitches);
    }
    if (message.morseFrag !== 0) {
      writer.uint32(29).float(message.morseFrag);
    }
    if (message.avgPrecision !== 0) {
      writer.uint32(37).float(message.avgPrecision);
    }
    if (message.aiid !== "") {
      writer.uint32(42).string(message.aiid);
    }
    if (message.uniqueSwitchRate !== 0) {
      writer.uint32(53).float(message.uniqueSwitchRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackerMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackerMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.motMota = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.motNumSwitches = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.morseFrag = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.avgPrecision = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aiid = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.uniqueSwitchRate = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackerMetrics {
    return {
      motMota: isSet(object.motMota) ? globalThis.Number(object.motMota) : 0,
      motNumSwitches: isSet(object.motNumSwitches) ? globalThis.Number(object.motNumSwitches) : 0,
      morseFrag: isSet(object.morseFrag) ? globalThis.Number(object.morseFrag) : 0,
      avgPrecision: isSet(object.avgPrecision) ? globalThis.Number(object.avgPrecision) : 0,
      aiid: isSet(object.aiid) ? globalThis.String(object.aiid) : "",
      uniqueSwitchRate: isSet(object.uniqueSwitchRate) ? globalThis.Number(object.uniqueSwitchRate) : 0,
    };
  },

  toJSON(message: TrackerMetrics): unknown {
    const obj: any = {};
    if (message.motMota !== 0) {
      obj.motMota = message.motMota;
    }
    if (message.motNumSwitches !== 0) {
      obj.motNumSwitches = Math.round(message.motNumSwitches);
    }
    if (message.morseFrag !== 0) {
      obj.morseFrag = message.morseFrag;
    }
    if (message.avgPrecision !== 0) {
      obj.avgPrecision = message.avgPrecision;
    }
    if (message.aiid !== "") {
      obj.aiid = message.aiid;
    }
    if (message.uniqueSwitchRate !== 0) {
      obj.uniqueSwitchRate = message.uniqueSwitchRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackerMetrics>, I>>(base?: I): TrackerMetrics {
    return TrackerMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackerMetrics>, I>>(object: I): TrackerMetrics {
    const message = createBaseTrackerMetrics();
    message.motMota = object.motMota ?? 0;
    message.motNumSwitches = object.motNumSwitches ?? 0;
    message.morseFrag = object.morseFrag ?? 0;
    message.avgPrecision = object.avgPrecision ?? 0;
    message.aiid = object.aiid ?? "";
    message.uniqueSwitchRate = object.uniqueSwitchRate ?? 0;
    return message;
  },
};

function createBaseEvalTestSetEntry(): EvalTestSetEntry {
  return {
    input: undefined,
    predictedConcepts: [],
    groundTruthConcepts: [],
    annotation: undefined,
    predictedAnnotation: undefined,
    groundTruthAnnotation: undefined,
  };
}

export const EvalTestSetEntry: MessageFns<EvalTestSetEntry> = {
  encode(message: EvalTestSetEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(50).fork()).join();
    }
    for (const v of message.predictedConcepts) {
      Concept.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.groundTruthConcepts) {
      Concept.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(42).fork()).join();
    }
    if (message.predictedAnnotation !== undefined) {
      Annotation.encode(message.predictedAnnotation, writer.uint32(58).fork()).join();
    }
    if (message.groundTruthAnnotation !== undefined) {
      Annotation.encode(message.groundTruthAnnotation, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalTestSetEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalTestSetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predictedConcepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groundTruthConcepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.predictedAnnotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.groundTruthAnnotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalTestSetEntry {
    return {
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      predictedConcepts: globalThis.Array.isArray(object?.predictedConcepts)
        ? object.predictedConcepts.map((e: any) => Concept.fromJSON(e))
        : [],
      groundTruthConcepts: globalThis.Array.isArray(object?.groundTruthConcepts)
        ? object.groundTruthConcepts.map((e: any) => Concept.fromJSON(e))
        : [],
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      predictedAnnotation: isSet(object.predictedAnnotation)
        ? Annotation.fromJSON(object.predictedAnnotation)
        : undefined,
      groundTruthAnnotation: isSet(object.groundTruthAnnotation)
        ? Annotation.fromJSON(object.groundTruthAnnotation)
        : undefined,
    };
  },

  toJSON(message: EvalTestSetEntry): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.predictedConcepts?.length) {
      obj.predictedConcepts = message.predictedConcepts.map((e) => Concept.toJSON(e));
    }
    if (message.groundTruthConcepts?.length) {
      obj.groundTruthConcepts = message.groundTruthConcepts.map((e) => Concept.toJSON(e));
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.predictedAnnotation !== undefined) {
      obj.predictedAnnotation = Annotation.toJSON(message.predictedAnnotation);
    }
    if (message.groundTruthAnnotation !== undefined) {
      obj.groundTruthAnnotation = Annotation.toJSON(message.groundTruthAnnotation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalTestSetEntry>, I>>(base?: I): EvalTestSetEntry {
    return EvalTestSetEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalTestSetEntry>, I>>(object: I): EvalTestSetEntry {
    const message = createBaseEvalTestSetEntry();
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.predictedConcepts = object.predictedConcepts?.map((e) => Concept.fromPartial(e)) || [];
    message.groundTruthConcepts = object.groundTruthConcepts?.map((e) => Concept.fromPartial(e)) || [];
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.predictedAnnotation = (object.predictedAnnotation !== undefined && object.predictedAnnotation !== null)
      ? Annotation.fromPartial(object.predictedAnnotation)
      : undefined;
    message.groundTruthAnnotation =
      (object.groundTruthAnnotation !== undefined && object.groundTruthAnnotation !== null)
        ? Annotation.fromPartial(object.groundTruthAnnotation)
        : undefined;
    return message;
  },
};

function createBaseLOPQEvalResult(): LOPQEvalResult {
  return {
    k: 0,
    recallVsBruteForce: 0,
    kendallTauVsBruteForce: 0,
    mostFrequentCodePercent: 0,
    lopqNdcg: 0,
    bruteForceNdcg: 0,
  };
}

export const LOPQEvalResult: MessageFns<LOPQEvalResult> = {
  encode(message: LOPQEvalResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.k !== 0) {
      writer.uint32(8).int32(message.k);
    }
    if (message.recallVsBruteForce !== 0) {
      writer.uint32(21).float(message.recallVsBruteForce);
    }
    if (message.kendallTauVsBruteForce !== 0) {
      writer.uint32(29).float(message.kendallTauVsBruteForce);
    }
    if (message.mostFrequentCodePercent !== 0) {
      writer.uint32(37).float(message.mostFrequentCodePercent);
    }
    if (message.lopqNdcg !== 0) {
      writer.uint32(45).float(message.lopqNdcg);
    }
    if (message.bruteForceNdcg !== 0) {
      writer.uint32(53).float(message.bruteForceNdcg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LOPQEvalResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLOPQEvalResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.k = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.recallVsBruteForce = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.kendallTauVsBruteForce = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.mostFrequentCodePercent = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.lopqNdcg = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.bruteForceNdcg = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LOPQEvalResult {
    return {
      k: isSet(object.k) ? globalThis.Number(object.k) : 0,
      recallVsBruteForce: isSet(object.recallVsBruteForce) ? globalThis.Number(object.recallVsBruteForce) : 0,
      kendallTauVsBruteForce: isSet(object.kendallTauVsBruteForce)
        ? globalThis.Number(object.kendallTauVsBruteForce)
        : 0,
      mostFrequentCodePercent: isSet(object.mostFrequentCodePercent)
        ? globalThis.Number(object.mostFrequentCodePercent)
        : 0,
      lopqNdcg: isSet(object.lopqNdcg) ? globalThis.Number(object.lopqNdcg) : 0,
      bruteForceNdcg: isSet(object.bruteForceNdcg) ? globalThis.Number(object.bruteForceNdcg) : 0,
    };
  },

  toJSON(message: LOPQEvalResult): unknown {
    const obj: any = {};
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    if (message.recallVsBruteForce !== 0) {
      obj.recallVsBruteForce = message.recallVsBruteForce;
    }
    if (message.kendallTauVsBruteForce !== 0) {
      obj.kendallTauVsBruteForce = message.kendallTauVsBruteForce;
    }
    if (message.mostFrequentCodePercent !== 0) {
      obj.mostFrequentCodePercent = message.mostFrequentCodePercent;
    }
    if (message.lopqNdcg !== 0) {
      obj.lopqNdcg = message.lopqNdcg;
    }
    if (message.bruteForceNdcg !== 0) {
      obj.bruteForceNdcg = message.bruteForceNdcg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LOPQEvalResult>, I>>(base?: I): LOPQEvalResult {
    return LOPQEvalResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LOPQEvalResult>, I>>(object: I): LOPQEvalResult {
    const message = createBaseLOPQEvalResult();
    message.k = object.k ?? 0;
    message.recallVsBruteForce = object.recallVsBruteForce ?? 0;
    message.kendallTauVsBruteForce = object.kendallTauVsBruteForce ?? 0;
    message.mostFrequentCodePercent = object.mostFrequentCodePercent ?? 0;
    message.lopqNdcg = object.lopqNdcg ?? 0;
    message.bruteForceNdcg = object.bruteForceNdcg ?? 0;
    return message;
  },
};

function createBaseMetricsSummary(): MetricsSummary {
  return {
    top1Accuracy: 0,
    top5Accuracy: 0,
    macroAvgRocAuc: 0,
    macroStdRocAuc: 0,
    macroAvgF1Score: 0,
    macroStdF1Score: 0,
    macroAvgPrecision: 0,
    macroAvgRecall: 0,
    meanAvgPrecisionIou50: 0,
    meanAvgPrecisionIouRange: 0,
    lopqMetrics: [],
  };
}

export const MetricsSummary: MessageFns<MetricsSummary> = {
  encode(message: MetricsSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.top1Accuracy !== 0) {
      writer.uint32(13).float(message.top1Accuracy);
    }
    if (message.top5Accuracy !== 0) {
      writer.uint32(21).float(message.top5Accuracy);
    }
    if (message.macroAvgRocAuc !== 0) {
      writer.uint32(29).float(message.macroAvgRocAuc);
    }
    if (message.macroStdRocAuc !== 0) {
      writer.uint32(37).float(message.macroStdRocAuc);
    }
    if (message.macroAvgF1Score !== 0) {
      writer.uint32(45).float(message.macroAvgF1Score);
    }
    if (message.macroStdF1Score !== 0) {
      writer.uint32(53).float(message.macroStdF1Score);
    }
    if (message.macroAvgPrecision !== 0) {
      writer.uint32(61).float(message.macroAvgPrecision);
    }
    if (message.macroAvgRecall !== 0) {
      writer.uint32(69).float(message.macroAvgRecall);
    }
    if (message.meanAvgPrecisionIou50 !== 0) {
      writer.uint32(85).float(message.meanAvgPrecisionIou50);
    }
    if (message.meanAvgPrecisionIouRange !== 0) {
      writer.uint32(93).float(message.meanAvgPrecisionIouRange);
    }
    for (const v of message.lopqMetrics) {
      LOPQEvalResult.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricsSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.top1Accuracy = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.top5Accuracy = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.macroAvgRocAuc = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.macroStdRocAuc = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.macroAvgF1Score = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.macroStdF1Score = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.macroAvgPrecision = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.macroAvgRecall = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.meanAvgPrecisionIou50 = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.meanAvgPrecisionIouRange = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lopqMetrics.push(LOPQEvalResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricsSummary {
    return {
      top1Accuracy: isSet(object.top1Accuracy) ? globalThis.Number(object.top1Accuracy) : 0,
      top5Accuracy: isSet(object.top5Accuracy) ? globalThis.Number(object.top5Accuracy) : 0,
      macroAvgRocAuc: isSet(object.macroAvgRocAuc) ? globalThis.Number(object.macroAvgRocAuc) : 0,
      macroStdRocAuc: isSet(object.macroStdRocAuc) ? globalThis.Number(object.macroStdRocAuc) : 0,
      macroAvgF1Score: isSet(object.macroAvgF1Score) ? globalThis.Number(object.macroAvgF1Score) : 0,
      macroStdF1Score: isSet(object.macroStdF1Score) ? globalThis.Number(object.macroStdF1Score) : 0,
      macroAvgPrecision: isSet(object.macroAvgPrecision) ? globalThis.Number(object.macroAvgPrecision) : 0,
      macroAvgRecall: isSet(object.macroAvgRecall) ? globalThis.Number(object.macroAvgRecall) : 0,
      meanAvgPrecisionIou50: isSet(object.meanAvgPrecisionIou50) ? globalThis.Number(object.meanAvgPrecisionIou50) : 0,
      meanAvgPrecisionIouRange: isSet(object.meanAvgPrecisionIouRange)
        ? globalThis.Number(object.meanAvgPrecisionIouRange)
        : 0,
      lopqMetrics: globalThis.Array.isArray(object?.lopqMetrics)
        ? object.lopqMetrics.map((e: any) => LOPQEvalResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricsSummary): unknown {
    const obj: any = {};
    if (message.top1Accuracy !== 0) {
      obj.top1Accuracy = message.top1Accuracy;
    }
    if (message.top5Accuracy !== 0) {
      obj.top5Accuracy = message.top5Accuracy;
    }
    if (message.macroAvgRocAuc !== 0) {
      obj.macroAvgRocAuc = message.macroAvgRocAuc;
    }
    if (message.macroStdRocAuc !== 0) {
      obj.macroStdRocAuc = message.macroStdRocAuc;
    }
    if (message.macroAvgF1Score !== 0) {
      obj.macroAvgF1Score = message.macroAvgF1Score;
    }
    if (message.macroStdF1Score !== 0) {
      obj.macroStdF1Score = message.macroStdF1Score;
    }
    if (message.macroAvgPrecision !== 0) {
      obj.macroAvgPrecision = message.macroAvgPrecision;
    }
    if (message.macroAvgRecall !== 0) {
      obj.macroAvgRecall = message.macroAvgRecall;
    }
    if (message.meanAvgPrecisionIou50 !== 0) {
      obj.meanAvgPrecisionIou50 = message.meanAvgPrecisionIou50;
    }
    if (message.meanAvgPrecisionIouRange !== 0) {
      obj.meanAvgPrecisionIouRange = message.meanAvgPrecisionIouRange;
    }
    if (message.lopqMetrics?.length) {
      obj.lopqMetrics = message.lopqMetrics.map((e) => LOPQEvalResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsSummary>, I>>(base?: I): MetricsSummary {
    return MetricsSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsSummary>, I>>(object: I): MetricsSummary {
    const message = createBaseMetricsSummary();
    message.top1Accuracy = object.top1Accuracy ?? 0;
    message.top5Accuracy = object.top5Accuracy ?? 0;
    message.macroAvgRocAuc = object.macroAvgRocAuc ?? 0;
    message.macroStdRocAuc = object.macroStdRocAuc ?? 0;
    message.macroAvgF1Score = object.macroAvgF1Score ?? 0;
    message.macroStdF1Score = object.macroStdF1Score ?? 0;
    message.macroAvgPrecision = object.macroAvgPrecision ?? 0;
    message.macroAvgRecall = object.macroAvgRecall ?? 0;
    message.meanAvgPrecisionIou50 = object.meanAvgPrecisionIou50 ?? 0;
    message.meanAvgPrecisionIouRange = object.meanAvgPrecisionIouRange ?? 0;
    message.lopqMetrics = object.lopqMetrics?.map((e) => LOPQEvalResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvalMetrics(): EvalMetrics {
  return {
    status: undefined,
    userId: "",
    appId: "",
    id: "",
    model: undefined,
    groundTruthDataset: undefined,
    predictionsDataset: undefined,
    summary: undefined,
    confusionMatrix: undefined,
    cooccurrenceMatrix: undefined,
    labelCounts: undefined,
    binaryMetrics: [],
    testSet: [],
    metricsByArea: [],
    metricsByClass: [],
    trackerMetrics: [],
    evalInfo: undefined,
    extendedMetrics: undefined,
  };
}

export const EvalMetrics: MessageFns<EvalMetrics> = {
  encode(message: EvalMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(122).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(130).string(message.appId);
    }
    if (message.id !== "") {
      writer.uint32(82).string(message.id);
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(106).fork()).join();
    }
    if (message.groundTruthDataset !== undefined) {
      Dataset.encode(message.groundTruthDataset, writer.uint32(114).fork()).join();
    }
    if (message.predictionsDataset !== undefined) {
      Dataset.encode(message.predictionsDataset, writer.uint32(146).fork()).join();
    }
    if (message.summary !== undefined) {
      MetricsSummary.encode(message.summary, writer.uint32(18).fork()).join();
    }
    if (message.confusionMatrix !== undefined) {
      ConfusionMatrix.encode(message.confusionMatrix, writer.uint32(26).fork()).join();
    }
    if (message.cooccurrenceMatrix !== undefined) {
      CooccurrenceMatrix.encode(message.cooccurrenceMatrix, writer.uint32(34).fork()).join();
    }
    if (message.labelCounts !== undefined) {
      LabelDistribution.encode(message.labelCounts, writer.uint32(42).fork()).join();
    }
    for (const v of message.binaryMetrics) {
      BinaryMetrics.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.testSet) {
      EvalTestSetEntry.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.metricsByArea) {
      BinaryMetrics.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.metricsByClass) {
      BinaryMetrics.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.trackerMetrics) {
      TrackerMetrics.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.evalInfo !== undefined) {
      EvalInfo.encode(message.evalInfo, writer.uint32(98).fork()).join();
    }
    if (message.extendedMetrics !== undefined) {
      ExtendedMetrics.encode(message.extendedMetrics, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.groundTruthDataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.predictionsDataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = MetricsSummary.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confusionMatrix = ConfusionMatrix.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cooccurrenceMatrix = CooccurrenceMatrix.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labelCounts = LabelDistribution.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.binaryMetrics.push(BinaryMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testSet.push(EvalTestSetEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metricsByArea.push(BinaryMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metricsByClass.push(BinaryMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.trackerMetrics.push(TrackerMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.evalInfo = EvalInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.extendedMetrics = ExtendedMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalMetrics {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      groundTruthDataset: isSet(object.groundTruthDataset) ? Dataset.fromJSON(object.groundTruthDataset) : undefined,
      predictionsDataset: isSet(object.predictionsDataset) ? Dataset.fromJSON(object.predictionsDataset) : undefined,
      summary: isSet(object.summary) ? MetricsSummary.fromJSON(object.summary) : undefined,
      confusionMatrix: isSet(object.confusionMatrix) ? ConfusionMatrix.fromJSON(object.confusionMatrix) : undefined,
      cooccurrenceMatrix: isSet(object.cooccurrenceMatrix)
        ? CooccurrenceMatrix.fromJSON(object.cooccurrenceMatrix)
        : undefined,
      labelCounts: isSet(object.labelCounts) ? LabelDistribution.fromJSON(object.labelCounts) : undefined,
      binaryMetrics: globalThis.Array.isArray(object?.binaryMetrics)
        ? object.binaryMetrics.map((e: any) => BinaryMetrics.fromJSON(e))
        : [],
      testSet: globalThis.Array.isArray(object?.testSet)
        ? object.testSet.map((e: any) => EvalTestSetEntry.fromJSON(e))
        : [],
      metricsByArea: globalThis.Array.isArray(object?.metricsByArea)
        ? object.metricsByArea.map((e: any) => BinaryMetrics.fromJSON(e))
        : [],
      metricsByClass: globalThis.Array.isArray(object?.metricsByClass)
        ? object.metricsByClass.map((e: any) => BinaryMetrics.fromJSON(e))
        : [],
      trackerMetrics: globalThis.Array.isArray(object?.trackerMetrics)
        ? object.trackerMetrics.map((e: any) => TrackerMetrics.fromJSON(e))
        : [],
      evalInfo: isSet(object.evalInfo) ? EvalInfo.fromJSON(object.evalInfo) : undefined,
      extendedMetrics: isSet(object.extendedMetrics) ? ExtendedMetrics.fromJSON(object.extendedMetrics) : undefined,
    };
  },

  toJSON(message: EvalMetrics): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.groundTruthDataset !== undefined) {
      obj.groundTruthDataset = Dataset.toJSON(message.groundTruthDataset);
    }
    if (message.predictionsDataset !== undefined) {
      obj.predictionsDataset = Dataset.toJSON(message.predictionsDataset);
    }
    if (message.summary !== undefined) {
      obj.summary = MetricsSummary.toJSON(message.summary);
    }
    if (message.confusionMatrix !== undefined) {
      obj.confusionMatrix = ConfusionMatrix.toJSON(message.confusionMatrix);
    }
    if (message.cooccurrenceMatrix !== undefined) {
      obj.cooccurrenceMatrix = CooccurrenceMatrix.toJSON(message.cooccurrenceMatrix);
    }
    if (message.labelCounts !== undefined) {
      obj.labelCounts = LabelDistribution.toJSON(message.labelCounts);
    }
    if (message.binaryMetrics?.length) {
      obj.binaryMetrics = message.binaryMetrics.map((e) => BinaryMetrics.toJSON(e));
    }
    if (message.testSet?.length) {
      obj.testSet = message.testSet.map((e) => EvalTestSetEntry.toJSON(e));
    }
    if (message.metricsByArea?.length) {
      obj.metricsByArea = message.metricsByArea.map((e) => BinaryMetrics.toJSON(e));
    }
    if (message.metricsByClass?.length) {
      obj.metricsByClass = message.metricsByClass.map((e) => BinaryMetrics.toJSON(e));
    }
    if (message.trackerMetrics?.length) {
      obj.trackerMetrics = message.trackerMetrics.map((e) => TrackerMetrics.toJSON(e));
    }
    if (message.evalInfo !== undefined) {
      obj.evalInfo = EvalInfo.toJSON(message.evalInfo);
    }
    if (message.extendedMetrics !== undefined) {
      obj.extendedMetrics = ExtendedMetrics.toJSON(message.extendedMetrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalMetrics>, I>>(base?: I): EvalMetrics {
    return EvalMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalMetrics>, I>>(object: I): EvalMetrics {
    const message = createBaseEvalMetrics();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.id = object.id ?? "";
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.groundTruthDataset = (object.groundTruthDataset !== undefined && object.groundTruthDataset !== null)
      ? Dataset.fromPartial(object.groundTruthDataset)
      : undefined;
    message.predictionsDataset = (object.predictionsDataset !== undefined && object.predictionsDataset !== null)
      ? Dataset.fromPartial(object.predictionsDataset)
      : undefined;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? MetricsSummary.fromPartial(object.summary)
      : undefined;
    message.confusionMatrix = (object.confusionMatrix !== undefined && object.confusionMatrix !== null)
      ? ConfusionMatrix.fromPartial(object.confusionMatrix)
      : undefined;
    message.cooccurrenceMatrix = (object.cooccurrenceMatrix !== undefined && object.cooccurrenceMatrix !== null)
      ? CooccurrenceMatrix.fromPartial(object.cooccurrenceMatrix)
      : undefined;
    message.labelCounts = (object.labelCounts !== undefined && object.labelCounts !== null)
      ? LabelDistribution.fromPartial(object.labelCounts)
      : undefined;
    message.binaryMetrics = object.binaryMetrics?.map((e) => BinaryMetrics.fromPartial(e)) || [];
    message.testSet = object.testSet?.map((e) => EvalTestSetEntry.fromPartial(e)) || [];
    message.metricsByArea = object.metricsByArea?.map((e) => BinaryMetrics.fromPartial(e)) || [];
    message.metricsByClass = object.metricsByClass?.map((e) => BinaryMetrics.fromPartial(e)) || [];
    message.trackerMetrics = object.trackerMetrics?.map((e) => TrackerMetrics.fromPartial(e)) || [];
    message.evalInfo = (object.evalInfo !== undefined && object.evalInfo !== null)
      ? EvalInfo.fromPartial(object.evalInfo)
      : undefined;
    message.extendedMetrics = (object.extendedMetrics !== undefined && object.extendedMetrics !== null)
      ? ExtendedMetrics.fromPartial(object.extendedMetrics)
      : undefined;
    return message;
  },
};

function createBaseExtendedMetrics(): ExtendedMetrics {
  return { userMetrics: undefined };
}

export const ExtendedMetrics: MessageFns<ExtendedMetrics> = {
  encode(message: ExtendedMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userMetrics !== undefined) {
      Struct.encode(Struct.wrap(message.userMetrics), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendedMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMetrics = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedMetrics {
    return { userMetrics: isObject(object.userMetrics) ? object.userMetrics : undefined };
  },

  toJSON(message: ExtendedMetrics): unknown {
    const obj: any = {};
    if (message.userMetrics !== undefined) {
      obj.userMetrics = message.userMetrics;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtendedMetrics>, I>>(base?: I): ExtendedMetrics {
    return ExtendedMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtendedMetrics>, I>>(object: I): ExtendedMetrics {
    const message = createBaseExtendedMetrics();
    message.userMetrics = object.userMetrics ?? undefined;
    return message;
  },
};

function createBaseFieldsValue(): FieldsValue {
  return {
    confusionMatrix: false,
    cooccurrenceMatrix: false,
    labelCounts: false,
    binaryMetrics: false,
    testSet: false,
    metricsByArea: false,
    metricsByClass: false,
  };
}

export const FieldsValue: MessageFns<FieldsValue> = {
  encode(message: FieldsValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confusionMatrix !== false) {
      writer.uint32(8).bool(message.confusionMatrix);
    }
    if (message.cooccurrenceMatrix !== false) {
      writer.uint32(16).bool(message.cooccurrenceMatrix);
    }
    if (message.labelCounts !== false) {
      writer.uint32(24).bool(message.labelCounts);
    }
    if (message.binaryMetrics !== false) {
      writer.uint32(32).bool(message.binaryMetrics);
    }
    if (message.testSet !== false) {
      writer.uint32(40).bool(message.testSet);
    }
    if (message.metricsByArea !== false) {
      writer.uint32(48).bool(message.metricsByArea);
    }
    if (message.metricsByClass !== false) {
      writer.uint32(56).bool(message.metricsByClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldsValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldsValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.confusionMatrix = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cooccurrenceMatrix = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.labelCounts = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.binaryMetrics = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.testSet = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.metricsByArea = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.metricsByClass = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldsValue {
    return {
      confusionMatrix: isSet(object.confusionMatrix) ? globalThis.Boolean(object.confusionMatrix) : false,
      cooccurrenceMatrix: isSet(object.cooccurrenceMatrix) ? globalThis.Boolean(object.cooccurrenceMatrix) : false,
      labelCounts: isSet(object.labelCounts) ? globalThis.Boolean(object.labelCounts) : false,
      binaryMetrics: isSet(object.binaryMetrics) ? globalThis.Boolean(object.binaryMetrics) : false,
      testSet: isSet(object.testSet) ? globalThis.Boolean(object.testSet) : false,
      metricsByArea: isSet(object.metricsByArea) ? globalThis.Boolean(object.metricsByArea) : false,
      metricsByClass: isSet(object.metricsByClass) ? globalThis.Boolean(object.metricsByClass) : false,
    };
  },

  toJSON(message: FieldsValue): unknown {
    const obj: any = {};
    if (message.confusionMatrix !== false) {
      obj.confusionMatrix = message.confusionMatrix;
    }
    if (message.cooccurrenceMatrix !== false) {
      obj.cooccurrenceMatrix = message.cooccurrenceMatrix;
    }
    if (message.labelCounts !== false) {
      obj.labelCounts = message.labelCounts;
    }
    if (message.binaryMetrics !== false) {
      obj.binaryMetrics = message.binaryMetrics;
    }
    if (message.testSet !== false) {
      obj.testSet = message.testSet;
    }
    if (message.metricsByArea !== false) {
      obj.metricsByArea = message.metricsByArea;
    }
    if (message.metricsByClass !== false) {
      obj.metricsByClass = message.metricsByClass;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldsValue>, I>>(base?: I): FieldsValue {
    return FieldsValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldsValue>, I>>(object: I): FieldsValue {
    const message = createBaseFieldsValue();
    message.confusionMatrix = object.confusionMatrix ?? false;
    message.cooccurrenceMatrix = object.cooccurrenceMatrix ?? false;
    message.labelCounts = object.labelCounts ?? false;
    message.binaryMetrics = object.binaryMetrics ?? false;
    message.testSet = object.testSet ?? false;
    message.metricsByArea = object.metricsByArea ?? false;
    message.metricsByClass = object.metricsByClass ?? false;
    return message;
  },
};

function createBaseOutput(): Output {
  return {
    id: "",
    status: undefined,
    createdAt: undefined,
    model: undefined,
    input: undefined,
    data: undefined,
    promptTokens: 0,
    completionTokens: 0,
  };
}

export const Output: MessageFns<Output> = {
  encode(message: Output, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(34).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(42).fork()).join();
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(50).fork()).join();
    }
    if (message.promptTokens !== 0) {
      writer.uint32(56).uint32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(64).uint32(message.completionTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.promptTokens = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.completionTokens = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
    };
  },

  toJSON(message: Output): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Output>, I>>(base?: I): Output {
    return Output.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Output>, I>>(object: I): Output {
    const message = createBaseOutput();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    return message;
  },
};

function createBaseScopeDeps(): ScopeDeps {
  return { scope: "", dependingScopes: [] };
}

export const ScopeDeps: MessageFns<ScopeDeps> = {
  encode(message: ScopeDeps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== "") {
      writer.uint32(10).string(message.scope);
    }
    for (const v of message.dependingScopes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeDeps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeDeps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dependingScopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeDeps {
    return {
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      dependingScopes: globalThis.Array.isArray(object?.dependingScopes)
        ? object.dependingScopes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ScopeDeps): unknown {
    const obj: any = {};
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.dependingScopes?.length) {
      obj.dependingScopes = message.dependingScopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScopeDeps>, I>>(base?: I): ScopeDeps {
    return ScopeDeps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScopeDeps>, I>>(object: I): ScopeDeps {
    const message = createBaseScopeDeps();
    message.scope = object.scope ?? "";
    message.dependingScopes = object.dependingScopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseEndpointDeps(): EndpointDeps {
  return { endpoint: "", dependingScopes: [] };
}

export const EndpointDeps: MessageFns<EndpointDeps> = {
  encode(message: EndpointDeps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    for (const v of message.dependingScopes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointDeps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointDeps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dependingScopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointDeps {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      dependingScopes: globalThis.Array.isArray(object?.dependingScopes)
        ? object.dependingScopes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EndpointDeps): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.dependingScopes?.length) {
      obj.dependingScopes = message.dependingScopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndpointDeps>, I>>(base?: I): EndpointDeps {
    return EndpointDeps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndpointDeps>, I>>(object: I): EndpointDeps {
    const message = createBaseEndpointDeps();
    message.endpoint = object.endpoint ?? "";
    message.dependingScopes = object.dependingScopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseHit(): Hit {
  return { score: 0, input: undefined, annotation: undefined, userId: "", appId: "" };
}

export const Hit: MessageFns<Hit> = {
  encode(message: Hit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(13).float(message.score);
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(26).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hit {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
    };
  },

  toJSON(message: Hit): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hit>, I>>(base?: I): Hit {
    return Hit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hit>, I>>(object: I): Hit {
    const message = createBaseHit();
    message.score = object.score ?? 0;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    return message;
  },
};

function createBaseHitCount(): HitCount {
  return { estimatedTotal: 0 };
}

export const HitCount: MessageFns<HitCount> = {
  encode(message: HitCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.estimatedTotal !== 0) {
      writer.uint32(8).uint64(message.estimatedTotal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HitCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHitCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.estimatedTotal = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HitCount {
    return { estimatedTotal: isSet(object.estimatedTotal) ? globalThis.Number(object.estimatedTotal) : 0 };
  },

  toJSON(message: HitCount): unknown {
    const obj: any = {};
    if (message.estimatedTotal !== 0) {
      obj.estimatedTotal = Math.round(message.estimatedTotal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HitCount>, I>>(base?: I): HitCount {
    return HitCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HitCount>, I>>(object: I): HitCount {
    const message = createBaseHitCount();
    message.estimatedTotal = object.estimatedTotal ?? 0;
    return message;
  },
};

function createBaseAnd(): And {
  return { input: undefined, output: undefined, negate: false, annotation: undefined };
}

export const And: MessageFns<And> = {
  encode(message: And, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(10).fork()).join();
    }
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(18).fork()).join();
    }
    if (message.negate !== false) {
      writer.uint32(24).bool(message.negate);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): And {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.negate = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): And {
    return {
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
      negate: isSet(object.negate) ? globalThis.Boolean(object.negate) : false,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
    };
  },

  toJSON(message: And): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    if (message.negate !== false) {
      obj.negate = message.negate;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<And>, I>>(base?: I): And {
    return And.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<And>, I>>(object: I): And {
    const message = createBaseAnd();
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.output = (object.output !== undefined && object.output !== null)
      ? Output.fromPartial(object.output)
      : undefined;
    message.negate = object.negate ?? false;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    return message;
  },
};

function createBaseQuery(): Query {
  return { ands: [], language: "", filters: [], ranks: [] };
}

export const Query: MessageFns<Query> = {
  encode(message: Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ands) {
      And.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.ranks) {
      Rank.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ands.push(And.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ranks.push(Rank.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query {
    return {
      ands: globalThis.Array.isArray(object?.ands) ? object.ands.map((e: any) => And.fromJSON(e)) : [],
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      ranks: globalThis.Array.isArray(object?.ranks) ? object.ranks.map((e: any) => Rank.fromJSON(e)) : [],
    };
  },

  toJSON(message: Query): unknown {
    const obj: any = {};
    if (message.ands?.length) {
      obj.ands = message.ands.map((e) => And.toJSON(e));
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.ranks?.length) {
      obj.ranks = message.ranks.map((e) => Rank.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Query>, I>>(base?: I): Query {
    return Query.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Query>, I>>(object: I): Query {
    const message = createBaseQuery();
    message.ands = object.ands?.map((e) => And.fromPartial(e)) || [];
    message.language = object.language ?? "";
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.ranks = object.ranks?.map((e) => Rank.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearch(): Search {
  return {
    query: undefined,
    id: "",
    applicationId: "",
    name: "",
    asOf: undefined,
    gitHash: "",
    createdAt: undefined,
    modifiedAt: undefined,
    algorithm: "",
    save: false,
    minValue: 0,
    visibility: undefined,
    metric: 0,
  };
}

export const Search: MessageFns<Search> = {
  encode(message: Search, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.applicationId !== "") {
      writer.uint32(26).string(message.applicationId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.asOf !== undefined) {
      Timestamp.encode(toTimestamp(message.asOf), writer.uint32(42).fork()).join();
    }
    if (message.gitHash !== "") {
      writer.uint32(50).string(message.gitHash);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(66).fork()).join();
    }
    if (message.algorithm !== "") {
      writer.uint32(74).string(message.algorithm);
    }
    if (message.save !== false) {
      writer.uint32(80).bool(message.save);
    }
    if (message.minValue !== 0) {
      writer.uint32(93).float(message.minValue);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(98).fork()).join();
    }
    if (message.metric !== 0) {
      writer.uint32(104).int32(message.metric);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Search {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applicationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.asOf = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.save = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.minValue = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.metric = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Search {
    return {
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      applicationId: isSet(object.applicationId) ? globalThis.String(object.applicationId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      asOf: isSet(object.asOf) ? fromJsonTimestamp(object.asOf) : undefined,
      gitHash: isSet(object.gitHash) ? globalThis.String(object.gitHash) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      save: isSet(object.save) ? globalThis.Boolean(object.save) : false,
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metric: isSet(object.metric) ? search_MetricFromJSON(object.metric) : 0,
    };
  },

  toJSON(message: Search): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.applicationId !== "") {
      obj.applicationId = message.applicationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.asOf !== undefined) {
      obj.asOf = message.asOf.toISOString();
    }
    if (message.gitHash !== "") {
      obj.gitHash = message.gitHash;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.save !== false) {
      obj.save = message.save;
    }
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metric !== 0) {
      obj.metric = search_MetricToJSON(message.metric);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Search>, I>>(base?: I): Search {
    return Search.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Search>, I>>(object: I): Search {
    const message = createBaseSearch();
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.id = object.id ?? "";
    message.applicationId = object.applicationId ?? "";
    message.name = object.name ?? "";
    message.asOf = object.asOf ?? undefined;
    message.gitHash = object.gitHash ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.algorithm = object.algorithm ?? "";
    message.save = object.save ?? false;
    message.minValue = object.minValue ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metric = object.metric ?? 0;
    return message;
  },
};

function createBaseFilter(): Filter {
  return { negate: false, annotation: undefined, input: undefined, lastUpdatedTimeRange: undefined };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.negate !== false) {
      writer.uint32(24).bool(message.negate);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(34).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(42).fork()).join();
    }
    if (message.lastUpdatedTimeRange !== undefined) {
      TimeRange.encode(message.lastUpdatedTimeRange, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.negate = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastUpdatedTimeRange = TimeRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      negate: isSet(object.negate) ? globalThis.Boolean(object.negate) : false,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      lastUpdatedTimeRange: isSet(object.lastUpdatedTimeRange)
        ? TimeRange.fromJSON(object.lastUpdatedTimeRange)
        : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.negate !== false) {
      obj.negate = message.negate;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.lastUpdatedTimeRange !== undefined) {
      obj.lastUpdatedTimeRange = TimeRange.toJSON(message.lastUpdatedTimeRange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.negate = object.negate ?? false;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.lastUpdatedTimeRange = (object.lastUpdatedTimeRange !== undefined && object.lastUpdatedTimeRange !== null)
      ? TimeRange.fromPartial(object.lastUpdatedTimeRange)
      : undefined;
    return message;
  },
};

function createBaseTimeRange(): TimeRange {
  return { startTime: undefined, endTime: undefined };
}

export const TimeRange: MessageFns<TimeRange> = {
  encode(message: TimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRange {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeRange): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeRange>, I>>(base?: I): TimeRange {
    return TimeRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeRange>, I>>(object: I): TimeRange {
    const message = createBaseTimeRange();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseRank(): Rank {
  return { negate: false, annotation: undefined };
}

export const Rank: MessageFns<Rank> = {
  encode(message: Rank, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.negate !== false) {
      writer.uint32(24).bool(message.negate);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rank {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRank();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.negate = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rank {
    return {
      negate: isSet(object.negate) ? globalThis.Boolean(object.negate) : false,
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
    };
  },

  toJSON(message: Rank): unknown {
    const obj: any = {};
    if (message.negate !== false) {
      obj.negate = message.negate;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rank>, I>>(base?: I): Rank {
    return Rank.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rank>, I>>(object: I): Rank {
    const message = createBaseRank();
    message.negate = object.negate ?? false;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    return message;
  },
};

function createBaseAnnotationSearchMetrics(): AnnotationSearchMetrics {
  return {
    groundTruth: undefined,
    searchToEval: undefined,
    metrics: undefined,
    data: undefined,
    activeConceptCount: 0,
    visibility: undefined,
  };
}

export const AnnotationSearchMetrics: MessageFns<AnnotationSearchMetrics> = {
  encode(message: AnnotationSearchMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groundTruth !== undefined) {
      Search.encode(message.groundTruth, writer.uint32(10).fork()).join();
    }
    if (message.searchToEval !== undefined) {
      Search.encode(message.searchToEval, writer.uint32(18).fork()).join();
    }
    if (message.metrics !== undefined) {
      EvalMetrics.encode(message.metrics, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.activeConceptCount !== 0) {
      writer.uint32(40).uint32(message.activeConceptCount);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationSearchMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationSearchMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groundTruth = Search.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchToEval = Search.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics = EvalMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activeConceptCount = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationSearchMetrics {
    return {
      groundTruth: isSet(object.groundTruth) ? Search.fromJSON(object.groundTruth) : undefined,
      searchToEval: isSet(object.searchToEval) ? Search.fromJSON(object.searchToEval) : undefined,
      metrics: isSet(object.metrics) ? EvalMetrics.fromJSON(object.metrics) : undefined,
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      activeConceptCount: isSet(object.activeConceptCount) ? globalThis.Number(object.activeConceptCount) : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
    };
  },

  toJSON(message: AnnotationSearchMetrics): unknown {
    const obj: any = {};
    if (message.groundTruth !== undefined) {
      obj.groundTruth = Search.toJSON(message.groundTruth);
    }
    if (message.searchToEval !== undefined) {
      obj.searchToEval = Search.toJSON(message.searchToEval);
    }
    if (message.metrics !== undefined) {
      obj.metrics = EvalMetrics.toJSON(message.metrics);
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.activeConceptCount !== 0) {
      obj.activeConceptCount = Math.round(message.activeConceptCount);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotationSearchMetrics>, I>>(base?: I): AnnotationSearchMetrics {
    return AnnotationSearchMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotationSearchMetrics>, I>>(object: I): AnnotationSearchMetrics {
    const message = createBaseAnnotationSearchMetrics();
    message.groundTruth = (object.groundTruth !== undefined && object.groundTruth !== null)
      ? Search.fromPartial(object.groundTruth)
      : undefined;
    message.searchToEval = (object.searchToEval !== undefined && object.searchToEval !== null)
      ? Search.fromPartial(object.searchToEval)
      : undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? EvalMetrics.fromPartial(object.metrics)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.activeConceptCount = object.activeConceptCount ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    return message;
  },
};

function createBaseText(): Text {
  return { raw: "", url: "", allowDuplicateUrl: false, hosted: undefined, textInfo: undefined };
}

export const Text: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.raw !== "") {
      writer.uint32(10).string(message.raw);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.allowDuplicateUrl !== false) {
      writer.uint32(24).bool(message.allowDuplicateUrl);
    }
    if (message.hosted !== undefined) {
      HostedURL.encode(message.hosted, writer.uint32(34).fork()).join();
    }
    if (message.textInfo !== undefined) {
      TextInfo.encode(message.textInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowDuplicateUrl = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hosted = HostedURL.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.textInfo = TextInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text {
    return {
      raw: isSet(object.raw) ? globalThis.String(object.raw) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      allowDuplicateUrl: isSet(object.allowDuplicateUrl) ? globalThis.Boolean(object.allowDuplicateUrl) : false,
      hosted: isSet(object.hosted) ? HostedURL.fromJSON(object.hosted) : undefined,
      textInfo: isSet(object.textInfo) ? TextInfo.fromJSON(object.textInfo) : undefined,
    };
  },

  toJSON(message: Text): unknown {
    const obj: any = {};
    if (message.raw !== "") {
      obj.raw = message.raw;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.allowDuplicateUrl !== false) {
      obj.allowDuplicateUrl = message.allowDuplicateUrl;
    }
    if (message.hosted !== undefined) {
      obj.hosted = HostedURL.toJSON(message.hosted);
    }
    if (message.textInfo !== undefined) {
      obj.textInfo = TextInfo.toJSON(message.textInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Text>, I>>(base?: I): Text {
    return Text.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text>, I>>(object: I): Text {
    const message = createBaseText();
    message.raw = object.raw ?? "";
    message.url = object.url ?? "";
    message.allowDuplicateUrl = object.allowDuplicateUrl ?? false;
    message.hosted = (object.hosted !== undefined && object.hosted !== null)
      ? HostedURL.fromPartial(object.hosted)
      : undefined;
    message.textInfo = (object.textInfo !== undefined && object.textInfo !== null)
      ? TextInfo.fromPartial(object.textInfo)
      : undefined;
    return message;
  },
};

function createBaseTextInfo(): TextInfo {
  return { charCount: 0, encoding: "" };
}

export const TextInfo: MessageFns<TextInfo> = {
  encode(message: TextInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.charCount !== 0) {
      writer.uint32(8).int32(message.charCount);
    }
    if (message.encoding !== "") {
      writer.uint32(18).string(message.encoding);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.charCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInfo {
    return {
      charCount: isSet(object.charCount) ? globalThis.Number(object.charCount) : 0,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
    };
  },

  toJSON(message: TextInfo): unknown {
    const obj: any = {};
    if (message.charCount !== 0) {
      obj.charCount = Math.round(message.charCount);
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInfo>, I>>(base?: I): TextInfo {
    return TextInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInfo>, I>>(object: I): TextInfo {
    const message = createBaseTextInfo();
    message.charCount = object.charCount ?? 0;
    message.encoding = object.encoding ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    primaryEmail: "",
    firstName: "",
    lastName: "",
    companyName: "",
    jobTitle: "",
    jobRole: "",
    intention: "",
    referralSource: "",
    billType: "",
    createdAt: undefined,
    dateGdprConsent: undefined,
    dateTosConsent: undefined,
    dateMarketingConsent: undefined,
    datePiiConsent: undefined,
    metadata: undefined,
    emailAddresses: [],
    twoFactorAuthEnabled: false,
    teamsCount: 0,
    isStarred: false,
    starCount: 0,
    visibility: undefined,
    userDetail: undefined,
    image: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.primaryEmail !== "") {
      writer.uint32(18).string(message.primaryEmail);
    }
    if (message.firstName !== "") {
      writer.uint32(26).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(34).string(message.lastName);
    }
    if (message.companyName !== "") {
      writer.uint32(42).string(message.companyName);
    }
    if (message.jobTitle !== "") {
      writer.uint32(154).string(message.jobTitle);
    }
    if (message.jobRole !== "") {
      writer.uint32(162).string(message.jobRole);
    }
    if (message.intention !== "") {
      writer.uint32(194).string(message.intention);
    }
    if (message.referralSource !== "") {
      writer.uint32(202).string(message.referralSource);
    }
    if (message.billType !== "") {
      writer.uint32(58).string(message.billType);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.dateGdprConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateGdprConsent), writer.uint32(66).fork()).join();
    }
    if (message.dateTosConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateTosConsent), writer.uint32(74).fork()).join();
    }
    if (message.dateMarketingConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateMarketingConsent), writer.uint32(82).fork()).join();
    }
    if (message.datePiiConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.datePiiConsent), writer.uint32(186).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(90).fork()).join();
    }
    for (const v of message.emailAddresses) {
      EmailAddress.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.twoFactorAuthEnabled !== false) {
      writer.uint32(120).bool(message.twoFactorAuthEnabled);
    }
    if (message.teamsCount !== 0) {
      writer.uint32(128).uint32(message.teamsCount);
    }
    if (message.isStarred !== false) {
      writer.uint32(168).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(176).int32(message.starCount);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(138).fork()).join();
    }
    if (message.userDetail !== undefined) {
      UserDetail.encode(message.userDetail, writer.uint32(146).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(210).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primaryEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.jobTitle = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.jobRole = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.intention = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.referralSource = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.billType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateGdprConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateTosConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dateMarketingConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.datePiiConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.emailAddresses.push(EmailAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.twoFactorAuthEnabled = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.teamsCount = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.userDetail = UserDetail.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      primaryEmail: isSet(object.primaryEmail) ? globalThis.String(object.primaryEmail) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      companyName: isSet(object.companyName) ? globalThis.String(object.companyName) : "",
      jobTitle: isSet(object.jobTitle) ? globalThis.String(object.jobTitle) : "",
      jobRole: isSet(object.jobRole) ? globalThis.String(object.jobRole) : "",
      intention: isSet(object.intention) ? globalThis.String(object.intention) : "",
      referralSource: isSet(object.referralSource) ? globalThis.String(object.referralSource) : "",
      billType: isSet(object.billType) ? globalThis.String(object.billType) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      dateGdprConsent: isSet(object.dateGdprConsent) ? fromJsonTimestamp(object.dateGdprConsent) : undefined,
      dateTosConsent: isSet(object.dateTosConsent) ? fromJsonTimestamp(object.dateTosConsent) : undefined,
      dateMarketingConsent: isSet(object.dateMarketingConsent)
        ? fromJsonTimestamp(object.dateMarketingConsent)
        : undefined,
      datePiiConsent: isSet(object.datePiiConsent) ? fromJsonTimestamp(object.datePiiConsent) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      emailAddresses: globalThis.Array.isArray(object?.emailAddresses)
        ? object.emailAddresses.map((e: any) => EmailAddress.fromJSON(e))
        : [],
      twoFactorAuthEnabled: isSet(object.twoFactorAuthEnabled)
        ? globalThis.Boolean(object.twoFactorAuthEnabled)
        : false,
      teamsCount: isSet(object.teamsCount) ? globalThis.Number(object.teamsCount) : 0,
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      userDetail: isSet(object.userDetail) ? UserDetail.fromJSON(object.userDetail) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.primaryEmail !== "") {
      obj.primaryEmail = message.primaryEmail;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.companyName !== "") {
      obj.companyName = message.companyName;
    }
    if (message.jobTitle !== "") {
      obj.jobTitle = message.jobTitle;
    }
    if (message.jobRole !== "") {
      obj.jobRole = message.jobRole;
    }
    if (message.intention !== "") {
      obj.intention = message.intention;
    }
    if (message.referralSource !== "") {
      obj.referralSource = message.referralSource;
    }
    if (message.billType !== "") {
      obj.billType = message.billType;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.dateGdprConsent !== undefined) {
      obj.dateGdprConsent = message.dateGdprConsent.toISOString();
    }
    if (message.dateTosConsent !== undefined) {
      obj.dateTosConsent = message.dateTosConsent.toISOString();
    }
    if (message.dateMarketingConsent !== undefined) {
      obj.dateMarketingConsent = message.dateMarketingConsent.toISOString();
    }
    if (message.datePiiConsent !== undefined) {
      obj.datePiiConsent = message.datePiiConsent.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.emailAddresses?.length) {
      obj.emailAddresses = message.emailAddresses.map((e) => EmailAddress.toJSON(e));
    }
    if (message.twoFactorAuthEnabled !== false) {
      obj.twoFactorAuthEnabled = message.twoFactorAuthEnabled;
    }
    if (message.teamsCount !== 0) {
      obj.teamsCount = Math.round(message.teamsCount);
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.userDetail !== undefined) {
      obj.userDetail = UserDetail.toJSON(message.userDetail);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.primaryEmail = object.primaryEmail ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.companyName = object.companyName ?? "";
    message.jobTitle = object.jobTitle ?? "";
    message.jobRole = object.jobRole ?? "";
    message.intention = object.intention ?? "";
    message.referralSource = object.referralSource ?? "";
    message.billType = object.billType ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.dateGdprConsent = object.dateGdprConsent ?? undefined;
    message.dateTosConsent = object.dateTosConsent ?? undefined;
    message.dateMarketingConsent = object.dateMarketingConsent ?? undefined;
    message.datePiiConsent = object.datePiiConsent ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.emailAddresses = object.emailAddresses?.map((e) => EmailAddress.fromPartial(e)) || [];
    message.twoFactorAuthEnabled = object.twoFactorAuthEnabled ?? false;
    message.teamsCount = object.teamsCount ?? 0;
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.userDetail = (object.userDetail !== undefined && object.userDetail !== null)
      ? UserDetail.fromPartial(object.userDetail)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseUserDetail(): UserDetail {
  return {
    primaryEmail: "",
    billType: "",
    dateGdprConsent: undefined,
    dateTosConsent: undefined,
    dateMarketingConsent: undefined,
    datePiiConsent: undefined,
    metadata: undefined,
    emailAddresses: [],
    twoFactorAuthEnabled: false,
    teamsCount: 0,
    country: "",
    state: "",
    commitmentValue: undefined,
  };
}

export const UserDetail: MessageFns<UserDetail> = {
  encode(message: UserDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryEmail !== "") {
      writer.uint32(10).string(message.primaryEmail);
    }
    if (message.billType !== "") {
      writer.uint32(18).string(message.billType);
    }
    if (message.dateGdprConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateGdprConsent), writer.uint32(26).fork()).join();
    }
    if (message.dateTosConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateTosConsent), writer.uint32(34).fork()).join();
    }
    if (message.dateMarketingConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.dateMarketingConsent), writer.uint32(42).fork()).join();
    }
    if (message.datePiiConsent !== undefined) {
      Timestamp.encode(toTimestamp(message.datePiiConsent), writer.uint32(106).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    for (const v of message.emailAddresses) {
      EmailAddress.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.twoFactorAuthEnabled !== false) {
      writer.uint32(72).bool(message.twoFactorAuthEnabled);
    }
    if (message.teamsCount !== 0) {
      writer.uint32(80).uint32(message.teamsCount);
    }
    if (message.country !== "") {
      writer.uint32(90).string(message.country);
    }
    if (message.state !== "") {
      writer.uint32(98).string(message.state);
    }
    if (message.commitmentValue !== undefined) {
      CommitmentValue.encode(message.commitmentValue, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primaryEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.billType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateGdprConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateTosConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateMarketingConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.datePiiConsent = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.emailAddresses.push(EmailAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.twoFactorAuthEnabled = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.teamsCount = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.commitmentValue = CommitmentValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDetail {
    return {
      primaryEmail: isSet(object.primaryEmail) ? globalThis.String(object.primaryEmail) : "",
      billType: isSet(object.billType) ? globalThis.String(object.billType) : "",
      dateGdprConsent: isSet(object.dateGdprConsent) ? fromJsonTimestamp(object.dateGdprConsent) : undefined,
      dateTosConsent: isSet(object.dateTosConsent) ? fromJsonTimestamp(object.dateTosConsent) : undefined,
      dateMarketingConsent: isSet(object.dateMarketingConsent)
        ? fromJsonTimestamp(object.dateMarketingConsent)
        : undefined,
      datePiiConsent: isSet(object.datePiiConsent) ? fromJsonTimestamp(object.datePiiConsent) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      emailAddresses: globalThis.Array.isArray(object?.emailAddresses)
        ? object.emailAddresses.map((e: any) => EmailAddress.fromJSON(e))
        : [],
      twoFactorAuthEnabled: isSet(object.twoFactorAuthEnabled)
        ? globalThis.Boolean(object.twoFactorAuthEnabled)
        : false,
      teamsCount: isSet(object.teamsCount) ? globalThis.Number(object.teamsCount) : 0,
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      commitmentValue: isSet(object.commitmentValue) ? CommitmentValue.fromJSON(object.commitmentValue) : undefined,
    };
  },

  toJSON(message: UserDetail): unknown {
    const obj: any = {};
    if (message.primaryEmail !== "") {
      obj.primaryEmail = message.primaryEmail;
    }
    if (message.billType !== "") {
      obj.billType = message.billType;
    }
    if (message.dateGdprConsent !== undefined) {
      obj.dateGdprConsent = message.dateGdprConsent.toISOString();
    }
    if (message.dateTosConsent !== undefined) {
      obj.dateTosConsent = message.dateTosConsent.toISOString();
    }
    if (message.dateMarketingConsent !== undefined) {
      obj.dateMarketingConsent = message.dateMarketingConsent.toISOString();
    }
    if (message.datePiiConsent !== undefined) {
      obj.datePiiConsent = message.datePiiConsent.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.emailAddresses?.length) {
      obj.emailAddresses = message.emailAddresses.map((e) => EmailAddress.toJSON(e));
    }
    if (message.twoFactorAuthEnabled !== false) {
      obj.twoFactorAuthEnabled = message.twoFactorAuthEnabled;
    }
    if (message.teamsCount !== 0) {
      obj.teamsCount = Math.round(message.teamsCount);
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.commitmentValue !== undefined) {
      obj.commitmentValue = CommitmentValue.toJSON(message.commitmentValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDetail>, I>>(base?: I): UserDetail {
    return UserDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDetail>, I>>(object: I): UserDetail {
    const message = createBaseUserDetail();
    message.primaryEmail = object.primaryEmail ?? "";
    message.billType = object.billType ?? "";
    message.dateGdprConsent = object.dateGdprConsent ?? undefined;
    message.dateTosConsent = object.dateTosConsent ?? undefined;
    message.dateMarketingConsent = object.dateMarketingConsent ?? undefined;
    message.datePiiConsent = object.datePiiConsent ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.emailAddresses = object.emailAddresses?.map((e) => EmailAddress.fromPartial(e)) || [];
    message.twoFactorAuthEnabled = object.twoFactorAuthEnabled ?? false;
    message.teamsCount = object.teamsCount ?? 0;
    message.country = object.country ?? "";
    message.state = object.state ?? "";
    message.commitmentValue = (object.commitmentValue !== undefined && object.commitmentValue !== null)
      ? CommitmentValue.fromPartial(object.commitmentValue)
      : undefined;
    return message;
  },
};

function createBaseEmailAddress(): EmailAddress {
  return { email: "", primary: false, verified: false };
}

export const EmailAddress: MessageFns<EmailAddress> = {
  encode(message: EmailAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.primary !== false) {
      writer.uint32(16).bool(message.primary);
    }
    if (message.verified !== false) {
      writer.uint32(24).bool(message.verified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.primary = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.verified = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailAddress {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      primary: isSet(object.primary) ? globalThis.Boolean(object.primary) : false,
      verified: isSet(object.verified) ? globalThis.Boolean(object.verified) : false,
    };
  },

  toJSON(message: EmailAddress): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.primary !== false) {
      obj.primary = message.primary;
    }
    if (message.verified !== false) {
      obj.verified = message.verified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailAddress>, I>>(base?: I): EmailAddress {
    return EmailAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailAddress>, I>>(object: I): EmailAddress {
    const message = createBaseEmailAddress();
    message.email = object.email ?? "";
    message.primary = object.primary ?? false;
    message.verified = object.verified ?? false;
    return message;
  },
};

function createBasePassword(): Password {
  return { plaintext: "" };
}

export const Password: MessageFns<Password> = {
  encode(message: Password, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext !== "") {
      writer.uint32(10).string(message.plaintext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Password {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Password {
    return { plaintext: isSet(object.plaintext) ? globalThis.String(object.plaintext) : "" };
  },

  toJSON(message: Password): unknown {
    const obj: any = {};
    if (message.plaintext !== "") {
      obj.plaintext = message.plaintext;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Password>, I>>(base?: I): Password {
    return Password.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Password>, I>>(object: I): Password {
    const message = createBasePassword();
    message.plaintext = object.plaintext ?? "";
    return message;
  },
};

function createBasePasswordViolations(): PasswordViolations {
  return {
    minimumLength: false,
    maximumLength: false,
    upperCaseNeeded: false,
    lowerCaseNeeded: false,
    numericNeeded: false,
    nonAlphanumericNeeded: false,
    passwordReuse: false,
    excludeNames: false,
    excludeEmail: false,
    noConfusingLetters: false,
    noSimplePasswords: false,
    noCommonVocabs: false,
    noOverlapWithOld: false,
    passwordLifespan: false,
  };
}

export const PasswordViolations: MessageFns<PasswordViolations> = {
  encode(message: PasswordViolations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimumLength !== false) {
      writer.uint32(8).bool(message.minimumLength);
    }
    if (message.maximumLength !== false) {
      writer.uint32(16).bool(message.maximumLength);
    }
    if (message.upperCaseNeeded !== false) {
      writer.uint32(24).bool(message.upperCaseNeeded);
    }
    if (message.lowerCaseNeeded !== false) {
      writer.uint32(32).bool(message.lowerCaseNeeded);
    }
    if (message.numericNeeded !== false) {
      writer.uint32(40).bool(message.numericNeeded);
    }
    if (message.nonAlphanumericNeeded !== false) {
      writer.uint32(48).bool(message.nonAlphanumericNeeded);
    }
    if (message.passwordReuse !== false) {
      writer.uint32(56).bool(message.passwordReuse);
    }
    if (message.excludeNames !== false) {
      writer.uint32(64).bool(message.excludeNames);
    }
    if (message.excludeEmail !== false) {
      writer.uint32(72).bool(message.excludeEmail);
    }
    if (message.noConfusingLetters !== false) {
      writer.uint32(80).bool(message.noConfusingLetters);
    }
    if (message.noSimplePasswords !== false) {
      writer.uint32(88).bool(message.noSimplePasswords);
    }
    if (message.noCommonVocabs !== false) {
      writer.uint32(96).bool(message.noCommonVocabs);
    }
    if (message.noOverlapWithOld !== false) {
      writer.uint32(104).bool(message.noOverlapWithOld);
    }
    if (message.passwordLifespan !== false) {
      writer.uint32(112).bool(message.passwordLifespan);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordViolations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordViolations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minimumLength = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximumLength = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.upperCaseNeeded = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lowerCaseNeeded = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numericNeeded = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nonAlphanumericNeeded = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.passwordReuse = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.excludeNames = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.excludeEmail = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.noConfusingLetters = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.noSimplePasswords = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.noCommonVocabs = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.noOverlapWithOld = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.passwordLifespan = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PasswordViolations {
    return {
      minimumLength: isSet(object.minimumLength) ? globalThis.Boolean(object.minimumLength) : false,
      maximumLength: isSet(object.maximumLength) ? globalThis.Boolean(object.maximumLength) : false,
      upperCaseNeeded: isSet(object.upperCaseNeeded) ? globalThis.Boolean(object.upperCaseNeeded) : false,
      lowerCaseNeeded: isSet(object.lowerCaseNeeded) ? globalThis.Boolean(object.lowerCaseNeeded) : false,
      numericNeeded: isSet(object.numericNeeded) ? globalThis.Boolean(object.numericNeeded) : false,
      nonAlphanumericNeeded: isSet(object.nonAlphanumericNeeded)
        ? globalThis.Boolean(object.nonAlphanumericNeeded)
        : false,
      passwordReuse: isSet(object.passwordReuse) ? globalThis.Boolean(object.passwordReuse) : false,
      excludeNames: isSet(object.excludeNames) ? globalThis.Boolean(object.excludeNames) : false,
      excludeEmail: isSet(object.excludeEmail) ? globalThis.Boolean(object.excludeEmail) : false,
      noConfusingLetters: isSet(object.noConfusingLetters) ? globalThis.Boolean(object.noConfusingLetters) : false,
      noSimplePasswords: isSet(object.noSimplePasswords) ? globalThis.Boolean(object.noSimplePasswords) : false,
      noCommonVocabs: isSet(object.noCommonVocabs) ? globalThis.Boolean(object.noCommonVocabs) : false,
      noOverlapWithOld: isSet(object.noOverlapWithOld) ? globalThis.Boolean(object.noOverlapWithOld) : false,
      passwordLifespan: isSet(object.passwordLifespan) ? globalThis.Boolean(object.passwordLifespan) : false,
    };
  },

  toJSON(message: PasswordViolations): unknown {
    const obj: any = {};
    if (message.minimumLength !== false) {
      obj.minimumLength = message.minimumLength;
    }
    if (message.maximumLength !== false) {
      obj.maximumLength = message.maximumLength;
    }
    if (message.upperCaseNeeded !== false) {
      obj.upperCaseNeeded = message.upperCaseNeeded;
    }
    if (message.lowerCaseNeeded !== false) {
      obj.lowerCaseNeeded = message.lowerCaseNeeded;
    }
    if (message.numericNeeded !== false) {
      obj.numericNeeded = message.numericNeeded;
    }
    if (message.nonAlphanumericNeeded !== false) {
      obj.nonAlphanumericNeeded = message.nonAlphanumericNeeded;
    }
    if (message.passwordReuse !== false) {
      obj.passwordReuse = message.passwordReuse;
    }
    if (message.excludeNames !== false) {
      obj.excludeNames = message.excludeNames;
    }
    if (message.excludeEmail !== false) {
      obj.excludeEmail = message.excludeEmail;
    }
    if (message.noConfusingLetters !== false) {
      obj.noConfusingLetters = message.noConfusingLetters;
    }
    if (message.noSimplePasswords !== false) {
      obj.noSimplePasswords = message.noSimplePasswords;
    }
    if (message.noCommonVocabs !== false) {
      obj.noCommonVocabs = message.noCommonVocabs;
    }
    if (message.noOverlapWithOld !== false) {
      obj.noOverlapWithOld = message.noOverlapWithOld;
    }
    if (message.passwordLifespan !== false) {
      obj.passwordLifespan = message.passwordLifespan;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PasswordViolations>, I>>(base?: I): PasswordViolations {
    return PasswordViolations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PasswordViolations>, I>>(object: I): PasswordViolations {
    const message = createBasePasswordViolations();
    message.minimumLength = object.minimumLength ?? false;
    message.maximumLength = object.maximumLength ?? false;
    message.upperCaseNeeded = object.upperCaseNeeded ?? false;
    message.lowerCaseNeeded = object.lowerCaseNeeded ?? false;
    message.numericNeeded = object.numericNeeded ?? false;
    message.nonAlphanumericNeeded = object.nonAlphanumericNeeded ?? false;
    message.passwordReuse = object.passwordReuse ?? false;
    message.excludeNames = object.excludeNames ?? false;
    message.excludeEmail = object.excludeEmail ?? false;
    message.noConfusingLetters = object.noConfusingLetters ?? false;
    message.noSimplePasswords = object.noSimplePasswords ?? false;
    message.noCommonVocabs = object.noCommonVocabs ?? false;
    message.noOverlapWithOld = object.noOverlapWithOld ?? false;
    message.passwordLifespan = object.passwordLifespan ?? false;
    return message;
  },
};

function createBaseCommitmentValue(): CommitmentValue {
  return { value: 0, type: 0 };
}

export const CommitmentValue: MessageFns<CommitmentValue> = {
  encode(message: CommitmentValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitmentValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitmentValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitmentValue {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      type: isSet(object.type) ? commitmentValue_CommitmentTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: CommitmentValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.type !== 0) {
      obj.type = commitmentValue_CommitmentTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitmentValue>, I>>(base?: I): CommitmentValue {
    return CommitmentValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitmentValue>, I>>(object: I): CommitmentValue {
    const message = createBaseCommitmentValue();
    message.value = object.value ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseVideo(): Video {
  return {
    url: "",
    base64: new Uint8Array(0),
    allowDuplicateUrl: false,
    thumbnailUrl: "",
    hosted: undefined,
    hostedThumbnail: undefined,
    videoInfo: undefined,
  };
}

export const Video: MessageFns<Video> = {
  encode(message: Video, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.base64.length !== 0) {
      writer.uint32(18).bytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      writer.uint32(32).bool(message.allowDuplicateUrl);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(42).string(message.thumbnailUrl);
    }
    if (message.hosted !== undefined) {
      HostedURL.encode(message.hosted, writer.uint32(50).fork()).join();
    }
    if (message.hostedThumbnail !== undefined) {
      HostedURL.encode(message.hostedThumbnail, writer.uint32(66).fork()).join();
    }
    if (message.videoInfo !== undefined) {
      VideoInfo.encode(message.videoInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Video {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64 = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowDuplicateUrl = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hosted = HostedURL.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.hostedThumbnail = HostedURL.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.videoInfo = VideoInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Video {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      base64: isSet(object.base64) ? bytesFromBase64(object.base64) : new Uint8Array(0),
      allowDuplicateUrl: isSet(object.allowDuplicateUrl) ? globalThis.Boolean(object.allowDuplicateUrl) : false,
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      hosted: isSet(object.hosted) ? HostedURL.fromJSON(object.hosted) : undefined,
      hostedThumbnail: isSet(object.hostedThumbnail) ? HostedURL.fromJSON(object.hostedThumbnail) : undefined,
      videoInfo: isSet(object.videoInfo) ? VideoInfo.fromJSON(object.videoInfo) : undefined,
    };
  },

  toJSON(message: Video): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.base64.length !== 0) {
      obj.base64 = base64FromBytes(message.base64);
    }
    if (message.allowDuplicateUrl !== false) {
      obj.allowDuplicateUrl = message.allowDuplicateUrl;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.hosted !== undefined) {
      obj.hosted = HostedURL.toJSON(message.hosted);
    }
    if (message.hostedThumbnail !== undefined) {
      obj.hostedThumbnail = HostedURL.toJSON(message.hostedThumbnail);
    }
    if (message.videoInfo !== undefined) {
      obj.videoInfo = VideoInfo.toJSON(message.videoInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Video>, I>>(base?: I): Video {
    return Video.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Video>, I>>(object: I): Video {
    const message = createBaseVideo();
    message.url = object.url ?? "";
    message.base64 = object.base64 ?? new Uint8Array(0);
    message.allowDuplicateUrl = object.allowDuplicateUrl ?? false;
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.hosted = (object.hosted !== undefined && object.hosted !== null)
      ? HostedURL.fromPartial(object.hosted)
      : undefined;
    message.hostedThumbnail = (object.hostedThumbnail !== undefined && object.hostedThumbnail !== null)
      ? HostedURL.fromPartial(object.hostedThumbnail)
      : undefined;
    message.videoInfo = (object.videoInfo !== undefined && object.videoInfo !== null)
      ? VideoInfo.fromPartial(object.videoInfo)
      : undefined;
    return message;
  },
};

function createBaseVideoInfo(): VideoInfo {
  return { width: 0, height: 0, fps: 0, videoFormat: "", bitRate: 0, frameCount: 0, durationSeconds: 0 };
}

export const VideoInfo: MessageFns<VideoInfo> = {
  encode(message: VideoInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.fps !== 0) {
      writer.uint32(29).float(message.fps);
    }
    if (message.videoFormat !== "") {
      writer.uint32(34).string(message.videoFormat);
    }
    if (message.bitRate !== 0) {
      writer.uint32(40).int32(message.bitRate);
    }
    if (message.frameCount !== 0) {
      writer.uint32(48).int32(message.frameCount);
    }
    if (message.durationSeconds !== 0) {
      writer.uint32(61).float(message.durationSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.fps = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoFormat = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bitRate = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.frameCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.durationSeconds = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoInfo {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      fps: isSet(object.fps) ? globalThis.Number(object.fps) : 0,
      videoFormat: isSet(object.videoFormat) ? globalThis.String(object.videoFormat) : "",
      bitRate: isSet(object.bitRate) ? globalThis.Number(object.bitRate) : 0,
      frameCount: isSet(object.frameCount) ? globalThis.Number(object.frameCount) : 0,
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
    };
  },

  toJSON(message: VideoInfo): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.fps !== 0) {
      obj.fps = message.fps;
    }
    if (message.videoFormat !== "") {
      obj.videoFormat = message.videoFormat;
    }
    if (message.bitRate !== 0) {
      obj.bitRate = Math.round(message.bitRate);
    }
    if (message.frameCount !== 0) {
      obj.frameCount = Math.round(message.frameCount);
    }
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = message.durationSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoInfo>, I>>(base?: I): VideoInfo {
    return VideoInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoInfo>, I>>(object: I): VideoInfo {
    const message = createBaseVideoInfo();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.fps = object.fps ?? 0;
    message.videoFormat = object.videoFormat ?? "";
    message.bitRate = object.bitRate ?? 0;
    message.frameCount = object.frameCount ?? 0;
    message.durationSeconds = object.durationSeconds ?? 0;
    return message;
  },
};

function createBaseWorkflow(): Workflow {
  return {
    id: "",
    appId: "",
    createdAt: undefined,
    nodes: [],
    metadata: undefined,
    visibility: undefined,
    userId: "",
    modifiedAt: undefined,
    version: undefined,
    isStarred: false,
    starCount: 0,
    description: "",
    notes: "",
    useCases: [],
    checkConsents: [],
    bookmarkOrigin: undefined,
    image: undefined,
  };
}

export const Workflow: MessageFns<Workflow> = {
  encode(message: Workflow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    for (const v of message.nodes) {
      WorkflowNode.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(42).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(50).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(58).string(message.userId);
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(66).fork()).join();
    }
    if (message.version !== undefined) {
      WorkflowVersion.encode(message.version, writer.uint32(74).fork()).join();
    }
    if (message.isStarred !== false) {
      writer.uint32(80).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(88).int32(message.starCount);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.notes !== "") {
      writer.uint32(106).string(message.notes);
    }
    for (const v of message.useCases) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.checkConsents) {
      writer.uint32(122).string(v!);
    }
    if (message.bookmarkOrigin !== undefined) {
      BookmarkOrigin.encode(message.bookmarkOrigin, writer.uint32(130).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workflow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodes.push(WorkflowNode.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.version = WorkflowVersion.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.useCases.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.checkConsents.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.bookmarkOrigin = BookmarkOrigin.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workflow {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => WorkflowNode.fromJSON(e)) : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      version: isSet(object.version) ? WorkflowVersion.fromJSON(object.version) : undefined,
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      useCases: globalThis.Array.isArray(object?.useCases) ? object.useCases.map((e: any) => globalThis.String(e)) : [],
      checkConsents: globalThis.Array.isArray(object?.checkConsents)
        ? object.checkConsents.map((e: any) => globalThis.String(e))
        : [],
      bookmarkOrigin: isSet(object.bookmarkOrigin) ? BookmarkOrigin.fromJSON(object.bookmarkOrigin) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: Workflow): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => WorkflowNode.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.version !== undefined) {
      obj.version = WorkflowVersion.toJSON(message.version);
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.useCases?.length) {
      obj.useCases = message.useCases;
    }
    if (message.checkConsents?.length) {
      obj.checkConsents = message.checkConsents;
    }
    if (message.bookmarkOrigin !== undefined) {
      obj.bookmarkOrigin = BookmarkOrigin.toJSON(message.bookmarkOrigin);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workflow>, I>>(base?: I): Workflow {
    return Workflow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workflow>, I>>(object: I): Workflow {
    const message = createBaseWorkflow();
    message.id = object.id ?? "";
    message.appId = object.appId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.nodes = object.nodes?.map((e) => WorkflowNode.fromPartial(e)) || [];
    message.metadata = object.metadata ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.userId = object.userId ?? "";
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? WorkflowVersion.fromPartial(object.version)
      : undefined;
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.description = object.description ?? "";
    message.notes = object.notes ?? "";
    message.useCases = object.useCases?.map((e) => e) || [];
    message.checkConsents = object.checkConsents?.map((e) => e) || [];
    message.bookmarkOrigin = (object.bookmarkOrigin !== undefined && object.bookmarkOrigin !== null)
      ? BookmarkOrigin.fromPartial(object.bookmarkOrigin)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseWorkflowVersion(): WorkflowVersion {
  return {
    id: "",
    workflowId: "",
    createdAt: undefined,
    modifiedAt: undefined,
    visibility: undefined,
    nodes: [],
    metadata: undefined,
    appId: "",
    userId: "",
    description: "",
    license: "",
    isDeprecated: false,
  };
}

export const WorkflowVersion: MessageFns<WorkflowVersion> = {
  encode(message: WorkflowVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(34).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(42).fork()).join();
    }
    for (const v of message.nodes) {
      WorkflowNode.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(58).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(74).string(message.userId);
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.license !== "") {
      writer.uint32(90).string(message.license);
    }
    if (message.isDeprecated !== false) {
      writer.uint32(96).bool(message.isDeprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nodes.push(WorkflowNode.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.license = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isDeprecated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => WorkflowNode.fromJSON(e)) : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      isDeprecated: isSet(object.isDeprecated) ? globalThis.Boolean(object.isDeprecated) : false,
    };
  },

  toJSON(message: WorkflowVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => WorkflowNode.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.isDeprecated !== false) {
      obj.isDeprecated = message.isDeprecated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersion>, I>>(base?: I): WorkflowVersion {
    return WorkflowVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersion>, I>>(object: I): WorkflowVersion {
    const message = createBaseWorkflowVersion();
    message.id = object.id ?? "";
    message.workflowId = object.workflowId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.nodes = object.nodes?.map((e) => WorkflowNode.fromPartial(e)) || [];
    message.metadata = object.metadata ?? undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.description = object.description ?? "";
    message.license = object.license ?? "";
    message.isDeprecated = object.isDeprecated ?? false;
    return message;
  },
};

function createBaseWorkflowNode(): WorkflowNode {
  return { id: "", model: undefined, nodeInputs: [], suppressOutput: false, outputInfoOverride: undefined };
}

export const WorkflowNode: MessageFns<WorkflowNode> = {
  encode(message: WorkflowNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodeInputs) {
      NodeInput.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.suppressOutput !== false) {
      writer.uint32(32).bool(message.suppressOutput);
    }
    if (message.outputInfoOverride !== undefined) {
      OutputInfo.encode(message.outputInfoOverride, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeInputs.push(NodeInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.suppressOutput = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputInfoOverride = OutputInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      nodeInputs: globalThis.Array.isArray(object?.nodeInputs)
        ? object.nodeInputs.map((e: any) => NodeInput.fromJSON(e))
        : [],
      suppressOutput: isSet(object.suppressOutput) ? globalThis.Boolean(object.suppressOutput) : false,
      outputInfoOverride: isSet(object.outputInfoOverride) ? OutputInfo.fromJSON(object.outputInfoOverride) : undefined,
    };
  },

  toJSON(message: WorkflowNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.nodeInputs?.length) {
      obj.nodeInputs = message.nodeInputs.map((e) => NodeInput.toJSON(e));
    }
    if (message.suppressOutput !== false) {
      obj.suppressOutput = message.suppressOutput;
    }
    if (message.outputInfoOverride !== undefined) {
      obj.outputInfoOverride = OutputInfo.toJSON(message.outputInfoOverride);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowNode>, I>>(base?: I): WorkflowNode {
    return WorkflowNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowNode>, I>>(object: I): WorkflowNode {
    const message = createBaseWorkflowNode();
    message.id = object.id ?? "";
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.nodeInputs = object.nodeInputs?.map((e) => NodeInput.fromPartial(e)) || [];
    message.suppressOutput = object.suppressOutput ?? false;
    message.outputInfoOverride = (object.outputInfoOverride !== undefined && object.outputInfoOverride !== null)
      ? OutputInfo.fromPartial(object.outputInfoOverride)
      : undefined;
    return message;
  },
};

function createBaseNodeInput(): NodeInput {
  return { nodeId: "" };
}

export const NodeInput: MessageFns<NodeInput> = {
  encode(message: NodeInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeInput {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: NodeInput): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInput>, I>>(base?: I): NodeInput {
    return NodeInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInput>, I>>(object: I): NodeInput {
    const message = createBaseNodeInput();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseWorkflowResult(): WorkflowResult {
  return { id: "", status: undefined, createdAt: undefined, input: undefined, outputs: [], suppressOutput: false };
}

export const WorkflowResult: MessageFns<WorkflowResult> = {
  encode(message: WorkflowResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(42).fork()).join();
    }
    for (const v of message.outputs) {
      Output.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.suppressOutput !== false) {
      writer.uint32(56).bool(message.suppressOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputs.push(Output.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.suppressOutput = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => Output.fromJSON(e)) : [],
      suppressOutput: isSet(object.suppressOutput) ? globalThis.Boolean(object.suppressOutput) : false,
    };
  },

  toJSON(message: WorkflowResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => Output.toJSON(e));
    }
    if (message.suppressOutput !== false) {
      obj.suppressOutput = message.suppressOutput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowResult>, I>>(base?: I): WorkflowResult {
    return WorkflowResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowResult>, I>>(object: I): WorkflowResult {
    const message = createBaseWorkflowResult();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];
    message.suppressOutput = object.suppressOutput ?? false;
    return message;
  },
};

function createBaseWorkflowState(): WorkflowState {
  return { id: "" };
}

export const WorkflowState: MessageFns<WorkflowState> = {
  encode(message: WorkflowState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowState {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: WorkflowState): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowState>, I>>(base?: I): WorkflowState {
    return WorkflowState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowState>, I>>(object: I): WorkflowState {
    const message = createBaseWorkflowState();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAppDuplication(): AppDuplication {
  return {
    id: "",
    destinationApp: undefined,
    existingAppId: "",
    newAppId: "",
    newAppName: "",
    status: undefined,
    createdAt: undefined,
    lastModifiedAt: undefined,
    filter: undefined,
    progress: [],
  };
}

export const AppDuplication: MessageFns<AppDuplication> = {
  encode(message: AppDuplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.destinationApp !== undefined) {
      App.encode(message.destinationApp, writer.uint32(82).fork()).join();
    }
    if (message.existingAppId !== "") {
      writer.uint32(66).string(message.existingAppId);
    }
    if (message.newAppId !== "") {
      writer.uint32(18).string(message.newAppId);
    }
    if (message.newAppName !== "") {
      writer.uint32(26).string(message.newAppName);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.lastModifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastModifiedAt), writer.uint32(50).fork()).join();
    }
    if (message.filter !== undefined) {
      AppDuplicationFilters.encode(message.filter, writer.uint32(58).fork()).join();
    }
    for (const v of message.progress) {
      AppCopyProgress.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDuplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDuplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.destinationApp = App.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.existingAppId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newAppId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAppName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastModifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.filter = AppDuplicationFilters.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.progress.push(AppCopyProgress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDuplication {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      destinationApp: isSet(object.destinationApp) ? App.fromJSON(object.destinationApp) : undefined,
      existingAppId: isSet(object.existingAppId) ? globalThis.String(object.existingAppId) : "",
      newAppId: isSet(object.newAppId) ? globalThis.String(object.newAppId) : "",
      newAppName: isSet(object.newAppName) ? globalThis.String(object.newAppName) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastModifiedAt: isSet(object.lastModifiedAt) ? fromJsonTimestamp(object.lastModifiedAt) : undefined,
      filter: isSet(object.filter) ? AppDuplicationFilters.fromJSON(object.filter) : undefined,
      progress: globalThis.Array.isArray(object?.progress)
        ? object.progress.map((e: any) => AppCopyProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AppDuplication): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.destinationApp !== undefined) {
      obj.destinationApp = App.toJSON(message.destinationApp);
    }
    if (message.existingAppId !== "") {
      obj.existingAppId = message.existingAppId;
    }
    if (message.newAppId !== "") {
      obj.newAppId = message.newAppId;
    }
    if (message.newAppName !== "") {
      obj.newAppName = message.newAppName;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastModifiedAt !== undefined) {
      obj.lastModifiedAt = message.lastModifiedAt.toISOString();
    }
    if (message.filter !== undefined) {
      obj.filter = AppDuplicationFilters.toJSON(message.filter);
    }
    if (message.progress?.length) {
      obj.progress = message.progress.map((e) => AppCopyProgress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDuplication>, I>>(base?: I): AppDuplication {
    return AppDuplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDuplication>, I>>(object: I): AppDuplication {
    const message = createBaseAppDuplication();
    message.id = object.id ?? "";
    message.destinationApp = (object.destinationApp !== undefined && object.destinationApp !== null)
      ? App.fromPartial(object.destinationApp)
      : undefined;
    message.existingAppId = object.existingAppId ?? "";
    message.newAppId = object.newAppId ?? "";
    message.newAppName = object.newAppName ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.lastModifiedAt = object.lastModifiedAt ?? undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? AppDuplicationFilters.fromPartial(object.filter)
      : undefined;
    message.progress = object.progress?.map((e) => AppCopyProgress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAppCopyProgress(): AppCopyProgress {
  return { field: "", value: 0 };
}

export const AppCopyProgress: MessageFns<AppCopyProgress> = {
  encode(message: AppCopyProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppCopyProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppCopyProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppCopyProgress {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: AppCopyProgress): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppCopyProgress>, I>>(base?: I): AppCopyProgress {
    return AppCopyProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppCopyProgress>, I>>(object: I): AppCopyProgress {
    const message = createBaseAppCopyProgress();
    message.field = object.field ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAppDuplicationFilters(): AppDuplicationFilters {
  return {
    copyInputs: false,
    copyConcepts: false,
    copyAnnotations: false,
    copyModels: false,
    copyWorkflows: false,
    copyInstalledModuleVersions: false,
  };
}

export const AppDuplicationFilters: MessageFns<AppDuplicationFilters> = {
  encode(message: AppDuplicationFilters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.copyInputs !== false) {
      writer.uint32(8).bool(message.copyInputs);
    }
    if (message.copyConcepts !== false) {
      writer.uint32(16).bool(message.copyConcepts);
    }
    if (message.copyAnnotations !== false) {
      writer.uint32(24).bool(message.copyAnnotations);
    }
    if (message.copyModels !== false) {
      writer.uint32(32).bool(message.copyModels);
    }
    if (message.copyWorkflows !== false) {
      writer.uint32(40).bool(message.copyWorkflows);
    }
    if (message.copyInstalledModuleVersions !== false) {
      writer.uint32(48).bool(message.copyInstalledModuleVersions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDuplicationFilters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDuplicationFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.copyInputs = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.copyConcepts = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.copyAnnotations = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.copyModels = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.copyWorkflows = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.copyInstalledModuleVersions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDuplicationFilters {
    return {
      copyInputs: isSet(object.copyInputs) ? globalThis.Boolean(object.copyInputs) : false,
      copyConcepts: isSet(object.copyConcepts) ? globalThis.Boolean(object.copyConcepts) : false,
      copyAnnotations: isSet(object.copyAnnotations) ? globalThis.Boolean(object.copyAnnotations) : false,
      copyModels: isSet(object.copyModels) ? globalThis.Boolean(object.copyModels) : false,
      copyWorkflows: isSet(object.copyWorkflows) ? globalThis.Boolean(object.copyWorkflows) : false,
      copyInstalledModuleVersions: isSet(object.copyInstalledModuleVersions)
        ? globalThis.Boolean(object.copyInstalledModuleVersions)
        : false,
    };
  },

  toJSON(message: AppDuplicationFilters): unknown {
    const obj: any = {};
    if (message.copyInputs !== false) {
      obj.copyInputs = message.copyInputs;
    }
    if (message.copyConcepts !== false) {
      obj.copyConcepts = message.copyConcepts;
    }
    if (message.copyAnnotations !== false) {
      obj.copyAnnotations = message.copyAnnotations;
    }
    if (message.copyModels !== false) {
      obj.copyModels = message.copyModels;
    }
    if (message.copyWorkflows !== false) {
      obj.copyWorkflows = message.copyWorkflows;
    }
    if (message.copyInstalledModuleVersions !== false) {
      obj.copyInstalledModuleVersions = message.copyInstalledModuleVersions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDuplicationFilters>, I>>(base?: I): AppDuplicationFilters {
    return AppDuplicationFilters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDuplicationFilters>, I>>(object: I): AppDuplicationFilters {
    const message = createBaseAppDuplicationFilters();
    message.copyInputs = object.copyInputs ?? false;
    message.copyConcepts = object.copyConcepts ?? false;
    message.copyAnnotations = object.copyAnnotations ?? false;
    message.copyModels = object.copyModels ?? false;
    message.copyWorkflows = object.copyWorkflows ?? false;
    message.copyInstalledModuleVersions = object.copyInstalledModuleVersions ?? false;
    return message;
  },
};

function createBaseLabelOrder(): LabelOrder {
  return {
    id: "",
    name: "",
    status: undefined,
    autoRelease: false,
    allowEmptyTag: false,
    desiredFulfillTime: undefined,
    estimateFulfillTime: undefined,
    task: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const LabelOrder: MessageFns<LabelOrder> = {
  encode(message: LabelOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    if (message.autoRelease !== false) {
      writer.uint32(32).bool(message.autoRelease);
    }
    if (message.allowEmptyTag !== false) {
      writer.uint32(40).bool(message.allowEmptyTag);
    }
    if (message.desiredFulfillTime !== undefined) {
      Timestamp.encode(toTimestamp(message.desiredFulfillTime), writer.uint32(50).fork()).join();
    }
    if (message.estimateFulfillTime !== undefined) {
      Timestamp.encode(toTimestamp(message.estimateFulfillTime), writer.uint32(58).fork()).join();
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.autoRelease = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allowEmptyTag = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.desiredFulfillTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.estimateFulfillTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelOrder {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      autoRelease: isSet(object.autoRelease) ? globalThis.Boolean(object.autoRelease) : false,
      allowEmptyTag: isSet(object.allowEmptyTag) ? globalThis.Boolean(object.allowEmptyTag) : false,
      desiredFulfillTime: isSet(object.desiredFulfillTime) ? fromJsonTimestamp(object.desiredFulfillTime) : undefined,
      estimateFulfillTime: isSet(object.estimateFulfillTime)
        ? fromJsonTimestamp(object.estimateFulfillTime)
        : undefined,
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: LabelOrder): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.autoRelease !== false) {
      obj.autoRelease = message.autoRelease;
    }
    if (message.allowEmptyTag !== false) {
      obj.allowEmptyTag = message.allowEmptyTag;
    }
    if (message.desiredFulfillTime !== undefined) {
      obj.desiredFulfillTime = message.desiredFulfillTime.toISOString();
    }
    if (message.estimateFulfillTime !== undefined) {
      obj.estimateFulfillTime = message.estimateFulfillTime.toISOString();
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LabelOrder>, I>>(base?: I): LabelOrder {
    return LabelOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LabelOrder>, I>>(object: I): LabelOrder {
    const message = createBaseLabelOrder();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.autoRelease = object.autoRelease ?? false;
    message.allowEmptyTag = object.allowEmptyTag ?? false;
    message.desiredFulfillTime = object.desiredFulfillTime ?? undefined;
    message.estimateFulfillTime = object.estimateFulfillTime ?? undefined;
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBaseTask(): Task {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    type: 0,
    description: "",
    worker: undefined,
    conceptIds: [],
    inputSource: undefined,
    sampleMs: 0,
    aiAssistant: undefined,
    review: undefined,
    status: undefined,
    name: "",
    aiAssistParams: undefined,
    visibility: undefined,
    appId: "",
    userId: "",
    labelOrderId: "",
    concepts: [],
    deletePreviousAnnotations: false,
    metrics: undefined,
    priority: 0,
    metadata: undefined,
  };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.worker !== undefined) {
      TaskWorker.encode(message.worker, writer.uint32(50).fork()).join();
    }
    for (const v of message.conceptIds) {
      writer.uint32(58).string(v!);
    }
    if (message.inputSource !== undefined) {
      TaskInputSource.encode(message.inputSource, writer.uint32(66).fork()).join();
    }
    if (message.sampleMs !== 0) {
      writer.uint32(72).uint32(message.sampleMs);
    }
    if (message.aiAssistant !== undefined) {
      TaskAIAssistant.encode(message.aiAssistant, writer.uint32(82).fork()).join();
    }
    if (message.review !== undefined) {
      TaskReview.encode(message.review, writer.uint32(90).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(98).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(106).string(message.name);
    }
    if (message.aiAssistParams !== undefined) {
      AiAssistParameters.encode(message.aiAssistParams, writer.uint32(114).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(122).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(130).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(138).string(message.userId);
    }
    if (message.labelOrderId !== "") {
      writer.uint32(146).string(message.labelOrderId);
    }
    for (const v of message.concepts) {
      TaskConcept.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.deletePreviousAnnotations !== false) {
      writer.uint32(160).bool(message.deletePreviousAnnotations);
    }
    if (message.metrics !== undefined) {
      TaskMetrics.encode(message.metrics, writer.uint32(170).fork()).join();
    }
    if (message.priority !== 0) {
      writer.uint32(184).int32(message.priority);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.worker = TaskWorker.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.conceptIds.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputSource = TaskInputSource.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sampleMs = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.aiAssistant = TaskAIAssistant.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.review = TaskReview.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.aiAssistParams = AiAssistParameters.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.labelOrderId = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.concepts.push(TaskConcept.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.deletePreviousAnnotations = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.metrics = TaskMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      type: isSet(object.type) ? task_TaskTypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      worker: isSet(object.worker) ? TaskWorker.fromJSON(object.worker) : undefined,
      conceptIds: globalThis.Array.isArray(object?.conceptIds)
        ? object.conceptIds.map((e: any) => globalThis.String(e))
        : [],
      inputSource: isSet(object.inputSource) ? TaskInputSource.fromJSON(object.inputSource) : undefined,
      sampleMs: isSet(object.sampleMs) ? globalThis.Number(object.sampleMs) : 0,
      aiAssistant: isSet(object.aiAssistant) ? TaskAIAssistant.fromJSON(object.aiAssistant) : undefined,
      review: isSet(object.review) ? TaskReview.fromJSON(object.review) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      aiAssistParams: isSet(object.aiAssistParams) ? AiAssistParameters.fromJSON(object.aiAssistParams) : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      labelOrderId: isSet(object.labelOrderId) ? globalThis.String(object.labelOrderId) : "",
      concepts: globalThis.Array.isArray(object?.concepts)
        ? object.concepts.map((e: any) => TaskConcept.fromJSON(e))
        : [],
      deletePreviousAnnotations: isSet(object.deletePreviousAnnotations)
        ? globalThis.Boolean(object.deletePreviousAnnotations)
        : false,
      metrics: isSet(object.metrics) ? TaskMetrics.fromJSON(object.metrics) : undefined,
      priority: isSet(object.priority) ? task_TaskPriorityFromJSON(object.priority) : 0,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.type !== 0) {
      obj.type = task_TaskTypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.worker !== undefined) {
      obj.worker = TaskWorker.toJSON(message.worker);
    }
    if (message.conceptIds?.length) {
      obj.conceptIds = message.conceptIds;
    }
    if (message.inputSource !== undefined) {
      obj.inputSource = TaskInputSource.toJSON(message.inputSource);
    }
    if (message.sampleMs !== 0) {
      obj.sampleMs = Math.round(message.sampleMs);
    }
    if (message.aiAssistant !== undefined) {
      obj.aiAssistant = TaskAIAssistant.toJSON(message.aiAssistant);
    }
    if (message.review !== undefined) {
      obj.review = TaskReview.toJSON(message.review);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.aiAssistParams !== undefined) {
      obj.aiAssistParams = AiAssistParameters.toJSON(message.aiAssistParams);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.labelOrderId !== "") {
      obj.labelOrderId = message.labelOrderId;
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => TaskConcept.toJSON(e));
    }
    if (message.deletePreviousAnnotations !== false) {
      obj.deletePreviousAnnotations = message.deletePreviousAnnotations;
    }
    if (message.metrics !== undefined) {
      obj.metrics = TaskMetrics.toJSON(message.metrics);
    }
    if (message.priority !== 0) {
      obj.priority = task_TaskPriorityToJSON(message.priority);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? TaskWorker.fromPartial(object.worker)
      : undefined;
    message.conceptIds = object.conceptIds?.map((e) => e) || [];
    message.inputSource = (object.inputSource !== undefined && object.inputSource !== null)
      ? TaskInputSource.fromPartial(object.inputSource)
      : undefined;
    message.sampleMs = object.sampleMs ?? 0;
    message.aiAssistant = (object.aiAssistant !== undefined && object.aiAssistant !== null)
      ? TaskAIAssistant.fromPartial(object.aiAssistant)
      : undefined;
    message.review = (object.review !== undefined && object.review !== null)
      ? TaskReview.fromPartial(object.review)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.name = object.name ?? "";
    message.aiAssistParams = (object.aiAssistParams !== undefined && object.aiAssistParams !== null)
      ? AiAssistParameters.fromPartial(object.aiAssistParams)
      : undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.labelOrderId = object.labelOrderId ?? "";
    message.concepts = object.concepts?.map((e) => TaskConcept.fromPartial(e)) || [];
    message.deletePreviousAnnotations = object.deletePreviousAnnotations ?? false;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? TaskMetrics.fromPartial(object.metrics)
      : undefined;
    message.priority = object.priority ?? 0;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseAiAssistParameters(): AiAssistParameters {
  return { minThreshold: 0, maxThreshold: 0, conceptRelationIds: [] };
}

export const AiAssistParameters: MessageFns<AiAssistParameters> = {
  encode(message: AiAssistParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minThreshold !== 0) {
      writer.uint32(13).float(message.minThreshold);
    }
    if (message.maxThreshold !== 0) {
      writer.uint32(21).float(message.maxThreshold);
    }
    for (const v of message.conceptRelationIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AiAssistParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAiAssistParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.minThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxThreshold = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.conceptRelationIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AiAssistParameters {
    return {
      minThreshold: isSet(object.minThreshold) ? globalThis.Number(object.minThreshold) : 0,
      maxThreshold: isSet(object.maxThreshold) ? globalThis.Number(object.maxThreshold) : 0,
      conceptRelationIds: globalThis.Array.isArray(object?.conceptRelationIds)
        ? object.conceptRelationIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AiAssistParameters): unknown {
    const obj: any = {};
    if (message.minThreshold !== 0) {
      obj.minThreshold = message.minThreshold;
    }
    if (message.maxThreshold !== 0) {
      obj.maxThreshold = message.maxThreshold;
    }
    if (message.conceptRelationIds?.length) {
      obj.conceptRelationIds = message.conceptRelationIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AiAssistParameters>, I>>(base?: I): AiAssistParameters {
    return AiAssistParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AiAssistParameters>, I>>(object: I): AiAssistParameters {
    const message = createBaseAiAssistParameters();
    message.minThreshold = object.minThreshold ?? 0;
    message.maxThreshold = object.maxThreshold ?? 0;
    message.conceptRelationIds = object.conceptRelationIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseTaskWorker(): TaskWorker {
  return { strategy: 0, userIds: [], users: [], partitionedStrategyInfo: undefined, workers: [], type: 0 };
}

export const TaskWorker: MessageFns<TaskWorker> = {
  encode(message: TaskWorker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strategy !== 0) {
      writer.uint32(8).int32(message.strategy);
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.partitionedStrategyInfo !== undefined) {
      TaskWorkerPartitionedStrategyInfo.encode(message.partitionedStrategyInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskWorker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strategy = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.partitionedStrategyInfo = TaskWorkerPartitionedStrategyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskWorker {
    return {
      strategy: isSet(object.strategy) ? taskWorker_TaskWorkerStrategyFromJSON(object.strategy) : 0,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      partitionedStrategyInfo: isSet(object.partitionedStrategyInfo)
        ? TaskWorkerPartitionedStrategyInfo.fromJSON(object.partitionedStrategyInfo)
        : undefined,
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
      type: isSet(object.type) ? taskWorker_WorkerTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: TaskWorker): unknown {
    const obj: any = {};
    if (message.strategy !== 0) {
      obj.strategy = taskWorker_TaskWorkerStrategyToJSON(message.strategy);
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.partitionedStrategyInfo !== undefined) {
      obj.partitionedStrategyInfo = TaskWorkerPartitionedStrategyInfo.toJSON(message.partitionedStrategyInfo);
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = taskWorker_WorkerTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskWorker>, I>>(base?: I): TaskWorker {
    return TaskWorker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskWorker>, I>>(object: I): TaskWorker {
    const message = createBaseTaskWorker();
    message.strategy = object.strategy ?? 0;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.partitionedStrategyInfo =
      (object.partitionedStrategyInfo !== undefined && object.partitionedStrategyInfo !== null)
        ? TaskWorkerPartitionedStrategyInfo.fromPartial(object.partitionedStrategyInfo)
        : undefined;
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTaskWorkerPartitionedStrategyInfo(): TaskWorkerPartitionedStrategyInfo {
  return { type: 0, workersPerInput: 0, weights: undefined };
}

export const TaskWorkerPartitionedStrategyInfo: MessageFns<TaskWorkerPartitionedStrategyInfo> = {
  encode(message: TaskWorkerPartitionedStrategyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.workersPerInput !== 0) {
      writer.uint32(16).int32(message.workersPerInput);
    }
    if (message.weights !== undefined) {
      Struct.encode(Struct.wrap(message.weights), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskWorkerPartitionedStrategyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkerPartitionedStrategyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workersPerInput = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.weights = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskWorkerPartitionedStrategyInfo {
    return {
      type: isSet(object.type)
        ? taskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategyFromJSON(object.type)
        : 0,
      workersPerInput: isSet(object.workersPerInput) ? globalThis.Number(object.workersPerInput) : 0,
      weights: isObject(object.weights) ? object.weights : undefined,
    };
  },

  toJSON(message: TaskWorkerPartitionedStrategyInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = taskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategyToJSON(message.type);
    }
    if (message.workersPerInput !== 0) {
      obj.workersPerInput = Math.round(message.workersPerInput);
    }
    if (message.weights !== undefined) {
      obj.weights = message.weights;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskWorkerPartitionedStrategyInfo>, I>>(
    base?: I,
  ): TaskWorkerPartitionedStrategyInfo {
    return TaskWorkerPartitionedStrategyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskWorkerPartitionedStrategyInfo>, I>>(
    object: I,
  ): TaskWorkerPartitionedStrategyInfo {
    const message = createBaseTaskWorkerPartitionedStrategyInfo();
    message.type = object.type ?? 0;
    message.workersPerInput = object.workersPerInput ?? 0;
    message.weights = object.weights ?? undefined;
    return message;
  },
};

function createBaseTaskInputSource(): TaskInputSource {
  return { type: 0, id: "" };
}

export const TaskInputSource: MessageFns<TaskInputSource> = {
  encode(message: TaskInputSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskInputSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskInputSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskInputSource {
    return {
      type: isSet(object.type) ? taskInputSource_TaskInputSourceTypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: TaskInputSource): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = taskInputSource_TaskInputSourceTypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskInputSource>, I>>(base?: I): TaskInputSource {
    return TaskInputSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskInputSource>, I>>(object: I): TaskInputSource {
    const message = createBaseTaskInputSource();
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseTaskReview(): TaskReview {
  return { strategy: 0, userIds: [], users: [], manualStrategyInfo: undefined, consensusStrategyInfo: undefined };
}

export const TaskReview: MessageFns<TaskReview> = {
  encode(message: TaskReview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strategy !== 0) {
      writer.uint32(8).int32(message.strategy);
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.manualStrategyInfo !== undefined) {
      TaskReviewManualStrategyInfo.encode(message.manualStrategyInfo, writer.uint32(26).fork()).join();
    }
    if (message.consensusStrategyInfo !== undefined) {
      TaskReviewConsensusStrategyInfo.encode(message.consensusStrategyInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskReview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskReview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strategy = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.manualStrategyInfo = TaskReviewManualStrategyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consensusStrategyInfo = TaskReviewConsensusStrategyInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskReview {
    return {
      strategy: isSet(object.strategy) ? taskReview_TaskReviewStrategyFromJSON(object.strategy) : 0,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      manualStrategyInfo: isSet(object.manualStrategyInfo)
        ? TaskReviewManualStrategyInfo.fromJSON(object.manualStrategyInfo)
        : undefined,
      consensusStrategyInfo: isSet(object.consensusStrategyInfo)
        ? TaskReviewConsensusStrategyInfo.fromJSON(object.consensusStrategyInfo)
        : undefined,
    };
  },

  toJSON(message: TaskReview): unknown {
    const obj: any = {};
    if (message.strategy !== 0) {
      obj.strategy = taskReview_TaskReviewStrategyToJSON(message.strategy);
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.manualStrategyInfo !== undefined) {
      obj.manualStrategyInfo = TaskReviewManualStrategyInfo.toJSON(message.manualStrategyInfo);
    }
    if (message.consensusStrategyInfo !== undefined) {
      obj.consensusStrategyInfo = TaskReviewConsensusStrategyInfo.toJSON(message.consensusStrategyInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskReview>, I>>(base?: I): TaskReview {
    return TaskReview.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskReview>, I>>(object: I): TaskReview {
    const message = createBaseTaskReview();
    message.strategy = object.strategy ?? 0;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.manualStrategyInfo = (object.manualStrategyInfo !== undefined && object.manualStrategyInfo !== null)
      ? TaskReviewManualStrategyInfo.fromPartial(object.manualStrategyInfo)
      : undefined;
    message.consensusStrategyInfo =
      (object.consensusStrategyInfo !== undefined && object.consensusStrategyInfo !== null)
        ? TaskReviewConsensusStrategyInfo.fromPartial(object.consensusStrategyInfo)
        : undefined;
    return message;
  },
};

function createBaseTaskReviewManualStrategyInfo(): TaskReviewManualStrategyInfo {
  return { samplePercentage: 0, approvalThreshold: 0 };
}

export const TaskReviewManualStrategyInfo: MessageFns<TaskReviewManualStrategyInfo> = {
  encode(message: TaskReviewManualStrategyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.samplePercentage !== 0) {
      writer.uint32(13).float(message.samplePercentage);
    }
    if (message.approvalThreshold !== 0) {
      writer.uint32(16).int32(message.approvalThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskReviewManualStrategyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskReviewManualStrategyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.samplePercentage = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approvalThreshold = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskReviewManualStrategyInfo {
    return {
      samplePercentage: isSet(object.samplePercentage) ? globalThis.Number(object.samplePercentage) : 0,
      approvalThreshold: isSet(object.approvalThreshold) ? globalThis.Number(object.approvalThreshold) : 0,
    };
  },

  toJSON(message: TaskReviewManualStrategyInfo): unknown {
    const obj: any = {};
    if (message.samplePercentage !== 0) {
      obj.samplePercentage = message.samplePercentage;
    }
    if (message.approvalThreshold !== 0) {
      obj.approvalThreshold = Math.round(message.approvalThreshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskReviewManualStrategyInfo>, I>>(base?: I): TaskReviewManualStrategyInfo {
    return TaskReviewManualStrategyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskReviewManualStrategyInfo>, I>>(object: I): TaskReviewManualStrategyInfo {
    const message = createBaseTaskReviewManualStrategyInfo();
    message.samplePercentage = object.samplePercentage ?? 0;
    message.approvalThreshold = object.approvalThreshold ?? 0;
    return message;
  },
};

function createBaseTaskReviewConsensusStrategyInfo(): TaskReviewConsensusStrategyInfo {
  return { approvalThreshold: 0, approvalThresholdLabelers: 0, approvalThresholdReviewers: 0 };
}

export const TaskReviewConsensusStrategyInfo: MessageFns<TaskReviewConsensusStrategyInfo> = {
  encode(message: TaskReviewConsensusStrategyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approvalThreshold !== 0) {
      writer.uint32(16).uint32(message.approvalThreshold);
    }
    if (message.approvalThresholdLabelers !== 0) {
      writer.uint32(24).uint32(message.approvalThresholdLabelers);
    }
    if (message.approvalThresholdReviewers !== 0) {
      writer.uint32(32).int32(message.approvalThresholdReviewers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskReviewConsensusStrategyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskReviewConsensusStrategyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approvalThreshold = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.approvalThresholdLabelers = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.approvalThresholdReviewers = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskReviewConsensusStrategyInfo {
    return {
      approvalThreshold: isSet(object.approvalThreshold) ? globalThis.Number(object.approvalThreshold) : 0,
      approvalThresholdLabelers: isSet(object.approvalThresholdLabelers)
        ? globalThis.Number(object.approvalThresholdLabelers)
        : 0,
      approvalThresholdReviewers: isSet(object.approvalThresholdReviewers)
        ? globalThis.Number(object.approvalThresholdReviewers)
        : 0,
    };
  },

  toJSON(message: TaskReviewConsensusStrategyInfo): unknown {
    const obj: any = {};
    if (message.approvalThreshold !== 0) {
      obj.approvalThreshold = Math.round(message.approvalThreshold);
    }
    if (message.approvalThresholdLabelers !== 0) {
      obj.approvalThresholdLabelers = Math.round(message.approvalThresholdLabelers);
    }
    if (message.approvalThresholdReviewers !== 0) {
      obj.approvalThresholdReviewers = Math.round(message.approvalThresholdReviewers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskReviewConsensusStrategyInfo>, I>>(base?: I): TaskReviewConsensusStrategyInfo {
    return TaskReviewConsensusStrategyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskReviewConsensusStrategyInfo>, I>>(
    object: I,
  ): TaskReviewConsensusStrategyInfo {
    const message = createBaseTaskReviewConsensusStrategyInfo();
    message.approvalThreshold = object.approvalThreshold ?? 0;
    message.approvalThresholdLabelers = object.approvalThresholdLabelers ?? 0;
    message.approvalThresholdReviewers = object.approvalThresholdReviewers ?? 0;
    return message;
  },
};

function createBaseTaskAIAssistant(): TaskAIAssistant {
  return { workflowId: "", workflow: undefined };
}

export const TaskAIAssistant: MessageFns<TaskAIAssistant> = {
  encode(message: TaskAIAssistant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskAIAssistant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAIAssistant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAIAssistant {
    return {
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
    };
  },

  toJSON(message: TaskAIAssistant): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAIAssistant>, I>>(base?: I): TaskAIAssistant {
    return TaskAIAssistant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAIAssistant>, I>>(object: I): TaskAIAssistant {
    const message = createBaseTaskAIAssistant();
    message.workflowId = object.workflowId ?? "";
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    return message;
  },
};

function createBaseTaskAssignment(): TaskAssignment {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    worker: undefined,
    input: undefined,
    status: undefined,
  };
}

export const TaskAssignment: MessageFns<TaskAssignment> = {
  encode(message: TaskAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(34).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(42).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAssignment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: TaskAssignment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAssignment>, I>>(base?: I): TaskAssignment {
    return TaskAssignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAssignment>, I>>(object: I): TaskAssignment {
    const message = createBaseTaskAssignment();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseTaskStatusCountPerUser(): TaskStatusCountPerUser {
  return {
    userId: "",
    pending: 0,
    awaitingReview: 0,
    success: 0,
    reviewDenied: 0,
    awaitingConsensusReview: 0,
    worker: undefined,
  };
}

export const TaskStatusCountPerUser: MessageFns<TaskStatusCountPerUser> = {
  encode(message: TaskStatusCountPerUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.pending !== 0) {
      writer.uint32(16).uint32(message.pending);
    }
    if (message.awaitingReview !== 0) {
      writer.uint32(24).uint32(message.awaitingReview);
    }
    if (message.success !== 0) {
      writer.uint32(32).uint32(message.success);
    }
    if (message.reviewDenied !== 0) {
      writer.uint32(40).uint32(message.reviewDenied);
    }
    if (message.awaitingConsensusReview !== 0) {
      writer.uint32(48).uint32(message.awaitingConsensusReview);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStatusCountPerUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStatusCountPerUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pending = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.awaitingReview = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reviewDenied = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.awaitingConsensusReview = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskStatusCountPerUser {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      pending: isSet(object.pending) ? globalThis.Number(object.pending) : 0,
      awaitingReview: isSet(object.awaitingReview) ? globalThis.Number(object.awaitingReview) : 0,
      success: isSet(object.success) ? globalThis.Number(object.success) : 0,
      reviewDenied: isSet(object.reviewDenied) ? globalThis.Number(object.reviewDenied) : 0,
      awaitingConsensusReview: isSet(object.awaitingConsensusReview)
        ? globalThis.Number(object.awaitingConsensusReview)
        : 0,
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
    };
  },

  toJSON(message: TaskStatusCountPerUser): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.pending !== 0) {
      obj.pending = Math.round(message.pending);
    }
    if (message.awaitingReview !== 0) {
      obj.awaitingReview = Math.round(message.awaitingReview);
    }
    if (message.success !== 0) {
      obj.success = Math.round(message.success);
    }
    if (message.reviewDenied !== 0) {
      obj.reviewDenied = Math.round(message.reviewDenied);
    }
    if (message.awaitingConsensusReview !== 0) {
      obj.awaitingConsensusReview = Math.round(message.awaitingConsensusReview);
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskStatusCountPerUser>, I>>(base?: I): TaskStatusCountPerUser {
    return TaskStatusCountPerUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskStatusCountPerUser>, I>>(object: I): TaskStatusCountPerUser {
    const message = createBaseTaskStatusCountPerUser();
    message.userId = object.userId ?? "";
    message.pending = object.pending ?? 0;
    message.awaitingReview = object.awaitingReview ?? 0;
    message.success = object.success ?? 0;
    message.reviewDenied = object.reviewDenied ?? 0;
    message.awaitingConsensusReview = object.awaitingConsensusReview ?? 0;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    return message;
  },
};

function createBaseThresholdRange(): ThresholdRange {
  return { isLowerInclusive: false, isUpperInclusive: false, lower: 0, upper: 0 };
}

export const ThresholdRange: MessageFns<ThresholdRange> = {
  encode(message: ThresholdRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isLowerInclusive !== false) {
      writer.uint32(8).bool(message.isLowerInclusive);
    }
    if (message.isUpperInclusive !== false) {
      writer.uint32(16).bool(message.isUpperInclusive);
    }
    if (message.lower !== 0) {
      writer.uint32(29).float(message.lower);
    }
    if (message.upper !== 0) {
      writer.uint32(37).float(message.upper);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThresholdRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThresholdRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isLowerInclusive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isUpperInclusive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.lower = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.upper = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThresholdRange {
    return {
      isLowerInclusive: isSet(object.isLowerInclusive) ? globalThis.Boolean(object.isLowerInclusive) : false,
      isUpperInclusive: isSet(object.isUpperInclusive) ? globalThis.Boolean(object.isUpperInclusive) : false,
      lower: isSet(object.lower) ? globalThis.Number(object.lower) : 0,
      upper: isSet(object.upper) ? globalThis.Number(object.upper) : 0,
    };
  },

  toJSON(message: ThresholdRange): unknown {
    const obj: any = {};
    if (message.isLowerInclusive !== false) {
      obj.isLowerInclusive = message.isLowerInclusive;
    }
    if (message.isUpperInclusive !== false) {
      obj.isUpperInclusive = message.isUpperInclusive;
    }
    if (message.lower !== 0) {
      obj.lower = message.lower;
    }
    if (message.upper !== 0) {
      obj.upper = message.upper;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThresholdRange>, I>>(base?: I): ThresholdRange {
    return ThresholdRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThresholdRange>, I>>(object: I): ThresholdRange {
    const message = createBaseThresholdRange();
    message.isLowerInclusive = object.isLowerInclusive ?? false;
    message.isUpperInclusive = object.isUpperInclusive ?? false;
    message.lower = object.lower ?? 0;
    message.upper = object.upper ?? 0;
    return message;
  },
};

function createBaseTaskConceptAutoAnnotationConfig(): TaskConceptAutoAnnotationConfig {
  return { annotationDataTypes: 0, thresholdRange: undefined, statusCode: 0 };
}

export const TaskConceptAutoAnnotationConfig: MessageFns<TaskConceptAutoAnnotationConfig> = {
  encode(message: TaskConceptAutoAnnotationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationDataTypes !== 0) {
      writer.uint32(8).uint32(message.annotationDataTypes);
    }
    if (message.thresholdRange !== undefined) {
      ThresholdRange.encode(message.thresholdRange, writer.uint32(18).fork()).join();
    }
    if (message.statusCode !== 0) {
      writer.uint32(24).int32(message.statusCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskConceptAutoAnnotationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskConceptAutoAnnotationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.annotationDataTypes = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thresholdRange = ThresholdRange.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statusCode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskConceptAutoAnnotationConfig {
    return {
      annotationDataTypes: isSet(object.annotationDataTypes) ? globalThis.Number(object.annotationDataTypes) : 0,
      thresholdRange: isSet(object.thresholdRange) ? ThresholdRange.fromJSON(object.thresholdRange) : undefined,
      statusCode: isSet(object.statusCode) ? statusCodeFromJSON(object.statusCode) : 0,
    };
  },

  toJSON(message: TaskConceptAutoAnnotationConfig): unknown {
    const obj: any = {};
    if (message.annotationDataTypes !== 0) {
      obj.annotationDataTypes = Math.round(message.annotationDataTypes);
    }
    if (message.thresholdRange !== undefined) {
      obj.thresholdRange = ThresholdRange.toJSON(message.thresholdRange);
    }
    if (message.statusCode !== 0) {
      obj.statusCode = statusCodeToJSON(message.statusCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskConceptAutoAnnotationConfig>, I>>(base?: I): TaskConceptAutoAnnotationConfig {
    return TaskConceptAutoAnnotationConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskConceptAutoAnnotationConfig>, I>>(
    object: I,
  ): TaskConceptAutoAnnotationConfig {
    const message = createBaseTaskConceptAutoAnnotationConfig();
    message.annotationDataTypes = object.annotationDataTypes ?? 0;
    message.thresholdRange = (object.thresholdRange !== undefined && object.thresholdRange !== null)
      ? ThresholdRange.fromPartial(object.thresholdRange)
      : undefined;
    message.statusCode = object.statusCode ?? 0;
    return message;
  },
};

function createBaseTaskConcept(): TaskConcept {
  return { concept: undefined, autoAnnotationConfig: undefined };
}

export const TaskConcept: MessageFns<TaskConcept> = {
  encode(message: TaskConcept, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.concept !== undefined) {
      Concept.encode(message.concept, writer.uint32(10).fork()).join();
    }
    if (message.autoAnnotationConfig !== undefined) {
      TaskConceptAutoAnnotationConfig.encode(message.autoAnnotationConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskConcept {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskConcept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.concept = Concept.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.autoAnnotationConfig = TaskConceptAutoAnnotationConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskConcept {
    return {
      concept: isSet(object.concept) ? Concept.fromJSON(object.concept) : undefined,
      autoAnnotationConfig: isSet(object.autoAnnotationConfig)
        ? TaskConceptAutoAnnotationConfig.fromJSON(object.autoAnnotationConfig)
        : undefined,
    };
  },

  toJSON(message: TaskConcept): unknown {
    const obj: any = {};
    if (message.concept !== undefined) {
      obj.concept = Concept.toJSON(message.concept);
    }
    if (message.autoAnnotationConfig !== undefined) {
      obj.autoAnnotationConfig = TaskConceptAutoAnnotationConfig.toJSON(message.autoAnnotationConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskConcept>, I>>(base?: I): TaskConcept {
    return TaskConcept.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskConcept>, I>>(object: I): TaskConcept {
    const message = createBaseTaskConcept();
    message.concept = (object.concept !== undefined && object.concept !== null)
      ? Concept.fromPartial(object.concept)
      : undefined;
    message.autoAnnotationConfig = (object.autoAnnotationConfig !== undefined && object.autoAnnotationConfig !== null)
      ? TaskConceptAutoAnnotationConfig.fromPartial(object.autoAnnotationConfig)
      : undefined;
    return message;
  },
};

function createBaseTaskMetrics(): TaskMetrics {
  return { work: undefined, review: undefined, inputSource: undefined };
}

export const TaskMetrics: MessageFns<TaskMetrics> = {
  encode(message: TaskMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.work !== undefined) {
      TaskWorkMetrics.encode(message.work, writer.uint32(18).fork()).join();
    }
    if (message.review !== undefined) {
      TaskReviewMetrics.encode(message.review, writer.uint32(26).fork()).join();
    }
    if (message.inputSource !== undefined) {
      TaskInputSourceMetrics.encode(message.inputSource, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.work = TaskWorkMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.review = TaskReviewMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputSource = TaskInputSourceMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetrics {
    return {
      work: isSet(object.work) ? TaskWorkMetrics.fromJSON(object.work) : undefined,
      review: isSet(object.review) ? TaskReviewMetrics.fromJSON(object.review) : undefined,
      inputSource: isSet(object.inputSource) ? TaskInputSourceMetrics.fromJSON(object.inputSource) : undefined,
    };
  },

  toJSON(message: TaskMetrics): unknown {
    const obj: any = {};
    if (message.work !== undefined) {
      obj.work = TaskWorkMetrics.toJSON(message.work);
    }
    if (message.review !== undefined) {
      obj.review = TaskReviewMetrics.toJSON(message.review);
    }
    if (message.inputSource !== undefined) {
      obj.inputSource = TaskInputSourceMetrics.toJSON(message.inputSource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskMetrics>, I>>(base?: I): TaskMetrics {
    return TaskMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskMetrics>, I>>(object: I): TaskMetrics {
    const message = createBaseTaskMetrics();
    message.work = (object.work !== undefined && object.work !== null)
      ? TaskWorkMetrics.fromPartial(object.work)
      : undefined;
    message.review = (object.review !== undefined && object.review !== null)
      ? TaskReviewMetrics.fromPartial(object.review)
      : undefined;
    message.inputSource = (object.inputSource !== undefined && object.inputSource !== null)
      ? TaskInputSourceMetrics.fromPartial(object.inputSource)
      : undefined;
    return message;
  },
};

function createBaseTaskWorkMetrics(): TaskWorkMetrics {
  return { inputsCountEstimated: 0, inputsPercentEstimated: 0 };
}

export const TaskWorkMetrics: MessageFns<TaskWorkMetrics> = {
  encode(message: TaskWorkMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsCountEstimated !== 0) {
      writer.uint32(8).uint64(message.inputsCountEstimated);
    }
    if (message.inputsPercentEstimated !== 0) {
      writer.uint32(16).uint32(message.inputsPercentEstimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskWorkMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskWorkMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputsCountEstimated = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputsPercentEstimated = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskWorkMetrics {
    return {
      inputsCountEstimated: isSet(object.inputsCountEstimated) ? globalThis.Number(object.inputsCountEstimated) : 0,
      inputsPercentEstimated: isSet(object.inputsPercentEstimated)
        ? globalThis.Number(object.inputsPercentEstimated)
        : 0,
    };
  },

  toJSON(message: TaskWorkMetrics): unknown {
    const obj: any = {};
    if (message.inputsCountEstimated !== 0) {
      obj.inputsCountEstimated = Math.round(message.inputsCountEstimated);
    }
    if (message.inputsPercentEstimated !== 0) {
      obj.inputsPercentEstimated = Math.round(message.inputsPercentEstimated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskWorkMetrics>, I>>(base?: I): TaskWorkMetrics {
    return TaskWorkMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskWorkMetrics>, I>>(object: I): TaskWorkMetrics {
    const message = createBaseTaskWorkMetrics();
    message.inputsCountEstimated = object.inputsCountEstimated ?? 0;
    message.inputsPercentEstimated = object.inputsPercentEstimated ?? 0;
    return message;
  },
};

function createBaseTaskReviewMetrics(): TaskReviewMetrics {
  return {
    inputsCountEstimated: 0,
    inputsPercentEstimated: 0,
    inputsCountEstimatedPerReviewer: [],
    inputsReviewableCountEstimatedPerReviewer: [],
    inputsPercentEstimatedPerReviewer: [],
  };
}

export const TaskReviewMetrics: MessageFns<TaskReviewMetrics> = {
  encode(message: TaskReviewMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsCountEstimated !== 0) {
      writer.uint32(8).uint64(message.inputsCountEstimated);
    }
    if (message.inputsPercentEstimated !== 0) {
      writer.uint32(16).uint32(message.inputsPercentEstimated);
    }
    writer.uint32(26).fork();
    for (const v of message.inputsCountEstimatedPerReviewer) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.inputsReviewableCountEstimatedPerReviewer) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.inputsPercentEstimatedPerReviewer) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskReviewMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskReviewMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputsCountEstimated = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputsPercentEstimated = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.inputsCountEstimatedPerReviewer.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inputsCountEstimatedPerReviewer.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.inputsReviewableCountEstimatedPerReviewer.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inputsReviewableCountEstimatedPerReviewer.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.inputsPercentEstimatedPerReviewer.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inputsPercentEstimatedPerReviewer.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskReviewMetrics {
    return {
      inputsCountEstimated: isSet(object.inputsCountEstimated) ? globalThis.Number(object.inputsCountEstimated) : 0,
      inputsPercentEstimated: isSet(object.inputsPercentEstimated)
        ? globalThis.Number(object.inputsPercentEstimated)
        : 0,
      inputsCountEstimatedPerReviewer: globalThis.Array.isArray(object?.inputsCountEstimatedPerReviewer)
        ? object.inputsCountEstimatedPerReviewer.map((e: any) => globalThis.Number(e))
        : [],
      inputsReviewableCountEstimatedPerReviewer:
        globalThis.Array.isArray(object?.inputsReviewableCountEstimatedPerReviewer)
          ? object.inputsReviewableCountEstimatedPerReviewer.map((e: any) => globalThis.Number(e))
          : [],
      inputsPercentEstimatedPerReviewer: globalThis.Array.isArray(object?.inputsPercentEstimatedPerReviewer)
        ? object.inputsPercentEstimatedPerReviewer.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: TaskReviewMetrics): unknown {
    const obj: any = {};
    if (message.inputsCountEstimated !== 0) {
      obj.inputsCountEstimated = Math.round(message.inputsCountEstimated);
    }
    if (message.inputsPercentEstimated !== 0) {
      obj.inputsPercentEstimated = Math.round(message.inputsPercentEstimated);
    }
    if (message.inputsCountEstimatedPerReviewer?.length) {
      obj.inputsCountEstimatedPerReviewer = message.inputsCountEstimatedPerReviewer.map((e) => Math.round(e));
    }
    if (message.inputsReviewableCountEstimatedPerReviewer?.length) {
      obj.inputsReviewableCountEstimatedPerReviewer = message.inputsReviewableCountEstimatedPerReviewer.map((e) =>
        Math.round(e)
      );
    }
    if (message.inputsPercentEstimatedPerReviewer?.length) {
      obj.inputsPercentEstimatedPerReviewer = message.inputsPercentEstimatedPerReviewer.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskReviewMetrics>, I>>(base?: I): TaskReviewMetrics {
    return TaskReviewMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskReviewMetrics>, I>>(object: I): TaskReviewMetrics {
    const message = createBaseTaskReviewMetrics();
    message.inputsCountEstimated = object.inputsCountEstimated ?? 0;
    message.inputsPercentEstimated = object.inputsPercentEstimated ?? 0;
    message.inputsCountEstimatedPerReviewer = object.inputsCountEstimatedPerReviewer?.map((e) => e) || [];
    message.inputsReviewableCountEstimatedPerReviewer =
      object.inputsReviewableCountEstimatedPerReviewer?.map((e) => e) || [];
    message.inputsPercentEstimatedPerReviewer = object.inputsPercentEstimatedPerReviewer?.map((e) => e) || [];
    return message;
  },
};

function createBaseTaskInputSourceMetrics(): TaskInputSourceMetrics {
  return { inputsCountEstimated: 0 };
}

export const TaskInputSourceMetrics: MessageFns<TaskInputSourceMetrics> = {
  encode(message: TaskInputSourceMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsCountEstimated !== 0) {
      writer.uint32(8).uint64(message.inputsCountEstimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskInputSourceMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskInputSourceMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputsCountEstimated = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskInputSourceMetrics {
    return {
      inputsCountEstimated: isSet(object.inputsCountEstimated) ? globalThis.Number(object.inputsCountEstimated) : 0,
    };
  },

  toJSON(message: TaskInputSourceMetrics): unknown {
    const obj: any = {};
    if (message.inputsCountEstimated !== 0) {
      obj.inputsCountEstimated = Math.round(message.inputsCountEstimated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskInputSourceMetrics>, I>>(base?: I): TaskInputSourceMetrics {
    return TaskInputSourceMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskInputSourceMetrics>, I>>(object: I): TaskInputSourceMetrics {
    const message = createBaseTaskInputSourceMetrics();
    message.inputsCountEstimated = object.inputsCountEstimated ?? 0;
    return message;
  },
};

function createBaseRole(): Role {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    name: "",
    description: "",
    scopes: [],
    endpoints: [],
    type: 0,
  };
}

export const Role: MessageFns<Role> = {
  encode(message: Role, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.scopes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.endpoints) {
      writer.uint32(58).string(v!);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Role {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Role {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? roleTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Role): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.type !== 0) {
      obj.type = roleTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Role>, I>>(base?: I): Role {
    return Role.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Role>, I>>(object: I): Role {
    const message = createBaseRole();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTeam(): Team {
  return { id: "", createdAt: undefined, modifiedAt: undefined, name: "", defaultRoleId: "" };
}

export const Team: MessageFns<Team> = {
  encode(message: Team, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.defaultRoleId !== "") {
      writer.uint32(42).string(message.defaultRoleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Team {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultRoleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Team {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      defaultRoleId: isSet(object.defaultRoleId) ? globalThis.String(object.defaultRoleId) : "",
    };
  },

  toJSON(message: Team): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.defaultRoleId !== "") {
      obj.defaultRoleId = message.defaultRoleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Team>, I>>(base?: I): Team {
    return Team.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Team>, I>>(object: I): Team {
    const message = createBaseTeam();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.name = object.name ?? "";
    message.defaultRoleId = object.defaultRoleId ?? "";
    return message;
  },
};

function createBaseCollector(): Collector {
  return {
    id: "",
    description: "",
    createdAt: undefined,
    preQueueWorkflowId: "",
    preQueueRandomSample: 0,
    postQueueWorkflowId: "",
    collectorSource: undefined,
    status: undefined,
    collectOutputs: false,
  };
}

export const Collector: MessageFns<Collector> = {
  encode(message: Collector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.preQueueWorkflowId !== "") {
      writer.uint32(34).string(message.preQueueWorkflowId);
    }
    if (message.preQueueRandomSample !== 0) {
      writer.uint32(69).float(message.preQueueRandomSample);
    }
    if (message.postQueueWorkflowId !== "") {
      writer.uint32(42).string(message.postQueueWorkflowId);
    }
    if (message.collectorSource !== undefined) {
      CollectorSource.encode(message.collectorSource, writer.uint32(50).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(58).fork()).join();
    }
    if (message.collectOutputs !== false) {
      writer.uint32(72).bool(message.collectOutputs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.preQueueWorkflowId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.preQueueRandomSample = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.postQueueWorkflowId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collectorSource = CollectorSource.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.collectOutputs = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collector {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      preQueueWorkflowId: isSet(object.preQueueWorkflowId) ? globalThis.String(object.preQueueWorkflowId) : "",
      preQueueRandomSample: isSet(object.preQueueRandomSample) ? globalThis.Number(object.preQueueRandomSample) : 0,
      postQueueWorkflowId: isSet(object.postQueueWorkflowId) ? globalThis.String(object.postQueueWorkflowId) : "",
      collectorSource: isSet(object.collectorSource) ? CollectorSource.fromJSON(object.collectorSource) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      collectOutputs: isSet(object.collectOutputs) ? globalThis.Boolean(object.collectOutputs) : false,
    };
  },

  toJSON(message: Collector): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.preQueueWorkflowId !== "") {
      obj.preQueueWorkflowId = message.preQueueWorkflowId;
    }
    if (message.preQueueRandomSample !== 0) {
      obj.preQueueRandomSample = message.preQueueRandomSample;
    }
    if (message.postQueueWorkflowId !== "") {
      obj.postQueueWorkflowId = message.postQueueWorkflowId;
    }
    if (message.collectorSource !== undefined) {
      obj.collectorSource = CollectorSource.toJSON(message.collectorSource);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.collectOutputs !== false) {
      obj.collectOutputs = message.collectOutputs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Collector>, I>>(base?: I): Collector {
    return Collector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Collector>, I>>(object: I): Collector {
    const message = createBaseCollector();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.preQueueWorkflowId = object.preQueueWorkflowId ?? "";
    message.preQueueRandomSample = object.preQueueRandomSample ?? 0;
    message.postQueueWorkflowId = object.postQueueWorkflowId ?? "";
    message.collectorSource = (object.collectorSource !== undefined && object.collectorSource !== null)
      ? CollectorSource.fromPartial(object.collectorSource)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.collectOutputs = object.collectOutputs ?? false;
    return message;
  },
};

function createBaseCollectorSource(): CollectorSource {
  return { apiPostModelOutputsCollectorSource: undefined };
}

export const CollectorSource: MessageFns<CollectorSource> = {
  encode(message: CollectorSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiPostModelOutputsCollectorSource !== undefined) {
      APIPostModelOutputsCollectorSource.encode(message.apiPostModelOutputsCollectorSource, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectorSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectorSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiPostModelOutputsCollectorSource = APIPostModelOutputsCollectorSource.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectorSource {
    return {
      apiPostModelOutputsCollectorSource: isSet(object.apiPostModelOutputsCollectorSource)
        ? APIPostModelOutputsCollectorSource.fromJSON(object.apiPostModelOutputsCollectorSource)
        : undefined,
    };
  },

  toJSON(message: CollectorSource): unknown {
    const obj: any = {};
    if (message.apiPostModelOutputsCollectorSource !== undefined) {
      obj.apiPostModelOutputsCollectorSource = APIPostModelOutputsCollectorSource.toJSON(
        message.apiPostModelOutputsCollectorSource,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CollectorSource>, I>>(base?: I): CollectorSource {
    return CollectorSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CollectorSource>, I>>(object: I): CollectorSource {
    const message = createBaseCollectorSource();
    message.apiPostModelOutputsCollectorSource =
      (object.apiPostModelOutputsCollectorSource !== undefined && object.apiPostModelOutputsCollectorSource !== null)
        ? APIPostModelOutputsCollectorSource.fromPartial(object.apiPostModelOutputsCollectorSource)
        : undefined;
    return message;
  },
};

function createBaseAPIPostModelOutputsCollectorSource(): APIPostModelOutputsCollectorSource {
  return { modelUserId: "", modelAppId: "", modelId: "", modelVersionId: "", postInputsKeyId: "", callerUserId: "" };
}

export const APIPostModelOutputsCollectorSource: MessageFns<APIPostModelOutputsCollectorSource> = {
  encode(message: APIPostModelOutputsCollectorSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelUserId !== "") {
      writer.uint32(10).string(message.modelUserId);
    }
    if (message.modelAppId !== "") {
      writer.uint32(18).string(message.modelAppId);
    }
    if (message.modelId !== "") {
      writer.uint32(26).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(34).string(message.modelVersionId);
    }
    if (message.postInputsKeyId !== "") {
      writer.uint32(42).string(message.postInputsKeyId);
    }
    if (message.callerUserId !== "") {
      writer.uint32(50).string(message.callerUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): APIPostModelOutputsCollectorSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIPostModelOutputsCollectorSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelUserId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelAppId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.postInputsKeyId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.callerUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APIPostModelOutputsCollectorSource {
    return {
      modelUserId: isSet(object.modelUserId) ? globalThis.String(object.modelUserId) : "",
      modelAppId: isSet(object.modelAppId) ? globalThis.String(object.modelAppId) : "",
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      postInputsKeyId: isSet(object.postInputsKeyId) ? globalThis.String(object.postInputsKeyId) : "",
      callerUserId: isSet(object.callerUserId) ? globalThis.String(object.callerUserId) : "",
    };
  },

  toJSON(message: APIPostModelOutputsCollectorSource): unknown {
    const obj: any = {};
    if (message.modelUserId !== "") {
      obj.modelUserId = message.modelUserId;
    }
    if (message.modelAppId !== "") {
      obj.modelAppId = message.modelAppId;
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.postInputsKeyId !== "") {
      obj.postInputsKeyId = message.postInputsKeyId;
    }
    if (message.callerUserId !== "") {
      obj.callerUserId = message.callerUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APIPostModelOutputsCollectorSource>, I>>(
    base?: I,
  ): APIPostModelOutputsCollectorSource {
    return APIPostModelOutputsCollectorSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APIPostModelOutputsCollectorSource>, I>>(
    object: I,
  ): APIPostModelOutputsCollectorSource {
    const message = createBaseAPIPostModelOutputsCollectorSource();
    message.modelUserId = object.modelUserId ?? "";
    message.modelAppId = object.modelAppId ?? "";
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.postInputsKeyId = object.postInputsKeyId ?? "";
    message.callerUserId = object.callerUserId ?? "";
    return message;
  },
};

function createBaseStatValue(): StatValue {
  return { time: undefined, value: 0, tags: [] };
}

export const StatValue: MessageFns<StatValue> = {
  encode(message: StatValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatValue {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StatValue): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatValue>, I>>(base?: I): StatValue {
    return StatValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatValue>, I>>(object: I): StatValue {
    const message = createBaseStatValue();
    message.time = object.time ?? undefined;
    message.value = object.value ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseStatValueAggregateResult(): StatValueAggregateResult {
  return { statValueAggregates: [], statValueAggregateQuery: undefined };
}

export const StatValueAggregateResult: MessageFns<StatValueAggregateResult> = {
  encode(message: StatValueAggregateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statValueAggregates) {
      StatValueAggregate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.statValueAggregateQuery !== undefined) {
      StatValueAggregateQuery.encode(message.statValueAggregateQuery, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatValueAggregateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatValueAggregateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statValueAggregates.push(StatValueAggregate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statValueAggregateQuery = StatValueAggregateQuery.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatValueAggregateResult {
    return {
      statValueAggregates: globalThis.Array.isArray(object?.statValueAggregates)
        ? object.statValueAggregates.map((e: any) => StatValueAggregate.fromJSON(e))
        : [],
      statValueAggregateQuery: isSet(object.statValueAggregateQuery)
        ? StatValueAggregateQuery.fromJSON(object.statValueAggregateQuery)
        : undefined,
    };
  },

  toJSON(message: StatValueAggregateResult): unknown {
    const obj: any = {};
    if (message.statValueAggregates?.length) {
      obj.statValueAggregates = message.statValueAggregates.map((e) => StatValueAggregate.toJSON(e));
    }
    if (message.statValueAggregateQuery !== undefined) {
      obj.statValueAggregateQuery = StatValueAggregateQuery.toJSON(message.statValueAggregateQuery);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatValueAggregateResult>, I>>(base?: I): StatValueAggregateResult {
    return StatValueAggregateResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatValueAggregateResult>, I>>(object: I): StatValueAggregateResult {
    const message = createBaseStatValueAggregateResult();
    message.statValueAggregates = object.statValueAggregates?.map((e) => StatValueAggregate.fromPartial(e)) || [];
    message.statValueAggregateQuery =
      (object.statValueAggregateQuery !== undefined && object.statValueAggregateQuery !== null)
        ? StatValueAggregateQuery.fromPartial(object.statValueAggregateQuery)
        : undefined;
    return message;
  },
};

function createBaseStatValueAggregate(): StatValueAggregate {
  return { time: undefined, aggregateValue: 0, count: 0, tags: [] };
}

export const StatValueAggregate: MessageFns<StatValueAggregate> = {
  encode(message: StatValueAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.aggregateValue !== 0) {
      writer.uint32(21).float(message.aggregateValue);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint64(message.count);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatValueAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatValueAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.aggregateValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatValueAggregate {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      aggregateValue: isSet(object.aggregateValue) ? globalThis.Number(object.aggregateValue) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StatValueAggregate): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.aggregateValue !== 0) {
      obj.aggregateValue = message.aggregateValue;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatValueAggregate>, I>>(base?: I): StatValueAggregate {
    return StatValueAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatValueAggregate>, I>>(object: I): StatValueAggregate {
    const message = createBaseStatValueAggregate();
    message.time = object.time ?? undefined;
    message.aggregateValue = object.aggregateValue ?? 0;
    message.count = object.count ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseStatValueAggregateQuery(): StatValueAggregateQuery {
  return { tags: [], tagGroups: [], statValueAggType: 0, statTimeAggType: 0, startTime: undefined, endTime: undefined };
}

export const StatValueAggregateQuery: MessageFns<StatValueAggregateQuery> = {
  encode(message: StatValueAggregateQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.tagGroups) {
      writer.uint32(18).string(v!);
    }
    if (message.statValueAggType !== 0) {
      writer.uint32(24).int32(message.statValueAggType);
    }
    if (message.statTimeAggType !== 0) {
      writer.uint32(32).int32(message.statTimeAggType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatValueAggregateQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatValueAggregateQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagGroups.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statValueAggType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.statTimeAggType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatValueAggregateQuery {
    return {
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      tagGroups: globalThis.Array.isArray(object?.tagGroups)
        ? object.tagGroups.map((e: any) => globalThis.String(e))
        : [],
      statValueAggType: isSet(object.statValueAggType) ? statValueAggTypeFromJSON(object.statValueAggType) : 0,
      statTimeAggType: isSet(object.statTimeAggType) ? statTimeAggTypeFromJSON(object.statTimeAggType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: StatValueAggregateQuery): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.tagGroups?.length) {
      obj.tagGroups = message.tagGroups;
    }
    if (message.statValueAggType !== 0) {
      obj.statValueAggType = statValueAggTypeToJSON(message.statValueAggType);
    }
    if (message.statTimeAggType !== 0) {
      obj.statTimeAggType = statTimeAggTypeToJSON(message.statTimeAggType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatValueAggregateQuery>, I>>(base?: I): StatValueAggregateQuery {
    return StatValueAggregateQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatValueAggregateQuery>, I>>(object: I): StatValueAggregateQuery {
    const message = createBaseStatValueAggregateQuery();
    message.tags = object.tags?.map((e) => e) || [];
    message.tagGroups = object.tagGroups?.map((e) => e) || [];
    message.statValueAggType = object.statValueAggType ?? 0;
    message.statTimeAggType = object.statTimeAggType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBasePCAProjectionComparator(): PCAProjectionComparator {
  return { distanceThreshold: 0, modelVersionId: "" };
}

export const PCAProjectionComparator: MessageFns<PCAProjectionComparator> = {
  encode(message: PCAProjectionComparator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceThreshold !== 0) {
      writer.uint32(13).float(message.distanceThreshold);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(18).string(message.modelVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PCAProjectionComparator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePCAProjectionComparator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.distanceThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PCAProjectionComparator {
    return {
      distanceThreshold: isSet(object.distanceThreshold) ? globalThis.Number(object.distanceThreshold) : 0,
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
    };
  },

  toJSON(message: PCAProjectionComparator): unknown {
    const obj: any = {};
    if (message.distanceThreshold !== 0) {
      obj.distanceThreshold = message.distanceThreshold;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PCAProjectionComparator>, I>>(base?: I): PCAProjectionComparator {
    return PCAProjectionComparator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PCAProjectionComparator>, I>>(object: I): PCAProjectionComparator {
    const message = createBasePCAProjectionComparator();
    message.distanceThreshold = object.distanceThreshold ?? 0;
    message.modelVersionId = object.modelVersionId ?? "";
    return message;
  },
};

function createBaseDuplicateAnnotationsResults(): DuplicateAnnotationsResults {
  return { duplicateCfid: [], uniqueCount: 0 };
}

export const DuplicateAnnotationsResults: MessageFns<DuplicateAnnotationsResults> = {
  encode(message: DuplicateAnnotationsResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.duplicateCfid) {
      writer.uint32(10).string(v!);
    }
    if (message.uniqueCount !== 0) {
      writer.uint32(16).int32(message.uniqueCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DuplicateAnnotationsResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateAnnotationsResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duplicateCfid.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uniqueCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateAnnotationsResults {
    return {
      duplicateCfid: globalThis.Array.isArray(object?.duplicateCfid)
        ? object.duplicateCfid.map((e: any) => globalThis.String(e))
        : [],
      uniqueCount: isSet(object.uniqueCount) ? globalThis.Number(object.uniqueCount) : 0,
    };
  },

  toJSON(message: DuplicateAnnotationsResults): unknown {
    const obj: any = {};
    if (message.duplicateCfid?.length) {
      obj.duplicateCfid = message.duplicateCfid;
    }
    if (message.uniqueCount !== 0) {
      obj.uniqueCount = Math.round(message.uniqueCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateAnnotationsResults>, I>>(base?: I): DuplicateAnnotationsResults {
    return DuplicateAnnotationsResults.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateAnnotationsResults>, I>>(object: I): DuplicateAnnotationsResults {
    const message = createBaseDuplicateAnnotationsResults();
    message.duplicateCfid = object.duplicateCfid?.map((e) => e) || [];
    message.uniqueCount = object.uniqueCount ?? 0;
    return message;
  },
};

function createBaseVisibility(): Visibility {
  return { gettable: 0 };
}

export const Visibility: MessageFns<Visibility> = {
  encode(message: Visibility, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gettable !== 0) {
      writer.uint32(8).int32(message.gettable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Visibility {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gettable = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Visibility {
    return { gettable: isSet(object.gettable) ? visibility_GettableFromJSON(object.gettable) : 0 };
  },

  toJSON(message: Visibility): unknown {
    const obj: any = {};
    if (message.gettable !== 0) {
      obj.gettable = visibility_GettableToJSON(message.gettable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Visibility>, I>>(base?: I): Visibility {
    return Visibility.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Visibility>, I>>(object: I): Visibility {
    const message = createBaseVisibility();
    message.gettable = object.gettable ?? 0;
    return message;
  },
};

function createBaseFullTag(): FullTag {
  return { name: "", id: "" };
}

export const FullTag: MessageFns<FullTag> = {
  encode(message: FullTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FullTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FullTag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: FullTag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FullTag>, I>>(base?: I): FullTag {
    return FullTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FullTag>, I>>(object: I): FullTag {
    const message = createBaseFullTag();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseTimeSegment(): TimeSegment {
  return { id: "", data: undefined, timeInfo: undefined };
}

export const TimeSegment: MessageFns<TimeSegment> = {
  encode(message: TimeSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== undefined) {
      Data.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.timeInfo !== undefined) {
      TimeInfo.encode(message.timeInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Data.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeInfo = TimeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSegment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? Data.fromJSON(object.data) : undefined,
      timeInfo: isSet(object.timeInfo) ? TimeInfo.fromJSON(object.timeInfo) : undefined,
    };
  },

  toJSON(message: TimeSegment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== undefined) {
      obj.data = Data.toJSON(message.data);
    }
    if (message.timeInfo !== undefined) {
      obj.timeInfo = TimeInfo.toJSON(message.timeInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeSegment>, I>>(base?: I): TimeSegment {
    return TimeSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeSegment>, I>>(object: I): TimeSegment {
    const message = createBaseTimeSegment();
    message.id = object.id ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Data.fromPartial(object.data) : undefined;
    message.timeInfo = (object.timeInfo !== undefined && object.timeInfo !== null)
      ? TimeInfo.fromPartial(object.timeInfo)
      : undefined;
    return message;
  },
};

function createBaseTimeInfo(): TimeInfo {
  return { numFrames: 0, beginTime: 0, endTime: 0 };
}

export const TimeInfo: MessageFns<TimeInfo> = {
  encode(message: TimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numFrames !== 0) {
      writer.uint32(8).uint32(message.numFrames);
    }
    if (message.beginTime !== 0) {
      writer.uint32(37).float(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(45).float(message.endTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numFrames = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.beginTime = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.endTime = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeInfo {
    return {
      numFrames: isSet(object.numFrames) ? globalThis.Number(object.numFrames) : 0,
      beginTime: isSet(object.beginTime) ? globalThis.Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
    };
  },

  toJSON(message: TimeInfo): unknown {
    const obj: any = {};
    if (message.numFrames !== 0) {
      obj.numFrames = Math.round(message.numFrames);
    }
    if (message.beginTime !== 0) {
      obj.beginTime = message.beginTime;
    }
    if (message.endTime !== 0) {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeInfo>, I>>(base?: I): TimeInfo {
    return TimeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeInfo>, I>>(object: I): TimeInfo {
    const message = createBaseTimeInfo();
    message.numFrames = object.numFrames ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    return message;
  },
};

function createBaseDatasetStar(): DatasetStar {
  return { datasetId: "" };
}

export const DatasetStar: MessageFns<DatasetStar> = {
  encode(message: DatasetStar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetStar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetStar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetStar {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: DatasetStar): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetStar>, I>>(base?: I): DatasetStar {
    return DatasetStar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetStar>, I>>(object: I): DatasetStar {
    const message = createBaseDatasetStar();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

function createBaseModuleStar(): ModuleStar {
  return { moduleId: "" };
}

export const ModuleStar: MessageFns<ModuleStar> = {
  encode(message: ModuleStar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleId !== "") {
      writer.uint32(10).string(message.moduleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleStar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleStar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleStar {
    return { moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "" };
  },

  toJSON(message: ModuleStar): unknown {
    const obj: any = {};
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleStar>, I>>(base?: I): ModuleStar {
    return ModuleStar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleStar>, I>>(object: I): ModuleStar {
    const message = createBaseModuleStar();
    message.moduleId = object.moduleId ?? "";
    return message;
  },
};

function createBaseModule(): Module {
  return {
    id: "",
    description: "",
    createdAt: undefined,
    modifiedAt: undefined,
    visibility: undefined,
    metadata: undefined,
    userId: "",
    appId: "",
    moduleVersion: undefined,
    isStarred: false,
    starCount: 0,
    bookmarkOrigin: undefined,
    image: undefined,
  };
}

export const Module: MessageFns<Module> = {
  encode(message: Module, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(42).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(74).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(82).string(message.appId);
    }
    if (message.moduleVersion !== undefined) {
      ModuleVersion.encode(message.moduleVersion, writer.uint32(90).fork()).join();
    }
    if (message.isStarred !== false) {
      writer.uint32(96).bool(message.isStarred);
    }
    if (message.starCount !== 0) {
      writer.uint32(104).int32(message.starCount);
    }
    if (message.bookmarkOrigin !== undefined) {
      BookmarkOrigin.encode(message.bookmarkOrigin, writer.uint32(114).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Module {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.moduleVersion = ModuleVersion.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.starCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bookmarkOrigin = BookmarkOrigin.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Module {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      moduleVersion: isSet(object.moduleVersion) ? ModuleVersion.fromJSON(object.moduleVersion) : undefined,
      isStarred: isSet(object.isStarred) ? globalThis.Boolean(object.isStarred) : false,
      starCount: isSet(object.starCount) ? globalThis.Number(object.starCount) : 0,
      bookmarkOrigin: isSet(object.bookmarkOrigin) ? BookmarkOrigin.fromJSON(object.bookmarkOrigin) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: Module): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.moduleVersion !== undefined) {
      obj.moduleVersion = ModuleVersion.toJSON(message.moduleVersion);
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.starCount !== 0) {
      obj.starCount = Math.round(message.starCount);
    }
    if (message.bookmarkOrigin !== undefined) {
      obj.bookmarkOrigin = BookmarkOrigin.toJSON(message.bookmarkOrigin);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Module>, I>>(base?: I): Module {
    return Module.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Module>, I>>(object: I): Module {
    const message = createBaseModule();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.moduleVersion = (object.moduleVersion !== undefined && object.moduleVersion !== null)
      ? ModuleVersion.fromPartial(object.moduleVersion)
      : undefined;
    message.isStarred = object.isStarred ?? false;
    message.starCount = object.starCount ?? 0;
    message.bookmarkOrigin = (object.bookmarkOrigin !== undefined && object.bookmarkOrigin !== null)
      ? BookmarkOrigin.fromPartial(object.bookmarkOrigin)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseModuleVersion(): ModuleVersion {
  return {
    id: "",
    moduleId: "",
    appId: "",
    userId: "",
    description: "",
    notes: "",
    createdAt: undefined,
    modifiedAt: undefined,
    gitCommitUrl: "",
    moduleNav: undefined,
    approved: false,
    visibility: undefined,
    metadata: undefined,
  };
}

export const ModuleVersion: MessageFns<ModuleVersion> = {
  encode(message: ModuleVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.moduleId !== "") {
      writer.uint32(18).string(message.moduleId);
    }
    if (message.appId !== "") {
      writer.uint32(26).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.notes !== "") {
      writer.uint32(58).string(message.notes);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(74).fork()).join();
    }
    if (message.gitCommitUrl !== "") {
      writer.uint32(82).string(message.gitCommitUrl);
    }
    if (message.moduleNav !== undefined) {
      ModuleVersion_ModuleNav.encode(message.moduleNav, writer.uint32(90).fork()).join();
    }
    if (message.approved !== false) {
      writer.uint32(96).bool(message.approved);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(106).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gitCommitUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.moduleNav = ModuleVersion_ModuleNav.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      gitCommitUrl: isSet(object.gitCommitUrl) ? globalThis.String(object.gitCommitUrl) : "",
      moduleNav: isSet(object.moduleNav) ? ModuleVersion_ModuleNav.fromJSON(object.moduleNav) : undefined,
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: ModuleVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.gitCommitUrl !== "") {
      obj.gitCommitUrl = message.gitCommitUrl;
    }
    if (message.moduleNav !== undefined) {
      obj.moduleNav = ModuleVersion_ModuleNav.toJSON(message.moduleNav);
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleVersion>, I>>(base?: I): ModuleVersion {
    return ModuleVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleVersion>, I>>(object: I): ModuleVersion {
    const message = createBaseModuleVersion();
    message.id = object.id ?? "";
    message.moduleId = object.moduleId ?? "";
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.description = object.description ?? "";
    message.notes = object.notes ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.gitCommitUrl = object.gitCommitUrl ?? "";
    message.moduleNav = (object.moduleNav !== undefined && object.moduleNav !== null)
      ? ModuleVersion_ModuleNav.fromPartial(object.moduleNav)
      : undefined;
    message.approved = object.approved ?? false;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseModuleVersion_ModuleSubNav(): ModuleVersion_ModuleSubNav {
  return { title: "", queryKey: "", queryValue: "" };
}

export const ModuleVersion_ModuleSubNav: MessageFns<ModuleVersion_ModuleSubNav> = {
  encode(message: ModuleVersion_ModuleSubNav, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.queryKey !== "") {
      writer.uint32(18).string(message.queryKey);
    }
    if (message.queryValue !== "") {
      writer.uint32(26).string(message.queryValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleVersion_ModuleSubNav {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleVersion_ModuleSubNav();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queryKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queryValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleVersion_ModuleSubNav {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      queryKey: isSet(object.queryKey) ? globalThis.String(object.queryKey) : "",
      queryValue: isSet(object.queryValue) ? globalThis.String(object.queryValue) : "",
    };
  },

  toJSON(message: ModuleVersion_ModuleSubNav): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.queryKey !== "") {
      obj.queryKey = message.queryKey;
    }
    if (message.queryValue !== "") {
      obj.queryValue = message.queryValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleVersion_ModuleSubNav>, I>>(base?: I): ModuleVersion_ModuleSubNav {
    return ModuleVersion_ModuleSubNav.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleVersion_ModuleSubNav>, I>>(object: I): ModuleVersion_ModuleSubNav {
    const message = createBaseModuleVersion_ModuleSubNav();
    message.title = object.title ?? "";
    message.queryKey = object.queryKey ?? "";
    message.queryValue = object.queryValue ?? "";
    return message;
  },
};

function createBaseModuleVersion_ModuleNav(): ModuleVersion_ModuleNav {
  return { title: "", moduleSubNavs: [] };
}

export const ModuleVersion_ModuleNav: MessageFns<ModuleVersion_ModuleNav> = {
  encode(message: ModuleVersion_ModuleNav, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.moduleSubNavs) {
      ModuleVersion_ModuleSubNav.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleVersion_ModuleNav {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleVersion_ModuleNav();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleSubNavs.push(ModuleVersion_ModuleSubNav.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleVersion_ModuleNav {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      moduleSubNavs: globalThis.Array.isArray(object?.moduleSubNavs)
        ? object.moduleSubNavs.map((e: any) => ModuleVersion_ModuleSubNav.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModuleVersion_ModuleNav): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.moduleSubNavs?.length) {
      obj.moduleSubNavs = message.moduleSubNavs.map((e) => ModuleVersion_ModuleSubNav.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModuleVersion_ModuleNav>, I>>(base?: I): ModuleVersion_ModuleNav {
    return ModuleVersion_ModuleNav.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModuleVersion_ModuleNav>, I>>(object: I): ModuleVersion_ModuleNav {
    const message = createBaseModuleVersion_ModuleNav();
    message.title = object.title ?? "";
    message.moduleSubNavs = object.moduleSubNavs?.map((e) => ModuleVersion_ModuleSubNav.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstalledModuleVersion(): InstalledModuleVersion {
  return {
    id: "",
    moduleVersion: undefined,
    appId: "",
    userId: "",
    createdAt: undefined,
    modifiedAt: undefined,
    deployUrl: "",
    visibility: undefined,
    keyId: "",
  };
}

export const InstalledModuleVersion: MessageFns<InstalledModuleVersion> = {
  encode(message: InstalledModuleVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.moduleVersion !== undefined) {
      ModuleVersion.encode(message.moduleVersion, writer.uint32(18).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(26).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(50).fork()).join();
    }
    if (message.deployUrl !== "") {
      writer.uint32(58).string(message.deployUrl);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(66).fork()).join();
    }
    if (message.keyId !== "") {
      writer.uint32(74).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstalledModuleVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstalledModuleVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleVersion = ModuleVersion.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deployUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstalledModuleVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      moduleVersion: isSet(object.moduleVersion) ? ModuleVersion.fromJSON(object.moduleVersion) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      deployUrl: isSet(object.deployUrl) ? globalThis.String(object.deployUrl) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
    };
  },

  toJSON(message: InstalledModuleVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.moduleVersion !== undefined) {
      obj.moduleVersion = ModuleVersion.toJSON(message.moduleVersion);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.deployUrl !== "") {
      obj.deployUrl = message.deployUrl;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstalledModuleVersion>, I>>(base?: I): InstalledModuleVersion {
    return InstalledModuleVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstalledModuleVersion>, I>>(object: I): InstalledModuleVersion {
    const message = createBaseInstalledModuleVersion();
    message.id = object.id ?? "";
    message.moduleVersion = (object.moduleVersion !== undefined && object.moduleVersion !== null)
      ? ModuleVersion.fromPartial(object.moduleVersion)
      : undefined;
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.deployUrl = object.deployUrl ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseBulkOperation(): BulkOperation {
  return {
    id: "",
    inputIds: undefined,
    search: undefined,
    dataset: undefined,
    annotationSearch: undefined,
    operation: undefined,
    appId: "",
    status: undefined,
    progress: undefined,
    createdBy: "",
    createdAt: undefined,
    lastModifiedAt: undefined,
  };
}

export const BulkOperation: MessageFns<BulkOperation> = {
  encode(message: BulkOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.inputIds !== undefined) {
      InputIDs.encode(message.inputIds, writer.uint32(18).fork()).join();
    }
    if (message.search !== undefined) {
      Search.encode(message.search, writer.uint32(82).fork()).join();
    }
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(90).fork()).join();
    }
    if (message.annotationSearch !== undefined) {
      Search.encode(message.annotationSearch, writer.uint32(98).fork()).join();
    }
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(26).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(42).fork()).join();
    }
    if (message.progress !== undefined) {
      Progress.encode(message.progress, writer.uint32(50).fork()).join();
    }
    if (message.createdBy !== "") {
      writer.uint32(58).string(message.createdBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.lastModifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastModifiedAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputIds = InputIDs.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.search = Search.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.annotationSearch = Search.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.progress = Progress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastModifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkOperation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputIds: isSet(object.inputIds) ? InputIDs.fromJSON(object.inputIds) : undefined,
      search: isSet(object.search) ? Search.fromJSON(object.search) : undefined,
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
      annotationSearch: isSet(object.annotationSearch) ? Search.fromJSON(object.annotationSearch) : undefined,
      operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      progress: isSet(object.progress) ? Progress.fromJSON(object.progress) : undefined,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastModifiedAt: isSet(object.lastModifiedAt) ? fromJsonTimestamp(object.lastModifiedAt) : undefined,
    };
  },

  toJSON(message: BulkOperation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputIds !== undefined) {
      obj.inputIds = InputIDs.toJSON(message.inputIds);
    }
    if (message.search !== undefined) {
      obj.search = Search.toJSON(message.search);
    }
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    if (message.annotationSearch !== undefined) {
      obj.annotationSearch = Search.toJSON(message.annotationSearch);
    }
    if (message.operation !== undefined) {
      obj.operation = Operation.toJSON(message.operation);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.progress !== undefined) {
      obj.progress = Progress.toJSON(message.progress);
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastModifiedAt !== undefined) {
      obj.lastModifiedAt = message.lastModifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkOperation>, I>>(base?: I): BulkOperation {
    return BulkOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkOperation>, I>>(object: I): BulkOperation {
    const message = createBaseBulkOperation();
    message.id = object.id ?? "";
    message.inputIds = (object.inputIds !== undefined && object.inputIds !== null)
      ? InputIDs.fromPartial(object.inputIds)
      : undefined;
    message.search = (object.search !== undefined && object.search !== null)
      ? Search.fromPartial(object.search)
      : undefined;
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    message.annotationSearch = (object.annotationSearch !== undefined && object.annotationSearch !== null)
      ? Search.fromPartial(object.annotationSearch)
      : undefined;
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    message.appId = object.appId ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? Progress.fromPartial(object.progress)
      : undefined;
    message.createdBy = object.createdBy ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.lastModifiedAt = object.lastModifiedAt ?? undefined;
    return message;
  },
};

function createBaseInputIDs(): InputIDs {
  return { inputIds: [] };
}

export const InputIDs: MessageFns<InputIDs> = {
  encode(message: InputIDs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputIDs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputIDs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputIDs {
    return {
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: InputIDs): unknown {
    const obj: any = {};
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputIDs>, I>>(base?: I): InputIDs {
    return InputIDs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputIDs>, I>>(object: I): InputIDs {
    const message = createBaseInputIDs();
    message.inputIds = object.inputIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseProgress(): Progress {
  return { processed: 0, lastProcessedId: "" };
}

export const Progress: MessageFns<Progress> = {
  encode(message: Progress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== 0) {
      writer.uint32(8).uint32(message.processed);
    }
    if (message.lastProcessedId !== "") {
      writer.uint32(18).string(message.lastProcessedId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Progress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processed = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastProcessedId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Progress {
    return {
      processed: isSet(object.processed) ? globalThis.Number(object.processed) : 0,
      lastProcessedId: isSet(object.lastProcessedId) ? globalThis.String(object.lastProcessedId) : "",
    };
  },

  toJSON(message: Progress): unknown {
    const obj: any = {};
    if (message.processed !== 0) {
      obj.processed = Math.round(message.processed);
    }
    if (message.lastProcessedId !== "") {
      obj.lastProcessedId = message.lastProcessedId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Progress>, I>>(base?: I): Progress {
    return Progress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Progress>, I>>(object: I): Progress {
    const message = createBaseProgress();
    message.processed = object.processed ?? 0;
    message.lastProcessedId = object.lastProcessedId ?? "";
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    addConcepts: undefined,
    deleteConcepts: undefined,
    addMetadata: undefined,
    deleteMetadata: undefined,
    overwriteGeo: undefined,
    deleteGeo: undefined,
    deleteFromDataset: undefined,
    addToDataset: undefined,
    splitIntoDatasets: undefined,
    deleteAnnotations: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addConcepts !== undefined) {
      AddConcepts.encode(message.addConcepts, writer.uint32(10).fork()).join();
    }
    if (message.deleteConcepts !== undefined) {
      DeleteConcepts.encode(message.deleteConcepts, writer.uint32(18).fork()).join();
    }
    if (message.addMetadata !== undefined) {
      AddMetadata.encode(message.addMetadata, writer.uint32(26).fork()).join();
    }
    if (message.deleteMetadata !== undefined) {
      DeleteMetadata.encode(message.deleteMetadata, writer.uint32(34).fork()).join();
    }
    if (message.overwriteGeo !== undefined) {
      OverwriteGeo.encode(message.overwriteGeo, writer.uint32(42).fork()).join();
    }
    if (message.deleteGeo !== undefined) {
      DeleteGeo.encode(message.deleteGeo, writer.uint32(50).fork()).join();
    }
    if (message.deleteFromDataset !== undefined) {
      DeleteFromDataset.encode(message.deleteFromDataset, writer.uint32(58).fork()).join();
    }
    if (message.addToDataset !== undefined) {
      AddToDataset.encode(message.addToDataset, writer.uint32(66).fork()).join();
    }
    if (message.splitIntoDatasets !== undefined) {
      SplitIntoDatasets.encode(message.splitIntoDatasets, writer.uint32(74).fork()).join();
    }
    if (message.deleteAnnotations !== undefined) {
      DeleteAnnotations.encode(message.deleteAnnotations, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addConcepts = AddConcepts.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deleteConcepts = DeleteConcepts.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addMetadata = AddMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deleteMetadata = DeleteMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.overwriteGeo = OverwriteGeo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deleteGeo = DeleteGeo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deleteFromDataset = DeleteFromDataset.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.addToDataset = AddToDataset.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.splitIntoDatasets = SplitIntoDatasets.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deleteAnnotations = DeleteAnnotations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      addConcepts: isSet(object.addConcepts) ? AddConcepts.fromJSON(object.addConcepts) : undefined,
      deleteConcepts: isSet(object.deleteConcepts) ? DeleteConcepts.fromJSON(object.deleteConcepts) : undefined,
      addMetadata: isSet(object.addMetadata) ? AddMetadata.fromJSON(object.addMetadata) : undefined,
      deleteMetadata: isSet(object.deleteMetadata) ? DeleteMetadata.fromJSON(object.deleteMetadata) : undefined,
      overwriteGeo: isSet(object.overwriteGeo) ? OverwriteGeo.fromJSON(object.overwriteGeo) : undefined,
      deleteGeo: isSet(object.deleteGeo) ? DeleteGeo.fromJSON(object.deleteGeo) : undefined,
      deleteFromDataset: isSet(object.deleteFromDataset)
        ? DeleteFromDataset.fromJSON(object.deleteFromDataset)
        : undefined,
      addToDataset: isSet(object.addToDataset) ? AddToDataset.fromJSON(object.addToDataset) : undefined,
      splitIntoDatasets: isSet(object.splitIntoDatasets)
        ? SplitIntoDatasets.fromJSON(object.splitIntoDatasets)
        : undefined,
      deleteAnnotations: isSet(object.deleteAnnotations)
        ? DeleteAnnotations.fromJSON(object.deleteAnnotations)
        : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.addConcepts !== undefined) {
      obj.addConcepts = AddConcepts.toJSON(message.addConcepts);
    }
    if (message.deleteConcepts !== undefined) {
      obj.deleteConcepts = DeleteConcepts.toJSON(message.deleteConcepts);
    }
    if (message.addMetadata !== undefined) {
      obj.addMetadata = AddMetadata.toJSON(message.addMetadata);
    }
    if (message.deleteMetadata !== undefined) {
      obj.deleteMetadata = DeleteMetadata.toJSON(message.deleteMetadata);
    }
    if (message.overwriteGeo !== undefined) {
      obj.overwriteGeo = OverwriteGeo.toJSON(message.overwriteGeo);
    }
    if (message.deleteGeo !== undefined) {
      obj.deleteGeo = DeleteGeo.toJSON(message.deleteGeo);
    }
    if (message.deleteFromDataset !== undefined) {
      obj.deleteFromDataset = DeleteFromDataset.toJSON(message.deleteFromDataset);
    }
    if (message.addToDataset !== undefined) {
      obj.addToDataset = AddToDataset.toJSON(message.addToDataset);
    }
    if (message.splitIntoDatasets !== undefined) {
      obj.splitIntoDatasets = SplitIntoDatasets.toJSON(message.splitIntoDatasets);
    }
    if (message.deleteAnnotations !== undefined) {
      obj.deleteAnnotations = DeleteAnnotations.toJSON(message.deleteAnnotations);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(object: I): Operation {
    const message = createBaseOperation();
    message.addConcepts = (object.addConcepts !== undefined && object.addConcepts !== null)
      ? AddConcepts.fromPartial(object.addConcepts)
      : undefined;
    message.deleteConcepts = (object.deleteConcepts !== undefined && object.deleteConcepts !== null)
      ? DeleteConcepts.fromPartial(object.deleteConcepts)
      : undefined;
    message.addMetadata = (object.addMetadata !== undefined && object.addMetadata !== null)
      ? AddMetadata.fromPartial(object.addMetadata)
      : undefined;
    message.deleteMetadata = (object.deleteMetadata !== undefined && object.deleteMetadata !== null)
      ? DeleteMetadata.fromPartial(object.deleteMetadata)
      : undefined;
    message.overwriteGeo = (object.overwriteGeo !== undefined && object.overwriteGeo !== null)
      ? OverwriteGeo.fromPartial(object.overwriteGeo)
      : undefined;
    message.deleteGeo = (object.deleteGeo !== undefined && object.deleteGeo !== null)
      ? DeleteGeo.fromPartial(object.deleteGeo)
      : undefined;
    message.deleteFromDataset = (object.deleteFromDataset !== undefined && object.deleteFromDataset !== null)
      ? DeleteFromDataset.fromPartial(object.deleteFromDataset)
      : undefined;
    message.addToDataset = (object.addToDataset !== undefined && object.addToDataset !== null)
      ? AddToDataset.fromPartial(object.addToDataset)
      : undefined;
    message.splitIntoDatasets = (object.splitIntoDatasets !== undefined && object.splitIntoDatasets !== null)
      ? SplitIntoDatasets.fromPartial(object.splitIntoDatasets)
      : undefined;
    message.deleteAnnotations = (object.deleteAnnotations !== undefined && object.deleteAnnotations !== null)
      ? DeleteAnnotations.fromPartial(object.deleteAnnotations)
      : undefined;
    return message;
  },
};

function createBaseAddConcepts(): AddConcepts {
  return { concepts: [] };
}

export const AddConcepts: MessageFns<AddConcepts> = {
  encode(message: AddConcepts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddConcepts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddConcepts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddConcepts {
    return {
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
    };
  },

  toJSON(message: AddConcepts): unknown {
    const obj: any = {};
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddConcepts>, I>>(base?: I): AddConcepts {
    return AddConcepts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddConcepts>, I>>(object: I): AddConcepts {
    const message = createBaseAddConcepts();
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteConcepts(): DeleteConcepts {
  return { concepts: [], userIds: [] };
}

export const DeleteConcepts: MessageFns<DeleteConcepts> = {
  encode(message: DeleteConcepts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.concepts) {
      Concept.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConcepts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConcepts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.concepts.push(Concept.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConcepts {
    return {
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => Concept.fromJSON(e)) : [],
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteConcepts): unknown {
    const obj: any = {};
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => Concept.toJSON(e));
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConcepts>, I>>(base?: I): DeleteConcepts {
    return DeleteConcepts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConcepts>, I>>(object: I): DeleteConcepts {
    const message = createBaseDeleteConcepts();
    message.concepts = object.concepts?.map((e) => Concept.fromPartial(e)) || [];
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddMetadata(): AddMetadata {
  return { metadata: undefined };
}

export const AddMetadata: MessageFns<AddMetadata> = {
  encode(message: AddMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMetadata {
    return { metadata: isObject(object.metadata) ? object.metadata : undefined };
  },

  toJSON(message: AddMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMetadata>, I>>(base?: I): AddMetadata {
    return AddMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMetadata>, I>>(object: I): AddMetadata {
    const message = createBaseAddMetadata();
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseDeleteMetadata(): DeleteMetadata {
  return { metadata: undefined };
}

export const DeleteMetadata: MessageFns<DeleteMetadata> = {
  encode(message: DeleteMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMetadata {
    return { metadata: isObject(object.metadata) ? object.metadata : undefined };
  },

  toJSON(message: DeleteMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMetadata>, I>>(base?: I): DeleteMetadata {
    return DeleteMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMetadata>, I>>(object: I): DeleteMetadata {
    const message = createBaseDeleteMetadata();
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseOverwriteGeo(): OverwriteGeo {
  return { geo: undefined };
}

export const OverwriteGeo: MessageFns<OverwriteGeo> = {
  encode(message: OverwriteGeo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geo !== undefined) {
      Geo.encode(message.geo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverwriteGeo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverwriteGeo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geo = Geo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverwriteGeo {
    return { geo: isSet(object.geo) ? Geo.fromJSON(object.geo) : undefined };
  },

  toJSON(message: OverwriteGeo): unknown {
    const obj: any = {};
    if (message.geo !== undefined) {
      obj.geo = Geo.toJSON(message.geo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverwriteGeo>, I>>(base?: I): OverwriteGeo {
    return OverwriteGeo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverwriteGeo>, I>>(object: I): OverwriteGeo {
    const message = createBaseOverwriteGeo();
    message.geo = (object.geo !== undefined && object.geo !== null) ? Geo.fromPartial(object.geo) : undefined;
    return message;
  },
};

function createBaseDeleteGeo(): DeleteGeo {
  return {};
}

export const DeleteGeo: MessageFns<DeleteGeo> = {
  encode(_: DeleteGeo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGeo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGeo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteGeo {
    return {};
  },

  toJSON(_: DeleteGeo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteGeo>, I>>(base?: I): DeleteGeo {
    return DeleteGeo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteGeo>, I>>(_: I): DeleteGeo {
    const message = createBaseDeleteGeo();
    return message;
  },
};

function createBaseAddToDataset(): AddToDataset {
  return { datasetId: "" };
}

export const AddToDataset: MessageFns<AddToDataset> = {
  encode(message: AddToDataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToDataset {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: AddToDataset): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddToDataset>, I>>(base?: I): AddToDataset {
    return AddToDataset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddToDataset>, I>>(object: I): AddToDataset {
    const message = createBaseAddToDataset();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

function createBaseDeleteFromDataset(): DeleteFromDataset {
  return { datasetId: "" };
}

export const DeleteFromDataset: MessageFns<DeleteFromDataset> = {
  encode(message: DeleteFromDataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFromDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFromDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFromDataset {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: DeleteFromDataset): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFromDataset>, I>>(base?: I): DeleteFromDataset {
    return DeleteFromDataset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFromDataset>, I>>(object: I): DeleteFromDataset {
    const message = createBaseDeleteFromDataset();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

function createBaseSplitIntoDatasets(): SplitIntoDatasets {
  return { datasetSplits: [], method: 0 };
}

export const SplitIntoDatasets: MessageFns<SplitIntoDatasets> = {
  encode(message: SplitIntoDatasets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datasetSplits) {
      DatasetSplit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.method !== 0) {
      writer.uint32(16).int32(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitIntoDatasets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitIntoDatasets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.datasetSplits.push(DatasetSplit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitIntoDatasets {
    return {
      datasetSplits: globalThis.Array.isArray(object?.datasetSplits)
        ? object.datasetSplits.map((e: any) => DatasetSplit.fromJSON(e))
        : [],
      method: isSet(object.method) ? splitIntoDatasets_DatasetSplitMethodFromJSON(object.method) : 0,
    };
  },

  toJSON(message: SplitIntoDatasets): unknown {
    const obj: any = {};
    if (message.datasetSplits?.length) {
      obj.datasetSplits = message.datasetSplits.map((e) => DatasetSplit.toJSON(e));
    }
    if (message.method !== 0) {
      obj.method = splitIntoDatasets_DatasetSplitMethodToJSON(message.method);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplitIntoDatasets>, I>>(base?: I): SplitIntoDatasets {
    return SplitIntoDatasets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplitIntoDatasets>, I>>(object: I): SplitIntoDatasets {
    const message = createBaseSplitIntoDatasets();
    message.datasetSplits = object.datasetSplits?.map((e) => DatasetSplit.fromPartial(e)) || [];
    message.method = object.method ?? 0;
    return message;
  },
};

function createBaseDatasetSplit(): DatasetSplit {
  return { dataset: undefined, percentage: undefined };
}

export const DatasetSplit: MessageFns<DatasetSplit> = {
  encode(message: DatasetSplit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(10).fork()).join();
    }
    if (message.percentage !== undefined) {
      writer.uint32(16).uint32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetSplit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetSplit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetSplit {
    return {
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : undefined,
    };
  },

  toJSON(message: DatasetSplit): unknown {
    const obj: any = {};
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    if (message.percentage !== undefined) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetSplit>, I>>(base?: I): DatasetSplit {
    return DatasetSplit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetSplit>, I>>(object: I): DatasetSplit {
    const message = createBaseDatasetSplit();
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    message.percentage = object.percentage ?? undefined;
    return message;
  },
};

function createBaseDeleteAnnotations(): DeleteAnnotations {
  return {};
}

export const DeleteAnnotations: MessageFns<DeleteAnnotations> = {
  encode(_: DeleteAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAnnotations {
    return {};
  },

  toJSON(_: DeleteAnnotations): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAnnotations>, I>>(base?: I): DeleteAnnotations {
    return DeleteAnnotations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAnnotations>, I>>(_: I): DeleteAnnotations {
    const message = createBaseDeleteAnnotations();
    return message;
  },
};

function createBaseInputsAddJob(): InputsAddJob {
  return {
    id: "",
    callBackUrl: "",
    appPat: "",
    progress: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
    extractionJobs: [],
    uploads: [],
    status: undefined,
  };
}

export const InputsAddJob: MessageFns<InputsAddJob> = {
  encode(message: InputsAddJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.callBackUrl !== "") {
      writer.uint32(26).string(message.callBackUrl);
    }
    if (message.appPat !== "") {
      writer.uint32(34).string(message.appPat);
    }
    if (message.progress !== undefined) {
      InputsAddJobProgress.encode(message.progress, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(74).fork()).join();
    }
    for (const v of message.extractionJobs) {
      InputsExtractionJob.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.uploads) {
      Upload.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsAddJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsAddJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.callBackUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appPat = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.progress = InputsAddJobProgress.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.extractionJobs.push(InputsExtractionJob.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.uploads.push(Upload.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsAddJob {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      callBackUrl: isSet(object.callBackUrl) ? globalThis.String(object.callBackUrl) : "",
      appPat: isSet(object.appPat) ? globalThis.String(object.appPat) : "",
      progress: isSet(object.progress) ? InputsAddJobProgress.fromJSON(object.progress) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      extractionJobs: globalThis.Array.isArray(object?.extractionJobs)
        ? object.extractionJobs.map((e: any) => InputsExtractionJob.fromJSON(e))
        : [],
      uploads: globalThis.Array.isArray(object?.uploads) ? object.uploads.map((e: any) => Upload.fromJSON(e)) : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: InputsAddJob): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.callBackUrl !== "") {
      obj.callBackUrl = message.callBackUrl;
    }
    if (message.appPat !== "") {
      obj.appPat = message.appPat;
    }
    if (message.progress !== undefined) {
      obj.progress = InputsAddJobProgress.toJSON(message.progress);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.extractionJobs?.length) {
      obj.extractionJobs = message.extractionJobs.map((e) => InputsExtractionJob.toJSON(e));
    }
    if (message.uploads?.length) {
      obj.uploads = message.uploads.map((e) => Upload.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsAddJob>, I>>(base?: I): InputsAddJob {
    return InputsAddJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsAddJob>, I>>(object: I): InputsAddJob {
    const message = createBaseInputsAddJob();
    message.id = object.id ?? "";
    message.callBackUrl = object.callBackUrl ?? "";
    message.appPat = object.appPat ?? "";
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? InputsAddJobProgress.fromPartial(object.progress)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.extractionJobs = object.extractionJobs?.map((e) => InputsExtractionJob.fromPartial(e)) || [];
    message.uploads = object.uploads?.map((e) => Upload.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseInputsAddJobProgress(): InputsAddJobProgress {
  return { pendingCount: 0, inProgressCount: 0, successCount: 0, failedCount: 0 };
}

export const InputsAddJobProgress: MessageFns<InputsAddJobProgress> = {
  encode(message: InputsAddJobProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingCount !== 0) {
      writer.uint32(8).uint64(message.pendingCount);
    }
    if (message.inProgressCount !== 0) {
      writer.uint32(16).uint64(message.inProgressCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(24).uint64(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(32).uint64(message.failedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsAddJobProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsAddJobProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pendingCount = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inProgressCount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.successCount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failedCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsAddJobProgress {
    return {
      pendingCount: isSet(object.pendingCount) ? globalThis.Number(object.pendingCount) : 0,
      inProgressCount: isSet(object.inProgressCount) ? globalThis.Number(object.inProgressCount) : 0,
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.Number(object.failedCount) : 0,
    };
  },

  toJSON(message: InputsAddJobProgress): unknown {
    const obj: any = {};
    if (message.pendingCount !== 0) {
      obj.pendingCount = Math.round(message.pendingCount);
    }
    if (message.inProgressCount !== 0) {
      obj.inProgressCount = Math.round(message.inProgressCount);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsAddJobProgress>, I>>(base?: I): InputsAddJobProgress {
    return InputsAddJobProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsAddJobProgress>, I>>(object: I): InputsAddJobProgress {
    const message = createBaseInputsAddJobProgress();
    message.pendingCount = object.pendingCount ?? 0;
    message.inProgressCount = object.inProgressCount ?? 0;
    message.successCount = object.successCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    return message;
  },
};

function createBaseUpload(): Upload {
  return {
    id: "",
    createdAt: undefined,
    modifiedAt: undefined,
    expiresAt: undefined,
    status: undefined,
    contentName: "",
    contentLength: 0,
    contentUrl: "",
  };
}

export const Upload: MessageFns<Upload> = {
  encode(message: Upload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(26).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(42).fork()).join();
    }
    if (message.contentName !== "") {
      writer.uint32(66).string(message.contentName);
    }
    if (message.contentLength !== 0) {
      writer.uint32(48).uint64(message.contentLength);
    }
    if (message.contentUrl !== "") {
      writer.uint32(58).string(message.contentUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Upload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contentName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.contentLength = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contentUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Upload {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      contentName: isSet(object.contentName) ? globalThis.String(object.contentName) : "",
      contentLength: isSet(object.contentLength) ? globalThis.Number(object.contentLength) : 0,
      contentUrl: isSet(object.contentUrl) ? globalThis.String(object.contentUrl) : "",
    };
  },

  toJSON(message: Upload): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.contentName !== "") {
      obj.contentName = message.contentName;
    }
    if (message.contentLength !== 0) {
      obj.contentLength = Math.round(message.contentLength);
    }
    if (message.contentUrl !== "") {
      obj.contentUrl = message.contentUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Upload>, I>>(base?: I): Upload {
    return Upload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Upload>, I>>(object: I): Upload {
    const message = createBaseUpload();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.contentName = object.contentName ?? "";
    message.contentLength = object.contentLength ?? 0;
    message.contentUrl = object.contentUrl ?? "";
    return message;
  },
};

function createBaseUploadContentPart(): UploadContentPart {
  return { rangeStart: 0, partNumber: 0, data: new Uint8Array(0) };
}

export const UploadContentPart: MessageFns<UploadContentPart> = {
  encode(message: UploadContentPart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rangeStart !== 0) {
      writer.uint32(8).uint64(message.rangeStart);
    }
    if (message.partNumber !== 0) {
      writer.uint32(16).int64(message.partNumber);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadContentPart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadContentPart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rangeStart = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.partNumber = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadContentPart {
    return {
      rangeStart: isSet(object.rangeStart) ? globalThis.Number(object.rangeStart) : 0,
      partNumber: isSet(object.partNumber) ? globalThis.Number(object.partNumber) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: UploadContentPart): unknown {
    const obj: any = {};
    if (message.rangeStart !== 0) {
      obj.rangeStart = Math.round(message.rangeStart);
    }
    if (message.partNumber !== 0) {
      obj.partNumber = Math.round(message.partNumber);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadContentPart>, I>>(base?: I): UploadContentPart {
    return UploadContentPart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadContentPart>, I>>(object: I): UploadContentPart {
    const message = createBaseUploadContentPart();
    message.rangeStart = object.rangeStart ?? 0;
    message.partNumber = object.partNumber ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInputsExtractionJob(): InputsExtractionJob {
  return {
    status: undefined,
    id: "",
    url: "",
    progress: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
    inputIdConflictResolution: 0,
    inputTemplate: undefined,
  };
}

export const InputsExtractionJob: MessageFns<InputsExtractionJob> = {
  encode(message: InputsExtractionJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.progress !== undefined) {
      InputsExtractionJobProgress.encode(message.progress, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(50).fork()).join();
    }
    if (message.inputIdConflictResolution !== 0) {
      writer.uint32(56).int32(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      Input.encode(message.inputTemplate, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsExtractionJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsExtractionJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.progress = InputsExtractionJobProgress.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inputIdConflictResolution = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inputTemplate = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsExtractionJob {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      progress: isSet(object.progress) ? InputsExtractionJobProgress.fromJSON(object.progress) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      inputIdConflictResolution: isSet(object.inputIdConflictResolution)
        ? inputIDConflictResolutionFromJSON(object.inputIdConflictResolution)
        : 0,
      inputTemplate: isSet(object.inputTemplate) ? Input.fromJSON(object.inputTemplate) : undefined,
    };
  },

  toJSON(message: InputsExtractionJob): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.progress !== undefined) {
      obj.progress = InputsExtractionJobProgress.toJSON(message.progress);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.inputIdConflictResolution !== 0) {
      obj.inputIdConflictResolution = inputIDConflictResolutionToJSON(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      obj.inputTemplate = Input.toJSON(message.inputTemplate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsExtractionJob>, I>>(base?: I): InputsExtractionJob {
    return InputsExtractionJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsExtractionJob>, I>>(object: I): InputsExtractionJob {
    const message = createBaseInputsExtractionJob();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? InputsExtractionJobProgress.fromPartial(object.progress)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.inputIdConflictResolution = object.inputIdConflictResolution ?? 0;
    message.inputTemplate = (object.inputTemplate !== undefined && object.inputTemplate !== null)
      ? Input.fromPartial(object.inputTemplate)
      : undefined;
    return message;
  },
};

function createBaseInputsExtractionJobProgress(): InputsExtractionJobProgress {
  return {
    audioInputsCount: 0,
    imageInputsCount: 0,
    videoInputsCount: 0,
    textInputsCount: 0,
    pendingArchivesCount: 0,
    inProgressArchivesCount: 0,
    completedArchivesCount: 0,
    failedArchivesCount: 0,
  };
}

export const InputsExtractionJobProgress: MessageFns<InputsExtractionJobProgress> = {
  encode(message: InputsExtractionJobProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioInputsCount !== 0) {
      writer.uint32(16).uint64(message.audioInputsCount);
    }
    if (message.imageInputsCount !== 0) {
      writer.uint32(24).uint64(message.imageInputsCount);
    }
    if (message.videoInputsCount !== 0) {
      writer.uint32(32).uint64(message.videoInputsCount);
    }
    if (message.textInputsCount !== 0) {
      writer.uint32(40).uint64(message.textInputsCount);
    }
    if (message.pendingArchivesCount !== 0) {
      writer.uint32(48).uint64(message.pendingArchivesCount);
    }
    if (message.inProgressArchivesCount !== 0) {
      writer.uint32(56).uint64(message.inProgressArchivesCount);
    }
    if (message.completedArchivesCount !== 0) {
      writer.uint32(64).uint64(message.completedArchivesCount);
    }
    if (message.failedArchivesCount !== 0) {
      writer.uint32(72).uint64(message.failedArchivesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsExtractionJobProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsExtractionJobProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.audioInputsCount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.imageInputsCount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.videoInputsCount = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.textInputsCount = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pendingArchivesCount = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inProgressArchivesCount = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.completedArchivesCount = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.failedArchivesCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsExtractionJobProgress {
    return {
      audioInputsCount: isSet(object.audioInputsCount) ? globalThis.Number(object.audioInputsCount) : 0,
      imageInputsCount: isSet(object.imageInputsCount) ? globalThis.Number(object.imageInputsCount) : 0,
      videoInputsCount: isSet(object.videoInputsCount) ? globalThis.Number(object.videoInputsCount) : 0,
      textInputsCount: isSet(object.textInputsCount) ? globalThis.Number(object.textInputsCount) : 0,
      pendingArchivesCount: isSet(object.pendingArchivesCount) ? globalThis.Number(object.pendingArchivesCount) : 0,
      inProgressArchivesCount: isSet(object.inProgressArchivesCount)
        ? globalThis.Number(object.inProgressArchivesCount)
        : 0,
      completedArchivesCount: isSet(object.completedArchivesCount)
        ? globalThis.Number(object.completedArchivesCount)
        : 0,
      failedArchivesCount: isSet(object.failedArchivesCount) ? globalThis.Number(object.failedArchivesCount) : 0,
    };
  },

  toJSON(message: InputsExtractionJobProgress): unknown {
    const obj: any = {};
    if (message.audioInputsCount !== 0) {
      obj.audioInputsCount = Math.round(message.audioInputsCount);
    }
    if (message.imageInputsCount !== 0) {
      obj.imageInputsCount = Math.round(message.imageInputsCount);
    }
    if (message.videoInputsCount !== 0) {
      obj.videoInputsCount = Math.round(message.videoInputsCount);
    }
    if (message.textInputsCount !== 0) {
      obj.textInputsCount = Math.round(message.textInputsCount);
    }
    if (message.pendingArchivesCount !== 0) {
      obj.pendingArchivesCount = Math.round(message.pendingArchivesCount);
    }
    if (message.inProgressArchivesCount !== 0) {
      obj.inProgressArchivesCount = Math.round(message.inProgressArchivesCount);
    }
    if (message.completedArchivesCount !== 0) {
      obj.completedArchivesCount = Math.round(message.completedArchivesCount);
    }
    if (message.failedArchivesCount !== 0) {
      obj.failedArchivesCount = Math.round(message.failedArchivesCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsExtractionJobProgress>, I>>(base?: I): InputsExtractionJobProgress {
    return InputsExtractionJobProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsExtractionJobProgress>, I>>(object: I): InputsExtractionJobProgress {
    const message = createBaseInputsExtractionJobProgress();
    message.audioInputsCount = object.audioInputsCount ?? 0;
    message.imageInputsCount = object.imageInputsCount ?? 0;
    message.videoInputsCount = object.videoInputsCount ?? 0;
    message.textInputsCount = object.textInputsCount ?? 0;
    message.pendingArchivesCount = object.pendingArchivesCount ?? 0;
    message.inProgressArchivesCount = object.inProgressArchivesCount ?? 0;
    message.completedArchivesCount = object.completedArchivesCount ?? 0;
    message.failedArchivesCount = object.failedArchivesCount ?? 0;
    return message;
  },
};

function createBaseInputsDataSource(): InputsDataSource {
  return { inputsAddJobId: "", url: undefined, inputIdConflictResolution: 0, inputTemplate: undefined };
}

export const InputsDataSource: MessageFns<InputsDataSource> = {
  encode(message: InputsDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsAddJobId !== "") {
      writer.uint32(10).string(message.inputsAddJobId);
    }
    if (message.url !== undefined) {
      DataSourceURL.encode(message.url, writer.uint32(18).fork()).join();
    }
    if (message.inputIdConflictResolution !== 0) {
      writer.uint32(24).int32(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      Input.encode(message.inputTemplate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputsAddJobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = DataSourceURL.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inputIdConflictResolution = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputTemplate = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsDataSource {
    return {
      inputsAddJobId: isSet(object.inputsAddJobId) ? globalThis.String(object.inputsAddJobId) : "",
      url: isSet(object.url) ? DataSourceURL.fromJSON(object.url) : undefined,
      inputIdConflictResolution: isSet(object.inputIdConflictResolution)
        ? inputIDConflictResolutionFromJSON(object.inputIdConflictResolution)
        : 0,
      inputTemplate: isSet(object.inputTemplate) ? Input.fromJSON(object.inputTemplate) : undefined,
    };
  },

  toJSON(message: InputsDataSource): unknown {
    const obj: any = {};
    if (message.inputsAddJobId !== "") {
      obj.inputsAddJobId = message.inputsAddJobId;
    }
    if (message.url !== undefined) {
      obj.url = DataSourceURL.toJSON(message.url);
    }
    if (message.inputIdConflictResolution !== 0) {
      obj.inputIdConflictResolution = inputIDConflictResolutionToJSON(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      obj.inputTemplate = Input.toJSON(message.inputTemplate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsDataSource>, I>>(base?: I): InputsDataSource {
    return InputsDataSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsDataSource>, I>>(object: I): InputsDataSource {
    const message = createBaseInputsDataSource();
    message.inputsAddJobId = object.inputsAddJobId ?? "";
    message.url = (object.url !== undefined && object.url !== null) ? DataSourceURL.fromPartial(object.url) : undefined;
    message.inputIdConflictResolution = object.inputIdConflictResolution ?? 0;
    message.inputTemplate = (object.inputTemplate !== undefined && object.inputTemplate !== null)
      ? Input.fromPartial(object.inputTemplate)
      : undefined;
    return message;
  },
};

function createBaseDataSourceURL(): DataSourceURL {
  return { url: "", credentials: undefined };
}

export const DataSourceURL: MessageFns<DataSourceURL> = {
  encode(message: DataSourceURL, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.credentials !== undefined) {
      DataSourceCredentials.encode(message.credentials, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceURL {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceURL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.credentials = DataSourceCredentials.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceURL {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      credentials: isSet(object.credentials) ? DataSourceCredentials.fromJSON(object.credentials) : undefined,
    };
  },

  toJSON(message: DataSourceURL): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.credentials !== undefined) {
      obj.credentials = DataSourceCredentials.toJSON(message.credentials);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataSourceURL>, I>>(base?: I): DataSourceURL {
    return DataSourceURL.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataSourceURL>, I>>(object: I): DataSourceURL {
    const message = createBaseDataSourceURL();
    message.url = object.url ?? "";
    message.credentials = (object.credentials !== undefined && object.credentials !== null)
      ? DataSourceCredentials.fromPartial(object.credentials)
      : undefined;
    return message;
  },
};

function createBaseDataSourceCredentials(): DataSourceCredentials {
  return { s3Creds: undefined, gcpCreds: undefined, azureBlobCreds: undefined };
}

export const DataSourceCredentials: MessageFns<DataSourceCredentials> = {
  encode(message: DataSourceCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.s3Creds !== undefined) {
      AWSCreds.encode(message.s3Creds, writer.uint32(10).fork()).join();
    }
    if (message.gcpCreds !== undefined) {
      writer.uint32(18).bytes(message.gcpCreds);
    }
    if (message.azureBlobCreds !== undefined) {
      AzureBlobCreds.encode(message.azureBlobCreds, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.s3Creds = AWSCreds.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gcpCreds = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.azureBlobCreds = AzureBlobCreds.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceCredentials {
    return {
      s3Creds: isSet(object.s3Creds) ? AWSCreds.fromJSON(object.s3Creds) : undefined,
      gcpCreds: isSet(object.gcpCreds) ? bytesFromBase64(object.gcpCreds) : undefined,
      azureBlobCreds: isSet(object.azureBlobCreds) ? AzureBlobCreds.fromJSON(object.azureBlobCreds) : undefined,
    };
  },

  toJSON(message: DataSourceCredentials): unknown {
    const obj: any = {};
    if (message.s3Creds !== undefined) {
      obj.s3Creds = AWSCreds.toJSON(message.s3Creds);
    }
    if (message.gcpCreds !== undefined) {
      obj.gcpCreds = base64FromBytes(message.gcpCreds);
    }
    if (message.azureBlobCreds !== undefined) {
      obj.azureBlobCreds = AzureBlobCreds.toJSON(message.azureBlobCreds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataSourceCredentials>, I>>(base?: I): DataSourceCredentials {
    return DataSourceCredentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataSourceCredentials>, I>>(object: I): DataSourceCredentials {
    const message = createBaseDataSourceCredentials();
    message.s3Creds = (object.s3Creds !== undefined && object.s3Creds !== null)
      ? AWSCreds.fromPartial(object.s3Creds)
      : undefined;
    message.gcpCreds = object.gcpCreds ?? undefined;
    message.azureBlobCreds = (object.azureBlobCreds !== undefined && object.azureBlobCreds !== null)
      ? AzureBlobCreds.fromPartial(object.azureBlobCreds)
      : undefined;
    return message;
  },
};

function createBaseAWSCreds(): AWSCreds {
  return { region: "", id: "", secret: "", token: "" };
}

export const AWSCreds: MessageFns<AWSCreds> = {
  encode(message: AWSCreds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.secret !== "") {
      writer.uint32(34).string(message.secret);
    }
    if (message.token !== "") {
      writer.uint32(42).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AWSCreds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAWSCreds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AWSCreds {
    return {
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: AWSCreds): unknown {
    const obj: any = {};
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AWSCreds>, I>>(base?: I): AWSCreds {
    return AWSCreds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AWSCreds>, I>>(object: I): AWSCreds {
    const message = createBaseAWSCreds();
    message.region = object.region ?? "";
    message.id = object.id ?? "";
    message.secret = object.secret ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseAzureBlobCreds(): AzureBlobCreds {
  return { accountName: "", accountKey: "" };
}

export const AzureBlobCreds: MessageFns<AzureBlobCreds> = {
  encode(message: AzureBlobCreds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    if (message.accountKey !== "") {
      writer.uint32(18).string(message.accountKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AzureBlobCreds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAzureBlobCreds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AzureBlobCreds {
    return {
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      accountKey: isSet(object.accountKey) ? globalThis.String(object.accountKey) : "",
    };
  },

  toJSON(message: AzureBlobCreds): unknown {
    const obj: any = {};
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.accountKey !== "") {
      obj.accountKey = message.accountKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AzureBlobCreds>, I>>(base?: I): AzureBlobCreds {
    return AzureBlobCreds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AzureBlobCreds>, I>>(object: I): AzureBlobCreds {
    const message = createBaseAzureBlobCreds();
    message.accountName = object.accountName ?? "";
    message.accountKey = object.accountKey ?? "";
    return message;
  },
};

function createBaseInputsUpload(): InputsUpload {
  return { inputsAddJobId: "", appPat: "", upload: undefined, inputIdConflictResolution: 0, inputTemplate: undefined };
}

export const InputsUpload: MessageFns<InputsUpload> = {
  encode(message: InputsUpload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputsAddJobId !== "") {
      writer.uint32(10).string(message.inputsAddJobId);
    }
    if (message.appPat !== "") {
      writer.uint32(18).string(message.appPat);
    }
    if (message.upload !== undefined) {
      Upload.encode(message.upload, writer.uint32(26).fork()).join();
    }
    if (message.inputIdConflictResolution !== 0) {
      writer.uint32(32).int32(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      Input.encode(message.inputTemplate, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputsUpload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputsUpload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputsAddJobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appPat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upload = Upload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inputIdConflictResolution = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputTemplate = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputsUpload {
    return {
      inputsAddJobId: isSet(object.inputsAddJobId) ? globalThis.String(object.inputsAddJobId) : "",
      appPat: isSet(object.appPat) ? globalThis.String(object.appPat) : "",
      upload: isSet(object.upload) ? Upload.fromJSON(object.upload) : undefined,
      inputIdConflictResolution: isSet(object.inputIdConflictResolution)
        ? inputIDConflictResolutionFromJSON(object.inputIdConflictResolution)
        : 0,
      inputTemplate: isSet(object.inputTemplate) ? Input.fromJSON(object.inputTemplate) : undefined,
    };
  },

  toJSON(message: InputsUpload): unknown {
    const obj: any = {};
    if (message.inputsAddJobId !== "") {
      obj.inputsAddJobId = message.inputsAddJobId;
    }
    if (message.appPat !== "") {
      obj.appPat = message.appPat;
    }
    if (message.upload !== undefined) {
      obj.upload = Upload.toJSON(message.upload);
    }
    if (message.inputIdConflictResolution !== 0) {
      obj.inputIdConflictResolution = inputIDConflictResolutionToJSON(message.inputIdConflictResolution);
    }
    if (message.inputTemplate !== undefined) {
      obj.inputTemplate = Input.toJSON(message.inputTemplate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputsUpload>, I>>(base?: I): InputsUpload {
    return InputsUpload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputsUpload>, I>>(object: I): InputsUpload {
    const message = createBaseInputsUpload();
    message.inputsAddJobId = object.inputsAddJobId ?? "";
    message.appPat = object.appPat ?? "";
    message.upload = (object.upload !== undefined && object.upload !== null)
      ? Upload.fromPartial(object.upload)
      : undefined;
    message.inputIdConflictResolution = object.inputIdConflictResolution ?? 0;
    message.inputTemplate = (object.inputTemplate !== undefined && object.inputTemplate !== null)
      ? Input.fromPartial(object.inputTemplate)
      : undefined;
    return message;
  },
};

function createBaseBookmarkOrigin(): BookmarkOrigin {
  return { id: "", appId: "", userId: "", resourceType: 0 };
}

export const BookmarkOrigin: MessageFns<BookmarkOrigin> = {
  encode(message: BookmarkOrigin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.resourceType !== 0) {
      writer.uint32(32).int32(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookmarkOrigin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookmarkOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookmarkOrigin {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      resourceType: isSet(object.resourceType) ? bookmarkOrigin_BookmarkTypeFromJSON(object.resourceType) : 0,
    };
  },

  toJSON(message: BookmarkOrigin): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = bookmarkOrigin_BookmarkTypeToJSON(message.resourceType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookmarkOrigin>, I>>(base?: I): BookmarkOrigin {
    return BookmarkOrigin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookmarkOrigin>, I>>(object: I): BookmarkOrigin {
    const message = createBaseBookmarkOrigin();
    message.id = object.id ?? "";
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.resourceType = object.resourceType ?? 0;
    return message;
  },
};

function createBaseRunner(): Runner {
  return {
    id: "",
    description: "",
    createdAt: undefined,
    modifiedAt: undefined,
    metadata: undefined,
    labels: [],
    worker: undefined,
    nodepool: undefined,
    computeInfo: undefined,
    numReplicas: 0,
  };
}

export const Runner: MessageFns<Runner> = {
  encode(message: Runner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(34).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(42).fork()).join();
    }
    for (const v of message.labels) {
      writer.uint32(58).string(v!);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(66).fork()).join();
    }
    if (message.nodepool !== undefined) {
      Nodepool.encode(message.nodepool, writer.uint32(74).fork()).join();
    }
    if (message.computeInfo !== undefined) {
      ComputeInfo.encode(message.computeInfo, writer.uint32(82).fork()).join();
    }
    if (message.numReplicas !== 0) {
      writer.uint32(88).uint32(message.numReplicas);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nodepool = Nodepool.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.computeInfo = ComputeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numReplicas = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runner {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      nodepool: isSet(object.nodepool) ? Nodepool.fromJSON(object.nodepool) : undefined,
      computeInfo: isSet(object.computeInfo) ? ComputeInfo.fromJSON(object.computeInfo) : undefined,
      numReplicas: isSet(object.numReplicas) ? globalThis.Number(object.numReplicas) : 0,
    };
  },

  toJSON(message: Runner): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.nodepool !== undefined) {
      obj.nodepool = Nodepool.toJSON(message.nodepool);
    }
    if (message.computeInfo !== undefined) {
      obj.computeInfo = ComputeInfo.toJSON(message.computeInfo);
    }
    if (message.numReplicas !== 0) {
      obj.numReplicas = Math.round(message.numReplicas);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Runner>, I>>(base?: I): Runner {
    return Runner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Runner>, I>>(object: I): Runner {
    const message = createBaseRunner();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.nodepool = (object.nodepool !== undefined && object.nodepool !== null)
      ? Nodepool.fromPartial(object.nodepool)
      : undefined;
    message.computeInfo = (object.computeInfo !== undefined && object.computeInfo !== null)
      ? ComputeInfo.fromPartial(object.computeInfo)
      : undefined;
    message.numReplicas = object.numReplicas ?? 0;
    return message;
  },
};

function createBaseNodepool(): Nodepool {
  return {
    id: "",
    description: "",
    createdAt: undefined,
    modifiedAt: undefined,
    computeCluster: undefined,
    nodeCapacityType: undefined,
    instanceTypes: [],
    minInstances: 0,
    maxInstances: 0,
    enforcedMinInstances: 0,
    enforcedMaxInstances: 0,
    visibility: undefined,
    metadata: undefined,
  };
}

export const Nodepool: MessageFns<Nodepool> = {
  encode(message: Nodepool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(34).fork()).join();
    }
    if (message.computeCluster !== undefined) {
      ComputeCluster.encode(message.computeCluster, writer.uint32(50).fork()).join();
    }
    if (message.nodeCapacityType !== undefined) {
      NodeCapacityType.encode(message.nodeCapacityType, writer.uint32(58).fork()).join();
    }
    for (const v of message.instanceTypes) {
      InstanceType.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.minInstances !== 0) {
      writer.uint32(72).uint32(message.minInstances);
    }
    if (message.maxInstances !== 0) {
      writer.uint32(80).uint32(message.maxInstances);
    }
    if (message.enforcedMinInstances !== 0) {
      writer.uint32(104).uint32(message.enforcedMinInstances);
    }
    if (message.enforcedMaxInstances !== 0) {
      writer.uint32(112).uint32(message.enforcedMaxInstances);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(90).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nodepool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodepool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.computeCluster = ComputeCluster.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nodeCapacityType = NodeCapacityType.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.instanceTypes.push(InstanceType.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.minInstances = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxInstances = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.enforcedMinInstances = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.enforcedMaxInstances = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Nodepool {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      computeCluster: isSet(object.computeCluster) ? ComputeCluster.fromJSON(object.computeCluster) : undefined,
      nodeCapacityType: isSet(object.nodeCapacityType) ? NodeCapacityType.fromJSON(object.nodeCapacityType) : undefined,
      instanceTypes: globalThis.Array.isArray(object?.instanceTypes)
        ? object.instanceTypes.map((e: any) => InstanceType.fromJSON(e))
        : [],
      minInstances: isSet(object.minInstances) ? globalThis.Number(object.minInstances) : 0,
      maxInstances: isSet(object.maxInstances) ? globalThis.Number(object.maxInstances) : 0,
      enforcedMinInstances: isSet(object.enforcedMinInstances) ? globalThis.Number(object.enforcedMinInstances) : 0,
      enforcedMaxInstances: isSet(object.enforcedMaxInstances) ? globalThis.Number(object.enforcedMaxInstances) : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Nodepool): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.computeCluster !== undefined) {
      obj.computeCluster = ComputeCluster.toJSON(message.computeCluster);
    }
    if (message.nodeCapacityType !== undefined) {
      obj.nodeCapacityType = NodeCapacityType.toJSON(message.nodeCapacityType);
    }
    if (message.instanceTypes?.length) {
      obj.instanceTypes = message.instanceTypes.map((e) => InstanceType.toJSON(e));
    }
    if (message.minInstances !== 0) {
      obj.minInstances = Math.round(message.minInstances);
    }
    if (message.maxInstances !== 0) {
      obj.maxInstances = Math.round(message.maxInstances);
    }
    if (message.enforcedMinInstances !== 0) {
      obj.enforcedMinInstances = Math.round(message.enforcedMinInstances);
    }
    if (message.enforcedMaxInstances !== 0) {
      obj.enforcedMaxInstances = Math.round(message.enforcedMaxInstances);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Nodepool>, I>>(base?: I): Nodepool {
    return Nodepool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Nodepool>, I>>(object: I): Nodepool {
    const message = createBaseNodepool();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.computeCluster = (object.computeCluster !== undefined && object.computeCluster !== null)
      ? ComputeCluster.fromPartial(object.computeCluster)
      : undefined;
    message.nodeCapacityType = (object.nodeCapacityType !== undefined && object.nodeCapacityType !== null)
      ? NodeCapacityType.fromPartial(object.nodeCapacityType)
      : undefined;
    message.instanceTypes = object.instanceTypes?.map((e) => InstanceType.fromPartial(e)) || [];
    message.minInstances = object.minInstances ?? 0;
    message.maxInstances = object.maxInstances ?? 0;
    message.enforcedMinInstances = object.enforcedMinInstances ?? 0;
    message.enforcedMaxInstances = object.enforcedMaxInstances ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseNodeCapacityType(): NodeCapacityType {
  return { capacityTypes: [] };
}

export const NodeCapacityType: MessageFns<NodeCapacityType> = {
  encode(message: NodeCapacityType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.capacityTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeCapacityType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeCapacityType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.capacityTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.capacityTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeCapacityType {
    return {
      capacityTypes: globalThis.Array.isArray(object?.capacityTypes)
        ? object.capacityTypes.map((e: any) => nodeCapacityType_CapacityTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeCapacityType): unknown {
    const obj: any = {};
    if (message.capacityTypes?.length) {
      obj.capacityTypes = message.capacityTypes.map((e) => nodeCapacityType_CapacityTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeCapacityType>, I>>(base?: I): NodeCapacityType {
    return NodeCapacityType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeCapacityType>, I>>(object: I): NodeCapacityType {
    const message = createBaseNodeCapacityType();
    message.capacityTypes = object.capacityTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstanceType(): InstanceType {
  return {
    id: "",
    description: "",
    computeInfo: undefined,
    price: "",
    cloudProvider: undefined,
    region: "",
    allowedCapacityTypes: undefined,
  };
}

export const InstanceType: MessageFns<InstanceType> = {
  encode(message: InstanceType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.computeInfo !== undefined) {
      ComputeInfo.encode(message.computeInfo, writer.uint32(26).fork()).join();
    }
    if (message.price !== "") {
      writer.uint32(34).string(message.price);
    }
    if (message.cloudProvider !== undefined) {
      CloudProvider.encode(message.cloudProvider, writer.uint32(42).fork()).join();
    }
    if (message.region !== "") {
      writer.uint32(50).string(message.region);
    }
    if (message.allowedCapacityTypes !== undefined) {
      NodeCapacityType.encode(message.allowedCapacityTypes, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.computeInfo = ComputeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cloudProvider = CloudProvider.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowedCapacityTypes = NodeCapacityType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceType {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      computeInfo: isSet(object.computeInfo) ? ComputeInfo.fromJSON(object.computeInfo) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      cloudProvider: isSet(object.cloudProvider) ? CloudProvider.fromJSON(object.cloudProvider) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      allowedCapacityTypes: isSet(object.allowedCapacityTypes)
        ? NodeCapacityType.fromJSON(object.allowedCapacityTypes)
        : undefined,
    };
  },

  toJSON(message: InstanceType): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.computeInfo !== undefined) {
      obj.computeInfo = ComputeInfo.toJSON(message.computeInfo);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.cloudProvider !== undefined) {
      obj.cloudProvider = CloudProvider.toJSON(message.cloudProvider);
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.allowedCapacityTypes !== undefined) {
      obj.allowedCapacityTypes = NodeCapacityType.toJSON(message.allowedCapacityTypes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceType>, I>>(base?: I): InstanceType {
    return InstanceType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceType>, I>>(object: I): InstanceType {
    const message = createBaseInstanceType();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.computeInfo = (object.computeInfo !== undefined && object.computeInfo !== null)
      ? ComputeInfo.fromPartial(object.computeInfo)
      : undefined;
    message.price = object.price ?? "";
    message.cloudProvider = (object.cloudProvider !== undefined && object.cloudProvider !== null)
      ? CloudProvider.fromPartial(object.cloudProvider)
      : undefined;
    message.region = object.region ?? "";
    message.allowedCapacityTypes = (object.allowedCapacityTypes !== undefined && object.allowedCapacityTypes !== null)
      ? NodeCapacityType.fromPartial(object.allowedCapacityTypes)
      : undefined;
    return message;
  },
};

function createBaseCloudProvider(): CloudProvider {
  return { id: "", name: "" };
}

export const CloudProvider: MessageFns<CloudProvider> = {
  encode(message: CloudProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudProvider {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CloudProvider): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudProvider>, I>>(base?: I): CloudProvider {
    return CloudProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudProvider>, I>>(object: I): CloudProvider {
    const message = createBaseCloudProvider();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseComputeCluster(): ComputeCluster {
  return {
    id: "",
    description: "",
    cloudProvider: undefined,
    region: "",
    userId: "",
    createdAt: undefined,
    modifiedAt: undefined,
    visibility: undefined,
    clusterType: "",
    managedBy: "",
    key: undefined,
  };
}

export const ComputeCluster: MessageFns<ComputeCluster> = {
  encode(message: ComputeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.cloudProvider !== undefined) {
      CloudProvider.encode(message.cloudProvider, writer.uint32(26).fork()).join();
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(58).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(66).fork()).join();
    }
    if (message.clusterType !== "") {
      writer.uint32(74).string(message.clusterType);
    }
    if (message.managedBy !== "") {
      writer.uint32(82).string(message.managedBy);
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cloudProvider = CloudProvider.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clusterType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.managedBy = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeCluster {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      cloudProvider: isSet(object.cloudProvider) ? CloudProvider.fromJSON(object.cloudProvider) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      clusterType: isSet(object.clusterType) ? globalThis.String(object.clusterType) : "",
      managedBy: isSet(object.managedBy) ? globalThis.String(object.managedBy) : "",
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: ComputeCluster): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.cloudProvider !== undefined) {
      obj.cloudProvider = CloudProvider.toJSON(message.cloudProvider);
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.clusterType !== "") {
      obj.clusterType = message.clusterType;
    }
    if (message.managedBy !== "") {
      obj.managedBy = message.managedBy;
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputeCluster>, I>>(base?: I): ComputeCluster {
    return ComputeCluster.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputeCluster>, I>>(object: I): ComputeCluster {
    const message = createBaseComputeCluster();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.cloudProvider = (object.cloudProvider !== undefined && object.cloudProvider !== null)
      ? CloudProvider.fromPartial(object.cloudProvider)
      : undefined;
    message.region = object.region ?? "";
    message.userId = object.userId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.clusterType = object.clusterType ?? "";
    message.managedBy = object.managedBy ?? "";
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseComputeInfo(): ComputeInfo {
  return {
    cpuLimit: "",
    cpuMemory: "",
    cpuRequests: "",
    cpuMemoryRequests: "",
    numAccelerators: 0,
    acceleratorMemory: "",
    acceleratorType: [],
  };
}

export const ComputeInfo: MessageFns<ComputeInfo> = {
  encode(message: ComputeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuLimit !== "") {
      writer.uint32(50).string(message.cpuLimit);
    }
    if (message.cpuMemory !== "") {
      writer.uint32(18).string(message.cpuMemory);
    }
    if (message.cpuRequests !== "") {
      writer.uint32(58).string(message.cpuRequests);
    }
    if (message.cpuMemoryRequests !== "") {
      writer.uint32(66).string(message.cpuMemoryRequests);
    }
    if (message.numAccelerators !== 0) {
      writer.uint32(24).uint32(message.numAccelerators);
    }
    if (message.acceleratorMemory !== "") {
      writer.uint32(34).string(message.acceleratorMemory);
    }
    for (const v of message.acceleratorType) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cpuLimit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cpuMemory = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cpuRequests = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cpuMemoryRequests = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numAccelerators = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.acceleratorMemory = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.acceleratorType.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInfo {
    return {
      cpuLimit: isSet(object.cpuLimit) ? globalThis.String(object.cpuLimit) : "",
      cpuMemory: isSet(object.cpuMemory) ? globalThis.String(object.cpuMemory) : "",
      cpuRequests: isSet(object.cpuRequests) ? globalThis.String(object.cpuRequests) : "",
      cpuMemoryRequests: isSet(object.cpuMemoryRequests) ? globalThis.String(object.cpuMemoryRequests) : "",
      numAccelerators: isSet(object.numAccelerators) ? globalThis.Number(object.numAccelerators) : 0,
      acceleratorMemory: isSet(object.acceleratorMemory) ? globalThis.String(object.acceleratorMemory) : "",
      acceleratorType: globalThis.Array.isArray(object?.acceleratorType)
        ? object.acceleratorType.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ComputeInfo): unknown {
    const obj: any = {};
    if (message.cpuLimit !== "") {
      obj.cpuLimit = message.cpuLimit;
    }
    if (message.cpuMemory !== "") {
      obj.cpuMemory = message.cpuMemory;
    }
    if (message.cpuRequests !== "") {
      obj.cpuRequests = message.cpuRequests;
    }
    if (message.cpuMemoryRequests !== "") {
      obj.cpuMemoryRequests = message.cpuMemoryRequests;
    }
    if (message.numAccelerators !== 0) {
      obj.numAccelerators = Math.round(message.numAccelerators);
    }
    if (message.acceleratorMemory !== "") {
      obj.acceleratorMemory = message.acceleratorMemory;
    }
    if (message.acceleratorType?.length) {
      obj.acceleratorType = message.acceleratorType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputeInfo>, I>>(base?: I): ComputeInfo {
    return ComputeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputeInfo>, I>>(object: I): ComputeInfo {
    const message = createBaseComputeInfo();
    message.cpuLimit = object.cpuLimit ?? "";
    message.cpuMemory = object.cpuMemory ?? "";
    message.cpuRequests = object.cpuRequests ?? "";
    message.cpuMemoryRequests = object.cpuMemoryRequests ?? "";
    message.numAccelerators = object.numAccelerators ?? 0;
    message.acceleratorMemory = object.acceleratorMemory ?? "";
    message.acceleratorType = object.acceleratorType?.map((e) => e) || [];
    return message;
  },
};

function createBaseAutoscaleConfig(): AutoscaleConfig {
  return {
    minReplicas: 0,
    maxReplicas: 0,
    trafficHistorySeconds: 0,
    scaleDownDelaySeconds: 0,
    scaleUpDelaySeconds: 0,
    disablePacking: false,
    scaleToZeroDelaySeconds: 0,
  };
}

export const AutoscaleConfig: MessageFns<AutoscaleConfig> = {
  encode(message: AutoscaleConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minReplicas !== 0) {
      writer.uint32(8).uint32(message.minReplicas);
    }
    if (message.maxReplicas !== 0) {
      writer.uint32(16).uint32(message.maxReplicas);
    }
    if (message.trafficHistorySeconds !== 0) {
      writer.uint32(24).uint32(message.trafficHistorySeconds);
    }
    if (message.scaleDownDelaySeconds !== 0) {
      writer.uint32(32).uint32(message.scaleDownDelaySeconds);
    }
    if (message.scaleUpDelaySeconds !== 0) {
      writer.uint32(40).uint32(message.scaleUpDelaySeconds);
    }
    if (message.disablePacking !== false) {
      writer.uint32(56).bool(message.disablePacking);
    }
    if (message.scaleToZeroDelaySeconds !== 0) {
      writer.uint32(64).uint32(message.scaleToZeroDelaySeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscaleConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscaleConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minReplicas = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxReplicas = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.trafficHistorySeconds = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scaleDownDelaySeconds = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scaleUpDelaySeconds = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.disablePacking = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.scaleToZeroDelaySeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscaleConfig {
    return {
      minReplicas: isSet(object.minReplicas) ? globalThis.Number(object.minReplicas) : 0,
      maxReplicas: isSet(object.maxReplicas) ? globalThis.Number(object.maxReplicas) : 0,
      trafficHistorySeconds: isSet(object.trafficHistorySeconds) ? globalThis.Number(object.trafficHistorySeconds) : 0,
      scaleDownDelaySeconds: isSet(object.scaleDownDelaySeconds) ? globalThis.Number(object.scaleDownDelaySeconds) : 0,
      scaleUpDelaySeconds: isSet(object.scaleUpDelaySeconds) ? globalThis.Number(object.scaleUpDelaySeconds) : 0,
      disablePacking: isSet(object.disablePacking) ? globalThis.Boolean(object.disablePacking) : false,
      scaleToZeroDelaySeconds: isSet(object.scaleToZeroDelaySeconds)
        ? globalThis.Number(object.scaleToZeroDelaySeconds)
        : 0,
    };
  },

  toJSON(message: AutoscaleConfig): unknown {
    const obj: any = {};
    if (message.minReplicas !== 0) {
      obj.minReplicas = Math.round(message.minReplicas);
    }
    if (message.maxReplicas !== 0) {
      obj.maxReplicas = Math.round(message.maxReplicas);
    }
    if (message.trafficHistorySeconds !== 0) {
      obj.trafficHistorySeconds = Math.round(message.trafficHistorySeconds);
    }
    if (message.scaleDownDelaySeconds !== 0) {
      obj.scaleDownDelaySeconds = Math.round(message.scaleDownDelaySeconds);
    }
    if (message.scaleUpDelaySeconds !== 0) {
      obj.scaleUpDelaySeconds = Math.round(message.scaleUpDelaySeconds);
    }
    if (message.disablePacking !== false) {
      obj.disablePacking = message.disablePacking;
    }
    if (message.scaleToZeroDelaySeconds !== 0) {
      obj.scaleToZeroDelaySeconds = Math.round(message.scaleToZeroDelaySeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutoscaleConfig>, I>>(base?: I): AutoscaleConfig {
    return AutoscaleConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutoscaleConfig>, I>>(object: I): AutoscaleConfig {
    const message = createBaseAutoscaleConfig();
    message.minReplicas = object.minReplicas ?? 0;
    message.maxReplicas = object.maxReplicas ?? 0;
    message.trafficHistorySeconds = object.trafficHistorySeconds ?? 0;
    message.scaleDownDelaySeconds = object.scaleDownDelaySeconds ?? 0;
    message.scaleUpDelaySeconds = object.scaleUpDelaySeconds ?? 0;
    message.disablePacking = object.disablePacking ?? false;
    message.scaleToZeroDelaySeconds = object.scaleToZeroDelaySeconds ?? 0;
    return message;
  },
};

function createBaseDeployment(): Deployment {
  return {
    id: "",
    userId: "",
    autoscaleConfig: undefined,
    nodepools: [],
    schedulingChoice: 0,
    visibility: undefined,
    metadata: undefined,
    description: "",
    worker: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
    deployLatestVersion: false,
  };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.autoscaleConfig !== undefined) {
      AutoscaleConfig.encode(message.autoscaleConfig, writer.uint32(26).fork()).join();
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.schedulingChoice !== 0) {
      writer.uint32(56).int32(message.schedulingChoice);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(66).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(74).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.worker !== undefined) {
      Worker.encode(message.worker, writer.uint32(90).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(106).fork()).join();
    }
    if (message.deployLatestVersion !== false) {
      writer.uint32(112).bool(message.deployLatestVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.autoscaleConfig = AutoscaleConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.schedulingChoice = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.worker = Worker.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.deployLatestVersion = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      autoscaleConfig: isSet(object.autoscaleConfig) ? AutoscaleConfig.fromJSON(object.autoscaleConfig) : undefined,
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
      schedulingChoice: isSet(object.schedulingChoice)
        ? deployment_SchedulingChoiceFromJSON(object.schedulingChoice)
        : 0,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      worker: isSet(object.worker) ? Worker.fromJSON(object.worker) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      deployLatestVersion: isSet(object.deployLatestVersion) ? globalThis.Boolean(object.deployLatestVersion) : false,
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.autoscaleConfig !== undefined) {
      obj.autoscaleConfig = AutoscaleConfig.toJSON(message.autoscaleConfig);
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    if (message.schedulingChoice !== 0) {
      obj.schedulingChoice = deployment_SchedulingChoiceToJSON(message.schedulingChoice);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.worker !== undefined) {
      obj.worker = Worker.toJSON(message.worker);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.deployLatestVersion !== false) {
      obj.deployLatestVersion = message.deployLatestVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deployment>, I>>(base?: I): Deployment {
    return Deployment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deployment>, I>>(object: I): Deployment {
    const message = createBaseDeployment();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.autoscaleConfig = (object.autoscaleConfig !== undefined && object.autoscaleConfig !== null)
      ? AutoscaleConfig.fromPartial(object.autoscaleConfig)
      : undefined;
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    message.schedulingChoice = object.schedulingChoice ?? 0;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.description = object.description ?? "";
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? Worker.fromPartial(object.worker)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.deployLatestVersion = object.deployLatestVersion ?? false;
    return message;
  },
};

function createBaseRunnerSelector(): RunnerSelector {
  return { nodepool: undefined, runner: undefined, deployment: undefined };
}

export const RunnerSelector: MessageFns<RunnerSelector> = {
  encode(message: RunnerSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodepool !== undefined) {
      Nodepool.encode(message.nodepool, writer.uint32(10).fork()).join();
    }
    if (message.runner !== undefined) {
      Runner.encode(message.runner, writer.uint32(18).fork()).join();
    }
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodepool = Nodepool.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runner = Runner.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunnerSelector {
    return {
      nodepool: isSet(object.nodepool) ? Nodepool.fromJSON(object.nodepool) : undefined,
      runner: isSet(object.runner) ? Runner.fromJSON(object.runner) : undefined,
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
    };
  },

  toJSON(message: RunnerSelector): unknown {
    const obj: any = {};
    if (message.nodepool !== undefined) {
      obj.nodepool = Nodepool.toJSON(message.nodepool);
    }
    if (message.runner !== undefined) {
      obj.runner = Runner.toJSON(message.runner);
    }
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunnerSelector>, I>>(base?: I): RunnerSelector {
    return RunnerSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunnerSelector>, I>>(object: I): RunnerSelector {
    const message = createBaseRunnerSelector();
    message.nodepool = (object.nodepool !== undefined && object.nodepool !== null)
      ? Nodepool.fromPartial(object.nodepool)
      : undefined;
    message.runner = (object.runner !== undefined && object.runner !== null)
      ? Runner.fromPartial(object.runner)
      : undefined;
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    return message;
  },
};

function createBaseProcessingInfo(): ProcessingInfo {
  return { runnerMethodType: 0, status: undefined, processingId: "" };
}

export const ProcessingInfo: MessageFns<ProcessingInfo> = {
  encode(message: ProcessingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runnerMethodType !== 0) {
      writer.uint32(8).int32(message.runnerMethodType);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.processingId !== "") {
      writer.uint32(26).string(message.processingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.runnerMethodType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingInfo {
    return {
      runnerMethodType: isSet(object.runnerMethodType) ? runnerMethodTypeFromJSON(object.runnerMethodType) : 0,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      processingId: isSet(object.processingId) ? globalThis.String(object.processingId) : "",
    };
  },

  toJSON(message: ProcessingInfo): unknown {
    const obj: any = {};
    if (message.runnerMethodType !== 0) {
      obj.runnerMethodType = runnerMethodTypeToJSON(message.runnerMethodType);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.processingId !== "") {
      obj.processingId = message.processingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingInfo>, I>>(base?: I): ProcessingInfo {
    return ProcessingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingInfo>, I>>(object: I): ProcessingInfo {
    const message = createBaseProcessingInfo();
    message.runnerMethodType = object.runnerMethodType ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.processingId = object.processingId ?? "";
    return message;
  },
};

function createBaseAuditLogTarget(): AuditLogTarget {
  return {
    user: undefined,
    role: undefined,
    team: undefined,
    app: undefined,
    module: undefined,
    moduleVersion: undefined,
    workflow: undefined,
    workflowVersion: undefined,
    model: undefined,
    modelVersion: undefined,
    computeCluster: undefined,
    nodepool: undefined,
    deployment: undefined,
  };
}

export const AuditLogTarget: MessageFns<AuditLogTarget> = {
  encode(message: AuditLogTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.role !== undefined) {
      Role.encode(message.role, writer.uint32(18).fork()).join();
    }
    if (message.team !== undefined) {
      Team.encode(message.team, writer.uint32(26).fork()).join();
    }
    if (message.app !== undefined) {
      App.encode(message.app, writer.uint32(34).fork()).join();
    }
    if (message.module !== undefined) {
      Module.encode(message.module, writer.uint32(42).fork()).join();
    }
    if (message.moduleVersion !== undefined) {
      ModuleVersion.encode(message.moduleVersion, writer.uint32(50).fork()).join();
    }
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(58).fork()).join();
    }
    if (message.workflowVersion !== undefined) {
      WorkflowVersion.encode(message.workflowVersion, writer.uint32(66).fork()).join();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(74).fork()).join();
    }
    if (message.modelVersion !== undefined) {
      ModelVersion.encode(message.modelVersion, writer.uint32(82).fork()).join();
    }
    if (message.computeCluster !== undefined) {
      ComputeCluster.encode(message.computeCluster, writer.uint32(90).fork()).join();
    }
    if (message.nodepool !== undefined) {
      Nodepool.encode(message.nodepool, writer.uint32(98).fork()).join();
    }
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = Role.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.team = Team.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.app = App.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.module = Module.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.moduleVersion = ModuleVersion.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.workflowVersion = WorkflowVersion.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modelVersion = ModelVersion.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.computeCluster = ComputeCluster.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.nodepool = Nodepool.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogTarget {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      role: isSet(object.role) ? Role.fromJSON(object.role) : undefined,
      team: isSet(object.team) ? Team.fromJSON(object.team) : undefined,
      app: isSet(object.app) ? App.fromJSON(object.app) : undefined,
      module: isSet(object.module) ? Module.fromJSON(object.module) : undefined,
      moduleVersion: isSet(object.moduleVersion) ? ModuleVersion.fromJSON(object.moduleVersion) : undefined,
      workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined,
      workflowVersion: isSet(object.workflowVersion) ? WorkflowVersion.fromJSON(object.workflowVersion) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
      modelVersion: isSet(object.modelVersion) ? ModelVersion.fromJSON(object.modelVersion) : undefined,
      computeCluster: isSet(object.computeCluster) ? ComputeCluster.fromJSON(object.computeCluster) : undefined,
      nodepool: isSet(object.nodepool) ? Nodepool.fromJSON(object.nodepool) : undefined,
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
    };
  },

  toJSON(message: AuditLogTarget): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.role !== undefined) {
      obj.role = Role.toJSON(message.role);
    }
    if (message.team !== undefined) {
      obj.team = Team.toJSON(message.team);
    }
    if (message.app !== undefined) {
      obj.app = App.toJSON(message.app);
    }
    if (message.module !== undefined) {
      obj.module = Module.toJSON(message.module);
    }
    if (message.moduleVersion !== undefined) {
      obj.moduleVersion = ModuleVersion.toJSON(message.moduleVersion);
    }
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    if (message.workflowVersion !== undefined) {
      obj.workflowVersion = WorkflowVersion.toJSON(message.workflowVersion);
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    if (message.modelVersion !== undefined) {
      obj.modelVersion = ModelVersion.toJSON(message.modelVersion);
    }
    if (message.computeCluster !== undefined) {
      obj.computeCluster = ComputeCluster.toJSON(message.computeCluster);
    }
    if (message.nodepool !== undefined) {
      obj.nodepool = Nodepool.toJSON(message.nodepool);
    }
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogTarget>, I>>(base?: I): AuditLogTarget {
    return AuditLogTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogTarget>, I>>(object: I): AuditLogTarget {
    const message = createBaseAuditLogTarget();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.role = (object.role !== undefined && object.role !== null) ? Role.fromPartial(object.role) : undefined;
    message.team = (object.team !== undefined && object.team !== null) ? Team.fromPartial(object.team) : undefined;
    message.app = (object.app !== undefined && object.app !== null) ? App.fromPartial(object.app) : undefined;
    message.module = (object.module !== undefined && object.module !== null)
      ? Module.fromPartial(object.module)
      : undefined;
    message.moduleVersion = (object.moduleVersion !== undefined && object.moduleVersion !== null)
      ? ModuleVersion.fromPartial(object.moduleVersion)
      : undefined;
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    message.workflowVersion = (object.workflowVersion !== undefined && object.workflowVersion !== null)
      ? WorkflowVersion.fromPartial(object.workflowVersion)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    message.modelVersion = (object.modelVersion !== undefined && object.modelVersion !== null)
      ? ModelVersion.fromPartial(object.modelVersion)
      : undefined;
    message.computeCluster = (object.computeCluster !== undefined && object.computeCluster !== null)
      ? ComputeCluster.fromPartial(object.computeCluster)
      : undefined;
    message.nodepool = (object.nodepool !== undefined && object.nodepool !== null)
      ? Nodepool.fromPartial(object.nodepool)
      : undefined;
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    return message;
  },
};

function createBaseAuditLogEntry(): AuditLogEntry {
  return {
    timestamp: undefined,
    user: undefined,
    operation: 0,
    description: "",
    targets: [],
    details: [],
    success: false,
    reqId: "",
    sourceIp: "",
  };
}

export const AuditLogEntry: MessageFns<AuditLogEntry> = {
  encode(message: AuditLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.operation !== 0) {
      writer.uint32(24).int32(message.operation);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.targets) {
      AuditLogTarget.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.details) {
      writer.uint32(50).string(v!);
    }
    if (message.success !== false) {
      writer.uint32(56).bool(message.success);
    }
    if (message.reqId !== "") {
      writer.uint32(66).string(message.reqId);
    }
    if (message.sourceIp !== "") {
      writer.uint32(74).string(message.sourceIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targets.push(AuditLogTarget.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.details.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reqId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogEntry {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      operation: isSet(object.operation) ? eventTypeFromJSON(object.operation) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targets: globalThis.Array.isArray(object?.targets)
        ? object.targets.map((e: any) => AuditLogTarget.fromJSON(e))
        : [],
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => globalThis.String(e)) : [],
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reqId: isSet(object.reqId) ? globalThis.String(object.reqId) : "",
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
    };
  },

  toJSON(message: AuditLogEntry): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.operation !== 0) {
      obj.operation = eventTypeToJSON(message.operation);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => AuditLogTarget.toJSON(e));
    }
    if (message.details?.length) {
      obj.details = message.details;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reqId !== "") {
      obj.reqId = message.reqId;
    }
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogEntry>, I>>(base?: I): AuditLogEntry {
    return AuditLogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogEntry>, I>>(object: I): AuditLogEntry {
    const message = createBaseAuditLogEntry();
    message.timestamp = object.timestamp ?? undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.operation = object.operation ?? 0;
    message.description = object.description ?? "";
    message.targets = object.targets?.map((e) => AuditLogTarget.fromPartial(e)) || [];
    message.details = object.details?.map((e) => e) || [];
    message.success = object.success ?? false;
    message.reqId = object.reqId ?? "";
    message.sourceIp = object.sourceIp ?? "";
    return message;
  },
};

function createBaseAuditLogQuery(): AuditLogQuery {
  return {
    timestampFrom: undefined,
    timestampTo: undefined,
    userIds: [],
    operations: [],
    targets: [],
    success: undefined,
    sourceIps: [],
  };
}

export const AuditLogQuery: MessageFns<AuditLogQuery> = {
  encode(message: AuditLogQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestampFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampFrom), writer.uint32(10).fork()).join();
    }
    if (message.timestampTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampTo), writer.uint32(18).fork()).join();
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.operations) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.targets) {
      AuditLogTarget.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.success !== undefined) {
      BoolValue.encode({ value: message.success! }, writer.uint32(50).fork()).join();
    }
    for (const v of message.sourceIps) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestampFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestampTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.operations.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.operations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targets.push(AuditLogTarget.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.success = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sourceIps.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogQuery {
    return {
      timestampFrom: isSet(object.timestampFrom) ? fromJsonTimestamp(object.timestampFrom) : undefined,
      timestampTo: isSet(object.timestampTo) ? fromJsonTimestamp(object.timestampTo) : undefined,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => eventTypeFromJSON(e))
        : [],
      targets: globalThis.Array.isArray(object?.targets)
        ? object.targets.map((e: any) => AuditLogTarget.fromJSON(e))
        : [],
      success: isSet(object.success) ? Boolean(object.success) : undefined,
      sourceIps: globalThis.Array.isArray(object?.sourceIps)
        ? object.sourceIps.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AuditLogQuery): unknown {
    const obj: any = {};
    if (message.timestampFrom !== undefined) {
      obj.timestampFrom = message.timestampFrom.toISOString();
    }
    if (message.timestampTo !== undefined) {
      obj.timestampTo = message.timestampTo.toISOString();
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => eventTypeToJSON(e));
    }
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => AuditLogTarget.toJSON(e));
    }
    if (message.success !== undefined) {
      obj.success = message.success;
    }
    if (message.sourceIps?.length) {
      obj.sourceIps = message.sourceIps;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogQuery>, I>>(base?: I): AuditLogQuery {
    return AuditLogQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogQuery>, I>>(object: I): AuditLogQuery {
    const message = createBaseAuditLogQuery();
    message.timestampFrom = object.timestampFrom ?? undefined;
    message.timestampTo = object.timestampTo ?? undefined;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.operations = object.operations?.map((e) => e) || [];
    message.targets = object.targets?.map((e) => AuditLogTarget.fromPartial(e)) || [];
    message.success = object.success ?? undefined;
    message.sourceIps = object.sourceIps?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkflowVersionEvaluationMetric(): WorkflowVersionEvaluationMetric {
  return { id: "", summary: "", description: "", dataType: 0, visualisationType: 0 };
}

export const WorkflowVersionEvaluationMetric: MessageFns<WorkflowVersionEvaluationMetric> = {
  encode(message: WorkflowVersionEvaluationMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.dataType !== 0) {
      writer.uint32(32).int32(message.dataType);
    }
    if (message.visualisationType !== 0) {
      writer.uint32(40).int32(message.visualisationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionEvaluationMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionEvaluationMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.visualisationType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionEvaluationMetric {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dataType: isSet(object.dataType) ? workflowVersionEvaluationMetric_DataTypeFromJSON(object.dataType) : 0,
      visualisationType: isSet(object.visualisationType)
        ? workflowVersionEvaluationMetric_VisualisationTypeFromJSON(object.visualisationType)
        : 0,
    };
  },

  toJSON(message: WorkflowVersionEvaluationMetric): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dataType !== 0) {
      obj.dataType = workflowVersionEvaluationMetric_DataTypeToJSON(message.dataType);
    }
    if (message.visualisationType !== 0) {
      obj.visualisationType = workflowVersionEvaluationMetric_VisualisationTypeToJSON(message.visualisationType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionEvaluationMetric>, I>>(base?: I): WorkflowVersionEvaluationMetric {
    return WorkflowVersionEvaluationMetric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionEvaluationMetric>, I>>(
    object: I,
  ): WorkflowVersionEvaluationMetric {
    const message = createBaseWorkflowVersionEvaluationMetric();
    message.id = object.id ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.dataType = object.dataType ?? 0;
    message.visualisationType = object.visualisationType ?? 0;
    return message;
  },
};

function createBaseWorkflowVersionEvaluationTemplate(): WorkflowVersionEvaluationTemplate {
  return { id: "", description: "", taskTypes: [], workflowVersionEvaluationMetrics: [] };
}

export const WorkflowVersionEvaluationTemplate: MessageFns<WorkflowVersionEvaluationTemplate> = {
  encode(message: WorkflowVersionEvaluationTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    writer.uint32(26).fork();
    for (const v of message.taskTypes) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.workflowVersionEvaluationMetrics) {
      WorkflowVersionEvaluationMetric.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionEvaluationTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionEvaluationTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.taskTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.taskTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowVersionEvaluationMetrics.push(
            WorkflowVersionEvaluationMetric.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionEvaluationTemplate {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      taskTypes: globalThis.Array.isArray(object?.taskTypes)
        ? object.taskTypes.map((e: any) => workflowVersionEvaluationTemplate_TaskTypeFromJSON(e))
        : [],
      workflowVersionEvaluationMetrics: globalThis.Array.isArray(object?.workflowVersionEvaluationMetrics)
        ? object.workflowVersionEvaluationMetrics.map((e: any) => WorkflowVersionEvaluationMetric.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkflowVersionEvaluationTemplate): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.taskTypes?.length) {
      obj.taskTypes = message.taskTypes.map((e) => workflowVersionEvaluationTemplate_TaskTypeToJSON(e));
    }
    if (message.workflowVersionEvaluationMetrics?.length) {
      obj.workflowVersionEvaluationMetrics = message.workflowVersionEvaluationMetrics.map((e) =>
        WorkflowVersionEvaluationMetric.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionEvaluationTemplate>, I>>(
    base?: I,
  ): WorkflowVersionEvaluationTemplate {
    return WorkflowVersionEvaluationTemplate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionEvaluationTemplate>, I>>(
    object: I,
  ): WorkflowVersionEvaluationTemplate {
    const message = createBaseWorkflowVersionEvaluationTemplate();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.taskTypes = object.taskTypes?.map((e) => e) || [];
    message.workflowVersionEvaluationMetrics =
      object.workflowVersionEvaluationMetrics?.map((e) => WorkflowVersionEvaluationMetric.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComputePlaneMetrics(): ComputePlaneMetrics {
  return {
    meta: undefined,
    cloud: "",
    region: "",
    instanceType: "",
    reservationType: "",
    reservationPrice: 0,
    runtimeS: 0,
    timestamp: undefined,
    eventType: "",
    gpuMetrics: [],
    hostname: "",
    cpuMetrics: [],
  };
}

export const ComputePlaneMetrics: MessageFns<ComputePlaneMetrics> = {
  encode(message: ComputePlaneMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      ComputeSourceMetadata.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.cloud !== "") {
      writer.uint32(18).string(message.cloud);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    if (message.instanceType !== "") {
      writer.uint32(34).string(message.instanceType);
    }
    if (message.reservationType !== "") {
      writer.uint32(42).string(message.reservationType);
    }
    if (message.reservationPrice !== 0) {
      writer.uint32(53).float(message.reservationPrice);
    }
    if (message.runtimeS !== 0) {
      writer.uint32(56).int32(message.runtimeS);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(66).fork()).join();
    }
    if (message.eventType !== "") {
      writer.uint32(74).string(message.eventType);
    }
    for (const v of message.gpuMetrics) {
      GpuMetrics.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.hostname !== "") {
      writer.uint32(90).string(message.hostname);
    }
    for (const v of message.cpuMetrics) {
      CpuMetrics.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputePlaneMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputePlaneMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = ComputeSourceMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cloud = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instanceType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reservationType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.reservationPrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.runtimeS = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gpuMetrics.push(GpuMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.cpuMetrics.push(CpuMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputePlaneMetrics {
    return {
      meta: isSet(object.meta) ? ComputeSourceMetadata.fromJSON(object.meta) : undefined,
      cloud: isSet(object.cloud) ? globalThis.String(object.cloud) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      instanceType: isSet(object.instanceType) ? globalThis.String(object.instanceType) : "",
      reservationType: isSet(object.reservationType) ? globalThis.String(object.reservationType) : "",
      reservationPrice: isSet(object.reservationPrice) ? globalThis.Number(object.reservationPrice) : 0,
      runtimeS: isSet(object.runtimeS) ? globalThis.Number(object.runtimeS) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      gpuMetrics: globalThis.Array.isArray(object?.gpuMetrics)
        ? object.gpuMetrics.map((e: any) => GpuMetrics.fromJSON(e))
        : [],
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      cpuMetrics: globalThis.Array.isArray(object?.cpuMetrics)
        ? object.cpuMetrics.map((e: any) => CpuMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComputePlaneMetrics): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = ComputeSourceMetadata.toJSON(message.meta);
    }
    if (message.cloud !== "") {
      obj.cloud = message.cloud;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.instanceType !== "") {
      obj.instanceType = message.instanceType;
    }
    if (message.reservationType !== "") {
      obj.reservationType = message.reservationType;
    }
    if (message.reservationPrice !== 0) {
      obj.reservationPrice = message.reservationPrice;
    }
    if (message.runtimeS !== 0) {
      obj.runtimeS = Math.round(message.runtimeS);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.gpuMetrics?.length) {
      obj.gpuMetrics = message.gpuMetrics.map((e) => GpuMetrics.toJSON(e));
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.cpuMetrics?.length) {
      obj.cpuMetrics = message.cpuMetrics.map((e) => CpuMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputePlaneMetrics>, I>>(base?: I): ComputePlaneMetrics {
    return ComputePlaneMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputePlaneMetrics>, I>>(object: I): ComputePlaneMetrics {
    const message = createBaseComputePlaneMetrics();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? ComputeSourceMetadata.fromPartial(object.meta)
      : undefined;
    message.cloud = object.cloud ?? "";
    message.region = object.region ?? "";
    message.instanceType = object.instanceType ?? "";
    message.reservationType = object.reservationType ?? "";
    message.reservationPrice = object.reservationPrice ?? 0;
    message.runtimeS = object.runtimeS ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.gpuMetrics = object.gpuMetrics?.map((e) => GpuMetrics.fromPartial(e)) || [];
    message.hostname = object.hostname ?? "";
    message.cpuMetrics = object.cpuMetrics?.map((e) => CpuMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGpuMetrics(): GpuMetrics {
  return { uuid: "", modelName: "", utilizationPct: 0, tensorUtilizationPct: 0, memoryUtilizationPct: 0 };
}

export const GpuMetrics: MessageFns<GpuMetrics> = {
  encode(message: GpuMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.modelName !== "") {
      writer.uint32(18).string(message.modelName);
    }
    if (message.utilizationPct !== 0) {
      writer.uint32(29).float(message.utilizationPct);
    }
    if (message.tensorUtilizationPct !== 0) {
      writer.uint32(37).float(message.tensorUtilizationPct);
    }
    if (message.memoryUtilizationPct !== 0) {
      writer.uint32(45).float(message.memoryUtilizationPct);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GpuMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGpuMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.utilizationPct = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.tensorUtilizationPct = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.memoryUtilizationPct = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GpuMetrics {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      utilizationPct: isSet(object.utilizationPct) ? globalThis.Number(object.utilizationPct) : 0,
      tensorUtilizationPct: isSet(object.tensorUtilizationPct) ? globalThis.Number(object.tensorUtilizationPct) : 0,
      memoryUtilizationPct: isSet(object.memoryUtilizationPct) ? globalThis.Number(object.memoryUtilizationPct) : 0,
    };
  },

  toJSON(message: GpuMetrics): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.utilizationPct !== 0) {
      obj.utilizationPct = message.utilizationPct;
    }
    if (message.tensorUtilizationPct !== 0) {
      obj.tensorUtilizationPct = message.tensorUtilizationPct;
    }
    if (message.memoryUtilizationPct !== 0) {
      obj.memoryUtilizationPct = message.memoryUtilizationPct;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GpuMetrics>, I>>(base?: I): GpuMetrics {
    return GpuMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GpuMetrics>, I>>(object: I): GpuMetrics {
    const message = createBaseGpuMetrics();
    message.uuid = object.uuid ?? "";
    message.modelName = object.modelName ?? "";
    message.utilizationPct = object.utilizationPct ?? 0;
    message.tensorUtilizationPct = object.tensorUtilizationPct ?? 0;
    message.memoryUtilizationPct = object.memoryUtilizationPct ?? 0;
    return message;
  },
};

function createBaseCpuMetrics(): CpuMetrics {
  return { timestamp: undefined, cpuUtilizationPct: 0, memoryUtilizationPct: 0, millicores: 0, memoryBytes: 0 };
}

export const CpuMetrics: MessageFns<CpuMetrics> = {
  encode(message: CpuMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.cpuUtilizationPct !== 0) {
      writer.uint32(21).float(message.cpuUtilizationPct);
    }
    if (message.memoryUtilizationPct !== 0) {
      writer.uint32(29).float(message.memoryUtilizationPct);
    }
    if (message.millicores !== 0) {
      writer.uint32(32).int64(message.millicores);
    }
    if (message.memoryBytes !== 0) {
      writer.uint32(40).int64(message.memoryBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CpuMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCpuMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.cpuUtilizationPct = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.memoryUtilizationPct = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.millicores = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryBytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CpuMetrics {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      cpuUtilizationPct: isSet(object.cpuUtilizationPct) ? globalThis.Number(object.cpuUtilizationPct) : 0,
      memoryUtilizationPct: isSet(object.memoryUtilizationPct) ? globalThis.Number(object.memoryUtilizationPct) : 0,
      millicores: isSet(object.millicores) ? globalThis.Number(object.millicores) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.Number(object.memoryBytes) : 0,
    };
  },

  toJSON(message: CpuMetrics): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.cpuUtilizationPct !== 0) {
      obj.cpuUtilizationPct = message.cpuUtilizationPct;
    }
    if (message.memoryUtilizationPct !== 0) {
      obj.memoryUtilizationPct = message.memoryUtilizationPct;
    }
    if (message.millicores !== 0) {
      obj.millicores = Math.round(message.millicores);
    }
    if (message.memoryBytes !== 0) {
      obj.memoryBytes = Math.round(message.memoryBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CpuMetrics>, I>>(base?: I): CpuMetrics {
    return CpuMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CpuMetrics>, I>>(object: I): CpuMetrics {
    const message = createBaseCpuMetrics();
    message.timestamp = object.timestamp ?? undefined;
    message.cpuUtilizationPct = object.cpuUtilizationPct ?? 0;
    message.memoryUtilizationPct = object.memoryUtilizationPct ?? 0;
    message.millicores = object.millicores ?? 0;
    message.memoryBytes = object.memoryBytes ?? 0;
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return { message: "", logType: "", url: "", meta: undefined };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.logType !== "") {
      writer.uint32(18).string(message.logType);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.meta !== undefined) {
      ComputeSourceMetadata.encode(message.meta, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.meta = ComputeSourceMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      logType: isSet(object.logType) ? globalThis.String(object.logType) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      meta: isSet(object.meta) ? ComputeSourceMetadata.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.logType !== "") {
      obj.logType = message.logType;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.meta !== undefined) {
      obj.meta = ComputeSourceMetadata.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntry>, I>>(base?: I): LogEntry {
    return LogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntry>, I>>(object: I): LogEntry {
    const message = createBaseLogEntry();
    message.message = object.message ?? "";
    message.logType = object.logType ?? "";
    message.url = object.url ?? "";
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? ComputeSourceMetadata.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseComputeSourceMetadata(): ComputeSourceMetadata {
  return {
    userAppId: undefined,
    modelId: "",
    modelVersionId: "",
    workflowId: "",
    computeClusterUserId: "",
    computeClusterId: "",
    nodepoolId: "",
    runnerId: "",
    pipelineId: "",
    pipelineVersionId: "",
    pipelineVersionRunId: "",
    pipelineStepId: "",
    pipelineStepVersionId: "",
  };
}

export const ComputeSourceMetadata: MessageFns<ComputeSourceMetadata> = {
  encode(message: ComputeSourceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAppId !== undefined) {
      UserAppIDSet.encode(message.userAppId, writer.uint32(10).fork()).join();
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(26).string(message.modelVersionId);
    }
    if (message.workflowId !== "") {
      writer.uint32(34).string(message.workflowId);
    }
    if (message.computeClusterUserId !== "") {
      writer.uint32(114).string(message.computeClusterUserId);
    }
    if (message.computeClusterId !== "") {
      writer.uint32(50).string(message.computeClusterId);
    }
    if (message.nodepoolId !== "") {
      writer.uint32(58).string(message.nodepoolId);
    }
    if (message.runnerId !== "") {
      writer.uint32(66).string(message.runnerId);
    }
    if (message.pipelineId !== "") {
      writer.uint32(74).string(message.pipelineId);
    }
    if (message.pipelineVersionId !== "") {
      writer.uint32(82).string(message.pipelineVersionId);
    }
    if (message.pipelineVersionRunId !== "") {
      writer.uint32(90).string(message.pipelineVersionRunId);
    }
    if (message.pipelineStepId !== "") {
      writer.uint32(98).string(message.pipelineStepId);
    }
    if (message.pipelineStepVersionId !== "") {
      writer.uint32(106).string(message.pipelineStepVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeSourceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeSourceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAppId = UserAppIDSet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.computeClusterUserId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.computeClusterId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nodepoolId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pipelineVersionId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.pipelineVersionRunId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pipelineStepId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.pipelineStepVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeSourceMetadata {
    return {
      userAppId: isSet(object.userAppId) ? UserAppIDSet.fromJSON(object.userAppId) : undefined,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      computeClusterUserId: isSet(object.computeClusterUserId) ? globalThis.String(object.computeClusterUserId) : "",
      computeClusterId: isSet(object.computeClusterId) ? globalThis.String(object.computeClusterId) : "",
      nodepoolId: isSet(object.nodepoolId) ? globalThis.String(object.nodepoolId) : "",
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      pipelineVersionId: isSet(object.pipelineVersionId) ? globalThis.String(object.pipelineVersionId) : "",
      pipelineVersionRunId: isSet(object.pipelineVersionRunId) ? globalThis.String(object.pipelineVersionRunId) : "",
      pipelineStepId: isSet(object.pipelineStepId) ? globalThis.String(object.pipelineStepId) : "",
      pipelineStepVersionId: isSet(object.pipelineStepVersionId) ? globalThis.String(object.pipelineStepVersionId) : "",
    };
  },

  toJSON(message: ComputeSourceMetadata): unknown {
    const obj: any = {};
    if (message.userAppId !== undefined) {
      obj.userAppId = UserAppIDSet.toJSON(message.userAppId);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.computeClusterUserId !== "") {
      obj.computeClusterUserId = message.computeClusterUserId;
    }
    if (message.computeClusterId !== "") {
      obj.computeClusterId = message.computeClusterId;
    }
    if (message.nodepoolId !== "") {
      obj.nodepoolId = message.nodepoolId;
    }
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.pipelineVersionId !== "") {
      obj.pipelineVersionId = message.pipelineVersionId;
    }
    if (message.pipelineVersionRunId !== "") {
      obj.pipelineVersionRunId = message.pipelineVersionRunId;
    }
    if (message.pipelineStepId !== "") {
      obj.pipelineStepId = message.pipelineStepId;
    }
    if (message.pipelineStepVersionId !== "") {
      obj.pipelineStepVersionId = message.pipelineStepVersionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputeSourceMetadata>, I>>(base?: I): ComputeSourceMetadata {
    return ComputeSourceMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputeSourceMetadata>, I>>(object: I): ComputeSourceMetadata {
    const message = createBaseComputeSourceMetadata();
    message.userAppId = (object.userAppId !== undefined && object.userAppId !== null)
      ? UserAppIDSet.fromPartial(object.userAppId)
      : undefined;
    message.modelId = object.modelId ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.workflowId = object.workflowId ?? "";
    message.computeClusterUserId = object.computeClusterUserId ?? "";
    message.computeClusterId = object.computeClusterId ?? "";
    message.nodepoolId = object.nodepoolId ?? "";
    message.runnerId = object.runnerId ?? "";
    message.pipelineId = object.pipelineId ?? "";
    message.pipelineVersionId = object.pipelineVersionId ?? "";
    message.pipelineVersionRunId = object.pipelineVersionRunId ?? "";
    message.pipelineStepId = object.pipelineStepId ?? "";
    message.pipelineStepVersionId = object.pipelineStepVersionId ?? "";
    return message;
  },
};

function createBaseWorkflowVersionEvaluation(): WorkflowVersionEvaluation {
  return {
    id: "",
    workflowVersion: undefined,
    targetNodeId: "",
    groundTruthDatasetVersion: undefined,
    predictionsDatasetVersion: undefined,
    workflowVersionEvaluationTemplate: undefined,
    userId: "",
    appId: "",
    workflowEvaluationResult: undefined,
    status: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const WorkflowVersionEvaluation: MessageFns<WorkflowVersionEvaluation> = {
  encode(message: WorkflowVersionEvaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.workflowVersion !== undefined) {
      WorkflowVersion.encode(message.workflowVersion, writer.uint32(18).fork()).join();
    }
    if (message.targetNodeId !== "") {
      writer.uint32(26).string(message.targetNodeId);
    }
    if (message.groundTruthDatasetVersion !== undefined) {
      DatasetVersion.encode(message.groundTruthDatasetVersion, writer.uint32(34).fork()).join();
    }
    if (message.predictionsDatasetVersion !== undefined) {
      DatasetVersion.encode(message.predictionsDatasetVersion, writer.uint32(42).fork()).join();
    }
    if (message.workflowVersionEvaluationTemplate !== undefined) {
      WorkflowVersionEvaluationTemplate.encode(message.workflowVersionEvaluationTemplate, writer.uint32(50).fork())
        .join();
    }
    if (message.userId !== "") {
      writer.uint32(58).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.workflowEvaluationResult !== undefined) {
      WorkflowEvaluationResult.encode(message.workflowEvaluationResult, writer.uint32(74).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(82).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(90).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionEvaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowVersion = WorkflowVersion.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetNodeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groundTruthDatasetVersion = DatasetVersion.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.predictionsDatasetVersion = DatasetVersion.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workflowVersionEvaluationTemplate = WorkflowVersionEvaluationTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.workflowEvaluationResult = WorkflowEvaluationResult.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionEvaluation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      workflowVersion: isSet(object.workflowVersion) ? WorkflowVersion.fromJSON(object.workflowVersion) : undefined,
      targetNodeId: isSet(object.targetNodeId) ? globalThis.String(object.targetNodeId) : "",
      groundTruthDatasetVersion: isSet(object.groundTruthDatasetVersion)
        ? DatasetVersion.fromJSON(object.groundTruthDatasetVersion)
        : undefined,
      predictionsDatasetVersion: isSet(object.predictionsDatasetVersion)
        ? DatasetVersion.fromJSON(object.predictionsDatasetVersion)
        : undefined,
      workflowVersionEvaluationTemplate: isSet(object.workflowVersionEvaluationTemplate)
        ? WorkflowVersionEvaluationTemplate.fromJSON(object.workflowVersionEvaluationTemplate)
        : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      workflowEvaluationResult: isSet(object.workflowEvaluationResult)
        ? WorkflowEvaluationResult.fromJSON(object.workflowEvaluationResult)
        : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: WorkflowVersionEvaluation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.workflowVersion !== undefined) {
      obj.workflowVersion = WorkflowVersion.toJSON(message.workflowVersion);
    }
    if (message.targetNodeId !== "") {
      obj.targetNodeId = message.targetNodeId;
    }
    if (message.groundTruthDatasetVersion !== undefined) {
      obj.groundTruthDatasetVersion = DatasetVersion.toJSON(message.groundTruthDatasetVersion);
    }
    if (message.predictionsDatasetVersion !== undefined) {
      obj.predictionsDatasetVersion = DatasetVersion.toJSON(message.predictionsDatasetVersion);
    }
    if (message.workflowVersionEvaluationTemplate !== undefined) {
      obj.workflowVersionEvaluationTemplate = WorkflowVersionEvaluationTemplate.toJSON(
        message.workflowVersionEvaluationTemplate,
      );
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.workflowEvaluationResult !== undefined) {
      obj.workflowEvaluationResult = WorkflowEvaluationResult.toJSON(message.workflowEvaluationResult);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionEvaluation>, I>>(base?: I): WorkflowVersionEvaluation {
    return WorkflowVersionEvaluation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionEvaluation>, I>>(object: I): WorkflowVersionEvaluation {
    const message = createBaseWorkflowVersionEvaluation();
    message.id = object.id ?? "";
    message.workflowVersion = (object.workflowVersion !== undefined && object.workflowVersion !== null)
      ? WorkflowVersion.fromPartial(object.workflowVersion)
      : undefined;
    message.targetNodeId = object.targetNodeId ?? "";
    message.groundTruthDatasetVersion =
      (object.groundTruthDatasetVersion !== undefined && object.groundTruthDatasetVersion !== null)
        ? DatasetVersion.fromPartial(object.groundTruthDatasetVersion)
        : undefined;
    message.predictionsDatasetVersion =
      (object.predictionsDatasetVersion !== undefined && object.predictionsDatasetVersion !== null)
        ? DatasetVersion.fromPartial(object.predictionsDatasetVersion)
        : undefined;
    message.workflowVersionEvaluationTemplate =
      (object.workflowVersionEvaluationTemplate !== undefined && object.workflowVersionEvaluationTemplate !== null)
        ? WorkflowVersionEvaluationTemplate.fromPartial(object.workflowVersionEvaluationTemplate)
        : undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.workflowEvaluationResult =
      (object.workflowEvaluationResult !== undefined && object.workflowEvaluationResult !== null)
        ? WorkflowEvaluationResult.fromPartial(object.workflowEvaluationResult)
        : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBaseWorkflowEvaluationResult(): WorkflowEvaluationResult {
  return { summary: undefined };
}

export const WorkflowEvaluationResult: MessageFns<WorkflowEvaluationResult> = {
  encode(message: WorkflowEvaluationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== undefined) {
      WorkflowEvaluationResultSummary.encode(message.summary, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvaluationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvaluationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = WorkflowEvaluationResultSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvaluationResult {
    return { summary: isSet(object.summary) ? WorkflowEvaluationResultSummary.fromJSON(object.summary) : undefined };
  },

  toJSON(message: WorkflowEvaluationResult): unknown {
    const obj: any = {};
    if (message.summary !== undefined) {
      obj.summary = WorkflowEvaluationResultSummary.toJSON(message.summary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowEvaluationResult>, I>>(base?: I): WorkflowEvaluationResult {
    return WorkflowEvaluationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowEvaluationResult>, I>>(object: I): WorkflowEvaluationResult {
    const message = createBaseWorkflowEvaluationResult();
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? WorkflowEvaluationResultSummary.fromPartial(object.summary)
      : undefined;
    return message;
  },
};

function createBaseWorkflowEvaluationResultSummary(): WorkflowEvaluationResultSummary {
  return { evaluationMetricValues: [] };
}

export const WorkflowEvaluationResultSummary: MessageFns<WorkflowEvaluationResultSummary> = {
  encode(message: WorkflowEvaluationResultSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.evaluationMetricValues) {
      EvaluationMetricValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvaluationResultSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvaluationResultSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluationMetricValues.push(EvaluationMetricValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvaluationResultSummary {
    return {
      evaluationMetricValues: globalThis.Array.isArray(object?.evaluationMetricValues)
        ? object.evaluationMetricValues.map((e: any) => EvaluationMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkflowEvaluationResultSummary): unknown {
    const obj: any = {};
    if (message.evaluationMetricValues?.length) {
      obj.evaluationMetricValues = message.evaluationMetricValues.map((e) => EvaluationMetricValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowEvaluationResultSummary>, I>>(base?: I): WorkflowEvaluationResultSummary {
    return WorkflowEvaluationResultSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowEvaluationResultSummary>, I>>(
    object: I,
  ): WorkflowEvaluationResultSummary {
    const message = createBaseWorkflowEvaluationResultSummary();
    message.evaluationMetricValues = object.evaluationMetricValues?.map((e) => EvaluationMetricValue.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseEvaluationMetricValue(): EvaluationMetricValue {
  return { evaluationMetricId: "", metricValue: undefined, explanation: "", perConceptValues: {} };
}

export const EvaluationMetricValue: MessageFns<EvaluationMetricValue> = {
  encode(message: EvaluationMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationMetricId !== "") {
      writer.uint32(10).string(message.evaluationMetricId);
    }
    if (message.metricValue !== undefined) {
      MetricValue.encode(message.metricValue, writer.uint32(18).fork()).join();
    }
    if (message.explanation !== "") {
      writer.uint32(26).string(message.explanation);
    }
    Object.entries(message.perConceptValues).forEach(([key, value]) => {
      EvaluationMetricValue_PerConceptValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluationMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluationMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationMetricId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metricValue = MetricValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = EvaluationMetricValue_PerConceptValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.perConceptValues[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluationMetricValue {
    return {
      evaluationMetricId: isSet(object.evaluationMetricId) ? globalThis.String(object.evaluationMetricId) : "",
      metricValue: isSet(object.metricValue) ? MetricValue.fromJSON(object.metricValue) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      perConceptValues: isObject(object.perConceptValues)
        ? Object.entries(object.perConceptValues).reduce<{ [key: string]: MetricValue }>((acc, [key, value]) => {
          acc[key] = MetricValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EvaluationMetricValue): unknown {
    const obj: any = {};
    if (message.evaluationMetricId !== "") {
      obj.evaluationMetricId = message.evaluationMetricId;
    }
    if (message.metricValue !== undefined) {
      obj.metricValue = MetricValue.toJSON(message.metricValue);
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.perConceptValues) {
      const entries = Object.entries(message.perConceptValues);
      if (entries.length > 0) {
        obj.perConceptValues = {};
        entries.forEach(([k, v]) => {
          obj.perConceptValues[k] = MetricValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluationMetricValue>, I>>(base?: I): EvaluationMetricValue {
    return EvaluationMetricValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluationMetricValue>, I>>(object: I): EvaluationMetricValue {
    const message = createBaseEvaluationMetricValue();
    message.evaluationMetricId = object.evaluationMetricId ?? "";
    message.metricValue = (object.metricValue !== undefined && object.metricValue !== null)
      ? MetricValue.fromPartial(object.metricValue)
      : undefined;
    message.explanation = object.explanation ?? "";
    message.perConceptValues = Object.entries(object.perConceptValues ?? {}).reduce<{ [key: string]: MetricValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MetricValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseEvaluationMetricValue_PerConceptValuesEntry(): EvaluationMetricValue_PerConceptValuesEntry {
  return { key: "", value: undefined };
}

export const EvaluationMetricValue_PerConceptValuesEntry: MessageFns<EvaluationMetricValue_PerConceptValuesEntry> = {
  encode(
    message: EvaluationMetricValue_PerConceptValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MetricValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluationMetricValue_PerConceptValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluationMetricValue_PerConceptValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MetricValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluationMetricValue_PerConceptValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MetricValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EvaluationMetricValue_PerConceptValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MetricValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluationMetricValue_PerConceptValuesEntry>, I>>(
    base?: I,
  ): EvaluationMetricValue_PerConceptValuesEntry {
    return EvaluationMetricValue_PerConceptValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluationMetricValue_PerConceptValuesEntry>, I>>(
    object: I,
  ): EvaluationMetricValue_PerConceptValuesEntry {
    const message = createBaseEvaluationMetricValue_PerConceptValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MetricValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInputEvaluationMetricValue(): InputEvaluationMetricValue {
  return { evaluationMetricId: "", metricValue: undefined, explanation: "", perRegionValues: {} };
}

export const InputEvaluationMetricValue: MessageFns<InputEvaluationMetricValue> = {
  encode(message: InputEvaluationMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationMetricId !== "") {
      writer.uint32(10).string(message.evaluationMetricId);
    }
    if (message.metricValue !== undefined) {
      MetricValue.encode(message.metricValue, writer.uint32(18).fork()).join();
    }
    if (message.explanation !== "") {
      writer.uint32(26).string(message.explanation);
    }
    Object.entries(message.perRegionValues).forEach(([key, value]) => {
      InputEvaluationMetricValue_PerRegionValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputEvaluationMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputEvaluationMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationMetricId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metricValue = MetricValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = InputEvaluationMetricValue_PerRegionValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.perRegionValues[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputEvaluationMetricValue {
    return {
      evaluationMetricId: isSet(object.evaluationMetricId) ? globalThis.String(object.evaluationMetricId) : "",
      metricValue: isSet(object.metricValue) ? MetricValue.fromJSON(object.metricValue) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      perRegionValues: isObject(object.perRegionValues)
        ? Object.entries(object.perRegionValues).reduce<{ [key: string]: MetricValue }>((acc, [key, value]) => {
          acc[key] = MetricValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InputEvaluationMetricValue): unknown {
    const obj: any = {};
    if (message.evaluationMetricId !== "") {
      obj.evaluationMetricId = message.evaluationMetricId;
    }
    if (message.metricValue !== undefined) {
      obj.metricValue = MetricValue.toJSON(message.metricValue);
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.perRegionValues) {
      const entries = Object.entries(message.perRegionValues);
      if (entries.length > 0) {
        obj.perRegionValues = {};
        entries.forEach(([k, v]) => {
          obj.perRegionValues[k] = MetricValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputEvaluationMetricValue>, I>>(base?: I): InputEvaluationMetricValue {
    return InputEvaluationMetricValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputEvaluationMetricValue>, I>>(object: I): InputEvaluationMetricValue {
    const message = createBaseInputEvaluationMetricValue();
    message.evaluationMetricId = object.evaluationMetricId ?? "";
    message.metricValue = (object.metricValue !== undefined && object.metricValue !== null)
      ? MetricValue.fromPartial(object.metricValue)
      : undefined;
    message.explanation = object.explanation ?? "";
    message.perRegionValues = Object.entries(object.perRegionValues ?? {}).reduce<{ [key: string]: MetricValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MetricValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInputEvaluationMetricValue_PerRegionValuesEntry(): InputEvaluationMetricValue_PerRegionValuesEntry {
  return { key: "", value: undefined };
}

export const InputEvaluationMetricValue_PerRegionValuesEntry: MessageFns<
  InputEvaluationMetricValue_PerRegionValuesEntry
> = {
  encode(
    message: InputEvaluationMetricValue_PerRegionValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MetricValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputEvaluationMetricValue_PerRegionValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputEvaluationMetricValue_PerRegionValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MetricValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputEvaluationMetricValue_PerRegionValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MetricValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: InputEvaluationMetricValue_PerRegionValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MetricValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputEvaluationMetricValue_PerRegionValuesEntry>, I>>(
    base?: I,
  ): InputEvaluationMetricValue_PerRegionValuesEntry {
    return InputEvaluationMetricValue_PerRegionValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputEvaluationMetricValue_PerRegionValuesEntry>, I>>(
    object: I,
  ): InputEvaluationMetricValue_PerRegionValuesEntry {
    const message = createBaseInputEvaluationMetricValue_PerRegionValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MetricValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMetricValue(): MetricValue {
  return { stringValue: undefined, floatValue: undefined, intValue: undefined };
}

export const MetricValue: MessageFns<MetricValue> = {
  encode(message: MetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.floatValue !== undefined) {
      writer.uint32(21).float(message.floatValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(24).int32(message.intValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
    };
  },

  toJSON(message: MetricValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricValue>, I>>(base?: I): MetricValue {
    return MetricValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricValue>, I>>(object: I): MetricValue {
    const message = createBaseMetricValue();
    message.stringValue = object.stringValue ?? undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    return message;
  },
};

function createBaseWorkflowEvaluationInputResult(): WorkflowEvaluationInputResult {
  return { inputEvaluationMetricValues: [] };
}

export const WorkflowEvaluationInputResult: MessageFns<WorkflowEvaluationInputResult> = {
  encode(message: WorkflowEvaluationInputResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputEvaluationMetricValues) {
      InputEvaluationMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvaluationInputResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvaluationInputResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputEvaluationMetricValues.push(InputEvaluationMetricValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvaluationInputResult {
    return {
      inputEvaluationMetricValues: globalThis.Array.isArray(object?.inputEvaluationMetricValues)
        ? object.inputEvaluationMetricValues.map((e: any) => InputEvaluationMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkflowEvaluationInputResult): unknown {
    const obj: any = {};
    if (message.inputEvaluationMetricValues?.length) {
      obj.inputEvaluationMetricValues = message.inputEvaluationMetricValues.map((e) =>
        InputEvaluationMetricValue.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowEvaluationInputResult>, I>>(base?: I): WorkflowEvaluationInputResult {
    return WorkflowEvaluationInputResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowEvaluationInputResult>, I>>(
    object: I,
  ): WorkflowEvaluationInputResult {
    const message = createBaseWorkflowEvaluationInputResult();
    message.inputEvaluationMetricValues =
      object.inputEvaluationMetricValues?.map((e) => InputEvaluationMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkflowVersionEvaluationData(): WorkflowVersionEvaluationData {
  return { id: "", input: undefined, groundTruths: [], predictions: [], workflowEvaluationSampleResult: undefined };
}

export const WorkflowVersionEvaluationData: MessageFns<WorkflowVersionEvaluationData> = {
  encode(message: WorkflowVersionEvaluationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    for (const v of message.groundTruths) {
      Data.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.predictions) {
      Data.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.workflowEvaluationSampleResult !== undefined) {
      WorkflowEvaluationInputResult.encode(message.workflowEvaluationSampleResult, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowVersionEvaluationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowVersionEvaluationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groundTruths.push(Data.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.predictions.push(Data.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowEvaluationSampleResult = WorkflowEvaluationInputResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowVersionEvaluationData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      groundTruths: globalThis.Array.isArray(object?.groundTruths)
        ? object.groundTruths.map((e: any) => Data.fromJSON(e))
        : [],
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => Data.fromJSON(e))
        : [],
      workflowEvaluationSampleResult: isSet(object.workflowEvaluationSampleResult)
        ? WorkflowEvaluationInputResult.fromJSON(object.workflowEvaluationSampleResult)
        : undefined,
    };
  },

  toJSON(message: WorkflowVersionEvaluationData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.groundTruths?.length) {
      obj.groundTruths = message.groundTruths.map((e) => Data.toJSON(e));
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => Data.toJSON(e));
    }
    if (message.workflowEvaluationSampleResult !== undefined) {
      obj.workflowEvaluationSampleResult = WorkflowEvaluationInputResult.toJSON(message.workflowEvaluationSampleResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowVersionEvaluationData>, I>>(base?: I): WorkflowVersionEvaluationData {
    return WorkflowVersionEvaluationData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowVersionEvaluationData>, I>>(
    object: I,
  ): WorkflowVersionEvaluationData {
    const message = createBaseWorkflowVersionEvaluationData();
    message.id = object.id ?? "";
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.groundTruths = object.groundTruths?.map((e) => Data.fromPartial(e)) || [];
    message.predictions = object.predictions?.map((e) => Data.fromPartial(e)) || [];
    message.workflowEvaluationSampleResult =
      (object.workflowEvaluationSampleResult !== undefined && object.workflowEvaluationSampleResult !== null)
        ? WorkflowEvaluationInputResult.fromPartial(object.workflowEvaluationSampleResult)
        : undefined;
    return message;
  },
};

function createBaseArgoOrchestrationSpec(): ArgoOrchestrationSpec {
  return { apiVersion: "", specJson: "" };
}

export const ArgoOrchestrationSpec: MessageFns<ArgoOrchestrationSpec> = {
  encode(message: ArgoOrchestrationSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(18).string(message.apiVersion);
    }
    if (message.specJson !== "") {
      writer.uint32(26).string(message.specJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArgoOrchestrationSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgoOrchestrationSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgoOrchestrationSpec {
    return {
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      specJson: isSet(object.specJson) ? globalThis.String(object.specJson) : "",
    };
  },

  toJSON(message: ArgoOrchestrationSpec): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.specJson !== "") {
      obj.specJson = message.specJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgoOrchestrationSpec>, I>>(base?: I): ArgoOrchestrationSpec {
    return ArgoOrchestrationSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgoOrchestrationSpec>, I>>(object: I): ArgoOrchestrationSpec {
    const message = createBaseArgoOrchestrationSpec();
    message.apiVersion = object.apiVersion ?? "";
    message.specJson = object.specJson ?? "";
    return message;
  },
};

function createBaseOrchestrationSpec(): OrchestrationSpec {
  return { argoOrchestrationSpec: undefined };
}

export const OrchestrationSpec: MessageFns<OrchestrationSpec> = {
  encode(message: OrchestrationSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argoOrchestrationSpec !== undefined) {
      ArgoOrchestrationSpec.encode(message.argoOrchestrationSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.argoOrchestrationSpec = ArgoOrchestrationSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrationSpec {
    return {
      argoOrchestrationSpec: isSet(object.argoOrchestrationSpec)
        ? ArgoOrchestrationSpec.fromJSON(object.argoOrchestrationSpec)
        : undefined,
    };
  },

  toJSON(message: OrchestrationSpec): unknown {
    const obj: any = {};
    if (message.argoOrchestrationSpec !== undefined) {
      obj.argoOrchestrationSpec = ArgoOrchestrationSpec.toJSON(message.argoOrchestrationSpec);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrchestrationSpec>, I>>(base?: I): OrchestrationSpec {
    return OrchestrationSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrchestrationSpec>, I>>(object: I): OrchestrationSpec {
    const message = createBaseOrchestrationSpec();
    message.argoOrchestrationSpec =
      (object.argoOrchestrationSpec !== undefined && object.argoOrchestrationSpec !== null)
        ? ArgoOrchestrationSpec.fromPartial(object.argoOrchestrationSpec)
        : undefined;
    return message;
  },
};

function createBasePipelineStepInputParam(): PipelineStepInputParam {
  return { name: "", defaultValue: "", description: "", acceptedValues: [] };
}

export const PipelineStepInputParam: MessageFns<PipelineStepInputParam> = {
  encode(message: PipelineStepInputParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.defaultValue !== "") {
      writer.uint32(18).string(message.defaultValue);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.acceptedValues) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineStepInputParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineStepInputParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.acceptedValues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineStepInputParam {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceptedValues: globalThis.Array.isArray(object?.acceptedValues)
        ? object.acceptedValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PipelineStepInputParam): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceptedValues?.length) {
      obj.acceptedValues = message.acceptedValues;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineStepInputParam>, I>>(base?: I): PipelineStepInputParam {
    return PipelineStepInputParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineStepInputParam>, I>>(object: I): PipelineStepInputParam {
    const message = createBasePipelineStepInputParam();
    message.name = object.name ?? "";
    message.defaultValue = object.defaultValue ?? "";
    message.description = object.description ?? "";
    message.acceptedValues = object.acceptedValues?.map((e) => e) || [];
    return message;
  },
};

function createBasePipelineStep(): PipelineStep {
  return {
    id: "",
    userId: "",
    description: "",
    pipelineStepVersion: undefined,
    visibility: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const PipelineStep: MessageFns<PipelineStep> = {
  encode(message: PipelineStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.pipelineStepVersion !== undefined) {
      PipelineStepVersion.encode(message.pipelineStepVersion, writer.uint32(34).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pipelineStepVersion = PipelineStepVersion.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineStep {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pipelineStepVersion: isSet(object.pipelineStepVersion)
        ? PipelineStepVersion.fromJSON(object.pipelineStepVersion)
        : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: PipelineStep): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pipelineStepVersion !== undefined) {
      obj.pipelineStepVersion = PipelineStepVersion.toJSON(message.pipelineStepVersion);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineStep>, I>>(base?: I): PipelineStep {
    return PipelineStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineStep>, I>>(object: I): PipelineStep {
    const message = createBasePipelineStep();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.description = object.description ?? "";
    message.pipelineStepVersion = (object.pipelineStepVersion !== undefined && object.pipelineStepVersion !== null)
      ? PipelineStepVersion.fromPartial(object.pipelineStepVersion)
      : undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBaseOrchestrationStepSpec(): OrchestrationStepSpec {
  return { argoOrchestrationStepSpec: undefined };
}

export const OrchestrationStepSpec: MessageFns<OrchestrationStepSpec> = {
  encode(message: OrchestrationStepSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argoOrchestrationStepSpec !== undefined) {
      ArgoOrchestrationStepSpec.encode(message.argoOrchestrationStepSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationStepSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationStepSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.argoOrchestrationStepSpec = ArgoOrchestrationStepSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrationStepSpec {
    return {
      argoOrchestrationStepSpec: isSet(object.argoOrchestrationStepSpec)
        ? ArgoOrchestrationStepSpec.fromJSON(object.argoOrchestrationStepSpec)
        : undefined,
    };
  },

  toJSON(message: OrchestrationStepSpec): unknown {
    const obj: any = {};
    if (message.argoOrchestrationStepSpec !== undefined) {
      obj.argoOrchestrationStepSpec = ArgoOrchestrationStepSpec.toJSON(message.argoOrchestrationStepSpec);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrchestrationStepSpec>, I>>(base?: I): OrchestrationStepSpec {
    return OrchestrationStepSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrchestrationStepSpec>, I>>(object: I): OrchestrationStepSpec {
    const message = createBaseOrchestrationStepSpec();
    message.argoOrchestrationStepSpec =
      (object.argoOrchestrationStepSpec !== undefined && object.argoOrchestrationStepSpec !== null)
        ? ArgoOrchestrationStepSpec.fromPartial(object.argoOrchestrationStepSpec)
        : undefined;
    return message;
  },
};

function createBaseArgoOrchestrationStepSpec(): ArgoOrchestrationStepSpec {
  return { apiVersion: "", specJson: "" };
}

export const ArgoOrchestrationStepSpec: MessageFns<ArgoOrchestrationStepSpec> = {
  encode(message: ArgoOrchestrationStepSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    if (message.specJson !== "") {
      writer.uint32(18).string(message.specJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArgoOrchestrationStepSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgoOrchestrationStepSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgoOrchestrationStepSpec {
    return {
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      specJson: isSet(object.specJson) ? globalThis.String(object.specJson) : "",
    };
  },

  toJSON(message: ArgoOrchestrationStepSpec): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.specJson !== "") {
      obj.specJson = message.specJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgoOrchestrationStepSpec>, I>>(base?: I): ArgoOrchestrationStepSpec {
    return ArgoOrchestrationStepSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgoOrchestrationStepSpec>, I>>(object: I): ArgoOrchestrationStepSpec {
    const message = createBaseArgoOrchestrationStepSpec();
    message.apiVersion = object.apiVersion ?? "";
    message.specJson = object.specJson ?? "";
    return message;
  },
};

function createBasePipelineStepVersion(): PipelineStepVersion {
  return {
    id: "",
    userId: "",
    appId: "",
    description: "",
    pipelineStep: undefined,
    orchestrationStepSpec: undefined,
    pipelineStepInputParams: [],
    status: undefined,
    pipelineStepComputeInfo: undefined,
    buildInfo: undefined,
    visibility: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const PipelineStepVersion: MessageFns<PipelineStepVersion> = {
  encode(message: PipelineStepVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(26).string(message.appId);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.pipelineStep !== undefined) {
      PipelineStep.encode(message.pipelineStep, writer.uint32(42).fork()).join();
    }
    if (message.orchestrationStepSpec !== undefined) {
      OrchestrationStepSpec.encode(message.orchestrationStepSpec, writer.uint32(50).fork()).join();
    }
    for (const v of message.pipelineStepInputParams) {
      PipelineStepInputParam.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(66).fork()).join();
    }
    if (message.pipelineStepComputeInfo !== undefined) {
      ComputeInfo.encode(message.pipelineStepComputeInfo, writer.uint32(74).fork()).join();
    }
    if (message.buildInfo !== undefined) {
      BuildInfo.encode(message.buildInfo, writer.uint32(82).fork()).join();
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(90).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineStepVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineStepVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pipelineStep = PipelineStep.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orchestrationStepSpec = OrchestrationStepSpec.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pipelineStepInputParams.push(PipelineStepInputParam.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pipelineStepComputeInfo = ComputeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineStepVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pipelineStep: isSet(object.pipelineStep) ? PipelineStep.fromJSON(object.pipelineStep) : undefined,
      orchestrationStepSpec: isSet(object.orchestrationStepSpec)
        ? OrchestrationStepSpec.fromJSON(object.orchestrationStepSpec)
        : undefined,
      pipelineStepInputParams: globalThis.Array.isArray(object?.pipelineStepInputParams)
        ? object.pipelineStepInputParams.map((e: any) => PipelineStepInputParam.fromJSON(e))
        : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pipelineStepComputeInfo: isSet(object.pipelineStepComputeInfo)
        ? ComputeInfo.fromJSON(object.pipelineStepComputeInfo)
        : undefined,
      buildInfo: isSet(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : undefined,
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: PipelineStepVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pipelineStep !== undefined) {
      obj.pipelineStep = PipelineStep.toJSON(message.pipelineStep);
    }
    if (message.orchestrationStepSpec !== undefined) {
      obj.orchestrationStepSpec = OrchestrationStepSpec.toJSON(message.orchestrationStepSpec);
    }
    if (message.pipelineStepInputParams?.length) {
      obj.pipelineStepInputParams = message.pipelineStepInputParams.map((e) => PipelineStepInputParam.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pipelineStepComputeInfo !== undefined) {
      obj.pipelineStepComputeInfo = ComputeInfo.toJSON(message.pipelineStepComputeInfo);
    }
    if (message.buildInfo !== undefined) {
      obj.buildInfo = BuildInfo.toJSON(message.buildInfo);
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineStepVersion>, I>>(base?: I): PipelineStepVersion {
    return PipelineStepVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineStepVersion>, I>>(object: I): PipelineStepVersion {
    const message = createBasePipelineStepVersion();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.description = object.description ?? "";
    message.pipelineStep = (object.pipelineStep !== undefined && object.pipelineStep !== null)
      ? PipelineStep.fromPartial(object.pipelineStep)
      : undefined;
    message.orchestrationStepSpec =
      (object.orchestrationStepSpec !== undefined && object.orchestrationStepSpec !== null)
        ? OrchestrationStepSpec.fromPartial(object.orchestrationStepSpec)
        : undefined;
    message.pipelineStepInputParams =
      object.pipelineStepInputParams?.map((e) => PipelineStepInputParam.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pipelineStepComputeInfo =
      (object.pipelineStepComputeInfo !== undefined && object.pipelineStepComputeInfo !== null)
        ? ComputeInfo.fromPartial(object.pipelineStepComputeInfo)
        : undefined;
    message.buildInfo = (object.buildInfo !== undefined && object.buildInfo !== null)
      ? BuildInfo.fromPartial(object.buildInfo)
      : undefined;
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBasePipeline(): Pipeline {
  return {
    id: "",
    userId: "",
    appId: "",
    pipelineVersion: undefined,
    description: "",
    visibility: undefined,
    notes: "",
    metadata: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const Pipeline: MessageFns<Pipeline> = {
  encode(message: Pipeline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(26).string(message.appId);
    }
    if (message.pipelineVersion !== undefined) {
      PipelineVersion.encode(message.pipelineVersion, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(58).fork()).join();
    }
    if (message.notes !== "") {
      writer.uint32(66).string(message.notes);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(74).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pipeline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipeline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pipelineVersion = PipelineVersion.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pipeline {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      pipelineVersion: isSet(object.pipelineVersion) ? PipelineVersion.fromJSON(object.pipelineVersion) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: Pipeline): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.pipelineVersion !== undefined) {
      obj.pipelineVersion = PipelineVersion.toJSON(message.pipelineVersion);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pipeline>, I>>(base?: I): Pipeline {
    return Pipeline.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pipeline>, I>>(object: I): Pipeline {
    const message = createBasePipeline();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.pipelineVersion = (object.pipelineVersion !== undefined && object.pipelineVersion !== null)
      ? PipelineVersion.fromPartial(object.pipelineVersion)
      : undefined;
    message.description = object.description ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.notes = object.notes ?? "";
    message.metadata = object.metadata ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBasePipelineVersion(): PipelineVersion {
  return {
    id: "",
    appId: "",
    userId: "",
    orchestrationSpec: undefined,
    pipelineId: "",
    description: "",
    visibility: undefined,
    metadata: undefined,
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const PipelineVersion: MessageFns<PipelineVersion> = {
  encode(message: PipelineVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.orchestrationSpec !== undefined) {
      OrchestrationSpec.encode(message.orchestrationSpec, writer.uint32(34).fork()).join();
    }
    if (message.pipelineId !== "") {
      writer.uint32(42).string(message.pipelineId);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.visibility !== undefined) {
      Visibility.encode(message.visibility, writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orchestrationSpec = OrchestrationSpec.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pipelineId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.visibility = Visibility.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineVersion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      orchestrationSpec: isSet(object.orchestrationSpec)
        ? OrchestrationSpec.fromJSON(object.orchestrationSpec)
        : undefined,
      pipelineId: isSet(object.pipelineId) ? globalThis.String(object.pipelineId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      visibility: isSet(object.visibility) ? Visibility.fromJSON(object.visibility) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: PipelineVersion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.orchestrationSpec !== undefined) {
      obj.orchestrationSpec = OrchestrationSpec.toJSON(message.orchestrationSpec);
    }
    if (message.pipelineId !== "") {
      obj.pipelineId = message.pipelineId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.visibility !== undefined) {
      obj.visibility = Visibility.toJSON(message.visibility);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineVersion>, I>>(base?: I): PipelineVersion {
    return PipelineVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineVersion>, I>>(object: I): PipelineVersion {
    const message = createBasePipelineVersion();
    message.id = object.id ?? "";
    message.appId = object.appId ?? "";
    message.userId = object.userId ?? "";
    message.orchestrationSpec = (object.orchestrationSpec !== undefined && object.orchestrationSpec !== null)
      ? OrchestrationSpec.fromPartial(object.orchestrationSpec)
      : undefined;
    message.pipelineId = object.pipelineId ?? "";
    message.description = object.description ?? "";
    message.visibility = (object.visibility !== undefined && object.visibility !== null)
      ? Visibility.fromPartial(object.visibility)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBaseOrchestrationStatus(): OrchestrationStatus {
  return { argoStatus: undefined, status: undefined };
}

export const OrchestrationStatus: MessageFns<OrchestrationStatus> = {
  encode(message: OrchestrationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argoStatus !== undefined) {
      ArgoOrchestrationStatus.encode(message.argoStatus, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.argoStatus = ArgoOrchestrationStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrationStatus {
    return {
      argoStatus: isSet(object.argoStatus) ? ArgoOrchestrationStatus.fromJSON(object.argoStatus) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: OrchestrationStatus): unknown {
    const obj: any = {};
    if (message.argoStatus !== undefined) {
      obj.argoStatus = ArgoOrchestrationStatus.toJSON(message.argoStatus);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrchestrationStatus>, I>>(base?: I): OrchestrationStatus {
    return OrchestrationStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrchestrationStatus>, I>>(object: I): OrchestrationStatus {
    const message = createBaseOrchestrationStatus();
    message.argoStatus = (object.argoStatus !== undefined && object.argoStatus !== null)
      ? ArgoOrchestrationStatus.fromPartial(object.argoStatus)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseArgoOrchestrationStatus(): ArgoOrchestrationStatus {
  return { status: "" };
}

export const ArgoOrchestrationStatus: MessageFns<ArgoOrchestrationStatus> = {
  encode(message: ArgoOrchestrationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArgoOrchestrationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArgoOrchestrationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArgoOrchestrationStatus {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: ArgoOrchestrationStatus): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArgoOrchestrationStatus>, I>>(base?: I): ArgoOrchestrationStatus {
    return ArgoOrchestrationStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArgoOrchestrationStatus>, I>>(object: I): ArgoOrchestrationStatus {
    const message = createBaseArgoOrchestrationStatus();
    message.status = object.status ?? "";
    return message;
  },
};

function createBasePipelineVersionRun(): PipelineVersionRun {
  return {
    id: "",
    pipelineVersion: undefined,
    nodepools: [],
    orchestrationStatus: undefined,
    userId: "",
    appId: "",
    createdAt: undefined,
    modifiedAt: undefined,
  };
}

export const PipelineVersionRun: MessageFns<PipelineVersionRun> = {
  encode(message: PipelineVersionRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pipelineVersion !== undefined) {
      PipelineVersion.encode(message.pipelineVersion, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodepools) {
      Nodepool.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.orchestrationStatus !== undefined) {
      OrchestrationStatus.encode(message.orchestrationStatus, writer.uint32(34).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.appId !== "") {
      writer.uint32(50).string(message.appId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineVersionRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineVersionRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipelineVersion = PipelineVersion.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodepools.push(Nodepool.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orchestrationStatus = OrchestrationStatus.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineVersionRun {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pipelineVersion: isSet(object.pipelineVersion) ? PipelineVersion.fromJSON(object.pipelineVersion) : undefined,
      nodepools: globalThis.Array.isArray(object?.nodepools)
        ? object.nodepools.map((e: any) => Nodepool.fromJSON(e))
        : [],
      orchestrationStatus: isSet(object.orchestrationStatus)
        ? OrchestrationStatus.fromJSON(object.orchestrationStatus)
        : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
    };
  },

  toJSON(message: PipelineVersionRun): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pipelineVersion !== undefined) {
      obj.pipelineVersion = PipelineVersion.toJSON(message.pipelineVersion);
    }
    if (message.nodepools?.length) {
      obj.nodepools = message.nodepools.map((e) => Nodepool.toJSON(e));
    }
    if (message.orchestrationStatus !== undefined) {
      obj.orchestrationStatus = OrchestrationStatus.toJSON(message.orchestrationStatus);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineVersionRun>, I>>(base?: I): PipelineVersionRun {
    return PipelineVersionRun.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineVersionRun>, I>>(object: I): PipelineVersionRun {
    const message = createBasePipelineVersionRun();
    message.id = object.id ?? "";
    message.pipelineVersion = (object.pipelineVersion !== undefined && object.pipelineVersion !== null)
      ? PipelineVersion.fromPartial(object.pipelineVersion)
      : undefined;
    message.nodepools = object.nodepools?.map((e) => Nodepool.fromPartial(e)) || [];
    message.orchestrationStatus = (object.orchestrationStatus !== undefined && object.orchestrationStatus !== null)
      ? OrchestrationStatus.fromPartial(object.orchestrationStatus)
      : undefined;
    message.userId = object.userId ?? "";
    message.appId = object.appId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    return message;
  },
};

function createBaseSecret(): Secret {
  return {
    id: "",
    userId: "",
    value: "",
    version: 0,
    description: "",
    createdAt: undefined,
    modifiedAt: undefined,
    expiresAt: undefined,
  };
}

export const Secret: MessageFns<Secret> = {
  encode(message: Secret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(90).string(message.userId);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.version !== 0) {
      writer.uint32(40).uint32(message.version);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(66).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Secret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Secret {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      modifiedAt: isSet(object.modifiedAt) ? fromJsonTimestamp(object.modifiedAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: Secret): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Secret>, I>>(base?: I): Secret {
    return Secret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Secret>, I>>(object: I): Secret {
    const message = createBaseSecret();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseMetricData(): MetricData {
  return { matrixData: undefined };
}

export const MetricData: MessageFns<MetricData> = {
  encode(message: MetricData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matrixData !== undefined) {
      MetricData_MatrixData.encode(message.matrixData, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matrixData = MetricData_MatrixData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData {
    return { matrixData: isSet(object.matrixData) ? MetricData_MatrixData.fromJSON(object.matrixData) : undefined };
  },

  toJSON(message: MetricData): unknown {
    const obj: any = {};
    if (message.matrixData !== undefined) {
      obj.matrixData = MetricData_MatrixData.toJSON(message.matrixData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData>, I>>(base?: I): MetricData {
    return MetricData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData>, I>>(object: I): MetricData {
    const message = createBaseMetricData();
    message.matrixData = (object.matrixData !== undefined && object.matrixData !== null)
      ? MetricData_MatrixData.fromPartial(object.matrixData)
      : undefined;
    return message;
  },
};

function createBaseMetricData_Label(): MetricData_Label {
  return { name: 0, value: "" };
}

export const MetricData_Label: MessageFns<MetricData_Label> = {
  encode(message: MetricData_Label, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== 0) {
      writer.uint32(8).int32(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricData_Label {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData_Label();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.name = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData_Label {
    return {
      name: isSet(object.name) ? metricLabelFromJSON(object.name) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MetricData_Label): unknown {
    const obj: any = {};
    if (message.name !== 0) {
      obj.name = metricLabelToJSON(message.name);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData_Label>, I>>(base?: I): MetricData_Label {
    return MetricData_Label.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData_Label>, I>>(object: I): MetricData_Label {
    const message = createBaseMetricData_Label();
    message.name = object.name ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetricData_MetricSample(): MetricData_MetricSample {
  return { timestamp: undefined, value: 0 };
}

export const MetricData_MetricSample: MessageFns<MetricData_MetricSample> = {
  encode(message: MetricData_MetricSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricData_MetricSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData_MetricSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData_MetricSample {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: MetricData_MetricSample): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData_MetricSample>, I>>(base?: I): MetricData_MetricSample {
    return MetricData_MetricSample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData_MetricSample>, I>>(object: I): MetricData_MetricSample {
    const message = createBaseMetricData_MetricSample();
    message.timestamp = object.timestamp ?? undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMetricData_MatrixData(): MetricData_MatrixData {
  return { series: [] };
}

export const MetricData_MatrixData: MessageFns<MetricData_MatrixData> = {
  encode(message: MetricData_MatrixData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.series) {
      MetricData_MatrixData_TimeSeries.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricData_MatrixData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData_MatrixData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.series.push(MetricData_MatrixData_TimeSeries.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData_MatrixData {
    return {
      series: globalThis.Array.isArray(object?.series)
        ? object.series.map((e: any) => MetricData_MatrixData_TimeSeries.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricData_MatrixData): unknown {
    const obj: any = {};
    if (message.series?.length) {
      obj.series = message.series.map((e) => MetricData_MatrixData_TimeSeries.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData_MatrixData>, I>>(base?: I): MetricData_MatrixData {
    return MetricData_MatrixData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData_MatrixData>, I>>(object: I): MetricData_MatrixData {
    const message = createBaseMetricData_MatrixData();
    message.series = object.series?.map((e) => MetricData_MatrixData_TimeSeries.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricData_MatrixData_TimeSeries(): MetricData_MatrixData_TimeSeries {
  return { labels: [], value: [] };
}

export const MetricData_MatrixData_TimeSeries: MessageFns<MetricData_MatrixData_TimeSeries> = {
  encode(message: MetricData_MatrixData_TimeSeries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labels) {
      MetricData_Label.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.value) {
      MetricData_MetricSample.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricData_MatrixData_TimeSeries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData_MatrixData_TimeSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.labels.push(MetricData_Label.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value.push(MetricData_MetricSample.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData_MatrixData_TimeSeries {
    return {
      labels: globalThis.Array.isArray(object?.labels)
        ? object.labels.map((e: any) => MetricData_Label.fromJSON(e))
        : [],
      value: globalThis.Array.isArray(object?.value)
        ? object.value.map((e: any) => MetricData_MetricSample.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricData_MatrixData_TimeSeries): unknown {
    const obj: any = {};
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => MetricData_Label.toJSON(e));
    }
    if (message.value?.length) {
      obj.value = message.value.map((e) => MetricData_MetricSample.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData_MatrixData_TimeSeries>, I>>(
    base?: I,
  ): MetricData_MatrixData_TimeSeries {
    return MetricData_MatrixData_TimeSeries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData_MatrixData_TimeSeries>, I>>(
    object: I,
  ): MetricData_MatrixData_TimeSeries {
    const message = createBaseMetricData_MatrixData_TimeSeries();
    message.labels = object.labels?.map((e) => MetricData_Label.fromPartial(e)) || [];
    message.value = object.value?.map((e) => MetricData_MetricSample.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricAggregate(): MetricAggregate {
  return { operator: 0, labels: [] };
}

export const MetricAggregate: MessageFns<MetricAggregate> = {
  encode(message: MetricAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    writer.uint32(18).fork();
    for (const v of message.labels) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.labels.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.labels.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricAggregate {
    return {
      operator: isSet(object.operator) ? metricAggregate_OperatorFromJSON(object.operator) : 0,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => metricLabelFromJSON(e)) : [],
    };
  },

  toJSON(message: MetricAggregate): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = metricAggregate_OperatorToJSON(message.operator);
    }
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => metricLabelToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricAggregate>, I>>(base?: I): MetricAggregate {
    return MetricAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricAggregate>, I>>(object: I): MetricAggregate {
    const message = createBaseMetricAggregate();
    message.operator = object.operator ?? 0;
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBaseMetricFilter(): MetricFilter {
  return { label: 0, equals: undefined, in: undefined };
}

export const MetricFilter: MessageFns<MetricFilter> = {
  encode(message: MetricFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== 0) {
      writer.uint32(8).int32(message.label);
    }
    if (message.equals !== undefined) {
      writer.uint32(18).string(message.equals);
    }
    if (message.in !== undefined) {
      MetricFilter_MultiValues.encode(message.in, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.label = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.equals = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.in = MetricFilter_MultiValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricFilter {
    return {
      label: isSet(object.label) ? metricLabelFromJSON(object.label) : 0,
      equals: isSet(object.equals) ? globalThis.String(object.equals) : undefined,
      in: isSet(object.in) ? MetricFilter_MultiValues.fromJSON(object.in) : undefined,
    };
  },

  toJSON(message: MetricFilter): unknown {
    const obj: any = {};
    if (message.label !== 0) {
      obj.label = metricLabelToJSON(message.label);
    }
    if (message.equals !== undefined) {
      obj.equals = message.equals;
    }
    if (message.in !== undefined) {
      obj.in = MetricFilter_MultiValues.toJSON(message.in);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricFilter>, I>>(base?: I): MetricFilter {
    return MetricFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricFilter>, I>>(object: I): MetricFilter {
    const message = createBaseMetricFilter();
    message.label = object.label ?? 0;
    message.equals = object.equals ?? undefined;
    message.in = (object.in !== undefined && object.in !== null)
      ? MetricFilter_MultiValues.fromPartial(object.in)
      : undefined;
    return message;
  },
};

function createBaseMetricFilter_MultiValues(): MetricFilter_MultiValues {
  return { in: [] };
}

export const MetricFilter_MultiValues: MessageFns<MetricFilter_MultiValues> = {
  encode(message: MetricFilter_MultiValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.in) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricFilter_MultiValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricFilter_MultiValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.in.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricFilter_MultiValues {
    return { in: globalThis.Array.isArray(object?.in) ? object.in.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: MetricFilter_MultiValues): unknown {
    const obj: any = {};
    if (message.in?.length) {
      obj.in = message.in;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricFilter_MultiValues>, I>>(base?: I): MetricFilter_MultiValues {
    return MetricFilter_MultiValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricFilter_MultiValues>, I>>(object: I): MetricFilter_MultiValues {
    const message = createBaseMetricFilter_MultiValues();
    message.in = object.in?.map((e) => e) || [];
    return message;
  },
};

function createBaseMetricSearchQuery(): MetricSearchQuery {
  return { metricType: 0, startTime: undefined, endTime: undefined, resolution: "", filters: [], aggregate: undefined };
}

export const MetricSearchQuery: MessageFns<MetricSearchQuery> = {
  encode(message: MetricSearchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricType !== 0) {
      writer.uint32(8).int32(message.metricType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    if (message.resolution !== "") {
      writer.uint32(34).string(message.resolution);
    }
    for (const v of message.filters) {
      MetricFilter.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.aggregate !== undefined) {
      MetricAggregate.encode(message.aggregate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricSearchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricSearchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.metricType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resolution = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(MetricFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.aggregate = MetricAggregate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricSearchQuery {
    return {
      metricType: isSet(object.metricType) ? metricTypeFromJSON(object.metricType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      resolution: isSet(object.resolution) ? globalThis.String(object.resolution) : "",
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => MetricFilter.fromJSON(e))
        : [],
      aggregate: isSet(object.aggregate) ? MetricAggregate.fromJSON(object.aggregate) : undefined,
    };
  },

  toJSON(message: MetricSearchQuery): unknown {
    const obj: any = {};
    if (message.metricType !== 0) {
      obj.metricType = metricTypeToJSON(message.metricType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.resolution !== "") {
      obj.resolution = message.resolution;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => MetricFilter.toJSON(e));
    }
    if (message.aggregate !== undefined) {
      obj.aggregate = MetricAggregate.toJSON(message.aggregate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricSearchQuery>, I>>(base?: I): MetricSearchQuery {
    return MetricSearchQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricSearchQuery>, I>>(object: I): MetricSearchQuery {
    const message = createBaseMetricSearchQuery();
    message.metricType = object.metricType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.resolution = object.resolution ?? "";
    message.filters = object.filters?.map((e) => MetricFilter.fromPartial(e)) || [];
    message.aggregate = (object.aggregate !== undefined && object.aggregate !== null)
      ? MetricAggregate.fromPartial(object.aggregate)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
